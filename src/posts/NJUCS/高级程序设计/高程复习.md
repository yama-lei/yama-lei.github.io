# 高级程序设计复习指南

## 老师最后一节课画的重点
1. 面相对象： 代码、背后的逻辑（在编程题和程序分析题）
2. 操作符重载：不会单独考，会和oop一起考（和编程题中加入，手写代码）
3. 面向对象IO（输入流输出流不作为重点，）不是重点，可能在编程里需要处理输入输出
4. Exception 不会多于5分，考程序分析题
5. 不会考时间驱动的
6. 泛型不会单独出题
7. 并行程序设计 10分左右，OJ、课后作业、课上例子的难度 
8. 内存安全程序设计： 程序分析题等，会和面向程序等知识结合
9. 函数式和程序
10. **只有程序分析题和编程题**（全是代码，不需要注意ppt里面有哪些概念，而是把编程熟悉）
11. STL 不考，如果考的话，会告诉所有api，甚至可以在考试的时候问。
12. 智能指针会考，因为属于内存安全问题（时间和空间，unique_ptr,shared_ptr,weak_ptr）
13. 题量比较大，可能是2h刚好写完，题量大
14. IO和事件驱动不用看 

## 核心必考内容

### 1. 面向对象编程

#### 1.1 对象的创建方式（必考）
- 直接创建：`A a;` 内存在stack区，作用域结束后内存自动释放
- 间接方式创建动态变量：`A* p=new A;` 需要手动释放内存 `delete p;`
- 在创建对象的可以传参（具体根据`constructor`来决定，但是A* alist= new A[100];只能调用默认构造函数；

#### 1.2 对象作为函数参数和返回值（必考）
```cpp
void fun(A a){} // 传入对象，创建临时对象
void g(A& a){} // 传入原对象的引用
Date f1(A& a){ return a; } // 创建临时变量并返回
Date& f1(A& a){ return a; } // 返回原对象的引用
```

比如，下面这个例子中，当对象作为值进行传递的时候，会调用拷贝构造函数**两次（传入一次，return一次）**

```cpp
String returnByValue(String getByValue){
        return getByValue;
    }
```

而下面这个例子只会出现一次：

```cpp
    String& returnByValue(String getByValue){
        return getByValue;
    }
```

都使用reference的话，不会出现拷贝构造：

```cpp
    String& returnByValue(String& getByValue){
        return getByValue;
    }
```



#### 1.3 析构函数（200%必考）

什么时候必须要析构函数：
```cpp
class String {
    int len;
    char *str;
public:
    String(char *s) { 
        len = strlen(s); 
        str = new char[len+1]; 
        strcpy(str,s); 
    }
    ~String() { 
        delete []str; 
        len=0; 
        str=nullptr; // 为了更加安全
    }
};
```

#### 1.4 拷贝构造函数（必考）
浅拷贝与深拷贝问题：

>   关注什么时候需要自定义拷贝构造函数！！

```cpp
class String {
    int len;
    char *str;
public:
    String(char *s) { 
        len = strlen(s); 
        str = new char[len+1]; 
        strcpy(str,s); 
    }
    // 深拷贝构造函数
    String(String& s) {
        len = s.len;
        str = new char[len+1];
        strcpy(str, s.str);
    }
    ~String() { delete []str; len=0; str=nullptr; }
};
```

当涉及到多个类的时候，情况更加复杂，如果A是B的一个成员变量（composition），B使用拷贝构造函数的时候，如果没有明确指出调用A的拷贝构造函数，那么就会调用A的默认构造函数:

```cpp
注意：自定义的拷贝构造函数默认调用的是成员对象类的默认构造函数来对成员对象初始化！
class A
{  int x,y;
 public:
  A() { x = y = 0; }
  void inc() { x++; y++; }
};
class B
{    int z;
   A a;
   public:
   B() { z = 0; }
   B(const B& b)            { z = b.z; }
   void inc() { z++; a.inc(); }
};
...
B b1;  /b1.z、b1.a.x和b1.a.y均为0
b1.inc();  //b1.z、b1.a.x和b1.a.y均变成了1
B b2(b1); //b2.z为1，b2.a.x和b2.a.y均为0
如何能让b2与b1一致呢？
在B类的拷贝构造函数的成员初始化表中显式指出！
下面对b2.a进行赋值初始化与拷贝构造的区别是什么？
class A { ...... };
class B
{ int z;
   A a;
  public:
   B() { ...... }
   B(const B& b)
   { z = b.z;
      a = b.a;
   }
   ......
};
B b1;
B b2(b1);
```



#### 1.5 派生类的成员对外访问情况（100%必考）

- public继承：基类public成员→派生类public成员；基类protected成员→派生类protected成员
- protected继承：基类public和protected成员→派生类protected成员
- private继承：基类public和protected成员→派生类private成员
- 不需要考虑积累的private成员变成派生类的什么成员，因为private成员无论那种继承都是不可见的

>   A man and woman are in a computer programming lecture. The man touches the woman's breasts.
>
>   "Hey!" she says. "Those are private!"
>
>   The man says, "But we're in the same class!"

---

>   NOTE：此处略去`常成员函数`和`继承`的内容，因为我tm时间来不及了，只能抓紧搞重点了；
>
>   有关继承注意一点： 可以将derived class的成员变量（或者pointer）赋值给base class，反之不行。并且先调用base的构造函数，再派生类；析构时恰好相反。

例子：

```cpp
class A
{	public:
		void f();
	protected:
		void g();
	private:
		void h();
};
class B: protected A
{ //f为protected
   //g为protected
   //h为不可直接访问
   public:
		void q() 
		{ f(); //?
		   g(); //?
		   h(); //?
		}
};
class C: public B
{	public:
		void r()
		{	f();  //OK
			g();  //OK
			h();  //Error
		     q();  //?
     }
};
void func()
{ B b;
   b.f();  //Error
   b.g(); //Error
   b.h(); //Error
   b.q(); //?
}
```



### 2. 虚函数和消息的动态绑定（200%必考）

#### 2.1 静态绑定与动态绑定

静态绑定：

```cpp
void main(){
	A a;
	func1(a);
	func2(&a);
	B b;
	func1(b);
	func2(&b);
}
//无论传入的是A还是B，都是调用A的f，因为这里的形参已经确定
void func1(A& x)
{	......
	x.f(); //调用A::f还是B::f ？
	......
}
void func2(A *p)
{	......
	p->f(); //调用A::f还是B::f ？
	......
}
```

动态绑定：

```cpp
class A {
public:
    virtual void f();
};
class B: public A {
public:
    void f(); 
    void g();
};
void func1(A& x) {
    x.f(); // 动态绑定，根据对象类型调用A::f或B::f
}
void func2(A *p) {
    p->f(); // 动态绑定，根据对象类型调用A::f或B::f
}
A a;
func1(a); // 调用A::f
B b;
func1(b); // 调用B::f
```

**重要提示**：
- 只有通过指针或引用调用虚函数才能实现动态绑定
- 构造函数不能是虚函数，析构函数往往是虚函数
- 在构造函数和析构函数中调用虚函数不会进行动态绑定

### 3. 操作符重载

#### 3.1 前置++和后置++的操作符重载（必考）
```cpp
class Counter {
    int value;
public:
    Counter() { value = 0; }
    // 前置++
    Counter& operator++() {
        value++;
        return *this;
    }
    // 后置++
    const Counter operator++(int) {
        Counter temp = *this; // 保存原对象
        value++; // 或 ++(*this);
        return temp; // 返回原对象
    }
};
```

#### 3.2 赋值操作符重载（必考）
```cpp
class String {
    int len;
    char *str;
public:
    String& operator=(const String& s) {
        if (&s == this) return *this;  // 防止自身赋值
        delete []str; // 释放原有内存
        str = new char[s.len+1];
        strcpy(str, s.str);
        len = s.len; 
        return *this;
    }
};
```

### 4. 异常处理（必考，10分左右）

```cpp
void f() {
    try {
        throw 1;
    } catch(int a) {
        cout << "Catch " << a << endl;
        throw 2;
    }
}

try {
    f();
    g();
} catch(int) {
    // 处理异常
} catch(char*) {
    // 处理异常
}
```

异常处理机制：
- 每个函数有一个catch表
- 执行throw时检查当前catch表是否能捕获
- 如果不能捕获，退栈回到上一个函数
- 如果能被catch，从捕获点继续执行
- 如果最终未被捕获，调用terminate()终止程序

### 5. 内存安全程序设计

#### 5.1 RAII和智能指针（100%必考）
```cpp
template<typename T> 
class Toy_ptr {
    T* ptr;
public:
    Toy_ptr(T* p = nullptr) : ptr(p) {}
    ~Toy_ptr() { delete ptr; }
    T& operator*() { return *ptr; }
    T* operator->() { return ptr; }
};
```

#### 5.2 智能指针（必考）

##### unique_ptr
```cpp
#include <memory>

std::unique_ptr<int> p1(new int(10));
auto p2 = std::make_unique<int>(10);
auto p3 = std::move(p2); // p2变为nullptr

int* raw_ptr = p1.release(); // p1变为nullptr，返回原始指针
p3.reset(new int(20)); // 释放原指针，设置新指针
```

##### shared_ptr
```cpp
std::shared_ptr<int> p1(new int(10));
auto p2 = p1; // 引用计数+1
auto p3 = std::make_shared<int>(20);

std::cout << p1.use_count(); // 输出引用计数
p2.reset(); // 减少引用计数
```

##### weak_ptr（解决循环引用问题）
```cpp
struct Node {
    std::shared_ptr<Node> next;
    std::weak_ptr<Node> prev; // 使用weak_ptr避免循环引用
};
```

### 6. 并行程序设计（10分左右）

多线程基础：
```cpp
#include <thread>

void func(int& n) {
    n++;
}

int main() {
    int n = 0;
    std::thread t1(func, std::ref(n));
    std::thread t2(func, std::ref(n));
    t1.join();
    t2.join();
    return 0;
}
```

## 注意事项

1. 代码题中注意检查：
   - 析构函数是否正确释放内存
   - 拷贝构造函数是否实现深拷贝
   - 赋值操作符是否检查自赋值
   - 智能指针的正确使用

2. 程序分析题中注意：
   - 虚函数的动态绑定规则
   - 派生类成员访问权限
   - 异常处理的执行流程
   - 智能指针的引用计数变化

3. 重点关注老师上课提到的例子，特别是标注为"必考"、"200%必考"的内容

## 模拟题

### 程序分析题

#### 题目1：分析虚函数与静态/动态绑定（15分）
找出以下代码中的错误并解释原因，同时分析每个函数调用时执行的是哪个类的函数。

```cpp
#include <iostream>
using namespace std;

class Base {
protected:
    int data;
public:
    Base(int d = 0) : data(d) { cout << "Base constructor" << endl; }
    virtual ~Base() { cout << "Base destructor" << endl; }
    virtual void show() { cout << "Base::show: " << data << endl; }
    void display() { cout << "Base::display" << endl; show(); }
};

class Derived : public Base {
    int* ptr;
public:
    Derived(int d = 0, int p = 0) : Base(d) {
        ptr = new int(p);
        cout << "Derived constructor" << endl;
        show();  
    }
    ~Derived() {
        cout << "Derived destructor" << endl;
        delete ptr;
    }
    void show() override {
        cout << "Derived::show: " << data << ", " << *ptr << endl;
    }
};

int main() {
    Base* bp = new Derived(5, 10);
    bp->show();
    bp->display();
    
    Derived d1(1, 2);
    Base b1 = d1;  
    b1.show();
    
    Derived d2(3, 4);
    Derived d3 = d2;     
    delete bp;
    return 0;
}
```

我的解答：

>   ```cpp
>   int main() {
>       Base* bp = new Derived(5, 10);
>       //调用: Base::Base() Derived::Derived() Derived::show()
>       bp->show();
>       //Derived::show()
>       bp->display();
>       //Base::display()
>       Derived d1(1, 2);
>       //调用: Base::Base() Derived::Derived() Derived::show()
>       
>       Base b1 = d1;  //会缺失derived class的一些东西
>       b1.show();	//Base::shwo()
>       
>       Derived d2(3, 4);
>       //调用: Base::Base() Derived::Derived() Derived::show()
>       
>       Derived d3 = d2;     
>       //shallow copy
>       delete bp;
>       return 0;
>   }
>   ```
>
>   

#### 题目2：内存安全与智能指针（20分）

以下代码存在几个内存安全问题，请找出并修正它们。

```cpp
#include <iostream>
#include <memory>
using namespace std;

class Resource {
    int id;
public:
    Resource(int i) : id(i) { cout << "Resource " << id << " created" << endl; }
    ~Resource() { cout << "Resource " << id << " destroyed" << endl; }
    void use() { cout << "Using resource " << id << endl; }
};

struct Node {
    shared_ptr<Resource> res;
    shared_ptr<Node> next;
    shared_ptr<Node> prev;
    
    Node(int id) : res(new Resource(id)) {}
};

void problematicFunction() {
    Resource* raw = new Resource(1);
    unique_ptr<Resource> u1(raw);
    unique_ptr<Resource> u2(raw);  
    shared_ptr<Resource> s1(new Resource(2));
    Resource* r2 = s1.get();
    delete r2; 
    
   auto node1 = make_shared<Node>(3);
    auto node2 = make_shared<Node>(4);
    node1->next = node2;
    node2->prev = node1; 
}

int main() {
    problematicFunction();
    cout << "Function finished" << endl;
    return 0;
}
```

>   My solution:
>
>   ```cpp
>   void problematicFunction() {
>       Resource* raw = new Resource(1);
>       unique_ptr<Resource> u1(raw);
>       unique_ptr<Resource> u2(raw);  //用同一个裸指针
>       shared_ptr<Resource> s1(new Resource(2));
>       Resource* r2 = s1.get();
>       delete r2;  //不能这样， 会出现重复释放问题    
>      auto node1 = make_shared<Node>(3);
>       auto node2 = make_shared<Node>(4);
>       node1->next = node2;
>       node2->prev = node1; //循环引用
>   }
>   ```
>
>   

#### 题目3：异常处理（10分）

分析以下代码的执行过程，说明每个catch块是否会执行，以及最终的输出结果。

```cpp
#include <iostream>
using namespace std;

void f3() {
    cout << "f3 starts" << endl;
    throw 42;
    cout << "f3 ends" << endl;
}

void f2() {
    cout << "f2 starts" << endl;
    try {
        f3();
    } catch (char* msg) {
        cout << "f2 caught char*: " << msg << endl;
    }
    cout << "f2 ends" << endl;
}

void f1() {
    cout << "f1 starts" << endl;
    try {
        f2();
    } catch (int e) {
        cout << "f1 caught int: " << e << endl;
        throw "Exception from f1";
    }
    cout << "f1 ends" << endl;
}

int main() {
    cout << "main starts" << endl;
    try {
        f1();
    } catch (const char* msg) {
        cout << "main caught char*: " << msg << endl;
    } catch (...) {
        cout << "main caught unknown exception" << endl;
    }
    cout << "main ends" << endl;
    return 0;
}
```

>   My solution:
>
>   ```cpp
>   #include <iostream>
>   using namespace std;
>   
>   void f3() {
>       cout << "f3 starts" << endl;
>       throw 42;
>       cout << "f3 ends" << endl;
>   }
>   
>   void f2() {
>       cout << "f2 starts" << endl;
>       try {
>           f3();
>       } catch (char* msg) {
>           cout << "f2 caught char*: " << msg << endl;
>       }
>       cout << "f2 ends" << endl;
>   }
>   
>   void f1() {
>       cout << "f1 starts" << endl;
>       try {
>           f2();
>       } catch (int e) {
>           //42被捕获
>           cout << "f1 caught int: " << e << endl;
>           throw "Exception from f1";
>       }
>       cout << "f1 ends" << endl;
>   }
>   
>   int main() {
>       cout << "main starts" << endl;
>       try {
>           f1();
>       } catch (const char* msg) {
>           //Exception from f1被捕获
>           cout << "main caught char*: " << msg << endl;
>       } catch (...) {
>           cout << "main caught unknown exception" << endl;
>       }
>       cout << "main ends" << endl;
>       return 0;
>   }
>   ```
>
>   

### 编程题

#### 题目4：实现一个内存池分配器（25分）
实现一个简单的内存池，使用operator new和operator delete来管理固定大小的对象。要求：

1. 每次申请内存时，如果池中有可用内存块，则从池中分配
2. 如果池为空，则一次性申请多个内存块（如32个）
3. 当对象被删除时，将内存归还到池中而不是直接释放
4. 程序结束时释放所有申请的内存

```cpp
class MemoryPool {
    // 实现代码
};

class MyClass {
    int data;
public:
    MyClass(int d = 0) : data(d) {}
    static void* operator new(size_t size);
    static void operator delete(void* p);
};
```

>   My solution：
>
>   ```cpp
>   class MemoryPool {
>       // 实现代码
>   };
>   
>   class MyClass {
>       int data;
>   public:
>       MyClass(int d = 0) : data(d) {}
>       static void* operator new(size_t size);
>       static void operator delete(void* p);
>   };
>   ```
>
>   

#### 题目5：设计一个线程安全的单例模式（15分）

实现一个线程安全的单例类，满足：

1. 懒汉式初始化（第一次使用时才创建实例）
2. 线程安全
3. 防止内存泄漏
4. 禁止拷贝和赋值

#### 题目6：实现一个安全的字符串类（15分）
设计一个安全的字符串类SafeString，正确处理内存管理、拷贝构造和赋值操作。要求：

1. 实现深拷贝的拷贝构造函数和赋值操作符
2. 正确处理自赋值情况
3. 实现移动构造函数和移动赋值操作符
4. 提供字符串连接运算符+和+=
5. 实现比较运算符==、!=、<、>等

```cpp
class SafeString {
private:
    char* data;
    size_t length;
    
public:
    // 构造函数和析构函数
    SafeString(const char* str = nullptr);
    SafeString(const SafeString& other);
    SafeString(SafeString&& other) noexcept;
    ~SafeString();
    
    // 赋值操作符
    SafeString& operator=(const SafeString& other);
    SafeString& operator=(SafeString&& other) noexcept;
    
    // 其他操作符重载
    // ...
    
    // 实用方法
    size_t size() const;
    const char* c_str() const;
};
```
比较考验细节的地方是：
```cpp
 SafeString operator+(const SafeString& other) const {
        size_t newLen = length + other.length;
        char* newData = new char[newLen + 1];
        std::strcpy(newData, data);
        std::strcat(newData, other.data);
        SafeString result(newData);
        delete[] newData;
        return result;//这里要先delete之前的数据
    }
```
#### 题目7：并行计算数组元素和（10分）
编写一个函数，使用多线程计算一个大数组的元素和。要求：

1. 将数组分成多个部分，每个线程计算一部分
2. 正确汇总各线程的计算结果
3. 处理线程同步问题
4. 考虑性能和线程数量的优化

