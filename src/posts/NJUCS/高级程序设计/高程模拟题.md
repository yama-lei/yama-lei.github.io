# 高级程序设计模拟题

## 一、面向对象编程

### 题目1.1：对象创建与内存管理
分析以下代码的输出结果，解释对象创建和销毁的顺序，以及可能存在的内存问题。

```cpp
#include <iostream>
using namespace std;
class Resource {
public:
    Resource() { cout << "Resource constructed" << endl; }
    ~Resource() { cout << "Resource destroyed" << endl; }
};

class Container {
    Resource* res;
public:
    Container() : res(new Resource()) {
        cout << "Container constructed" << endl;
    }
    ~Container() {
        cout << "Container destroyed" << endl;
    }
};

int main() {
    {
        Container c1;
        Container* c2 = new Container();
    }
    cout << "End of block" << endl;
    return 0;
}
```

### 题目1.2：拷贝构造与赋值操作
下面的String类实现有什么问题？请指出并修复。

```cpp
class String {
    char* str;
    int length;
public:
    String(const char* s = "") {
        length = strlen(s);
        str = new char[length + 1];
        strcpy(str, s);
    }
    
    ~String() {
        delete[] str;
    }
    
    // 拷贝构造函数
    String(const String& other) {
        length = other.length;
        str = other.str;
    }
    
    // 赋值操作符
    String& operator=(const String& other) {
        length = other.length;
        str = other.str;
        return *this;
    }
};
```

### 题目1.3：继承与访问控制
给定以下代码，判断每个访问是否合法，并解释原因。

```cpp
class Base {
private:
    int privateVar;
protected:
    int protectedVar;
public:
    int publicVar;
    
    void baseFunc() {
        privateVar = 1;
        protectedVar = 2;
        publicVar = 3;
    }
};

class Derived1 : public Base {
public:
    void derived1Func() {
        privateVar = 1;
        protectedVar = 2;
        publicVar = 3;
    }
};

class Derived2 : protected Base {
public:
    void derived2Func() {
        privateVar = 1;
        protectedVar = 2;
        publicVar = 3;
    }
};

class Derived3 : private Base {
public:
    void derived3Func() {
        privateVar = 1;
        protectedVar = 2;
        publicVar = 3;
    }
};

int main() {
    Base b;
    Derived1 d1;
    Derived2 d2;
    Derived3 d3;
    
    b.privateVar = 1;
    b.protectedVar = 2;
    b.publicVar = 3;
    
    d1.privateVar = 1;
    d1.protectedVar = 2;
    d1.publicVar = 3;
    
    d2.privateVar = 1;
    d2.protectedVar = 2;
    d2.publicVar = 3;
    
    d3.privateVar = 1;
    d3.protectedVar = 2;
    d3.publicVar = 3;
    
    return 0;
}
```

## 二、虚函数与动态绑定

### 题目2.1：虚函数调用分析
分析以下代码，确定每次函数调用调用的是哪个类的方法，并解释原因。

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() { cout << "Base constructor" << endl; }
    virtual ~Base() { cout << "Base destructor" << endl; }
    
    virtual void vFunc() { cout << "Base::vFunc()" << endl; }
    void nonVFunc() { cout << "Base::nonVFunc()" << endl; }
    
    virtual void callVFunc() { 
        cout << "Base::callVFunc() calls "; 
        vFunc(); 
    }
};

class Derived : public Base {
public:
    Derived() { cout << "Derived constructor" << endl; }
    ~Derived() { cout << "Derived destructor" << endl; }
    
    void vFunc() override { cout << "Derived::vFunc()" << endl; }
    void nonVFunc() { cout << "Derived::nonVFunc()" << endl; }
};

int main() {
    cout << "=== Test 1 ===" << endl;
    Base* bp = new Derived();
    bp->vFunc();
    bp->nonVFunc();
    bp->callVFunc();
    delete bp;
    
    cout << "\n=== Test 2 ===" << endl;
    Derived d;
    Base& br = d;
    br.vFunc();
    br.nonVFunc();
    
    cout << "\n=== Test 3 ===" << endl;
    Base b = Derived();
    b.vFunc();
    b.nonVFunc();
    
    return 0;
}
```

### 题目2.2：构造与析构中的虚函数调用
以下代码有什么问题？为什么？修复它。

```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() { 
        cout << "Base constructor" << endl;
        initialize(); 
    }
    virtual ~Base() { 
        cout << "Base destructor" << endl; 
        cleanup();
    }
    
    virtual void initialize() { 
        cout << "Base::initialize()" << endl; 
    }
    
    virtual void cleanup() { 
        cout << "Base::cleanup()" << endl; 
    }
};

class Derived : public Base {
    int* resource;
public:
    Derived() { 
        cout << "Derived constructor" << endl; 
        resource = new int[100];
    }
    
    ~Derived() { 
        cout << "Derived destructor" << endl;
        delete[] resource;
    }
    
    void initialize() override { 
        cout << "Derived::initialize()" << endl;
        resource[0] = 1;
    }
    
    void cleanup() override { 
        cout << "Derived::cleanup()" << endl;
    }
};

int main() {
    Derived d;
    return 0;
}
```

## 三、操作符重载

### 题目3.1：前缀后缀递增递减运算符
为以下计数器类实现前缀和后缀的递增(++)和递减(--)操作符。

```cpp
class Counter {
private:
    int value;
public:
    Counter(int val = 0) : value(val) {}
    int getValue() const { return value; }
    
};
```

### 题目3.2：智能指针类设计
实现一个简单的智能指针类MyUniquePtr，包含以下功能：
1. 构造函数、析构函数
2. 移动构造和移动赋值（但不允许拷贝）
3. 实现*和->操作符
4. 实现release()和reset()方法

```cpp
template<typename T>
class MyUniquePtr {
private:
    T* ptr;

public:
    
};
```

## 四、异常处理

### 题目4.1：异常处理流程分析
分析以下代码的执行流程，指出每个try-catch块是否会执行，以及最终输出。

```cpp
#include <iostream>
using namespace std;

class MyException {};
class DerivedEx : public MyException {};

void funcC() {
    cout << "funcC starts" << endl;
    throw DerivedEx();
    cout << "funcC ends" << endl;
}

void funcB() {
    cout << "funcB starts" << endl;
    try {
        funcC();
    }
    catch (MyException) {
        cout << "funcB caught MyException" << endl;
        throw;
    }
    cout << "funcB ends" << endl;
}

void funcA() {
    cout << "funcA starts" << endl;
    try {
        funcB();
    }
    catch (DerivedEx) {
        cout << "funcA caught DerivedEx" << endl;
    }
    catch (...) {
        cout << "funcA caught unknown exception" << endl;
    }
    cout << "funcA ends" << endl;
}

int main() {
    cout << "main starts" << endl;
    try {
        funcA();
    }
    catch (...) {
        cout << "main caught exception" << endl;
    }
    cout << "main ends" << endl;
    return 0;
}
```

### 题目4.2：RAII与异常安全
下面的代码在发生异常时可能导致资源泄漏，请使用RAII技术修复它。

```cpp
#include <iostream>
using namespace std;

class Resource {
public:
    Resource() { cout << "Resource acquired" << endl; }
    ~Resource() { cout << "Resource released" << endl; }
};

void riskyOperation() {
    throw runtime_error("Something went wrong");
}

void processData() {
    Resource* r1 = new Resource();
    Resource* r2 = new Resource();
    
    try {
        riskyOperation();
        // 处理数据...
        delete r1;
        delete r2;
    }
    catch (const exception& e) {
        cout << "Exception: " << e.what() << endl;
        delete r1;
        delete r2;
        throw;
    }
}

int main() {
    try {
        processData();
    }
    catch (const exception& e) {
        cout << "Caught in main: " << e.what() << endl;
    }
    return 0;
}
```

## 五、内存安全程序设计

### 题目5.1：智能指针使用
找出以下代码中的内存安全问题，并使用适当的智能指针修复它们。

```cpp
#include <iostream>
#include <memory>
using namespace std;

class Node {
public:
    int data;
    Node* next;
    Node* prev;
    
    Node(int d) : data(d), next(nullptr), prev(nullptr) {
        cout << "Node " << data << " created" << endl;
    }
    
    ~Node() {
        cout << "Node " << data << " destroyed" << endl;
    }
};

void createLinkedList() {
    Node* head = new Node(1);
    Node* second = new Node(2);
    Node* third = new Node(3);
    
    head->next = second;
    second->prev = head;
    second->next = third;
    third->prev = second;
    
    // 由于异常或提前返回，可能导致内存泄漏
    if (third->data == 3) {
        return;
    }
    
    delete third;
    delete second;
    delete head;
}

int main() {
    createLinkedList();
    cout << "Program finished" << endl;
    return 0;
}
```

### 题目5.2：循环引用问题
以下代码中存在循环引用问题，导致内存泄漏。请分析问题并修复。

```cpp
#include <iostream>
#include <memory>
#include <string>
using namespace std;

class Person {
    string name;
    shared_ptr<Person> spouse;  // 配偶

public:
    Person(const string& n) : name(n) {
        cout << "Person " << name << " created" << endl;
    }
    
    ~Person() {
        cout << "Person " << name << " destroyed" << endl;
    }
    
    void marry(shared_ptr<Person> other) {
        cout << name << " marries " << other->name << endl;
        spouse = other;
        other->spouse = shared_ptr<Person>(this);
    }
    
    string getName() const { return name; }
};

int main() {
    {
        auto alice = make_shared<Person>("Alice");
        auto bob = make_shared<Person>("Bob");
        
        alice->marry(bob);
    }
    
    cout << "End of scope" << endl;
    return 0;
}
```

## 六、并行程序设计

### 题目6.1：线程安全的计数器
实现一个线程安全的计数器类，可以被多个线程同时增加和减少。

```cpp
#include <thread>
#include <vector>
#include <iostream>

class ThreadSafeCounter {
private:

public:
    ThreadSafeCounter(int initial = 0);
    void increment();
    void decrement();
    int getValue() const;
};

// 测试代码
void test() {
    ThreadSafeCounter counter(0);
    std::vector<std::thread> threads;
    
    for (int i = 0; i < 10; ++i) {
        threads.push_back(std::thread([&counter]() {
            for (int j = 0; j < 1000; ++j) {
                counter.increment();
            }
        }));
    }
    
    for (int i = 0; i < 10; ++i) {
        threads.push_back(std::thread([&counter]() {
            for (int j = 0; j < 500; ++j) {
                counter.decrement();
            }
        }));
    }
    
    for (auto& t : threads) {
        t.join();
    }
    
    std::cout << "Final counter value: " << counter.getValue() << std::endl;
}
```

### 题目6.2：线程池实现
设计一个简单的线程池，能够接受任务并分配给空闲线程执行。

```cpp
#include <functional>
#include <queue>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <vector>

class ThreadPool {
private:
    
public:
    ThreadPool(size_t numThreads);
    ~ThreadPool();
    
    template<class F>
    void enqueue(F&& f);
    
    ThreadPool(const ThreadPool&) = delete;
    ThreadPool& operator=(const ThreadPool&) = delete;
};
```

## 答案

### 题目1.1答案
输出结果为：
```
Resource constructed
Container constructed
Container constructed
Container destroyed
End of block
```

分析：
1. 首先创建了栈上的c1对象，构造c1时创建了一个Resource对象
2. 然后创建了堆上的c2对象，构造c2时创建了另一个Resource对象
3. 作用域结束时，栈上的c1被销毁，调用其析构函数
4. 然而，c1的析构函数没有释放res指针指向的资源，导致内存泄漏
5. 堆上的c2对象没有被delete，因此c2本身和c2持有的Resource对象都没有被销毁，这也导致内存泄漏

内存问题：
1. Container类的析构函数没有释放res指针，导致资源泄漏
2. 堆上分配的c2没有被delete，导致c2及其资源都泄漏

修复方法：
```cpp
~Container() {
    cout << "Container destroyed" << endl;
    delete res;  // 释放资源
}

// 在main中添加
delete c2;  // 释放堆上的Container对象
```

### 题目1.2答案
问题：
1. 拷贝构造函数实现的是浅拷贝，直接复制了str指针，导致两个String对象指向同一块内存
2. 赋值操作符也是浅拷贝，没有释放原有的内存，导致内存泄漏
3. 赋值操作符没有检查自赋值情况
4. 没有正确处理空字符串情况

修复后的代码：
```cpp
class String {
    char* str;
    int length;
public:
    String(const char* s = "") {
        length = s ? strlen(s) : 0;
        str = new char[length + 1];
        if (s) strcpy(str, s);
        else str[0] = '\0';
    }
    
    ~String() {
        delete[] str;
    }
    
    // 深拷贝构造函数
    String(const String& other) {
        length = other.length;
        str = new char[length + 1];
        strcpy(str, other.str);
    }
    
    // 赋值操作符
    String& operator=(const String& other) {
        if (this == &other) return *this;  // 检查自赋值
        
        delete[] str;  // 释放原有内存
        length = other.length;
        str = new char[length + 1];
        strcpy(str, other.str);
        return *this;
    }
};
```

### 题目1.3答案
合法性分析：
- 访问1：不合法，私有成员不能被派生类访问
- 访问2：合法，protected成员可以被派生类访问
- 访问3：合法，public成员可以被派生类访问
- 访问4：不合法，同访问1
- 访问5：合法，同访问2
- 访问6：合法，同访问3
- 访问7：不合法，同访问1
- 访问8：合法，同访问2
- 访问9：合法，同访问3
- 访问10：不合法，私有成员不能在类外访问
- 访问11：不合法，protected成员不能在类外访问
- 访问12：合法，public继承时，基类public成员在派生类中仍为public
- 访问13：不合法，Base的私有成员不能被外部访问
- 访问14：不合法，Base的protected成员不能被外部访问
- 访问15：合法，public继承时，基类public成员在派生类中变为protected，不能被外部访问
- 访问16：不合法，同访问13
- 访问17：不合法，同访问14
- 访问18：不合法，protected继承时，基类public成员在派生类中变为protected，不能被外部访问
- 访问19：不合法，同访问13
- 访问20：不合法，同访问14
- 访问21：不合法，private继承时，基类所有成员在派生类中都变为private，不能被外部访问

### 题目2.1答案
分析：
- 调用1：`Derived::vFunc()`，因为bp指向Derived对象，vFunc是虚函数，所以动态绑定到Derived::vFunc
- 调用2：`Base::nonVFunc()`，因为nonVFunc不是虚函数，所以静态绑定到Base::nonVFunc
- 调用3：先调用`Base::callVFunc()`，然后由于vFunc是虚函数且通过this指针调用，所以动态绑定到`Derived::vFunc()`
- 调用4：`Derived::vFunc()`，因为br引用了Derived对象，vFunc是虚函数，所以动态绑定
- 调用5：`Base::nonVFunc()`，因为nonVFunc不是虚函数，所以静态绑定
- 调用6：`Base::vFunc()`，这里发生了对象切片，b实际上是Base类型，不是Derived类型
- 调用7：`Base::nonVFunc()`，同上，b是Base类型

完整输出：
```
=== Test 1 ===
Base constructor
Derived constructor
Derived::vFunc()
Base::nonVFunc()
Base::callVFunc() calls Derived::vFunc()
Base destructor

=== Test 2 ===
Base constructor
Derived constructor
Derived::vFunc()
Base::nonVFunc()

=== Test 3 ===
Base constructor
Derived constructor
Base destructor
Base::vFunc()
Base::nonVFunc()
Base destructor
Derived destructor
```

注意：Test 3中的对象切片问题导致Derived部分在赋值时就被销毁了。

### 题目2.2答案
问题：
1. 在Base的构造函数中调用虚函数initialize()，此时派生类部分尚未构造，会调用Base::initialize()而不是Derived::initialize()
2. 在Base的析构函数中调用虚函数cleanup()，此时派生类部分已经被销毁，会调用Base::cleanup()而不是Derived::cleanup()
3. 在Derived::initialize()中访问resource，但在Base构造阶段调用时resource尚未初始化
4. 在Derived::cleanup()中可能在resource已被释放后仍然尝试访问它

修复后的代码：
```cpp
#include <iostream>
using namespace std;

class Base {
public:
    Base() { 
        cout << "Base constructor" << endl;
        baseInitialize(); 
    }
    virtual ~Base() { 
        cout << "Base destructor" << endl; 
        baseCleanup();
    }
    
    // 非虚函数，供构造函数调用
    void baseInitialize() { 
        cout << "Base::baseInitialize()" << endl; 
        // 基类自己的初始化逻辑
    }
    
    // 非虚函数，供析构函数调用
    void baseCleanup() { 
        cout << "Base::baseCleanup()" << endl; 
        // 基类自己的清理逻辑
    }
    
    // 保留虚函数供正常操作使用
    virtual void initialize() { 
        cout << "Base::initialize()" << endl; 
    }
    
    virtual void cleanup() { 
        cout << "Base::cleanup()" << endl; 
    }
};

class Derived : public Base {
    int* resource;
public:
    Derived() { 
        cout << "Derived constructor" << endl; 
        resource = new int[100];
    }
    
    ~Derived() { 
        cleanup();  // 派生类析构前先调用虚函数
        cout << "Derived destructor" << endl;
        delete[] resource;
    }
    
    void initialize() override { 
        cout << "Derived::initialize()" << endl;
        resource[0] = 1;  // 此时resource已初始化
    }
    
    void cleanup() override { 
        cout << "Derived::cleanup()" << endl;
    }
};
```

### 题目3.1答案
```cpp
class Counter {
private:
    int value;
public:
    Counter(int val = 0) : value(val) {}
    int getValue() const { return value; }
    
    // 前缀++
    Counter& operator++() {
        ++value;
        return *this;
    }
    
    // 后缀++
    Counter operator++(int) {
        Counter temp = *this;
        ++value;
        return temp;
    }
    
    // 前缀--
    Counter& operator--() {
        --value;
        return *this;
    }
    
    // 后缀--
    Counter operator--(int) {
        Counter temp = *this;
        --value;
        return temp;
    }
};
```

### 题目3.2答案
```cpp
template<typename T>
class MyUniquePtr {
private:
    T* ptr;

public:
    // 构造函数
    explicit MyUniquePtr(T* p = nullptr) : ptr(p) {}
    
    // 析构函数
    ~MyUniquePtr() {
        if (ptr) delete ptr;
    }
    
    // 移动构造函数
    MyUniquePtr(MyUniquePtr&& other) noexcept : ptr(other.ptr) {
        other.ptr = nullptr;
    }
    
    // 移动赋值运算符
    MyUniquePtr& operator=(MyUniquePtr&& other) noexcept {
        if (this != &other) {
            reset();
            ptr = other.ptr;
            other.ptr = nullptr;
        }
        return *this;
    }
    
    // 禁用拷贝构造和拷贝赋值
    MyUniquePtr(const MyUniquePtr&) = delete;
    MyUniquePtr& operator=(const MyUniquePtr&) = delete;
    
    // 解引用操作符
    T& operator*() const {
        return *ptr;
    }
    
    // 箭头操作符
    T* operator->() const {
        return ptr;
    }
    
    // 获取原始指针
    T* get() const {
        return ptr;
    }
    
    // 释放所有权
    T* release() {
        T* temp = ptr;
        ptr = nullptr;
        return temp;
    }
    
    // 重置指针
    void reset(T* p = nullptr) {
        if (ptr) delete ptr;
        ptr = p;
    }
    
    // 布尔转换操作符
    explicit operator bool() const {
        return ptr != nullptr;
    }
};
```

### 题目4.1答案
执行流程：
1. main调用funcA
2. funcA调用funcB
3. funcB调用funcC
4. funcC抛出DerivedEx异常
5. funcB捕获到MyException异常（基类可以捕获派生类异常），输出"funcB caught MyException"
6. funcB重新抛出异常，继续传播
7. funcA捕获到DerivedEx异常（这里是精确匹配），输出"funcA caught DerivedEx"
8. funcA正常结束，输出"funcA ends"
9. main正常结束，输出"main ends"

完整输出：
```
main starts
funcA starts
funcB starts
funcC starts
funcB caught MyException
funcA caught DerivedEx
funcA ends
main ends
```

注意：
- funcB中的"funcB ends"不会输出，因为重新抛出异常后函数不会继续执行
- 由于异常已在funcA中处理，main中的catch块不会执行

### 题目4.2答案
问题：当riskyOperation()抛出异常时，即使try块中有delete语句，也不会执行到。catch块中又重新抛出异常，如果第二个delete之前又有异常，则第二个资源不会被释放。

使用RAII修复：
```cpp
#include <iostream>
#include <memory>
using namespace std;

class Resource {
public:
    Resource() { cout << "Resource acquired" << endl; }
    ~Resource() { cout << "Resource released" << endl; }
};

void riskyOperation() {
    throw runtime_error("Something went wrong");
}

void processData() {
    // 使用智能指针自动管理资源
    unique_ptr<Resource> r1(new Resource());
    unique_ptr<Resource> r2(new Resource());
    
    // 无需手动释放资源
    riskyOperation();
    // 处理数据...
}

int main() {
    try {
        processData();
    }
    catch (const exception& e) {
        cout << "Caught in main: " << e.what() << endl;
    }
    return 0;
}
```

或者使用传统的RAII封装：
```cpp
#include <iostream>
using namespace std;

class Resource {
public:
    Resource() { cout << "Resource acquired" << endl; }
    ~Resource() { cout << "Resource released" << endl; }
};

// RAII封装
class ResourceGuard {
    Resource* res;
public:
    ResourceGuard(Resource* r) : res(r) {}
    ~ResourceGuard() { delete res; }
    // 禁止拷贝
    ResourceGuard(const ResourceGuard&) = delete;
    ResourceGuard& operator=(const ResourceGuard&) = delete;
};

void riskyOperation() {
    throw runtime_error("Something went wrong");
}

void processData() {
    Resource* r1 = new Resource();
    ResourceGuard g1(r1);  // g1负责释放r1
    
    Resource* r2 = new Resource();
    ResourceGuard g2(r2);  // g2负责释放r2
    
    riskyOperation();
    // 处理数据...
}

int main() {
    try {
        processData();
    }
    catch (const exception& e) {
        cout << "Caught in main: " << e.what() << endl;
    }
    return 0;
}
```

### 题目5.1答案
问题：
1. 函数提前返回时，没有释放已分配的节点，导致内存泄漏
2. 双向链表中的节点互相引用，应该使用智能指针管理

修复后的代码：
```cpp
#include <iostream>
#include <memory>
using namespace std;

class Node {
public:
    int data;
    shared_ptr<Node> next;
    weak_ptr<Node> prev;  // 使用weak_ptr避免循环引用
    
    Node(int d) : data(d) {
        cout << "Node " << data << " created" << endl;
    }
    
    ~Node() {
        cout << "Node " << data << " destroyed" << endl;
    }
};

void createLinkedList() {
    auto head = make_shared<Node>(1);
    auto second = make_shared<Node>(2);
    auto third = make_shared<Node>(3);
    
    head->next = second;
    second->prev = head;  // weak_ptr不会增加引用计数
    second->next = third;
    third->prev = second;
    
    // 即使提前返回，智能指针也会自动释放内存
    if (third->data == 3) {
        return;
    }
}

int main() {
    createLinkedList();
    cout << "Program finished" << endl;
    return 0;
}
```

### 题目5.2答案
问题：
在marry函数中，使用`other->spouse = shared_ptr<Person>(this);`创建了一个新的shared_ptr，但是它与alice和bob已有的shared_ptr不共享引用计数，导致循环引用。

修复方法：
```cpp
#include <iostream>
#include <memory>
#include <string>
using namespace std;

class Person {
    string name;
    weak_ptr<Person> spouse;  // 改用weak_ptr避免循环引用

public:
    Person(const string& n) : name(n) {
        cout << "Person " << name << " created" << endl;
    }
    
    ~Person() {
        cout << "Person " << name << " destroyed" << endl;
    }
    
    void marry(shared_ptr<Person> other) {
        cout << name << " marries " << other->name << endl;
        spouse = other;  // weak_ptr不会增加引用计数
        
        // 使用lock()方法获取shared_ptr
        if (auto sp = spouse.lock()) {
            sp->setSpouse(shared_from_this());
        }
    }
    
    void setSpouse(shared_ptr<Person> other) {
        spouse = other;
    }
    
    string getName() const { return name; }
};

int main() {
    {
        auto alice = make_shared<Person>("Alice");
        auto bob = make_shared<Person>("Bob");
        
        alice->marry(bob);
    }
    
    cout << "End of scope" << endl;
    return 0;
}
```

注意：要使用shared_from_this()，Person类需要继承enable_shared_from_this<Person>。

### 题目6.1答案
```cpp
#include <thread>
#include <vector>
#include <iostream>
#include <mutex>

class ThreadSafeCounter {
private:
    int count;
    mutable std::mutex mtx;  // mutable允许在const方法中修改

public:
    ThreadSafeCounter(int initial = 0) : count(initial) {}
    
    void increment() {
        std::lock_guard<std::mutex> lock(mtx);
        count++;
    }
    
    void decrement() {
        std::lock_guard<std::mutex> lock(mtx);
        count--;
    }
    
    int getValue() const {
        std::lock_guard<std::mutex> lock(mtx);
        return count;
    }
};

// 测试代码
void test() {
    ThreadSafeCounter counter(0);
    std::vector<std::thread> threads;
    
    for (int i = 0; i < 10; ++i) {
        threads.push_back(std::thread([&counter]() {
            for (int j = 0; j < 1000; ++j) {
                counter.increment();
            }
        }));
    }
    
    for (int i = 0; i < 10; ++i) {
        threads.push_back(std::thread([&counter]() {
            for (int j = 0; j < 500; ++j) {
                counter.decrement();
            }
        }));
    }
    
    for (auto& t : threads) {
        t.join();
    }
    
    std::cout << "Final counter value: " << counter.getValue() << std::endl;
}
```

### 题目6.2答案
```cpp
#include <functional>
#include <queue>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <vector>

class ThreadPool {
private:
    
public:
    ThreadPool(size_t numThreads);
    ~ThreadPool();
    
    template<class F>
    void enqueue(F&& f);
    
    ThreadPool(const ThreadPool&) = delete;
    ThreadPool& operator=(const ThreadPool&) = delete;
}; 