---
title: 第三章：程序的转换以及机器数表示
author: Yama
---

# 程序的转换以及机器数表示

**RTL表示**

RTL：Register Transfer Language。在本书中规定为：R[r]寄存器r里面存储的内容，M[addr]地址addr里面存储的内容，PC程序计数器

目的寄存器在左，源操作数在

>   重点掌握32位的知识，这个是考试的核心的内容，但是64位是现在用的比较多的。。
>
>   考试形式：给高级语言和汇编语言，分析程序执行过程中的各种内容的分析

**汇编语言格式**

>   以mov指令为例，这里选取了一个基址+变址*倍数 +偏移量的方式

Intel格式： mov [bx+di-6], cl 

AT&T格式：

>   课程采取AT&T的格式

我们需要学习的是，如何写RTL语言



**一条指令必须包含的信息**

操作码：指定操作类型

操作数：一个或多个源操作数所在的地址

**x86_64和IA32的区别**

x86_64添加了8个64位的通用寄存器，所有的GPRs都由原先的32位扩充到64位。字长变为64位，过程调用的时候通常用通用寄存器而不是栈来传递参数

## 3.2 IA-32

### 寻址方式


> 寄存器的顺序是： **eax ecx edx ebx** 分别代表了0 1 2 3 > 然后是esp，ebp，esi和edi分别是5678



## IA32指令格式

机器指令由指令前缀+指令本身构成
指令前缀：
指令的结构为：
OP+ModR/M+ SIB+位移+ 立即数



b  w l q(分别代表1个，2个，4个和8个字节)

w要加66，q要加一个48（不一定是48，二进制的低三位不一定全为0）

### 常见的汇编指令
**操作码的后缀**
因为数据宽度的不同（比如有8位寄存器，16位寄存器和32位寄存器等等），同一个指令后面加上数据宽度的后缀就能够表示对不同宽度寄存器的操作
- `movl %eax %ecx `将32位（4个字节）的eax内的数据传递到ecx里面
- `pushq %ebx` 从栈中弹出64位的（8个字节）数据，保存到ebx里面
其中，一般用b w l q 代表1,2,4,8个字节（一个字节是8位）

MOV: 
MOVS: 符号扩展传递，如movsbw将byte的移动到一个w长度的寄存器
MOVZ:
> 不存在从单独的截断指令，直接使用mov指令传送即可，按照位数低的来进行传送，默认会选取低XX位进行传送。
> `movl %edi %eax`把

**PUSH、POP**：入栈出栈，如pushq为推入一个4字节的指令
注意：在执行pop和push的时候，一定会改变esp的值，比如：
```ass
pushl %eax
popl %ecx
```
在这里中

**LEA指令** (Load Effective Adderess)有效地址传输
比如 leal 6(%eax), %edx 用于将eax寄存器+6的地址存在edx中（如果eax的值是x，那么edx里面存储的是x+6)
lea的花哨用法：用于加减乘法，
比如 leal 0x10(%eax, %eax, 3) %eax 的效果为：$x= 4* x+10$
**输入输出指令**
in将端口内容送累加器，out将累加器送I/O端口
**标志传送指令**
pushf将标志寄存器的内容压栈；popf将栈顶的内容存入标志寄存器中
**加减指令**
ADD和SUB都是将结果存入目的地，并且加减的结果标志送入标志寄存器`FLAGS/EFLAGS`中
**INC/DEC**
对指定的位串进行+1（INC，increment）或者-1（DEC，decrement）操作，标志信息存标志寄存器中
**NEG指令**
取负指令，或者为取补指令，对指定的位串进行按位取反再加一。
如果是0，那么NEG后仍为0，但是CF置为0（其他的情况，CF一直都是0）
如果是首位为1，其他位都是0（也就是最大的负数），NEG之后，值不变，且将OF设置为1，即溢出。
**乘除指令**
> 比较复杂，建议看书，P106

