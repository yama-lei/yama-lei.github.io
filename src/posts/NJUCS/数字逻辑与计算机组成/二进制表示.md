---
title: 二进制表示
---

# 二进制表示

## 1.1 计算机系统概述

### 冯诺依曼结构

采用**存储程序**的工作方式

计算机由运算器，存储器，控制器，输入/输出设备（I/O设备）构成。

其中：

-   存储器：存储指令和数据（指令和数据在计算机内部的表示方式一致，但是计算机由识别 他们的方法）
-   运算器：内部有**ALU**（arithmetic and logic unit）算数逻辑单元和通用寄存器组**GPRs**（General Purposed Register Set），**是指令的执行单元**;
-   控制器：**自动地取出指令**;内有指令寄存器**IR**(Instruction Register)和**PC**(Program Count)程序计数器，前者存放从主存中取来的指令
-   I/O设备，输入和输出

![image-20250217111409374](./二进制表示.assets/image-20250217111409374.png)

>   CPU中 除了‘控制部件’都是运算器；
>
>   注意缩写的含义!
>
>   ![image-20250217125953166](./二进制表示.assets/image-20250217125953166.png)
>
>   图中内容来自教材

### 程序的表示和执行（核心！！！）

1.   程序在执行前：
     -   将数据和指令存放在**内存**中
     -   每一条指令和数据都有地址
     -   指令有序存放  （但是不一定按序执行）
     -   将程序的起始地址置入PC（Program Count）（PC其实是一个地址寄存器，用于寄存下一个指令的地址）

>   程序执行前指的是“从点击鼠标”到执行第一条指令前的过程

2.   程序执行的过程中：

     -   根据PC取指令

     -   翻译PC指令中的操作码

     -   根据操作码：取操作数，执行操作，将结果写入目的地址中

     -   **修改PC为下一条指令的地址**（这是指令依次执行的关键），再循环上述流程

         >   指令中通常包括以下信息：操作码（加减等）源操作数1 或/和 源操作数2（的地址）  目的操作数地址  



关于计算机读取指令的过程，还可以看下面deepseek r1生成的内容

>   #### **1. 取指阶段（Fetch）**
>
>   -   **目标**：从内存中读取下一条指令。
>   -   **步骤**：
>       1.  **程序计数器（PC）**：控制器中的寄存器PC存储当前指令的内存地址。
>       2.  **发送地址**：控制器将PC中的地址发送到内存。
>       3.  **读取指令**：内存根据地址返回指令内容（二进制码）。
>       4.  **存入指令寄存器（IR）**：指令被临时存入控制器的**指令寄存器（IR）**。
>       5.  **更新PC**：PC自动+1（或根据跳转指令修改），指向下一条指令地址。
>
>   ------
>
>   #### **2. 解码阶段（Decode）**
>
>   -   **目标**：解析指令内容，确定操作类型和操作数。
>   -   **步骤**：
>       1.  **拆分指令**：指令分为**操作码（Opcode）\**和\**操作数（Operand）**。
>           -   **操作码**：指明操作类型（如加法、跳转）。
>           -   **操作数**：指明数据来源（如寄存器、内存地址）。
>       2.  **控制器生成控制信号**：根据操作码，向各部件发送控制信号（如激活ALU、选择寄存器）。
>
>   ------
>
>   #### **3. 执行阶段（Execute）**
>
>   -   **目标**：完成指令规定的操作。
>   -   **可能的操作类型**：
>       -   **算术/逻辑运算**（由ALU执行）：
>           -   例如：`ADD R1, R2`（将寄存器R1和R2的值相加）。
>           -   控制器将R1和R2的数据送入ALU，ALU计算结果后存回指定寄存器。
>       -   **数据移动**：
>           -   例如：`LOAD R1, 0x100`（将内存地址0x100的数据加载到R1）。
>           -   控制器从内存读取地址0x100的数据，存入寄存器R1。
>       -   **控制流跳转**：
>           -   例如：`JMP 0x200`（跳转到地址0x200执行）。
>           -   直接修改PC的值，改变下一条指令地址。
>
>   ------
>
>   #### **4. 写回阶段（Write Back）**
>
>   -   **目标**：将执行结果写回寄存器或内存。
>   -   **例如**：运算结果存入寄存器，或内存地址更新数据。

---



### 计算机系统的抽象层

![image-20250217192637741](./二进制表示.assets/image-20250217192637741.png)

 **软硬件交互--ISA**

ISA是硬件和软件之间的桥梁，规定了软件和硬件之间交互的接口；

ISA是一种规约，规定了可执行的指令的集合，以及指令可以接受的操作数的类型。

---

### 机器级语言：机器语言，汇编语言

-   机器语言：0011.....

-   汇编语言优点： 1. 可读性 2. 便于编写代码。

汇编语言程序!=汇编程序， **汇编语言程序**是用汇编语言写的程序；**汇编程序**是将汇编语言转换成**机器级语言**的程序。

汇编符合某一个ISA，只能在同一个ISA设计的 机器上运行。之所以我们写高级语言不用操心这一个，是因为有一层封装。

**硬件只能执行机器语言程序**

**编译与解释**：

1.   编译：将高级语言源程序->机器级语言
2.   解释：逐条翻译成

机器代码还需要通过**指令译码器**翻译成控制信号

![image-20250221103502221](./二进制表示.assets/image-20250221103502221.png)

---

### 一个例子

**8位**模型机M：8位定长指令字，4个GPR，16个主存单元；8位指的是指令的长度，GPR中大部分也为8位；

>   目前市面上大部分的存储设备的主存单元都是8位

详细见ppt。

---

## 1.2 二进制编码

机器只能执行二进制的机器代码，只能计算二进制的数据。

-   真值：01序列代表的现实中的值
-   机器数：01序列



1. 数值型数据

​	不同的进制：二进制B，八进制O，十六进制H(或ox- prefix)

2. 非数值型数据

**不同进制之间的转换**

1.   十进制和其他进制
2.   二进制与十六进制，二进制与八进制。



## 1.3 数值型数据的表示

原码：首位是符号位！

#### 定点数

定点数可以表示小数，也可以表示小数；小数的小数点默认在最左边，整数的小数点默认在最左边。

>   定点整数：小数点固定在数值位最右，**无需显式表达**定点小数：小数点固定在数值位最左，**无需显式表达**

补码：在模n的运算中，任何一个数的补码是它对n取模后的结果。

如果用n位二进制来表示补码，则可以表示-2^(n--1) 到 2^(n-1)-1的数字；

给定任何一个这个范围中的数字，对2^n取模，将这个结果表示为二进制，即得到了这个数的补码。

1.   显然，对于这个范围之间的正数，补码就是他的本身
2.   对于负数，先加上 $2^n$，再表示为二进制。

>   **给定一个8位的二进制，$2^8$-这个二进制=这个二进制按位取反+1；因为在这个二进制+这个二进制的取反= $2^8$-1**

因此，计算 -1101100的补码，只需要计算 $2^n$-1101100的二进制表示，即1101100按位取反再加一
