---
title: 顺序结构
---

**线性表**

LinerList，每一个元素（除了表头和表尾）有且仅有一个前驱和后继，每一个元素的结构可以不一样（如果不一样，可以使用UNION，联合体）

>   UNION：
>
>   ```cpp
>   typedef union{
>   	long long int val;
>       char ch;
>   }data;
>   //Use data.val to access longlongint, use data.ch to access ch; however, them share the same memory!
>   ```

动态分配和静态分配：*Stack and Heap*

Stack：栈空间在编译的时候分配，栈空间比较小，编译器自动分配空间。

Heap: 堆空间在运行的时候分配，空间较大，但是分配比较慢。

**顺序表**

顺序表可以继承自线性表：

| 访问控制符 | 类内部 | 派生类 | 类外部 |
| :--------- | :----- | :----- | :----- |
| public     | ✓      | ✓      | ✓      |
| protected  | ✓      | ✓      | ✗      |
| private    | ✓      | ✗      | ✗      |

顺序表类似于数组（或者说数组是顺序表）

**顺序表的操作**

-   顺序表的查找
-   顺序表的删除

**顺序表应用**

-   集合的交

    ```cpp
    #LA.len()为n, LB.len()为m
    i=0
    while(i<LA.len()){
       if(LB.search(LA[i])==0){
    		//B中没有的话，把A中的删除了，搜索的复杂度为m，A的删除的复杂度为n
           LA.remove(i);
       }else{
    		i++;
           //注意，如果删除了的话，就不需要i++了，因为“自动”地往前移动了
       }
    }
    ```

    最好地时间复杂度为：O(mn)， 最差地复杂度为O(n(m+n))



-   集合的并

```cpp
#LA.len()为n, LB.len()为m
i=0
while(i<LA.len()){
   if(LB.search(LA[i])==0){
       
       LB.append(La[i]);
   		i+=1;
   }
}
```







**链表**

-   Node使用class实现的时候，需要使用friend class

    >   在class Node中声明Link是其frined class，这样就可以在Link中获取到Node的private member比如data和prev/next的等
