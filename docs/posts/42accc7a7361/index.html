<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>高级程序设计课程笔记 | YamaBlog</title><meta name="author" content="Yama-lei"><meta name="copyright" content="Yama-lei"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="高程的一些课程笔记 课程ppt: 高级程序设计2025春季 这里笔记的顺序是按照单元顺序来写的，只有大纲； 标注的必考和200%必考的更加注意。">
<meta property="og:type" content="article">
<meta property="og:title" content="高级程序设计课程笔记">
<meta property="og:url" content="https://yama-lei.top/posts/42accc7a7361/index.html">
<meta property="og:site_name" content="YamaBlog">
<meta property="og:description" content="高程的一些课程笔记 课程ppt: 高级程序设计2025春季 这里笔记的顺序是按照单元顺序来写的，只有大纲； 标注的必考和200%必考的更加注意。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/yama.webp">
<meta property="article:published_time" content="2025-03-25T16:00:00.000Z">
<meta property="article:modified_time" content="2025-09-28T13:41:20.031Z">
<meta property="article:author" content="Yama-lei">
<meta property="article:tag" content="博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/yama.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "高级程序设计课程笔记",
  "url": "https://yama-lei.top/posts/42accc7a7361/",
  "image": "https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/yama.webp",
  "datePublished": "2025-03-25T16:00:00.000Z",
  "dateModified": "2025-09-28T13:41:20.031Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yama-lei",
      "url": "https://yama-lei.top"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yama-lei.top/posts/42accc7a7361/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":true,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '高级程序设计课程笔记',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/callout_blocks.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/homepage-hero.css"><link rel="stylesheet" href="/css/card-enhance.css"><link rel="stylesheet" href="/css/sidebar-enhance.css"><link rel="stylesheet" href="/css/category-tag-page.css"><meta name="generator" content="Hexo 8.0.0"><link rel="alternate" href="/atom.xml" title="YamaBlog" type="application/atom+xml">
</head><body><div id="web_bg" style="background-color: #ffffff;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/yama.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">105</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-list"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/essay/"><i class="fa-fw fas fa-comment-dots"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/playground/"><i class="fa-fw fas fa-flask"></i><span> Playground</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-user-friends"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img fixed" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">YamaBlog</span></a><a class="nav-page-title" href="/"><span class="site-name">高级程序设计课程笔记</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-list"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/essay/"><i class="fa-fw fas fa-comment-dots"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/playground/"><i class="fa-fw fas fa-flask"></i><span> Playground</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-user-friends"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">高级程序设计课程笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-25T16:00:00.000Z" title="发表于 2025-03-26 00:00:00">2025-03-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-28T13:41:20.031Z" title="更新于 2025-09-28 21:41:20">2025-09-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/NJUCS/">NJUCS</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/NJUCS/%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/">高级程序设计</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><p>高程的一些课程笔记</p>
<p>课程ppt: <a target="_blank" rel="noopener" href="https://cslab-cms.nju.edu.cn/classrooms/noivrc5f/attachment">高级程序设计2025春季</a></p>
<p>这里笔记的顺序是按照单元顺序来写的，只有大纲；</p>
<p>标注的<strong>必考</strong>和<strong>200%必考</strong>的更加注意。</p>
<span id="more"></span>
<h1 id="抽象与封装"><a class="markdownIt-Anchor" href="#抽象与封装"></a> 抽象与封装</h1>
<p>抽象与封装使得开发者无需关心底层</p>
<p>内部实现不影响外部的使用</p>
<p>例子：用链表封装stack</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num;</span><br><span class="line">    Node *prev;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">int</span> num, Node *prev = <span class="literal">nullptr</span>) : <span class="built_in">num</span>(num), <span class="built_in">prev</span>(prev) &#123;&#125;</span><br><span class="line">&#125; node;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> num)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get_size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="type">int</span>&amp; <span class="title">top</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="built_in">Stack</span>();</span><br><span class="line"><span class="comment">// 在pubulic 里面定义的是interface</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    node *tail;</span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 数据常常标为private   </span></span><br><span class="line"> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stack::push</span><span class="params">(<span class="type">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    size += <span class="number">1</span>;</span><br><span class="line">    tail = <span class="keyword">new</span> <span class="built_in">node</span>(num, tail);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stack::pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> tail;</span><br><span class="line">        tail = tail-&gt;prev;</span><br><span class="line">        size -= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">Stack::get_size</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">Stack::empty</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span>&amp; <span class="title">Stack::top</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (tail-&gt;num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stack::<span class="built_in">Stack</span>():<span class="built_in">tail</span>(<span class="literal">nullptr</span>),<span class="built_in">size</span>(<span class="number">0</span>)&#123;&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    Stack st;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        st.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        cout&lt;&lt;st.<span class="built_in">top</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        st.<span class="built_in">push</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        st.<span class="built_in">top</span>()+=<span class="number">1</span>;</span><br><span class="line">        cout&lt;&lt;st.<span class="built_in">top</span>()&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;\n-------------------\n&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;size: &quot;</span>&lt;&lt;st.<span class="built_in">get_size</span>()&lt;&lt;<span class="string">&quot; isEmpty? &quot;</span>&lt;&lt;st.<span class="built_in">empty</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="面向对象"><a class="markdownIt-Anchor" href="#面向对象"></a> 面向对象</h1>
<p><a href="./class">另外一篇与class有关的文章</a></p>
<p>细节：<strong>class在定义完成之前是不能创建实例的</strong>；但是可以创建这个类型的pointer和reference</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    A a;<span class="comment">//Error! Compiler don&#x27;t konw how much memory to allocate</span></span><br><span class="line">    A* p;<span class="comment">//OK</span></span><br><span class="line">    A&amp; r;<span class="comment">//OK</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>下面内容必考，前面不是重点</strong></p>
<h2 id="对象的创建方式注意不同创建的方式高频考点"><a class="markdownIt-Anchor" href="#对象的创建方式注意不同创建的方式高频考点"></a> 对象的创建方式（<strong>注意不同创建的方式，高频考点</strong>）</h2>
<ul>
<li>
<p>直接创建 : A a; 内存在stack区，作用域结束后内存自动释放</p>
</li>
<li>
<p>间接方式创建动态变量:A* p=new A;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在最后记得要delete p！！delete对应的是p所指的heap上面的空间</span></span><br><span class="line"><span class="comment">//p是栈上的变量，但是p所指的是heap上的一段空间</span></span><br><span class="line"><span class="keyword">delete</span> p;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="public-privateprotected"><a class="markdownIt-Anchor" href="#public-privateprotected"></a> public, private,protected:</h3>
<ul>
<li>public:   可以在class之外被访问</li>
<li>private: 在class之外不能访问，不能被derived class继承</li>
<li>protected：在class之外不能别访问，可以被derived class继承</li>
</ul>
<blockquote>
<p>友元函数可以访问public和protected</p>
</blockquote>
<h3 id="对象作为函数参数进行传递作为函数返回值必考点区分下面的区别必考"><a class="markdownIt-Anchor" href="#对象作为函数参数进行传递作为函数返回值必考点区分下面的区别必考"></a> 对象作为函数参数进行传递,作为函数返回值（<strong>必考点</strong>，区分下面的区别）！！！<strong>必考</strong></h3>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(A a)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传入对象，并创建一个临时的A对象</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">(A&amp; a)</span></span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//传入的是原先对象的引用</span></span><br><span class="line"><span class="function">Date <span class="title">f1</span><span class="params">(A&amp; a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//会创建一个临时变量并返回</span></span><br><span class="line"><span class="function">Date&amp; <span class="title">f1</span><span class="params">(A&amp; a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//只会return 临时的变量！</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>注意<code>f1</code>return了原来的对象！！</p>
<h2 id="构造函数和析构函数"><a class="markdownIt-Anchor" href="#构造函数和析构函数"></a> 构造函数和析构函数</h2>
<ul>
<li>
<p>构造函数可以有多个，可以重载：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>();</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> a);</span><br><span class="line">    <span class="built_in">A</span>(A&amp; a);</span><br><span class="line">&#125;</span><br><span class="line">A::<span class="built_in">A</span>()&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;Default class constructor\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">A::<span class="built_in">A</span>(<span class="type">int</span> a)&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;This is &quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此外，还可以本地初始化，在类创建的时候，还可以</p>
</li>
<li>
<p>如果在instance中申请了额外的内存空间，那么<strong>必须</strong>自定义一个析构函数来销毁这个类的instance</p>
</li>
</ul>
<p>什么时候必须要析构函数<strong>下面这个200%必考！！！！！！！！！！！</strong></p>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250226105914264.png" alt="image-20250226105914264" /></p>
<blockquote>
<p>图中讲str赋值为nullptr是为了更加地安全。也可以没有；</p>
<p>NOTE：析构函数注意要判断nullptr！！！delete之后一定要将指针赋值为nullptr，防止有手动析构的样例！！！</p>
</blockquote>
<p><strong>内存是怎么分配的？</strong></p>
<ul>
<li>stack里面有一个String instance: int 4bytes, char* 4bytes; 8bytes in total;</li>
<li>在调用构造函数的时候，在heap上要了5个char位置，存放’a’,‘b’,‘c’,‘d’,‘\n’.</li>
</ul>
<p>当这个类的instance的作用域消失以后，编译器会自动调用这个类的析构函数；如果没有的话，就会自动创造一个析构函数，但是这个默认的够细函数是不会自己去销毁heap上的内存，需要手动销毁，防止内存泄露！</p>
<h3 id="this指针"><a class="markdownIt-Anchor" href="#this指针"></a> this指针</h3>
<p>每一个类的成员函数其实都会隐藏一个默认的<code>this</code>指针。面向对象其实是一种思想。</p>
<p>不重要，不是考点。</p>
<h3 id="拷贝构造函数考点之一"><a class="markdownIt-Anchor" href="#拷贝构造函数考点之一"></a> 拷贝构造函数（考点之一）</h3>
<p>你必须care拷贝构造函数。</p>
<p>相当于是构造函数一种特殊的重载。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> data):<span class="built_in">data</span>(data)</span><br><span class="line">    <span class="built_in">A</span>(A&amp; a):<span class="built_in">data</span>(a.data)<span class="comment">//拷贝构造函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>三种情况下会调用这个拷贝构造函数：</p>
<ol>
<li>利用一个instance 创造另一个instance</li>
<li>当一个instance作为参数传递给一个函数时（pass by value,会在函数内部调用拷贝构造函数创建一个新的临时对象）</li>
<li>当一个instance作为函数返回值时 （注意，和上面一样，不是referece，而是pass by value）</li>
</ol>
<p>如果没有构造函数，就会生成一段简单的拷贝构造函数。</p>
<ul>
<li>直接将成员里面的变量赋值给被拷贝的对象，是<code>shallow copy</code>！</li>
</ul>
<p>比如，以下面这个200%会考的内容为例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//例如，在下面的类中没有自定义拷贝构造函数：</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;    <span class="type">int</span> len;</span><br><span class="line">    <span class="type">char</span> *str;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">String</span>(<span class="type">char</span> *s) </span><br><span class="line">  &#123; len = <span class="built_in">strlen</span>(s); </span><br><span class="line">     str = <span class="keyword">new</span> <span class="type">char</span>[len<span class="number">+1</span>]; </span><br><span class="line">     <span class="built_in">strcpy</span>(str,s); </span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">String</span>() &#123; <span class="keyword">delete</span> []str; len=<span class="number">0</span>; str=<span class="literal">NULL</span>; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">......</span><br><span class="line"><span class="function">String <span class="title">s1</span><span class="params">(<span class="string">&quot;abcd&quot;</span>)</span></span>;</span><br><span class="line"><span class="function">String <span class="title">s2</span><span class="params">(s1)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li>系统提供的隐式拷贝构造函数将会使得s1和s2的成员指针str指向同一块内存区域！</li>
</ul>
</blockquote>
<p>会带来一系列的内存安全问题</p>
<ul>
<li>如果对一个对象（s1或s2）操作之后修改了这块空间的内容，则另一个对象将会受到影响。如果不是设计者特意所为，这将是一个隐藏的错误。</li>
<li>当对象s1和s2消亡时，将会分别去调用它们的析构函数，这会使得同一块内存区域将被归还两次，从而导致程序运行错误。</li>
<li>当对象s1和s2中有一个消亡，另一个还没消亡时，则会出现使用已被归还的空间问题！</li>
</ul>
<p>我们需要自定义拷贝构造函数，进行<code>deep copy</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>(String&amp; s)&#123;</span><br><span class="line">    len=s.len;</span><br><span class="line">    str=<span class="keyword">new</span> <span class="type">char</span>[len<span class="number">+1</span>];</span><br><span class="line">    <span class="built_in">strcpy</span>(str,s.str);<span class="comment">//将s.str的内容复制到str中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<h2 id="32常成员函数"><a class="markdownIt-Anchor" href="#32常成员函数"></a> 3.2常成员函数</h2>
<h4 id="常成员函数"><a class="markdownIt-Anchor" href="#常成员函数"></a> 常成员函数</h4>
<ol>
<li>可以用const约束函数，使得这个函数不能修改类成员的值：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="type">int</span>* b;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span> <span class="type">const</span></span>&#123;</span><br><span class="line">        a=<span class="number">1</span>;<span class="comment">//Error, 不能改；</span></span><br><span class="line">       	b=<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);<span class="comment">//Error不能修改b的值</span></span><br><span class="line">        *b=<span class="number">1</span>;<span class="comment">//正确，因为b的值没有改变，只是改变了b所指的地址的值。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//But you can modify static member fo the class!</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>常成员只能调用常成员函数</li>
</ol>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250305102533844.png" alt="image-20250305102533844" /></p>
<h4 id="静态数据成员"><a class="markdownIt-Anchor" href="#静态数据成员"></a> <strong>静态数据成员</strong></h4>
<ol>
<li>存储在<strong>静态存储区</strong>，内存为所有类的实例共享。</li>
<li>必须在类的内部声明，并且在类的外部初始化：</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> a;<span class="comment">//不能在类的内部赋值</span></span><br><span class="line">&#125;</span><br><span class="line">\\.....</span><br><span class="line"><span class="type">int</span> A::a=<span class="number">10</span>;<span class="comment">//在类的外面赋值    </span></span><br></pre></td></tr></table></figure>
<h4 id="静态成员函数"><a class="markdownIt-Anchor" href="#静态成员函数"></a> 静态成员函数</h4>
<p>只能访问到静态成员对象</p>
<h3 id="33友元"><a class="markdownIt-Anchor" href="#33友元"></a> 3.3友元</h3>
<p>友元不是类的成员，但是可以访问类的所有成员，包括private和protected。</p>
<p>如:</p>
<p><strong>熟悉下面这个即可</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">friend</span> ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, A&amp; a)&#123;</span><br><span class="line">        os&lt;&lt;<span class="string">&quot;A(&quot;</span>&lt;&lt;a&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line"> 	<span class="keyword">friend</span> istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream&amp; os,A&amp; a)&#123;</span><br><span class="line">        os&gt;&gt;a.a;</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="34类的模块化设计"><a class="markdownIt-Anchor" href="#34类的模块化设计"></a> 3.4类的模块化设计</h3>
<blockquote>
<p><strong>cpp里面的模块化设计</strong></p>
<ul>
<li>接口：包含被外界使用的类型定义、常量定义以及全局变量和函数的声明。（.h文件）</li>
<li>实现：包含本模块中所有的类型、常量、全局变量和函数的定义。（.cpp文件）</li>
</ul>
</blockquote>
<h2 id="41inheritance继承"><a class="markdownIt-Anchor" href="#41inheritance继承"></a> 4.1Inheritance继承</h2>
<p>派生类(derived class)，即子类。</p>
<p>基类(base class)，即父类。</p>
<p>继承从基类的数量，分为<code>多继承（很少考）</code>和<code>单继承</code></p>
<p>继承按照继承的方式可以分为<code> public继承</code>  <code>private继承(by default)</code> <code>protected继承</code></p>
<hr />
<p><strong>派生类：</strong></p>
<ul>
<li>有子类的所有成员和函数，但是不能访问<code>private</code>成员;有，但是不能访问！</li>
<li>可以override base class的成员</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;驿站寄旧衣，七毛一公斤&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;a;<span class="comment">//Error</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span>: <span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="type">int</span> a;<span class="comment">//override</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;a;<span class="comment">//It&#x27;s ok!</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>注意，如果要覆盖的话，就需要用作用域修饰符：</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;sdddsds&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>:<span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;I am a member function of B&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">fun</span>();</span><br><span class="line">        A::<span class="built_in">fun</span>();</span><br><span class="line">        <span class="comment">//output:  I am a member function of B</span></span><br><span class="line">        <span class="comment">//         sdddsds</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>派生类的成员对外访问情况</strong> | <strong>百分之一百的考点！！！</strong></p>
<blockquote>
<p>考法为程序分析题，给一段代码，找出错误。</p>
</blockquote>
<p>从base class继承而来的成员的访问限定情况，和继承的方式有关：</p>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250305114142277.png" alt="image-20250305114142277" /></p>
<p>关注ppt上的那个例题。</p>
<p><strong>子类型</strong></p>
<p>派生类就是基类的一个子类型；</p>
<ul>
<li>派生类对象可以直接赋值给基类，其中不属于基类的成员将被忽略。</li>
<li>基类的指针可以指向派生类。</li>
</ul>
<p><strong>drived class对象的创建和消亡</strong></p>
<p>从基类集成的数据由基类的构造函数初始化，派生类的数据类型由派生类的构造函数初始化；</p>
<ul>
<li>先执行基类的构造函数，再执行派生类的构造函数</li>
<li>默认是执行基类的默认构造函数，除非在派生类的构造函数的成员初始化列表中给出</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">B</span>(): <span class="built_in">A</span>(<span class="type">int</span> a)&#123;</span><br><span class="line">        <span class="comment">//初始化列表里面调用A的构造函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这样的话，B的默认构造函数会调用A的一个构造函数（ A(int i)&#123;&#125;;）</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果派生类里面没有提供构造函数，则会生成一个derived class的默认构造函数，这个函数会自动调用基类的默认构造函数；</p>
</blockquote>
<p><strong>继承构造函数</strong>：允许派生类通过简单的声明来继承基类的构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A&#123;</span><br><span class="line">  <span class="keyword">using</span> A::A;<span class="comment">//继承了A的所有构造函数</span></span><br><span class="line">  <span class="comment">//如果想要给派生类的成员赋值，那就需要自己写</span></span><br><span class="line">  <span class="built_in">B</span>(<span class="type">int</span> a,<span class="type">int</span> b): <span class="built_in">A</span>(a)&#123;</span><br><span class="line">      <span class="comment">//在成员的初始化列表里面初始化A</span></span><br><span class="line">      <span class="comment">//....这里可以给B的成员赋值</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>拷贝构造函数</strong>：如果不写，就会自动调用基类的拷贝构造函数；但是如果在子类的拷贝构造函数中需要调用base的拷贝构造函数，那么应该显式地在成员初始化列表中调用，<strong>否则调用的是base的默认构造函数</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="built_in">B</span>(<span class="type">const</span> B&amp; b): <span class="built_in">A</span>(b)&#123;&#125;    </span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><strong>赋值的操作符重载</strong>：需要显式地调用base的赋值拷贝构造函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; ...... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A</span><br><span class="line">&#123;		......</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		B&amp; <span class="keyword">operator</span> =(<span class="type">const</span> B&amp; b)</span><br><span class="line">		&#123;	<span class="keyword">if</span> (&amp;b == <span class="keyword">this</span>) <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">//防止自身赋值。</span></span><br><span class="line">			 *(A*)<span class="keyword">this</span> = b; <span class="comment">//调用基类的赋值操作符对基类成员</span></span><br><span class="line">						          <span class="comment">//进行赋值。也可写成： </span></span><br><span class="line">						          <span class="comment">//this-&gt;A::operator =(b); </span></span><br><span class="line">			...... <span class="comment">//对派生类的成员赋值</span></span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>派生类的构析函数</strong></p>
<center>上面的笔记不够完整，请去看4-1ppt</center>
<hr />
<blockquote>
<p>老师说：期末会参考这个例子：“继承的实例：一个公司中的职员类和部门经理类的设计。”（PPT 42）</p>
<p>可能考点：为什么要用 指针数组；</p>
<ol>
<li>修改了这个对象之后其他的拷贝不会修改，但是用指针的话都是访问同一个对象</li>
<li>减少内存的开销，提升性能</li>
<li>是聚合的关系而非组合composition（或者拥有）</li>
</ol>
</blockquote>
<p><strong>一个例子</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Employee</span> <span class="comment">//普通职员类</span></span><br><span class="line">&#123;		String name; <span class="comment">//String为字符串类。</span></span><br><span class="line">		<span class="type">int</span> salary;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Employee</span>(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> n=<span class="number">0</span>):<span class="built_in">name</span>(s) </span><br><span class="line">		&#123;	salary = n; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">set_salary</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123; salary = n; &#125;</span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">get_salary</span><span class="params">()</span> <span class="type">const</span> </span>&#123; <span class="keyword">return</span> salary; &#125;</span><br><span class="line">	......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">int</span> MAX_NUM_OF_EMPS=<span class="number">20</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Manager</span>: <span class="keyword">public</span> Employee <span class="comment">//部门经理类</span></span><br><span class="line">&#123;		Employee *group[MAX_NUM_OF_EMPS];</span><br><span class="line">		<span class="type">int</span> num_of_emps;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Manager</span>(<span class="type">const</span> <span class="type">char</span> *s, <span class="type">int</span> n=<span class="number">0</span>): <span class="built_in">Employee</span>(s,n) </span><br><span class="line">		&#123; num_of_emps = <span class="number">0</span>; </span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">add_employee</span><span class="params">(Employee *e)</span></span>;</span><br><span class="line">		<span class="function"><span class="type">bool</span> <span class="title">remove_employee</span><span class="params">(Employee *e)</span></span>; </span><br><span class="line">		<span class="function"><span class="type">int</span> <span class="title">get_num_of_emps</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> num_of_emps; &#125;</span><br><span class="line">	......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建职员对象Jack和Jane</span></span><br><span class="line"><span class="function">Employee <span class="title">e1</span><span class="params">(<span class="string">&quot;Jack&quot;</span>,<span class="number">1000</span>)</span>,<span class="title">e2</span><span class="params">(<span class="string">&quot;Jane&quot;</span>,<span class="number">2000</span>)</span></span>; </span><br><span class="line"><span class="comment">//创建经理对象Mark</span></span><br><span class="line"><span class="function">Manager <span class="title">m</span><span class="params">(<span class="string">&quot;Mark&quot;</span>,<span class="number">4000</span>)</span></span>; </span><br><span class="line"><span class="comment">//把职员Jack和Jane纳入经理Mark的管理m.add_employee(&amp;e1);</span></span><br><span class="line">m.<span class="built_in">add_employee</span>(&amp;e2);</span><br><span class="line"><span class="comment">//老师上课说： 这里不一定是要用new在堆上来创建一个带地址的对象，在stack上创建之后完全可以将栈上的地址作为指针传入；</span></span><br><span class="line"><span class="comment">//显示经理Mark的工资</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Mark&#x27;s salary is &quot;</span> &lt;&lt; m.<span class="built_in">get_salary</span>() &lt;&lt; <span class="string">&#x27;.&#x27;</span> </span><br><span class="line">	&lt;&lt; endl; </span><br><span class="line"><span class="comment">//显示经理Mark的管理人数</span></span><br><span class="line">cout&lt;&lt; <span class="string">&quot;Number of employees managed by Mark is &quot;</span> </span><br><span class="line">	&lt;&lt; m.<span class="built_in">get_num_of_emps</span>() &lt;&lt; <span class="string">&#x27;.&#x27;</span> &lt;&lt; endl; </span><br><span class="line"><span class="comment">//职员Jack脱离经理Mark的管理</span></span><br><span class="line">m.<span class="built_in">remove_employee</span>(&amp;e1); </span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<blockquote>
<p>老师上课说：可能出一个没有错误的纠错题，找出错误之后扣分。                 –  2025.3.12 10.45</p>
</blockquote>
<h3 id="42-多继承"><a class="markdownIt-Anchor" href="#42-多继承"></a> 4.2 多继承</h3>
<p>多继承：同时继承多个成员</p>
<blockquote>
<p>老师：<strong>考试不考，平时也不建议你用</strong></p>
</blockquote>
<h3 id="43-聚合-组合"><a class="markdownIt-Anchor" href="#43-聚合-组合"></a> 4.3 聚合、组合</h3>
<blockquote>
<p>会有一到两个程序分析题考这个，主要要区分哪个是组合哪个是聚合</p>
</blockquote>
<p>继承不是唯一代码复用的方式；继承体现的是：“is a type of”,但是还有一种“a part of&quot;的关系；</p>
<p><strong>聚合</strong>:在聚合关系中，被包含的对象与包含它的对象<strong>独立创建</strong>和消亡，被包含的对象<strong>可以脱离</strong>包含它的对象独立存在。<code>聚是一团火，散是满天星</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123; ...... &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="comment">//B与A是聚合关系</span></span><br><span class="line">&#123; A *pm; <span class="comment">//指向成员对象</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">B</span>(A *p) &#123; pm = p; &#125; <span class="comment">//成员对象在聚合类对象外部创建，然后传入</span></span><br><span class="line">   ~<span class="built_in">B</span>() &#123; pm = <span class="literal">NULL</span>; &#125; <span class="comment">//传进来的成员对象不再是聚合类对象的成员</span></span><br><span class="line">   ......</span><br><span class="line">&#125;;</span><br><span class="line">......</span><br><span class="line">A *pa=<span class="keyword">new</span> A; <span class="comment">//创建一个A类对象</span></span><br><span class="line">B *pb=<span class="keyword">new</span> <span class="built_in">B</span>(pa); <span class="comment">//创建一个聚合类对象，其成员对象是pa指向的对象</span></span><br><span class="line">......</span><br><span class="line"><span class="keyword">delete</span> pb; <span class="comment">//聚合类对象消亡了，其成员对象并没有消亡</span></span><br><span class="line">...... <span class="comment">// pa指向的对象还可以用在其它地方</span></span><br><span class="line"><span class="keyword">delete</span> pa; <span class="comment">//聚合类对象原来的成员对象消亡</span></span><br></pre></td></tr></table></figure>
<p>在这里A和B就是聚合关系，B的对象消亡的时候并不会导致B对象里面的A对象消亡，因为在B的析构函数里面，只是将对象A的指针赋值为<code>NULL</code>，但是并没有delete对象A；</p>
<p><strong>组合 | Composition</strong>：在组合关系中，被包含的对象随包含它的对象创建和消亡，被包含的对象不能脱离包含它的对象独立存在。</p>
<p>实现组合的方法：</p>
<ol>
<li>直接在内部创建成员对象；</li>
<li>如果用指针的话：记得在组合类的构析函数中delete成员对象；</li>
</ol>
<p><strong>继承更容易实现子类型、多态，组合和聚合是无法实现的</strong></p>
<h2 id="51-虚函数和消息的动态绑定"><a class="markdownIt-Anchor" href="#51-虚函数和消息的动态绑定"></a> 5.1 虚函数和消息的动态绑定</h2>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/661551054">C++中的静态绑定与动态绑定：深入解析与比较 - 知乎</a></p>
<p><strong>静态绑定</strong></p>
<p>如果一个对象有两个同名的函数（一个是从base class继承而来），一般情况下，会在编译时刻根据对象的类型来决定采用那个消息处理函数<code>（静态绑定）</code></p>
<blockquote>
<p>静态绑定调用哪个函数 要看调用点的这个形参的类型！</p>
</blockquote>
<p>在编译的时候就已经确定了，调用那个函数由形参决定：</p>
<p><strong>这个代码是必考的内容！！！！</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;	<span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A</span><br><span class="line">&#123;	<span class="keyword">public</span>:</span><br><span class="line">	  <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">	  <span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>; </span><br><span class="line">&#125;;</span><br><span class="line">......</span><br><span class="line">A a;</span><br><span class="line">B b;</span><br><span class="line">a.<span class="built_in">f</span>(); <span class="comment">//A的f</span></span><br><span class="line">b.<span class="built_in">f</span>(); <span class="comment">//B的f</span></span><br><span class="line">b.A::<span class="built_in">f</span>(); <span class="comment">//A的f</span></span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	<span class="built_in">func1</span>(a);</span><br><span class="line">	<span class="built_in">func2</span>(&amp;a);</span><br><span class="line">	B b;</span><br><span class="line">	<span class="built_in">func1</span>(b);</span><br><span class="line">	<span class="built_in">func2</span>(&amp;b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//无论传入的是A还是B，都是调用A的f，因为这里的形参已经确定</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(A&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;	......</span><br><span class="line">	x.<span class="built_in">f</span>(); <span class="comment">//调用A::f还是B::f ？</span></span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(A *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;	......</span><br><span class="line">	p-&gt;<span class="built_in">f</span>(); <span class="comment">//调用A::f还是B::f ？</span></span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>答案均为a.f()</p>
</blockquote>
<p><strong>消息的动态绑定 | Dynamic Dispatch</strong></p>
<p>我们通常希望，在代码中能够根据对象的类型来执行对应的函数。</p>
<p>这个时候我们需要引入<code>virtual function</code></p>
<p>在base class中，将某个函数声明为虚函数,则在调用这个函数的时候，就能根据对应的对象来调用对应的函数</p>
<center><em>200%必考的内容</em></center>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;	 <span class="type">int</span> x,y;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">	 <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A</span><br><span class="line">&#123;	 <span class="type">int</span> z;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">   	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>; </span><br><span class="line">   	<span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func1</span><span class="params">(A&amp; x)</span></span></span><br><span class="line"><span class="function"></span>&#123;	......</span><br><span class="line">	x.<span class="built_in">f</span>(); <span class="comment">//调用A::f或B::f</span></span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func2</span><span class="params">(A *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;	......</span><br><span class="line">	p-&gt;<span class="built_in">f</span>(); <span class="comment">//调用A::f或B::f</span></span><br><span class="line">	......</span><br><span class="line">&#125;</span><br><span class="line">......</span><br><span class="line">A a;</span><br><span class="line"><span class="built_in">func1</span>(a); <span class="comment">//在func1中调用A::f</span></span><br><span class="line"><span class="built_in">func2</span>(&amp;a); <span class="comment">//在func2中调用A::f</span></span><br><span class="line">B b;</span><br><span class="line"><span class="built_in">func1</span>(b); <span class="comment">//在func1中调用B::f</span></span><br><span class="line"><span class="built_in">func2</span>(&amp;b); <span class="comment">//在func2中调用B::f</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Warning:</p>
<ul>
<li>
<p>静态成员函数不能是虚函数</p>
</li>
<li>
<p>派生类不要写<code>virtual</code> 派生类要写<code>override</code></p>
</li>
<li>
<p>**只有通过指针或者引用来调用函数，才能<code>dynamic bonding</code>!!!**必考内容！</p>
</li>
<li>
<p>构造函数不能是虚函数，析构函数往往是虚函数</p>
<ul>
<li>如果构造函数也动态绑定，老师说，会导致baseclass的成员初始化不完全 – 存疑 （6月11日补充：结合前面继承中的初始化相关知识，应该指的是如果只调用派生类的构造函数而不调用基类的构造函数，会导致出现基类的成员没有被初始化）</li>
<li>析构函数如果不用虚函数的话，当删除基类指针的时候，就只会进行静态绑定，调用基类的析构函数</li>
</ul>
<blockquote>
<p><strong>如果基类的析构函数不是虚函数，那么在删除基类指针时，只会调用基类的析构函数，而不会调用派生类的析构函数。</strong></p>
</blockquote>
</li>
<li>
<p>在构造函数和析构函数里面如果调用了虚函数，不进行动态绑定</p>
<p>reason:</p>
<ul>
<li>因为先调用的是基类构造函数，这个时候derived class的成员还没初始化，如果就调用derived class的函数会出错</li>
<li>因为先调用的是derived class的析构函数，已经删除了派生类的成员对象，会出错。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;  ......</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>() &#123; <span class="built_in">f</span>(); &#125;</span><br><span class="line">	~<span class="built_in">A</span>() &#123; <span class="built_in">f</span>(); &#125;</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">h</span><span class="params">()</span> </span>&#123; <span class="built_in">f</span>(); <span class="built_in">g</span>(); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span>: <span class="keyword">public</span> A</span><br><span class="line">&#123;  .......</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">   <span class="built_in">B</span>() &#123; ...... &#125;</span><br><span class="line">	~<span class="built_in">B</span>();</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>; </span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">g</span><span class="params">()</span></span>; </span><br><span class="line">&#125;;</span><br><span class="line">......</span><br><span class="line">A a;  <span class="comment">//调用A::A()和A::f</span></span><br><span class="line">a.<span class="built_in">f</span>();  <span class="comment">//调用A::f,f是虚函数，但是因为没有通过指针或引用调用，是静态绑定</span></span><br><span class="line">a.<span class="built_in">g</span>();  <span class="comment">//调用A::g，静态绑定</span></span><br><span class="line">a.<span class="built_in">h</span>();  <span class="comment">//调用A::h、A::f和A::g，这里调用A::f是动态绑定，因为是隐式地用this指针调用，f也是虚函数；</span></span><br><span class="line"><span class="comment">//a消亡时会调用A::~A()和A::f</span></span><br><span class="line">    </span><br><span class="line">B b;  <span class="comment">//调用B::B()、A::A()和A::f</span></span><br><span class="line">b.<span class="built_in">f</span>();  <span class="comment">//调用B::f</span></span><br><span class="line">b.<span class="built_in">g</span>();  <span class="comment">//调用B::g</span></span><br><span class="line">b.<span class="built_in">h</span>();  <span class="comment">//调用A::h、B::f和A::g 在这里调用f函数的时候是`dynamic bonding`;但是调用g的时候，因为这不是一个虚函数，所以只能是静态绑定</span></span><br><span class="line"><span class="comment">//b消亡时会调用B::~B()、A::~A()和A::f</span></span><br><span class="line">A *p;   <span class="comment">//p是A类（基类）指针</span></span><br><span class="line">p = &amp;a; <span class="comment">//p指向A类对象</span></span><br><span class="line">p-&gt;<span class="built_in">f</span>();  <span class="comment">//调用A::f</span></span><br><span class="line">p-&gt;<span class="built_in">g</span>();  <span class="comment">//调用A::g</span></span><br><span class="line">p-&gt;<span class="built_in">h</span>();  <span class="comment">//调用A::h, A::f和A::g</span></span><br><span class="line">p = &amp;b;  <span class="comment">//p指向B类对象</span></span><br><span class="line">p-&gt;<span class="built_in">f</span>();  <span class="comment">//调用B::f</span></span><br><span class="line">p-&gt;<span class="built_in">g</span>();  <span class="comment">//调用A::g，非虚函数采用静态绑定</span></span><br><span class="line">p-&gt;<span class="built_in">h</span>();  <span class="comment">//调用A::h, B::f和A::g</span></span><br><span class="line">p = <span class="keyword">new</span> B;  <span class="comment">//调用B::B(), A::A()和A::f</span></span><br><span class="line">.......</span><br><span class="line"><span class="keyword">delete</span> p;  <span class="comment">//只调用A::~A()和A::f ，</span></span><br><span class="line">               <span class="comment">//没调用B:~B()，为什么？</span></span><br><span class="line">                 <span class="comment">//没有把A的析构函数定义为虚函数！</span></span><br></pre></td></tr></table></figure>
<p>check the type of bonding in each case above ! ! ! ! ! ! ! ! ! !</p>
</li>
</ul>
</blockquote>
<p><strong>虚函数动态绑定的实现</strong>: 背后维护了一个<code>vtable</code>;</p>
<h3 id="纯虚函数和抽象类"><a class="markdownIt-Anchor" href="#纯虚函数和抽象类"></a> 纯虚函数和抽象类</h3>
<p>将虚函数声明为纯虚函数，此时这个类变成了一个抽象类，不能创建对象，仅做为接口；</p>
<p>纯虚函数必须在derived class里面重写；</p>
<p>抽象类可以真正地实现继承和封装.</p>
<p><strong>可能考</strong> ：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">例如： </span><br><span class="line"><span class="comment">//A.h （类A的对外接口）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span></span><br><span class="line">&#123;	<span class="type">int</span> i,j;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>();</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> x,<span class="type">int</span> y);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//A.cpp （类A的实现，不公开）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;A.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::A</span><span class="params">()</span> </span>&#123; ...... &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::A</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123; ...... &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::f</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; ...... &#125;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">//B.cpp （A类对象的某个使用者）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;A.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(A *p)</span>  <span class="comment">//绕过对象类的访问控制！</span></span></span><br><span class="line"><span class="function"></span>&#123;	p-&gt;<span class="built_in">f</span>(<span class="number">2</span>); <span class="comment">//Ok</span></span><br><span class="line">	p-&gt;i = <span class="number">1</span>; <span class="comment">//Error</span></span><br><span class="line">	p-&gt;j = <span class="number">2</span>; <span class="comment">//Error</span></span><br><span class="line">	*((<span class="type">int</span> *)p) = <span class="number">1</span>; <span class="comment">//Ok，访问p所指向的对象的成员i</span></span><br><span class="line">	*((<span class="type">int</span> *)p<span class="number">+1</span>) = <span class="number">2</span>; <span class="comment">//Ok，访问p所指向的对象的成员j</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样子打破了封装的效果！！！！</p>
<p>如何防止上面的情况？</p>
<p>只给一个抽象接口，让使用者只能看到抽象的接口，而看不到别的数据；</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">用抽象类I_A给类A提供一个抽象接口</span><br><span class="line"></span><br><span class="line">    <span class="comment">//A.cpp （类A的实现，不公开）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;I_A.h&quot;</span></span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>: <span class="keyword">public</span> I_A</span><br><span class="line">&#123;	<span class="type">int</span> i,j;</span><br><span class="line">   <span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">A</span>();</span><br><span class="line">	<span class="built_in">A</span>(<span class="type">int</span> x,<span class="type">int</span> y);</span><br><span class="line">	<span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span> x)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::A</span><span class="params">()</span> </span>&#123; ...... &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::A</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span> </span>&#123; ...... &#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::f</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; ...... &#125;</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line"><span class="comment">//I_A.h （类A的对外接口）</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">I_A</span></span><br><span class="line">&#123; <span class="keyword">public</span>:</span><br><span class="line">   	  <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>)</span></span>=<span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//B.cpp （A类对象的某个使用者）</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;I_A.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">(I_A *p)</span></span></span><br><span class="line"><span class="function"></span>&#123;	p-&gt;<span class="built_in">f</span>(<span class="number">2</span>);  <span class="comment">//Ok</span></span><br><span class="line"></span><br><span class="line">	 *((<span class="type">int</span> *)p) = <span class="number">1</span>; <span class="comment">//这里不知道p所指向的对象有哪些数据成员，</span></span><br><span class="line">      <span class="comment">//用户不知道数据定义情况，并不知道这样访问的是哪个数据成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="6-操作符重载"><a class="markdownIt-Anchor" href="#6-操作符重载"></a> 6 操作符重载</h2>
<p>操作符重载可通过下面两个途径来实现：</p>
<p>​	•作为一个类的非静态的成员函数（操作符new和delete除外）。</p>
<p>​	•作为一个全局（友元）函数。</p>
<p>至少应该有一个参数是类、结构、枚举或它们的引用类型。</p>
<p>不管是采用成员函数还是全局函数，重载的函数名字都为：</p>
<p><code>	operator #</code>  “#”代表任意可重载的操作符。</p>
<hr />
<h4 id="操作符重载的原则"><a class="markdownIt-Anchor" href="#操作符重载的原则"></a> <strong>操作符重载的原则</strong>：</h4>
<p>只能重载C++语言中已有的操作符，不可臆造新的操作符。</p>
<p>可以重载C++中除下列操作符外的所有操作符：</p>
<p>“. ”， “.* ”，“?: ”，“:: ”，“sizeof ”</p>
<p>遵循已有操作符的语法:</p>
<p>​	•不能改变操作数个数。</p>
<p>​	•不改变原操作符的优先级和结合性。</p>
<p>尽量遵循已有操作符原来的语义：</p>
<p>​	•语言本身没有对此做任何规定，使用者自己把握 ！</p>
<h4 id="单元操作符"><a class="markdownIt-Anchor" href="#单元操作符"></a> <strong>单元操作符</strong></h4>
<ul>
<li>自增自减操作符</li>
</ul>
<blockquote>
<p><strong>注意自增自减操作符有 前和后的区别</strong></p>
<p>x<ins>的值是x，<ins>x的值是x+1; 且，x</ins>得到的是一个right-value expression,但是</ins>x是left-value expression</p>
<p>也就是说： <ins>(x</ins>)或者 (x++)<ins>都会报错，因为x</ins>得到的是左值表达式</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Complex</span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    Complex&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">        <span class="comment">//定义前增操作符</span></span><br><span class="line">        real++;</span><br><span class="line">        imag++;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Complex <span class="keyword">operator</span>++(<span class="type">int</span>)&#123;</span><br><span class="line">        <span class="comment">//定义后增操作符</span></span><br><span class="line">        Complex p=*<span class="keyword">this</span>; <span class="comment">//记得 1 。</span></span><br><span class="line">        real++;</span><br><span class="line">        imag++;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面这个例子很重要，曾经考过：<strong>这个是必考内容！！！！！！！！</strong>（前<ins>和后</ins>的操作符重载！）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Counter</span></span><br><span class="line">&#123;		<span class="type">int</span> value;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Counter</span>() &#123; value = <span class="number">0</span>; &#125;</span><br><span class="line">		Counter&amp; <span class="keyword">operator</span> ++()  <span class="comment">//前置的++重载函数</span></span><br><span class="line">		&#123;	value++;</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="type">const</span> Counter <span class="keyword">operator</span> ++(<span class="type">int</span>)  <span class="comment">//后置的++重载函数</span></span><br><span class="line">		&#123;	Counter temp=*<span class="keyword">this</span>; <span class="comment">//保存原来的对象</span></span><br><span class="line">			value++; <span class="comment">//写成：++(*this);更好！调用前置的++重载函数</span></span><br><span class="line">			<span class="keyword">return</span> temp; <span class="comment">//返回原来的对象</span></span><br><span class="line">         <span class="comment">//temp的生存期仅在这个函数内，而会赋值temp给一个临时的对象。</span></span><br><span class="line">		&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Check your understanding:</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Counter a,b,c;</span><br><span class="line">++a;  <span class="comment">//使用的是不带参数的操作符++重载函数</span></span><br><span class="line">a++;  <span class="comment">//使用的是带int型参数的操作符++重载函数</span></span><br><span class="line">b = ++a;  <span class="comment">//加一之后的a赋值给b</span></span><br><span class="line">c = a++;  <span class="comment">//加一之前的a赋值给c</span></span><br><span class="line">++(++a);或 (++a)++; <span class="comment">//OK，a加2</span></span><br><span class="line">++(a++);或 (a++)++; <span class="comment">//Error，编译不通过</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>请问c的类型是const吗？不是，仍为普通的，是否为const是由创建时声明决定的！(注：const的对象实例只能调用声明为const的成员函数，成员不能被改变)</p>
<p>请问可以写成Complex operator++()吗？会有什么影响？</p>
<p>ans: 只会影响到类似<code>(++a)++</code>的句子，因为这个只会加一次，后面的后置<ins>其实是对一个临时对象的</ins>；</p>
<p>请问后置<ins>那个改成const Counter&amp; operator</ins>(int) 可以吗？</p>
<p>不可以！因为temp是临时的对象，不能return它的&amp;，会出现<code>悬浮指针</code>问题，<em>实际上编译器也会报错</em></p>
</blockquote>
<h4 id="双元操作符"><a class="markdownIt-Anchor" href="#双元操作符"></a> <strong>双元操作符</strong></h4>
<h4 id="特殊的操作符重载"><a class="markdownIt-Anchor" href="#特殊的操作符重载"></a> 特殊的操作符重载</h4>
<p><strong>赋值操作符</strong> | <strong>必考！！！</strong></p>
<p>如果没有自定义赋值操作符，会自动生成有一个shallow copy的赋值函数；</p>
<p>但是如果涉及到指针，通常要自定义一个deepcopy的函数，防止指向同一块区域，并且释放原先自己指向的内存区域，防止内存泄露。</p>
<p>比如经典的String类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">解决上面问题的办法是针对String类自己定义赋值操作符重载函数：</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">String</span></span><br><span class="line">&#123;  ......</span><br><span class="line">String&amp; <span class="keyword">operator</span> = (<span class="type">const</span> String&amp; s)</span><br><span class="line">	&#123;	</span><br><span class="line">    	<span class="keyword">if</span> (&amp;s == <span class="keyword">this</span>) <span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">//防止自身赋值：a=a</span></span><br><span class="line">		<span class="keyword">delete</span> []str;</span><br><span class="line">		str = <span class="keyword">new</span> <span class="type">char</span>[s.len<span class="number">+1</span>];</span><br><span class="line">		<span class="built_in">strcpy</span>(str,s.str);</span><br><span class="line">   		len = s.len; </span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注： 下面这一部分是使用了ai进行整理，使得ppt上面的内容更加的清晰，实际使用的时候建议和ppt一起使用。</p>
<p><strong>NOTE：</strong> 赋值操作符要记得检查自赋值逻辑！！！OJ因此丢过好多分！！！</p>
</blockquote>
<h4 id="c-自定义-new-和-delete-操作符详解"><a class="markdownIt-Anchor" href="#c-自定义-new-和-delete-操作符详解"></a> C++ 自定义 <code>new</code> 和 <code>delete</code> 操作符详解</h4>
<h5 id="1-operator-new-重载基础"><a class="markdownIt-Anchor" href="#1-operator-new-重载基础"></a> 1. <code>operator new</code> 重载基础</h5>
<p>基本语法</p>
<p><code>operator new</code> 必须作为静态成员函数重载（<code>static</code> 关键字可省略）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>返回类型</strong>：必须是 <code>void*</code></li>
<li><strong>参数</strong>：<code>size_t size</code> 表示对象所需空间大小
<ul>
<li><code>size_t</code> 是 <code>sizeof()</code> 操作符返回的类型（通常为 <code>unsigned long</code>）</li>
</ul>
</li>
</ul>
<p>使用方式</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="type">void</span>* p = <span class="built_in">malloc</span>(size);</span><br><span class="line">        <span class="built_in">memset</span>(p, <span class="number">0</span>, size);  <span class="comment">// 初始化内存为0</span></span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A* p = <span class="keyword">new</span> A;  <span class="comment">// 调用重载的operator new</span></span><br></pre></td></tr></table></figure>
<p>特点</p>
<ol>
<li>自动计算类大小并作为 <code>size</code> 参数传递</li>
<li>可以初始化内存（即使类没有构造函数）</li>
<li>不一定要在堆上分配内存（后面会讲placement new）</li>
</ol>
<h5 id="2-placement-new定位new"><a class="markdownIt-Anchor" href="#2-placement-new定位new"></a> 2. Placement New（定位new）</h5>
<p>允许在已分配的内存上构造对象：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">A</span>(<span class="type">int</span> i, <span class="type">int</span> j) : <span class="built_in">x</span>(i), <span class="built_in">y</span>(j) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size, <span class="type">void</span>* p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p;  <span class="comment">// 直接返回传入的指针</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">char</span> buf[<span class="built_in">sizeof</span>(A)];  <span class="comment">// 预分配内存（栈上）</span></span><br><span class="line">A* p = <span class="built_in">new</span> (buf) <span class="built_in">A</span>(<span class="number">1</span>, <span class="number">2</span>);  <span class="comment">// 在buf上构造对象</span></span><br><span class="line">p-&gt;~<span class="built_in">A</span>();  <span class="comment">// 必须显式调用析构函数！</span></span><br></pre></td></tr></table></figure>
<p>关键点</p>
<ul>
<li>不分配内存，只构造对象</li>
<li>必须手动调用析构函数</li>
<li>常用于内存池、特殊硬件地址操作</li>
</ul>
<h5 id="3-operator-delete-重载"><a class="markdownIt-Anchor" href="#3-operator-delete-重载"></a> 3. <code>operator delete</code> 重载</h5>
<p>基本语法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* p[, <span class="type">size_t</span> size])</span></span>;	</span><br></pre></td></tr></table></figure>
<ul>
<li>必须是静态成员函数</li>
<li>第二个参数 <code>size_t</code> 是可选的</li>
<li>必须与 <code>operator new</code> 配对实现</li>
</ul>
<p>示例</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">int</span> x, y;	</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="type">void</span>* p = <span class="built_in">malloc</span>(size);</span><br><span class="line">        <span class="built_in">memset</span>(p, <span class="number">0</span>, size);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* p)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A* ptr = <span class="keyword">new</span> A;</span><br><span class="line"><span class="keyword">delete</span> ptr;  <span class="comment">// 调用重载的delete</span></span><br></pre></td></tr></table></figure>
<h5 id="4-内存池实现必考"><a class="markdownIt-Anchor" href="#4-内存池实现必考"></a> 4. 内存池实现（必考）</h5>
<p>设计思路</p>
<ol>
<li>第一次创建对象时申请一大块内存</li>
<li>将大内存分割为对象大小的块，用链表管理</li>
<li>从链表中分配/回收内存，避免频繁系统调用</li>
</ol>
<p>完整实现</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="comment">// 类原有成员</span></span><br><span class="line">    <span class="type">static</span> A* p_free;  <span class="comment">// 自由链表头指针</span></span><br><span class="line">    A* next;          <span class="comment">// 链表指针</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* p)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A* A::p_free = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> NUM = <span class="number">32</span>;  <span class="comment">// 每次申请的对象数量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* A::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p_free == <span class="literal">nullptr</span>) &#123;  <span class="comment">// 首次分配</span></span><br><span class="line">        <span class="comment">// 申请NUM个对象的大内存块</span></span><br><span class="line">        p_free = <span class="built_in">static_cast</span>&lt;A*&gt;(<span class="built_in">malloc</span>(size * NUM));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 初始化自由链表</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; NUM<span class="number">-1</span>; ++i) &#123;</span><br><span class="line">            p_free[i].next = &amp;p_free[i<span class="number">+1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        p_free[NUM<span class="number">-1</span>].next = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 从链表分配一个对象</span></span><br><span class="line">    A* p = p_free;</span><br><span class="line">    p_free = p_free-&gt;next;</span><br><span class="line">    <span class="built_in">memset</span>(p, <span class="number">0</span>, size);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> A::<span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将内存块插回链表头部</span></span><br><span class="line">    <span class="built_in">static_cast</span>&lt;A*&gt;(p)-&gt;next = p_free;</span><br><span class="line">    p_free = <span class="built_in">static_cast</span>&lt;A*&gt;(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内存布局示例</p>
<p>初始状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[对象1] -&gt; [对象2] -&gt; ... -&gt; [对象32] -&gt; NULL</span><br></pre></td></tr></table></figure>
<p>经过多次分配释放后可能变成：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[对象5] -&gt; [对象2] -&gt; [对象10] -&gt; ...（非连续）</span><br></pre></td></tr></table></figure>
<p>关键优势</p>
<ol>
<li>避免内存碎片</li>
<li>分配/释放效率高（O(1)时间复杂度）</li>
<li>减少系统调用开销</li>
</ol>
<h5 id="5-内存释放问题必考"><a class="markdownIt-Anchor" href="#5-内存释放问题必考"></a> 5. 内存释放问题（必考）</h5>
<p>问题描述</p>
<p>当程序不再需要内存池时，如何释放所有申请的大内存块？</p>
<p>解决方案</p>
<p>需要额外维护一个列表记录所有申请的大内存块：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;</span><br><span class="line">    <span class="type">static</span> A* p_free;</span><br><span class="line">    <span class="type">static</span> std::vector&lt;<span class="type">void</span>*&gt; big_blocks;  <span class="comment">// 记录所有大内存块</span></span><br><span class="line">    A* next;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span>* <span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="keyword">operator</span> <span class="title">delete</span><span class="params">(<span class="type">void</span>* p)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">release_memory</span><span class="params">()</span></span>;  <span class="comment">// 释放所有内存</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">A::release_memory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">void</span>* block : big_blocks) &#123;</span><br><span class="line">        <span class="built_in">free</span>(block);</span><br><span class="line">    &#125;</span><br><span class="line">    big_blocks.<span class="built_in">clear</span>();</span><br><span class="line">    p_free = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span>* A::<span class="keyword">operator</span> <span class="title">new</span><span class="params">(<span class="type">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p_free == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="type">void</span>* block = <span class="built_in">malloc</span>(size * NUM);</span><br><span class="line">        big_blocks.<span class="built_in">push_back</span>(block);</span><br><span class="line">        <span class="comment">// 初始化链表...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分配逻辑...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="6-重载newdelete的意义"><a class="markdownIt-Anchor" href="#6-重载newdelete的意义"></a> 6. 重载new/delete的意义</h5>
<ol>
<li><strong>提高效率</strong>：避免频繁系统调用</li>
<li><strong>避免碎片</strong>：固定大小分配减少碎片</li>
<li><strong>特殊需求</strong>：
<ul>
<li>调试/统计内存使用</li>
<li>硬件特定地址分配</li>
<li>实时系统（确定性的分配时间）</li>
</ul>
</li>
</ol>
<h5 id="7-注意事项"><a class="markdownIt-Anchor" href="#7-注意事项"></a> 7. 注意事项</h5>
<ol>
<li>必须成对实现new/delete</li>
<li>placement new必须手动调用析构函数</li>
<li>多线程环境需要加锁保护</li>
<li>继承情况下的行为（派生类会使用基类的operator new）</li>
<li>不要轻易替换全局new/delete</li>
</ol>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250326115553726.png" alt="image-20250326115553726" /></p>
<hr />
<p><strong>自定义类型转换</strong></p>
<ol>
<li>
<p>通过带参数的构造函数</p>
</li>
<li>
<p>通过操作符重载</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span>&#123;</span><br><span class="line">    <span class="type">int</span> a;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">A a;</span><br><span class="line"><span class="type">int</span> b=(<span class="type">int</span>)a;<span class="comment">//类型转换</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>歧义问题</strong>：</p>
<ol>
<li>比如我如果重载了int和A的加法，在执行<code>int b=1+a;</code>时，应该是调用int和A重载的加法呢？还是调用a到int的重载呢？</li>
<li>如果我有从A到int的转换，也有从int到A的转换，那么执行<code>a+b</code>的时候应该调用哪一个呢？</li>
</ol>
<p><strong>解决方法：</strong></p>
</li>
</ol>
<p>​	1. 手动显示类型转换</p>
<pre><code>2. 在函数前面加上`explict` 关键字，不允许隐式类型转换；`explict operator int(){...}`;
</code></pre>
<hr />
<h2 id="第七章-iohandle-exception-and-debug"><a class="markdownIt-Anchor" href="#第七章-iohandle-exception-and-debug"></a> 第七章: IO,Handle Exception and Debug</h2>
<h3 id="输入输出"><a class="markdownIt-Anchor" href="#输入输出"></a> 输入输出</h3>
<p><strong>Warning:OJ必考！！！！</strong></p>
<p>IO模式有三种：</p>
<ul>
<li>文件输入输出</li>
<li>面向控制台的输入输出</li>
<li>面向字符串常亮的输入输出</li>
</ul>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250402102126315.png" alt="image-20250402102126315" /></p>
<p>(图为c++里面文件相关库)</p>
<blockquote>
<ul>
<li>The <code>istream</code> class itself does not have a public constructor that you can directly use. Instead, it is designed to be inherited by derived classes like <code>ifstream</code>, <code>istringstream</code>, and others.</li>
</ul>
</blockquote>
<p><code>istream</code> is the base class of <code>ifstream</code> and <code>istringstream</code> , so you can define a function whose parameter is <code>istream</code> type to handle both <code>ifstream</code> and <code>istringstream</code>.</p>
<p>例子：</p>
<blockquote>
<p>Pay attention to the cases of PPT form page20-page25, the OJ would have related problems. But the final exam won’t.</p>
</blockquote>
<hr />
<p><em>cin和cout的格式化输入输出</em>：</p>
<ul>
<li>flush</li>
<li>endl</li>
</ul>
<blockquote>
<p>cin和cout是有缓冲区的，请查询相关内容</p>
</blockquote>
<p>等等。</p>
<p>文件的读写有三步：1. 打开文件 2. 进行操作 3. <strong>关闭文件</strong></p>
<ol>
<li>
<p>打开文件</p>
<ul>
<li>
<p>ofstream out_file(&lt;文件名&gt; [,&lt;打开方式&gt;])</p>
</li>
<li>
<p>ofstream out_file;</p>
<p>out_file.open(&lt;文件名&gt; [,&lt;打开方式&gt;]);</p>
</li>
<li>
<p>打开方式有 <code>ios::app</code>,<code>ios::out</code>等</p>
</li>
</ul>
</li>
<li>
<p>判断文件是否成功打开</p>
<ul>
<li>out_file.is_open()</li>
<li>out_file.fail()</li>
</ul>
</li>
<li>
<p>文件的读写</p>
<blockquote>
<p>n以文本方式输出的文件要以文本方式输入；以二进制方式输出的文件要以二进制方式输入！</p>
</blockquote>
</li>
<li>
<p>文件的关闭</p>
<blockquote>
<p>n以文本方式读写的文件要以文本方式打开；以二进制方式读写的文件要以二进制方式打开！</p>
</blockquote>
</li>
</ol>
<h3 id="异常处理"><a class="markdownIt-Anchor" href="#异常处理"></a> 异常处理</h3>
<p>很多时候，程序没有语法错误，但是存在隐式的错误，比如 x/y在某个事件段出现 y=0</p>
<p>则会出现<code>Division by zero</code>的错误。还有比如内存溢出的错误。</p>
<hr />
<p>异常处理的方法：</p>
<ul>
<li>
<p>本地处理</p>
</li>
<li>
<p>异地处理</p>
<blockquote>
<p>一个case是PA1的FileSimulator，当输入的cmd有错误时，error不是就地处理，而是回到循环调用readCommand函数里，处理异常。</p>
</blockquote>
</li>
</ul>
<hr />
<p>在c<ins>中除了可以通过函数的返回值来判断函数执行是否正常（Liunx用c写的，出现了很多这样的逻辑） 还可以用c</ins>的结构化处理异常的机制<code>try catch</code></p>
<ul>
<li>
<p>try: 把有可能遭遇异常的代码（语句或函数调用）构成一个try语句块。</p>
</li>
<li>
<p>throw: 如果try语句块中的某部分代码在执行中发生了异常，则由throw语句产生一个异常对象，之后的操作不再进行。</p>
</li>
<li>
<p>catch: 抛掷的异常对象通过catch语句块来捕获并处理之。</p>
</li>
</ul>
<p><strong>注意：不一定是throw一个字符串或者一个runtime_error，你可以throw anything， but 要在catch中捕获相同的代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">fun</span><span class="params">(fstream* fs)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!fs-&gt;<span class="built_in">open</span>())&#123;</span><br><span class="line">        <span class="keyword">throw</span> fs;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">    <span class="built_in">fun</span>(fs1);</span><br><span class="line">&#125;<span class="built_in">catch</span>(fstream* failed_file)&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个try后可以接多个catch，用于捕获不同的异常</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="built_in">catch</span>(<span class="type">int</span> a)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Catch &quot;</span>&lt;&lt;a&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">throw</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	<span class="built_in">f</span>();</span><br><span class="line">    <span class="built_in">g</span>();</span><br><span class="line">&#125;<span class="built_in">catch</span>(<span class="type">int</span> )&#123;</span><br><span class="line">...</span><br><span class="line">&#125;<span class="built_in">catch</span>(<span class="type">char</span>* )&#123;</span><br><span class="line">... </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>如果当前的<code>throw</code>没有被<code>catch</code>,那么会回退到上一层，看是否会被捕获，如果最终也没有被捕获，那么就会<code>abort</code>并退出。</p>
<p><strong>try catch的例子是期末必考的题目！！！！</strong> 必考 10分左右！！</p>
<p>看ppt的例子h(),g(),f()</p>
<hr />
<p><em>异常处理机制</em></p>
<ul>
<li>每一个函数都有一个catch表</li>
<li>执行throw的时候看当前catch表是否能够正常捕获</li>
<li>如果不行，那么退栈，回到上一个函数</li>
<li>如果能够被catch，那么从这个函数继续执行</li>
<li>否则，回到main函数执行<code>terminate()</code> to end the program.</li>
</ul>
<hr />
<h3 id="基于断言的调试"><a class="markdownIt-Anchor" href="#基于断言的调试"></a> 基于断言的调试</h3>
<p><code>assert(expr)</code> will throw an error when <code>expr</code> is false otherwise noting happend.</p>
<ul>
<li>Easy to understand</li>
<li>Debug</li>
</ul>
<p>assert的实现：assert其实是一个宏，定义类似这样：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> assert(exp) ((exp)?(void)0:<span class="string">&lt;输出诊断语句 and call abort( to end the program)&gt;</span>))</span></span><br></pre></td></tr></table></figure>
<h3 id="事件驱动的程序设计"><a class="markdownIt-Anchor" href="#事件驱动的程序设计"></a> 事件驱动的程序设计</h3>
<p>略，自己看ppt</p>
<hr />
<h2 id="第八章"><a class="markdownIt-Anchor" href="#第八章"></a> 第八章</h2>
<h3 id="泛型程序设计"><a class="markdownIt-Anchor" href="#泛型程序设计"></a> 泛型程序设计</h3>
<p>一个程序实体能对多种类型的数据进行操作或描述的特性称为类属或泛型（Generics）。</p>
<p>具有类属特性的程序实体通常有：</p>
<ul>
<li>
<p>类属函数：一个能对不同类型的数据完成相同操作的函数。</p>
</li>
<li>
<p>类属类：一个成员类型可变、但功能不变的类。</p>
</li>
</ul>
<p>基于具有类属特性的程序实体进行程序设计的技术称为：泛型程序设计（Generic Programming）</p>
<p><strong>类属函数</strong></p>
<p>能对不同类型的参数实现相同的操作。</p>
<p>比如：</p>
<p><em>不排除考察的可能性，因为指针是c++的精华</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//函数定义：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">unsigned</span> <span class="type">char</span> byte;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(<span class="type">void</span> *base, <span class="comment">//需排序的数据（数组）内存首地址</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">unsigned</span> <span class="type">int</span> num, <span class="comment">//数据元素的个数</span></span></span></span><br><span class="line"><span class="params"><span class="function">	<span class="type">unsigned</span> <span class="type">int</span> element_size, <span class="comment">//一个数据元素所占内存大小（字节数）</span></span></span></span><br><span class="line"><span class="params"><span class="function"> 	<span class="type">bool</span> (*cmp)(<span class="type">const</span> <span class="type">void</span> *, <span class="type">const</span> <span class="type">void</span> *) )</span> <span class="comment">//比较两个元素的函数</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="comment">//不论采用何种排序算法，一般都需要对数组进行以下操作：	</span></span><br><span class="line">     <span class="comment">//取第i个元素</span></span><br><span class="line">        (byte *)base+i*element_size</span><br><span class="line">     <span class="comment">//比较第i个和第j个元素的大小 （利用调用者提供的回调函数cmp实现）</span></span><br><span class="line">        <span class="built_in">cmp</span>((byte *)base+i*element_size,(byte *)base+j*element_size)</span><br><span class="line">     <span class="comment">//交换第i个和第j个元素的位置</span></span><br><span class="line">        byte *p1=(byte *)base+i*element_size,</span><br><span class="line">	     *p2=(byte *)base+j*element_size;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">0</span>; k&lt;element_size; k++)</span><br><span class="line">        &#123;	 byte temp=p1[k]; p1[k] = p2[k]; p2[k] = temp;</span><br><span class="line">        &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用void*的指针来实现对不同的数据进行操作，很Amazing！！！</p>
<p><strong>函数模板</strong></p>
<p>函数模板是带有<strong>类型参数</strong>的函数定义</p>
<p>定义的模板如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">sort</span><span class="params">(T element[], <span class="type">unsigned</span> <span class="type">int</span> count)</span></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中，<code>template&lt;class T&gt; or template&lt;typename T&gt; </code>的含义是声明一个模板。</p>
<p>在调用函数的时候，可以显式的声明模板类型<code>func&lt;int&gt;(a,b)</code> ,这样的话强制设置模板为int,末班也可以设定一个默认值：<code>template&lt;typename T=int&gt;</code></p>
<p>同时要注意，这里的template必须连着函数或者类的定义</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T</span>=<span class="type">int</span>&gt;</span><br><span class="line"><span class="function">T <span class="title">add</span><span class="params">(T a,T b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">T <span class="title">sub</span><span class="params">(T a, T b)</span></span>&#123; <span class="comment">//Error, T is undefined</span></span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>类模板</strong></p>
<p>如果一个类定义中用到的类型可变、但操作不变，则该类称为类属类。</p>
<p>在C++中，类属类用类模板实现。</p>
<p>类模板的格式为：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T1</span>,<span class="keyword">class</span> <span class="title class_">T2</span>,...&gt; <span class="comment">//class也可以写成typename</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> &lt;类名&gt;</span><br><span class="line"></span><br><span class="line">&#123; &lt;类成员说明&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>T1、T2等为类模板的类型参数，在类成员的说明中可以用T1、T2等来作为它们的类型。</li>
</ul>
<p>比如我们可以使用模板来实现适合多种类型的模板类：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">例如，用类模板实现类属的栈类：</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span></span><br><span class="line">&#123;		T buffer[<span class="number">100</span>];</span><br><span class="line">		<span class="type">int</span> top;</span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="built_in">Stack</span>() &#123; top = <span class="number">-1</span>; &#125;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">const</span> T &amp;x)</span></span>;</span><br><span class="line">		<span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">(T &amp;x)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="type">void</span> Stack &lt;T&gt;::<span class="built_in">push</span>(<span class="type">const</span> T &amp;x) &#123; ...... &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="type">void</span> Stack &lt;T&gt;::<span class="built_in">pop</span>(T &amp;x) &#123; ...... &#125;</span><br></pre></td></tr></table></figure>
<p>在创建类的实例时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stack&lt;<span class="type">int</span>&gt; a; <span class="comment">//显式地指出</span></span><br></pre></td></tr></table></figure>
<p>在实现类的各个函数时：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="type">void</span> Stack&lt;T&gt;::<span class="built_in">pop</span>(T &amp;X)</span><br></pre></td></tr></table></figure>
<p>注意：不同模板的类成员不会共享相同的静态成员；即Stack&lt;int&gt;和 Stack&lt;double&gt;的静态成员相互独立。友元函数也是这样的！</p>
<hr />
<p><strong>因为只有实例化的时候才又实实在在的class生成!</strong></p>
<ul>
<li>
<p>使用一个模板之前首先要对其实例化（用一个具体的类型去替代模板的类型参数），实例化是在（预）编译时刻进行。</p>
</li>
<li>
<p>模板实例化一定要见到相应的源代码，否则无法实例化</p>
</li>
</ul>
<p>一个例子：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// file1.h</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">S</span> <span class="comment">//类模板S的定义</span></span><br><span class="line">&#123;    T a;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">      <span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="type">void</span> <span class="title">func</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// file1.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;file1.h&quot;</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="type">void</span> S&lt;T&gt;::<span class="built_in">f</span>() <span class="comment">//类模板S中f的实现</span></span><br><span class="line">&#123; ......</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; S&lt;<span class="type">float</span>&gt; x; <span class="comment">//实例化“S&lt;float&gt;”并创建该类的一个对象x</span></span><br><span class="line">   x.<span class="built_in">f</span>(); <span class="comment">//实例化“void S&lt;float&gt;::f()”并调用之</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// file2.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;file1.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123; S&lt;<span class="type">float</span>&gt; s1; <span class="comment">//实例化“S&lt;float&gt;”并创建该类的一个对象s1</span></span><br><span class="line">   s<span class="number">1.f</span>(); <span class="comment">//没有实例化“void S&lt;float&gt;::f()”，但调用之</span></span><br><span class="line">   S&lt;<span class="type">int</span>&gt; s2; <span class="comment">//实例化“S&lt;int&gt;”并创建该类的一个对象s2 </span></span><br><span class="line">   s<span class="number">2.f</span>(); <span class="comment">//没有实例化“void S&lt;int&gt;::f()”，但调用之</span></span><br><span class="line">   <span class="built_in">func</span>();</span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;<span class="comment">/* </span></span><br><span class="line"><span class="comment">两个模块都能通过编译，但在链接时出错，链接程序指出：</span></span><br><span class="line"><span class="comment">file2中调用的“void S&lt;int&gt;::f()”不存在！</span></span><br><span class="line"><span class="comment">S&lt;float&gt;::f() 没错的原因 ：S&lt;float&gt;::f() 的实例化发生在 file1.cpp 中，因此链接器可以找到它的定义。</span></span><br><span class="line"><span class="comment">S&lt;int&gt;::f() 出错的原因 ：S&lt;int&gt;::f() 的实例化未发生，因为其实现对 file2.cpp 不可见。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<hr />
<blockquote>
<p>在模板实例化的时候，编译器会根据相应的类型<em>复制</em>出相同逻辑，类型不同的代码。 也就是在做代码的拷贝和类型的替换！</p>
</blockquote>
<p>代码替换的情况：</p>
<ol>
<li>头文件的include</li>
<li>类的一些默认生成的函数</li>
<li>模板函数和模板类</li>
<li>inline函数</li>
<li>宏定义</li>
</ol>
<h3 id="stl编程"><a class="markdownIt-Anchor" href="#stl编程"></a> STL编程</h3>
<p>STL由容器，算法，迭代器构成。</p>
<p>自己看ppt吧，内容还挺多的。</p>
<h1 id="其他内容"><a class="markdownIt-Anchor" href="#其他内容"></a> 其他内容</h1>
<h2 id="并行程序设计"><a class="markdownIt-Anchor" href="#并行程序设计"></a> 并行程序设计</h2>
<p><strong>并发和并行：</strong></p>
<ul>
<li>并发： 同一时间段可以交替处理多个操作</li>
<li>并行：同一个事件可以同时进行多个操作</li>
</ul>
<p><strong>进程和线程</strong>：</p>
<ul>
<li>process 进程： 在一个内存空间上运行的应用程序。每一个进程都有多个线程。</li>
<li>thread 线程： 进程中的一个执行任务。同类的多个线程共享进程的堆和方法区，但是也有自己的程序计数器和本地方法栈。<img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250509151156595.png" alt="image-20250509151156595" /></li>
</ul>
<h2 id="内存安全程序设计"><a class="markdownIt-Anchor" href="#内存安全程序设计"></a> 内存安全程序设计</h2>
<p>woc！！忘记保存了！，做了那么久的笔记。。。</p>
<h3 id="temporal-memory-problem"><a class="markdownIt-Anchor" href="#temporal-memory-problem"></a> Temporal Memory Problem</h3>
<h4 id="raii-constructor-aqusition-destrucror-release"><a class="markdownIt-Anchor" href="#raii-constructor-aqusition-destrucror-release"></a> <strong>RAII</strong> ：Constructor Aqusition， Destrucror Release</h4>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">FileObj</span>&#123;</span><br><span class="line">    <span class="comment">//1.将指针封装到class里面  2. 对象是local地创建的，而非使用new</span></span><br><span class="line">	<span class="built_in">FileObje</span>(<span class="type">char</span>* name)&#123;</span><br><span class="line">        FILE* file= <span class="built_in">fopen</span>(name,<span class="string">&#x27;r&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//自己看ppt吧</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用相似的思想我们可以封装一个指针对象：(之后只要local地创建对象)<strong>100%必考！！！期末考试必考</strong></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename T&gt; </span><br><span class="line">class Toy_ptr&#123;</span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="smartpoint-依赖于泛型和raii思想实现"><a class="markdownIt-Anchor" href="#smartpoint-依赖于泛型和raii思想实现"></a> <strong>SmartPoint</strong> 依赖于泛型和RAII思想实现</h4>
<ul>
<li>unique_ptr</li>
<li>shared_ptr</li>
<li>weadk_ptr</li>
</ul>
<p><strong>unique_ptr</strong>:</p>
<p>A unique_ptr takes ownership of a pointer. Destorys the object when goes out of the scope by invoking <code>delete()</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;memory&gt;</span><br><span class="line">int main()&#123;</span><br><span class="line">	unique_ptr&lt;int&gt; p(new int(10));</span><br><span class="line">	//可以正常使用p,注意unique_ptr是local创建的</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Initialization:</p>
<ul>
<li>
<p>Constructor</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_ptr&lt;T&gt; <span class="title">pT</span><span class="params">(<span class="keyword">new</span> T())</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>make_unique</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pT= <span class="built_in">make_unique</span>&lt;<span class="type">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//make_unique&lt;T&gt;  is also a template function which needs a template!s</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>move</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// move 是一个 高效的拷贝，许多其他的地方也有move操作</span></span><br><span class="line"><span class="comment">// move= release+ reset</span></span><br><span class="line"><span class="keyword">auto</span> p1=<span class="built_in">move</span>(p2)<span class="comment">//p2 is a unique_ptr</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>The copy constructor and assignment operator is not allowed !</p>
<p><code>std::unique_ptr&lt;int&gt; y(x)</code> or <code>std::unique_ptr&lt;int&gt; y= x</code> are not allowed !</p>
<p>老师说：为什么不行？ 因为如果支持这样的操作的话，会导致shallow copy的发生，导致别的对象也拥有这个指针，但是可能原先的那个对象已经out of scope ，释放了对象</p>
</blockquote>
<p><code>reset</code>  and  <code>release()</code>:</p>
<ul>
<li>
<p>release(): release the pointer and set the wrapped pointer to nullptr;</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//release the pointer which is no longer managed by the pointer</span></span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt;p= <span class="built_in">make_unique</span>(<span class="number">10</span>); </span><br><span class="line"><span class="type">int</span> *a=p.<span class="built_in">release</span>(); </span><br><span class="line"><span class="comment">//a get the pointer of p</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>reset(): delete the current pointer and stores a new one</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* p1= <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>);</span><br><span class="line"><span class="type">int</span>* p2= <span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(p1)</span></span>;</span><br><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; b=<span class="built_in">move</span>(a);</span><br><span class="line">b.<span class="built_in">reset</span>(p2);</span><br><span class="line"><span class="comment">//p1所指地址被释放,a为空，b为p2</span></span><br></pre></td></tr></table></figure>
<p>其他的细节： 每一个unique_ptr在out of scope的时候都会进行delete指针：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">unique_ptr&lt;<span class="type">int</span>&gt; p1;</span><br><span class="line">p<span class="number">1.</span><span class="built_in">reset</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">10</span>));</span><br><span class="line"><span class="function">unique_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(p<span class="number">1.</span>get())</span></span>;</span><br><span class="line">cout&lt;&lt;p<span class="number">1.</span><span class="built_in">get</span>()&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;p<span class="number">2.</span><span class="built_in">get</span>();</span><br><span class="line"><span class="comment">//ERROR!! 会Double Free！</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>shared_ptr</strong>:</p>
<p>In some scenerios, myltiple pointer needs to point to one pointer.</p>
<p>比如在多线程中：<strong>考试可能出现相同内容、可能出现！！</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">inc</span><span class="params">(unique_ptr&lt;<span class="type">int</span>&gt; p)</span></span>&#123;</span><br><span class="line">	(*p)++;</span><br><span class="line">    cout&lt;&lt;*p&lt;&lt;<span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    unique_ptr&lt;<span class="type">int</span>&gt;<span class="built_in">p</span>(<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>));</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(inc,p)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">t2</span><span class="params">(inc,p)</span></span>;<span class="comment">//Error: unique_ptr is an instance, 当对象作为参数闯入函数时，会拷贝构造函数，而unique_ptr是不允许的；</span></span><br><span class="line">    <span class="comment">//假如运行这个操作，因为拷贝对象在out of scope之后会自己吧原先的指针给释放！！</span></span><br><span class="line">    t<span class="number">1.</span><span class="built_in">join</span>();</span><br><span class="line">    t<span class="number">2.</span><span class="built_in">join</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在unique_ptr的基础上，进行计数：</p>
<ul>
<li>Constructor/ Copy Constructor / Assignment operator : increment the count by one</li>
<li>desturctor: decrease the counter by one.</li>
<li>When count equals to zero, delete the pointer;</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span> (<span class="number">10</span>))</span></span>;</span><br><span class="line">shared_ptr&lt;<span class="type">int</span>&gt; p2=p1;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">p3</span><span class="params">(p2)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Initialization:</p>
<ul>
<li>
<p>make_shared</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p= <span class="built_in">make_shared</span>&lt;T&gt;();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>constructor/ copy constructor /  operator =</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//省略，但是需要注意的是shaed_ptr是支持等号赋值和拷贝构造的，会导致shared_ptr加1</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>一些接口：</p>
<ul>
<li>
<p>reset: release the current pointer and set a new pointer(nullptr default)</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(<span class="keyword">new</span> <span class="type">int</span>(<span class="number">10</span>))</span></span>;</span><br><span class="line"><span class="keyword">auto</span> p2=p1;</span><br><span class="line"><span class="keyword">auto</span> p3=<span class="built_in">shared_ptr</span>&lt;<span class="type">int</span>&gt;(p1);</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Use counts: &quot;</span>&lt;&lt;p<span class="number">1.</span><span class="built_in">use_count</span>()&lt;&lt;<span class="string">&quot;\n&quot;</span>;<span class="comment">//3</span></span><br><span class="line">p<span class="number">2.</span><span class="built_in">reset</span>();</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;Use counts: &quot;</span>&lt;&lt;p<span class="number">1.</span><span class="built_in">use_count</span>()&lt;&lt;<span class="string">&quot;\n&quot;</span>; <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>use_count: get the counts of the shared_ptr that shares the current pointer;</p>
<blockquote>
<p>All shared_ptr (that points to the same pointer) has a membership pointer that stores the counts of shared_ptrs;</p>
</blockquote>
<p><strong>Note: Avoid duplicated creatation of share_ptrs to the same pointer</strong></p>
<p>即，不要用同一个裸指针创建多个share_ptrs！！！同样的，当然也不要用同一个裸指针创建多个unique_ptr!!!</p>
<p>会出现类似的问题：会出现double free。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="type">int</span>* p =<span class="keyword">new</span> <span class="built_in">int</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p1</span><span class="params">(p)</span></span>;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">shared_ptr&lt;<span class="type">int</span>&gt; <span class="title">p2</span><span class="params">(p)</span></span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;P1 points to&quot;</span>&lt;&lt;p<span class="number">1.</span><span class="built_in">get</span>()&lt;&lt;<span class="string">&quot; value: &quot;</span>&lt;&lt;*p1;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;P2 points to&quot;</span>&lt;&lt;p<span class="number">2.</span><span class="built_in">get</span>()&lt;&lt;<span class="string">&quot; value: &quot;</span>&lt;&lt;*p2;</span><br><span class="line">        cout&lt;&lt;p<span class="number">1.</span><span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;p<span class="number">2.</span><span class="built_in">use_count</span>()&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;P1 points to&quot;</span>&lt;&lt;p<span class="number">1.</span><span class="built_in">get</span>()&lt;&lt;<span class="string">&quot; value: &quot;</span>&lt;&lt;*p1;</span><br><span class="line"><span class="comment">//因为</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>一个问题： <code>cyclic reference of shared_ptrs</code></p>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250507102250380.png" alt="image-20250507102250380" /></p>
<p>解决方法：</p>
<p>（为什么不能是把next改成weak_ptr? 会出现什么问题？<strong>这个是期末考题</strong>，每一个例题都要注意，都有可能成为考题。）</p>
<p>（有同学提问：将prev换成裸指针可以吗）</p>
<p>老师回答： weak_ptr相当于可以理解为shared_ptr不计数，但是毕竟可以获取到shared_ptrs的相关信息，比如use_counts等等。裸指针也可以实现，只是没有这些接口了。</p>
<p><strong>weak_ptr</strong>:</p>
<p>weak_ptr is similiar to share_ptr but doesn’t effect the count;</p>
<p>weak_ptr的接口：</p>
<ul>
<li>use_counts</li>
<li>expired</li>
<li>lock()：implemnted as <code>expired()?shared_ptr&lt;T&gt;(this):shared_ptr&lt;T&gt;(this)</code></li>
</ul>
<p>考试会加上：1、并行程序设计（OJ会考，下次就会考） 2. 内存安全程序设计（OJ和考试都会考） 3. 函数式编程</p>
<p><strong>第一年考这些新的内容，难度会下降一点</strong>。</p>
<p>会占大概30-40分；</p>
<h3 id="空间类内存安全spatial-safety-caused-by-wrong-access"><a class="markdownIt-Anchor" href="#空间类内存安全spatial-safety-caused-by-wrong-access"></a> 空间类内存安全（Spatial safety caused by wrong access）</h3>
<p><strong>常见的spacial safety problem错误</strong></p>
<p>缓冲区溢出（Buffer overflow）</p>
<p>解引用空指针（Null pointer dereferencing）</p>
<p>访问未初始化内存（Dereference uninitialized pointer）</p>
<p><strong>Fat-Pointer</strong></p>
<p>除了存储指针信息，还存储一些<strong>meta data</strong>来进行动态检查，增强安全性。</p>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250507113601646.png" alt="image-20250507113601646" /></p>
<p>在malloc之后还需要存储相关的meta data，比如base 和 bound，代表起始位置和最后的位置</p>
<p>但是会出现一个问题：加入了base和bound之后可能会出现内存对齐和兼容性问题：</p>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250507114121808.png" alt="image-20250507114121808" /></p>
<p>因此需要更好的方法：</p>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250507114653612.png" alt="image-20250507114653612" /></p>
<p>将meta data存储在一片单独的空间中，比如上面的p指针对应的disjoint  space的相应位置就存储了p指针的bound和base信息。<strong>原理</strong> ：对于每个普通指针 <code>p</code>，其元数据存储在 <code>shadow_space[p]</code> 中。</p>
<p>但是空间利用率不高，我们可以用tire（字典树）的方式解决这个问题</p>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250507115026627.png" alt="image-20250507115026627" /></p>
<h2 id="函数式编程"><a class="markdownIt-Anchor" href="#函数式编程"></a> 函数式编程</h2>
<p>声明式程序设计,老师说这个不是考点，往年都不一定出题目</p>
<hr />
<p>程序设计范式：</p>
<ul>
<li>命令式Imperative programming . 如面向过程和面向对象程序设计</li>
<li>声明式Declarative programming. 如函数式程序设计（scheme）和逻辑式程序设计（SQL）</li>
</ul>
<p>函数式程序设计的基本特征：</p>
<ul>
<li>pure function纯函数 1. 相同输入相同输出  2. 无副作用</li>
<li>没有状态</li>
<li>函数也是值</li>
<li>递归为主要的控制结构</li>
<li>lazy evaluation</li>
<li>并行性：程序没有状态，以及函数引用的透明，无副作用等特点，有的操作可以进行并行。</li>
</ul>
<p><strong>函数式程序设计的基本手段</strong></p>
<ul>
<li>递归和尾递归</li>
<li>过滤/映射/规约操作（Filter/Map/Reduce）</li>
<li>部分函数应用（Partial Function Application）</li>
<li>柯里化（Currying）</li>
<li>…</li>
</ul>
<p><strong>递归和尾递归</strong></p>
<p><code>tail recursion</code></p>
<p>例子：使用尾递归实现fib的计算</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">fib</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> a, <span class="type">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)<span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(n==<span class="number">2</span>)<span class="keyword">return</span> b;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">fib</span>(n<span class="number">-1</span>,b,a+b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="其他的老师仓颉语言架构师大厂"><a class="markdownIt-Anchor" href="#其他的老师仓颉语言架构师大厂"></a> 其他的老师：仓颉语言架构师，大厂</h2>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://yama-lei.top">Yama-lei</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://yama-lei.top/posts/42accc7a7361/">https://yama-lei.top/posts/42accc7a7361/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://yama-lei.top" target="_blank">YamaBlog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/yama.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/409805ea00ab/" title="String, buffer and file operation"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">String, buffer and file operation</div></div><div class="info-2"><div class="info-item-1"> I/O Stream Input/Output (I/O) operations in C++ are managed through a set of libraries that provide abstractions for handling streams of data. These libraries allow you to interact with various sources like the console, files, and strings seamlessly.  iostream The &lt;iostream&gt; library provides functionality for reading from and writing to the standard input (std::cin) and standard output (std::cout). It also includes error streams (std::cerr and std::clog).  Key Features:   Standard Inpu...</div></div></div></a><a class="pagination-related" href="/posts/f39878f331ca/" title="FPGA设计和硬件描述语言"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">FPGA设计和硬件描述语言</div></div><div class="info-2"><div class="info-item-1">这一章不是重点。   PLD 器件 简单了解一下PLD的画法：  注意，列阵表示的含义：第一个固定连接和之后所有的可编程连接的变量都相连，相连的方式是右侧具体的逻辑门。  可编程逻辑阵列（Programmable Logic Array，PLA）是一种与阵列、或阵列都可编程的逻辑阵列:   存储器阵列 存储器阵列可以用于存储大量数据，但是读取速度比寄存器稍慢： 按照功能，可以分为ROM和RAM ROM：Read-Only-Memory ROM根据晶体管的有无，来存储01. RAM： RAM又可以区分为SRAM(静态的RAM)，和DRAM（动态的RAM）。  FPGA程序设计  Field Programmable Gate Array，FPGA  ​  下面JacyCui的笔记作为补充：  Chapter 05 FPGA设计和硬件描述语言 崔家才 201220014  1 可编程逻辑器件 可编程逻辑器件(Programmable Logic Device, PLD)：主要由与阵列和或阵列构成，逻辑门可以通过编程开关连接，以形成所需要的逻辑电路。 可编程只读储存器(Programm...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/yama.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yama-lei</div><div class="author-info-description">记录一个NJUCSer的学习</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">105</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yama-lei"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/yama-lei" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:your@email.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss" style="color: #FFA500;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">博客正在建设中...能看就行...😋😋😋</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E4%B8%8E%E5%B0%81%E8%A3%85"><span class="toc-number">1.</span> <span class="toc-text"> 抽象与封装</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.</span> <span class="toc-text"> 面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E6%B3%A8%E6%84%8F%E4%B8%8D%E5%90%8C%E5%88%9B%E5%BB%BA%E7%9A%84%E6%96%B9%E5%BC%8F%E9%AB%98%E9%A2%91%E8%80%83%E7%82%B9"><span class="toc-number">2.1.</span> <span class="toc-text"> 对象的创建方式（注意不同创建的方式，高频考点）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#public-privateprotected"><span class="toc-number">2.1.1.</span> <span class="toc-text"> public, private,protected:</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E8%B1%A1%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E8%BF%9B%E8%A1%8C%E4%BC%A0%E9%80%92%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E5%BF%85%E8%80%83%E7%82%B9%E5%8C%BA%E5%88%86%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%8C%BA%E5%88%AB%E5%BF%85%E8%80%83"><span class="toc-number">2.1.2.</span> <span class="toc-text"> 对象作为函数参数进行传递,作为函数返回值（必考点，区分下面的区别）！！！必考</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-number">2.2.</span> <span class="toc-text"> 构造函数和析构函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#this%E6%8C%87%E9%92%88"><span class="toc-number">2.2.1.</span> <span class="toc-text"> this指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8B%B7%E8%B4%9D%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E8%80%83%E7%82%B9%E4%B9%8B%E4%B8%80"><span class="toc-number">2.2.2.</span> <span class="toc-text"> 拷贝构造函数（考点之一）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32%E5%B8%B8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.</span> <span class="toc-text"> 3.2常成员函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.0.1.</span> <span class="toc-text"> 常成员函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%95%B0%E6%8D%AE%E6%88%90%E5%91%98"><span class="toc-number">2.3.0.2.</span> <span class="toc-text"> 静态数据成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-number">2.3.0.3.</span> <span class="toc-text"> 静态成员函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#33%E5%8F%8B%E5%85%83"><span class="toc-number">2.3.1.</span> <span class="toc-text"> 3.3友元</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#34%E7%B1%BB%E7%9A%84%E6%A8%A1%E5%9D%97%E5%8C%96%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.3.2.</span> <span class="toc-text"> 3.4类的模块化设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41inheritance%E7%BB%A7%E6%89%BF"><span class="toc-number">2.4.</span> <span class="toc-text"> 4.1Inheritance继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#42-%E5%A4%9A%E7%BB%A7%E6%89%BF"><span class="toc-number">2.4.1.</span> <span class="toc-text"> 4.2 多继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#43-%E8%81%9A%E5%90%88-%E7%BB%84%E5%90%88"><span class="toc-number">2.4.2.</span> <span class="toc-text"> 4.3 聚合、组合</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51-%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%B6%88%E6%81%AF%E7%9A%84%E5%8A%A8%E6%80%81%E7%BB%91%E5%AE%9A"><span class="toc-number">2.5.</span> <span class="toc-text"> 5.1 虚函数和消息的动态绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%AF%E8%99%9A%E5%87%BD%E6%95%B0%E5%92%8C%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">2.5.1.</span> <span class="toc-text"> 纯虚函数和抽象类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">2.6.</span> <span class="toc-text"> 6 操作符重载</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD%E7%9A%84%E5%8E%9F%E5%88%99"><span class="toc-number">2.6.0.1.</span> <span class="toc-text"> 操作符重载的原则：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">2.6.0.2.</span> <span class="toc-text"> 单元操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%85%83%E6%93%8D%E4%BD%9C%E7%AC%A6"><span class="toc-number">2.6.0.3.</span> <span class="toc-text"> 双元操作符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84%E6%93%8D%E4%BD%9C%E7%AC%A6%E9%87%8D%E8%BD%BD"><span class="toc-number">2.6.0.4.</span> <span class="toc-text"> 特殊的操作符重载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#c-%E8%87%AA%E5%AE%9A%E4%B9%89-new-%E5%92%8C-delete-%E6%93%8D%E4%BD%9C%E7%AC%A6%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.6.0.5.</span> <span class="toc-text"> C++ 自定义 new 和 delete 操作符详解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-operator-new-%E9%87%8D%E8%BD%BD%E5%9F%BA%E7%A1%80"><span class="toc-number">2.6.0.5.1.</span> <span class="toc-text"> 1. operator new 重载基础</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-placement-new%E5%AE%9A%E4%BD%8Dnew"><span class="toc-number">2.6.0.5.2.</span> <span class="toc-text"> 2. Placement New（定位new）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-operator-delete-%E9%87%8D%E8%BD%BD"><span class="toc-number">2.6.0.5.3.</span> <span class="toc-text"> 3. operator delete 重载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%86%85%E5%AD%98%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%BF%85%E8%80%83"><span class="toc-number">2.6.0.5.4.</span> <span class="toc-text"> 4. 内存池实现（必考）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-%E5%86%85%E5%AD%98%E9%87%8A%E6%94%BE%E9%97%AE%E9%A2%98%E5%BF%85%E8%80%83"><span class="toc-number">2.6.0.5.5.</span> <span class="toc-text"> 5. 内存释放问题（必考）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-%E9%87%8D%E8%BD%BDnewdelete%E7%9A%84%E6%84%8F%E4%B9%89"><span class="toc-number">2.6.0.5.6.</span> <span class="toc-text"> 6. 重载new&#x2F;delete的意义</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-number">2.6.0.5.7.</span> <span class="toc-text"> 7. 注意事项</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-iohandle-exception-and-debug"><span class="toc-number">2.7.</span> <span class="toc-text"> 第七章: IO,Handle Exception and Debug</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">2.7.1.</span> <span class="toc-text"> 输入输出</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">2.7.2.</span> <span class="toc-text"> 异常处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8E%E6%96%AD%E8%A8%80%E7%9A%84%E8%B0%83%E8%AF%95"><span class="toc-number">2.7.3.</span> <span class="toc-text"> 基于断言的调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E9%A9%B1%E5%8A%A8%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.7.4.</span> <span class="toc-text"> 事件驱动的程序设计</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E5%85%AB%E7%AB%A0"><span class="toc-number">2.8.</span> <span class="toc-text"> 第八章</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%9E%8B%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.8.1.</span> <span class="toc-text"> 泛型程序设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#stl%E7%BC%96%E7%A8%8B"><span class="toc-number">2.8.2.</span> <span class="toc-text"> STL编程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9"><span class="toc-number">3.</span> <span class="toc-text"> 其他内容</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.1.</span> <span class="toc-text"> 并行程序设计</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.2.</span> <span class="toc-text"> 内存安全程序设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#temporal-memory-problem"><span class="toc-number">3.2.1.</span> <span class="toc-text"> Temporal Memory Problem</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#raii-constructor-aqusition-destrucror-release"><span class="toc-number">3.2.1.1.</span> <span class="toc-text"> RAII ：Constructor Aqusition， Destrucror Release</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#smartpoint-%E4%BE%9D%E8%B5%96%E4%BA%8E%E6%B3%9B%E5%9E%8B%E5%92%8Craii%E6%80%9D%E6%83%B3%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.1.2.</span> <span class="toc-text"> SmartPoint 依赖于泛型和RAII思想实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E7%B1%BB%E5%86%85%E5%AD%98%E5%AE%89%E5%85%A8spatial-safety-caused-by-wrong-access"><span class="toc-number">3.2.2.</span> <span class="toc-text"> 空间类内存安全（Spatial safety caused by wrong access）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B"><span class="toc-number">3.3.</span> <span class="toc-text"> 函数式编程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E7%9A%84%E8%80%81%E5%B8%88%E4%BB%93%E9%A2%89%E8%AF%AD%E8%A8%80%E6%9E%B6%E6%9E%84%E5%B8%88%E5%A4%A7%E5%8E%82"><span class="toc-number">3.4.</span> <span class="toc-text"> 其他的老师：仓颉语言架构师，大厂</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/66b650927646/" title="多维数组">多维数组</a><time datetime="2025-09-30T16:00:00.000Z" title="发表于 2025-10-01 00:00:00">2025-10-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/66c438509deb/" title="多模态综述">多模态综述</a><time datetime="2025-09-30T13:14:40.000Z" title="发表于 2025-09-30 21:14:40">2025-09-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/54b78cdb42c3/" title="无标题">无标题</a><time datetime="2025-09-30T01:58:28.349Z" title="发表于 2025-09-30 09:58:28">2025-09-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/0ac3e125560f/" title="Riscv介绍">Riscv介绍</a><time datetime="2025-09-29T16:00:00.000Z" title="发表于 2025-09-30 00:00:00">2025-09-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>记录一个NJUCSer的学习历程 · 代码改变世界，技术创造未来</div><div class="btn-xz-box"><a class="btn-xz" href="/about/">了解更多</a></div></div></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"><a href="/links/" title="广告位招租"><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/zhaozu.jpg" alt="广告位招租"/></a></div><div class="img-group-item"><a href="/links/" title="更多友联"><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/zhaozu.jpg" alt="友链"/></a></div></div></div></div><div class="copyright"><span><b>&copy;2025</b></span><span><b>&nbsp;&nbsp;By Yama-lei</b></span></div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Less is more · © YamaBlog</div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo"><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat-square" alt="Hexo"/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly"><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat-square" alt="Butterfly"/></a><a class="github-badge" target="_blank" href="https://github.com/yama-lei" style="margin-inline:5px" title="源码托管于GitHub"><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat-square" alt="GitHub"/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><script src="/js/custom.js"></script><script src="/js/footer-enhance.js"></script><script src="/js/homepage-enhance.js"></script><script defer src="/js/runtime.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索..." type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>