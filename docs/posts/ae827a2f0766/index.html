<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>chapter8 | CPU的设计 | YamaBlog</title><meta name="author" content="Yama-lei"><meta name="copyright" content="Yama-lei"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="[toc]  CPU概述 CPU执行指令的过程：  根据pc取指令  异常时内部异常，中断时由于外部事件的出现导致CPU停止执行指令； 即内部异常，外部中断   计算机的五大组成部件  Memory I&#x2F;O Datapath 数据通路 执行部件 Control Unit 控制部件 控制器：控制器对执行部件发出信号。    数据通路Datapath的基本结构 数据通路是由操作元件和存储元件通过总线方">
<meta property="og:type" content="article">
<meta property="og:title" content="chapter8 | CPU的设计">
<meta property="og:url" content="https://yama-lei.top/posts/ae827a2f0766/index.html">
<meta property="og:site_name" content="YamaBlog">
<meta property="og:description" content="[toc]  CPU概述 CPU执行指令的过程：  根据pc取指令  异常时内部异常，中断时由于外部事件的出现导致CPU停止执行指令； 即内部异常，外部中断   计算机的五大组成部件  Memory I&#x2F;O Datapath 数据通路 执行部件 Control Unit 控制部件 控制器：控制器对执行部件发出信号。    数据通路Datapath的基本结构 数据通路是由操作元件和存储元件通过总线方">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/yama.webp">
<meta property="article:published_time" content="2025-04-20T16:00:00.000Z">
<meta property="article:modified_time" content="2025-09-28T13:41:20.030Z">
<meta property="article:author" content="Yama-lei">
<meta property="article:tag" content="博客">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/yama.webp"><script type="application/ld+json">{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "chapter8 | CPU的设计",
  "url": "https://yama-lei.top/posts/ae827a2f0766/",
  "image": "https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/yama.webp",
  "datePublished": "2025-04-20T16:00:00.000Z",
  "dateModified": "2025-09-28T13:41:20.030Z",
  "author": [
    {
      "@type": "Person",
      "name": "Yama-lei",
      "url": "https://yama-lei.top"
    }
  ]
}</script><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://yama-lei.top/posts/ae827a2f0766/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.json","preload":true,"top_n_per_article":1,"unescape":false,"pagination":{"enable":false,"hitsPerPage":8},"languages":{"hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'null',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyloadPlugin: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'chapter8 | CPU的设计',
  isHighlightShrink: false,
  isToc: true,
  pageType: 'post'
}</script><link rel="stylesheet" href="/css/callout_blocks.css"><link rel="stylesheet" href="/css/custom.css"><link rel="stylesheet" href="/css/homepage-hero.css"><link rel="stylesheet" href="/css/card-enhance.css"><link rel="stylesheet" href="/css/sidebar-enhance.css"><link rel="stylesheet" href="/css/category-tag-page.css"><meta name="generator" content="Hexo 8.0.0"><link rel="alternate" href="/atom.xml" title="YamaBlog" type="application/atom+xml">
</head><body><div id="web_bg" style="background-color: #ffffff;"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/yama.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">105</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-list"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/essay/"><i class="fa-fw fas fa-comment-dots"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/playground/"><i class="fa-fw fas fa-flask"></i><span> Playground</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-user-friends"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="not-top-img fixed" id="page-header"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">YamaBlog</span></a><a class="nav-page-title" href="/"><span class="site-name">chapter8 | CPU的设计</span><span class="site-name"><i class="fa-solid fa-circle-arrow-left"></i><span>  返回首页</span></span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-list"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/essay/"><i class="fa-fw fas fa-comment-dots"></i><span> 说说</span></a></div><div class="menus_item"><a class="site-page" href="/playground/"><i class="fa-fw fas fa-flask"></i><span> Playground</span></a></div><div class="menus_item"><a class="site-page" href="/links/"><i class="fa-fw fas fa-user-friends"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-user"></i><span> 关于</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav></header><main class="layout" id="content-inner"><div id="post"><div id="post-info"><h1 class="post-title">chapter8 | CPU的设计</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-04-20T16:00:00.000Z" title="发表于 2025-04-21 00:00:00">2025-04-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-09-28T13:41:20.030Z" title="更新于 2025-09-28 21:41:20">2025-09-28</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/NJUCS/">NJUCS</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/NJUCS/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/">数字逻辑与计算机组成</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div><article class="container post-content" id="article-container"><p>[toc]</p>
<h2 id="cpu概述"><a class="markdownIt-Anchor" href="#cpu概述"></a> CPU概述</h2>
<p><strong>CPU执行指令的过程</strong>：</p>
<ol>
<li>根据pc取指令</li>
</ol>
<p>异常时内部异常，中断时由于外部事件的出现导致CPU停止执行指令； 即<code>内部异常，外部中断</code></p>
<hr />
<h3 id="计算机的五大组成部件"><a class="markdownIt-Anchor" href="#计算机的五大组成部件"></a> <strong>计算机的五大组成部件</strong></h3>
<ul>
<li>Memory</li>
<li>I/O</li>
<li>Datapath 数据通路 <strong>执行部件</strong></li>
<li>Control Unit 控制部件 <strong>控制器</strong>：控制器对执行部件发出信号。</li>
</ul>
<hr />
<h4 id="数据通路datapath的基本结构"><a class="markdownIt-Anchor" href="#数据通路datapath的基本结构"></a> <strong>数据通路Datapath的基本结构</strong></h4>
<p>数据通路是由<strong>操作元件和存储元件</strong>通过<strong>总线</strong>方式或<strong>分散</strong>方式连接而成的进行<em><strong>数据存储、处理、传送</strong></em>的路径</p>
<p><strong>操作元件</strong>：（是组合逻辑电路）</p>
<p><strong>存储元件</strong>：（时序逻辑电路）</p>
<p>setup时间：在时钟边沿到来<strong>之前</strong>，输入端保持不变的时间；</p>
<p>hold时间：在时钟边沿<strong>之后</strong>，输入端必须保持不变的时间；</p>
<p>clk-to-q锁存延迟：从时钟边沿到输出端稳定的时间；</p>
<h4 id="数据通路和时序控制"><a class="markdownIt-Anchor" href="#数据通路和时序控制"></a> 数据通路和时序控制</h4>
<p>指令周期 : CPU执行一条指令需要的时间。</p>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250421114837747.png" alt="image-20250421114837747" /></p>
<p>指令周期：<strong>Cycle Time = Latch Prop + Longest Delay Path + Setup + Clock Skew</strong></p>
<p>为了满足数据通路的要求，要能够满足下面这个约束关系：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>h</mi><mi>o</mi><mi>l</mi><mi>d</mi><mi>T</mi><mi>i</mi><mi>m</mi><mi>e</mi><mo>&lt;</mo><mi>C</mi><mi>l</mi><mi>k</mi><mi>T</mi><mi>o</mi><mi>Q</mi><mo>+</mo><mi>s</mi><mi>h</mi><mi>o</mi><mi>r</mi><mi>t</mi><mi>e</mi><mi>s</mi><mi>t</mi><mi>D</mi><mi>e</mi><mi>l</mi><mi>a</mi><mi>y</mi></mrow><annotation encoding="application/x-tex">holdTime&lt; ClkToQ+shortestDelay
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathnormal">h</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">o</span><span class="mord mathnormal">Q</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">h</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mord mathnormal">t</span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span></span></p>
<p>即，<strong>在下一个信号到来前，能够hold不变，防止输出异常</strong></p>
<hr />
<h3 id="计算机性能"><a class="markdownIt-Anchor" href="#计算机性能"></a> 计算机性能</h3>
<p>衡量CPU性能的是<strong>用户CPU时间</strong>，执行用户的作业所需的时间，不考虑IO等</p>
<p>CPU的执行时间：</p>
<p>T= CPU的时钟周期数*时钟周期/程序= 指令条数/程序 *CPI *时钟周期</p>
<blockquote>
<p>一个程序的时钟周期数x时钟周期</p>
</blockquote>
<p><strong>CPI</strong>： Cycle Per Instruction，每一条指令需要多少个时钟周期</p>
<p>CPI是一个确定值–和CPU的设计,指令类型有关。</p>
<p>某个程序的CPU时间为：</p>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>C</mi><mi>P</mi><mi>U</mi><mtext> </mtext><mi>T</mi><mi>i</mi><mi>m</mi><mi>e</mi><mo>=</mo><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></munderover><mrow><mi>C</mi><mi>P</mi><msub><mi>I</mi><mi>i</mi></msub><mo>∗</mo><msub><mi>C</mi><mi>i</mi></msub></mrow></mrow><annotation encoding="application/x-tex">CPU \space Time= \sum_{i=1}^n {CPI_i * C_i}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord mathnormal" style="margin-right:0.10903em;">U</span><span class="mspace"> </span><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="mord mathnormal">i</span><span class="mord mathnormal">m</span><span class="mord mathnormal">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.929066em;vertical-align:-1.277669em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.6513970000000002em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07847em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>Ci为第i类指令，CPI_i 是这种指令的CPI。 再除以指令总数，即可得到程序的平均CPI.</p>
<hr />
<p>为什么 ISA也会影响CPI？ 因为RISC-V没有提供像乘法和除法的指令，每个指令的时钟周期都比较短。</p>
<p>时钟频率翻倍但是</p>
<p>基准测试程序：专门用于测试性能测试的程序，使得计算机有个公共的比较方法。</p>
<p><strong>计算机性能由三个关键因素决定：指令数目，CPI，时钟周期</strong></p>
<ul>
<li>指令数目由编译器和ISA决定</li>
<li>CPI由ISA和CPU决定</li>
<li>时钟周期由CPU的实现来决定</li>
</ul>
<p>CPU时间 = 指令数目 * CPI* 时钟周期</p>
<h2 id="单周期的cpu设计"><a class="markdownIt-Anchor" href="#单周期的cpu设计"></a> 单周期的CPU设计</h2>
<p><strong>单总线数据通路</strong></p>
<p>这一部分没有听懂，请自行看ppt。</p>
<p>时钟周期的宽度：以read、write为准（因为要以最长的为准）</p>
<p><strong>常见的指令！！！</strong></p>
<table>
<thead>
<tr>
<th>指令</th>
<th>功能 这里用的不是RTL！是我自己写的</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>add rd rs1 rs2</td>
<td>R[rd]=R[rs1]+R[rs2]</td>
<td></td>
</tr>
<tr>
<td>slt rd rs1 rs2</td>
<td>rd = 1 if R[rs1]&lt;R[rs2] else 0</td>
<td>使用signed比较</td>
</tr>
<tr>
<td>sltu rd rs1 rs2</td>
<td>rd= 1 if R[rs1]&lt;R[rs2] else 0</td>
<td>使用unsigned比较</td>
</tr>
<tr>
<td>ori rd rs1 imm12</td>
<td>R[rd]= rs1 | SEXT[imm12]</td>
<td>ori：or immedia</td>
</tr>
<tr>
<td>lui rd imm20</td>
<td>R[rd]= SEXT[imm20]</td>
<td>U型imm</td>
</tr>
<tr>
<td>lw rd rs1 imm12</td>
<td>R[rd] = M[rs1+SEXT[imm12]]</td>
<td></td>
</tr>
<tr>
<td>sw rs1 rs2 imm12</td>
<td>M[R[rs1]+SEXT[imm12]] =</td>
<td></td>
</tr>
<tr>
<td>beq rs1 rs2 imm12</td>
<td>PC=PC+SEXT[imm12*2] if rs1= rs2</td>
<td>注意imm12要乘以2</td>
</tr>
<tr>
<td>jal rd im20</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<blockquote>
<p>注意： 有关imm乘以几的问题，可以参考这个文章<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/377200438">RV32I控制转移指令的偏移量计算问题 - 知乎</a></p>
<p>省流不看版本：除了jalr指令，所有的B和J型指令的imm都表示跳转imm*2 bytes(显然PC+1代表比PC往前了一个byte)，而指令是按照<code>字</code>来编码的（32位机器字长代表4个bytes），因此需要对imm进行乘以2，这样子，就能成功地实现跳转。</p>
</blockquote>
<p><strong>存储数据的指定</strong>：</p>
<p>寄存器编号只需5位</p>
<p>32bit machine的总线只有32位，理论上最大访问的内存为2的32次方，也就是4GB；</p>
<hr />
<h3 id="单流水线cpu的设计"><a class="markdownIt-Anchor" href="#单流水线cpu的设计"></a> <strong>单流水线CPU的设计</strong></h3>
<p>除R-型外，其他5类都带有立即数   ——立即数扩展器</p>
<p>核心运算类功能的实现  		  ——ALU<br />
根据PC取指令和PC+4	    	——取指令部件<br />
指令的RTL最终实现		        ——完整数据通路</p>
<h4 id="立即数扩展器"><a class="markdownIt-Anchor" href="#立即数扩展器"></a> 立即数扩展器</h4>
<p>为什么需要一个立即数扩展器？ 因为RISCV的指令二进制表示中，imm的排列很混乱，而且不同的指令的imm位数和排列往往不同，因此需要立即数扩展器</p>
<img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250425114704950.png" alt="image-20250425114704950" style="zoom:50%;" />
<p>除了R型指令不需要寄存器，其他都有寄存器。因此需要一个5选1的选择器。ExtOP为3位，具体如何得到ExtOP呢？<strong>需要根据编码Instr得到</strong></p>
<h4 id="alu-算数逻辑部件的设计"><a class="markdownIt-Anchor" href="#alu-算数逻辑部件的设计"></a> ALU 算数逻辑部件的设计</h4>
<img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250425115156719.png" alt="image-20250425115156719" style="zoom:50%;" />
<p>实现的功能：</p>
<ul>
<li>
<p>add or slt sltu srcB,判0</p>
<p>即实现了加法，或运算，比较，将B直接输出，判断是否为0；</p>
</li>
</ul>
<p>因为上述的9条指令需要这些运算，比如lw指令，需要加法（lw rd rs1 imm12: R[rd] &lt;— M[R[]]</p>
<h4 id="取指令部件-instruction-fetch-unit"><a class="markdownIt-Anchor" href="#取指令部件-instruction-fetch-unit"></a> 取指令部件 Instruction Fetch Unit</h4>
<p>每一次运行指令都有一步<strong>更新PC</strong>的步骤，需要依靠取指令部件；</p>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427103915530.png" alt="image-20250427103915530" /></p>
<h4 id="r型指令的数据通路"><a class="markdownIt-Anchor" href="#r型指令的数据通路"></a> R型指令的数据通路</h4>
<p>R型指令：</p>
<ul>
<li>add rd rs1 rs2:</li>
<li>slt rd rs1 rs2;</li>
<li>sltu rd rs1 rs2;</li>
</ul>
<p>R型指令无需imm，直接从寄存器组中读取、写入数据即可：</p>
<p><strong>写使能端信号不能乱取！！！防止出现错误</strong></p>
<p>R型指令中，RegWr（<strong>Reg</strong>ister <strong>Wr</strong>ite）为1；</p>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427104315618.png" alt="image-20250427104315618" /></p>
<h4 id="i型指令的型号通路ori"><a class="markdownIt-Anchor" href="#i型指令的型号通路ori"></a> I型指令的型号通路（ori)</h4>
<p>因为除了R型指令，其他的指令都有imm，rs只有一个，因此需要ALU的输入端需要一个多路选择器，以<strong>ALUBSrc</strong>为控制信号。</p>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427104604542.png" alt="image-20250427104604542" /></p>
<h4 id="u型指令的信号通路"><a class="markdownIt-Anchor" href="#u型指令的信号通路"></a> U型指令的信号通路</h4>
<p>U型指令只有一个lui</p>
<ul>
<li>lui rd imm20</li>
</ul>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427110900124.png" alt="image-20250427110900124" /></p>
<h4 id="loadstore指令的信号通路"><a class="markdownIt-Anchor" href="#loadstore指令的信号通路"></a> Load&amp;Store指令的信号通路</h4>
<p>指令详情：</p>
<ul>
<li>load rd rs1 imm12; R[rd] = M[R[rs1]+SEXT[imm12]] 。 <strong>注意：这里的imm不需要乘以2，因为数据是按字节寻址的</strong></li>
<li>store rs1 rs2 imm12; M[R[rs1]+SEXT[imm12]]&lt;–R[rs2]。</li>
</ul>
<p>Load和Store指令涉及到了存储器的访问，这里以理想存储器为例：</p>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427110804853.png" alt="image-20250427110804853" /></p>
<blockquote>
<p>MemtoReg: 即 Memory To Register</p>
</blockquote>
<p>注意：B和J型指令的imm通常需要左移一位，这是因为在设计的时候省略了1位，或者说默认最后一位为0（处于对齐指令的目的）；在RISCV规范中，给出了相关的内容，可以参考<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/377200438">RV32I控制转移指令的偏移量计算问题 - 知乎</a></p>
<h4 id="b型指令的数据通路"><a class="markdownIt-Anchor" href="#b型指令的数据通路"></a> B型指令的数据通路</h4>
<p>指令为：</p>
<ul>
<li>beq rs1 rs2 imm12; if(R[rs1]=R[rs2]) PC&lt;-- PC+(SEXT(imm12)&lt;&lt;1) else PC&lt;-- PC+4;</li>
</ul>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427112357474.png" alt="image-20250427112357474" /></p>
<p>其中下地址逻辑为：（只有当ALU计算结果为0，并且是Branch指令，才会将imm和PC相加，否则PC=PC+4）</p>
<img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427112744627.png" alt="image-20250427112744627" style="zoom:50%;" />
<h4 id="j型指令"><a class="markdownIt-Anchor" href="#j型指令"></a> J型指令</h4>
<p>J型指令：</p>
<ul>
<li>jal rd imm20; R[rd]&lt;- PC+4, PC&lt;- PC+SEXT(imm20&lt;&lt;1);</li>
</ul>
<p>J型指令除了需要跳转，还需要将下一条指令存入寄存器（实现call的操作）</p>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427113923927.png" alt="image-20250427113923927" /></p>
<hr />
<p><strong>指令的执行结果总是在新的时钟周期到来之前，才会将其保存在寄存器、PC、存储器中</strong></p>
<p>一个时钟周期的时间为：clk-to-q+longest delay +setup+ 时钟偏移，可以看出，时钟周期应该根据最长的delay来决定。</p>
<hr />
<blockquote>
<p>考试的时候以 短周期和流水线的数据通路图、控制器，很清楚地知道每一个控制信号，每一条线的内容，指令必须看得到，不一定会写汇编代码。</p>
</blockquote>
<h3 id="控制器的设计"><a class="markdownIt-Anchor" href="#控制器的设计"></a> 控制器的设计</h3>
<p>前面提过，CPU的核心是数据通路（执行部件）和控制器（控制部件），前面已经设计好了数据通路，但是数据通路中的很多信号，比如ALUctr需要控制器的作用。</p>
<h4 id="控制信号的取值分析"><a class="markdownIt-Anchor" href="#控制信号的取值分析"></a> 控制信号的取值分析</h4>
<ol>
<li>
<p><strong>所有指令执行的共同操作</strong></p>
<p>每一条指令运行的过程都是：Clk信号到来，经过一个Clk-To-Q（锁存延时）之后，PC被写入<strong>指令存储器</strong>，经过取数时间，指令被取出，送入控制器，<strong>在控制器中译码，并且发出控制信号</strong>，之后进入数据通路计算，下一个时钟周期到来，新的数据被写入。</p>
<blockquote>
<p>对于R型指令，新的PC很快得到，到那时对于跳转指令，需要等待运算才能得到新的PC值。</p>
</blockquote>
</li>
<li>
<p><strong>R型指令的执行过程</strong></p>
<p>Rd,Rs1,Rs2来自取指令单元（指令存储器），各种控制信号来自控制器。（回顾过程：PC寄存器经过clk2q之后MAR得</p>
<p>R型指令的执行过程可以概括为：Rigister(rs1,rs2) -&gt; busA,busB-&gt;buwW-&gt;Rigister(rd)</p>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250428101709013.png" alt="image-20250428101709013" /></p>
<blockquote>
<p>留心这些控制信号的取值和含义，比如MemWr应该一定为0，MemtoReg也是为0</p>
</blockquote>
<p>R型指令的时间分析：</p>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250428102812207.png" alt="image-20250428102812207" /></p>
</li>
<li>
<p>I型指令的执行过程</p>
<p>Rigister(rs1)-&gt;busA,扩展器(imm12)-&gt; ALU-&gt; Rigister(rd)</p>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250428103132649.png" alt="image-20250428103132649" /></p>
</li>
<li>
<p>U型指令的执行过程</p>
</li>
<li>
<p>Load指令</p>
</li>
<li>
<p>Store指令</p>
</li>
<li>
<p>B型指令</p>
</li>
<li>
<p>J型指令</p>
</li>
<li>
<p>最终指令和真值表的取值</p>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250428103320124.png" alt="image-20250428103320124" />因此可以通过极小项写出每一个控制信号的 逻辑表达式</p>
<p>比如：Branch=op&lt;6&gt;&amp;op&lt;5&gt;&amp;<sub>op&lt;4&gt;&amp;</sub>op&lt;3&gt;&amp;~op&lt;2&gt;&amp;op&lt;1&gt;&amp;op&lt;0&gt;    (B-type)</p>
<p>Jump=op&lt;6&gt;&amp;op&lt;5&gt;&amp;~op&lt;4&gt;&amp;op&lt;3&gt;&amp;op&lt;2&gt;&amp;op&lt;1&gt;&amp;op&lt;0&gt;           (J-type)</p>
<blockquote>
<p>这里没有考虑funct3功能码，是因为B-type指令的op都是1100011，具体功能由funct3决定，即，B型指令的op都相同，只要保证op为1100011时Branch信号为1即可；而J-type的指令没有funct3字段；</p>
</blockquote>
<p>我们依次分析每一个控制信号的真值表达式，最后链接电路：</p>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250428105102309.png" alt="image-20250428105102309" /></p>
</li>
</ol>
<h4 id="时钟周期的设计"><a class="markdownIt-Anchor" href="#时钟周期的设计"></a> 时钟周期的设计</h4>
<p>时钟周期应该要满足最慢的指令（load）的要求</p>
<p>load指令：（load rd rs1 imm12）</p>
<ul>
<li>clk2q+取指令时间</li>
<li>译码时间（控制单元延迟）</li>
<li>寄存器读数延迟（得到R[rs1]）</li>
<li>ALU延迟（得到addr=R[rs1]+SEXT[imm12]）</li>
<li>存储器读数延迟 （读取M[addr]）</li>
<li>寄存器setup时间</li>
</ul>
<hr />
<p>例子：<a id="q"> </a>假设在单周期处理器中，各主要功能单元的操作时间为：</p>
<p>存储单元：200ps\  ALU和加法器：100ps\ 寄存器堆（读/写）：50ps</p>
<p>假设MUX、控制单元、PC、扩展器和传输线路都没有延迟，则单周期实现方式（每条指令在一个固定长度的时钟周期内完成）中，CPU执行时间如何计算？</p>
<p>那么我们可以确定：</p>
<p>R-type： 取指令200+读rs1、rs2 50+ALU100+写rd 50= 400</p>
<p>Load Word指令：取指令200+读rs1 50+ ALU100+ 存储器读取 200+ 写入rd 50= 600</p>
<p>Store Word指令：取指令200 +   读取rs1，rs2 50 +ALU100 + store 200= 550（注意rs1和rs2的读取是并行的）</p>
<p>Branch： 取指令200+ 读取rs1，rs2, 50 +ALU100 = 350</p>
<p>Jump： 取指令200+ 存入PC+4 50 + ALU计算跳转位置 100 =350；</p>
<hr />
<h2 id="多周期cpu设计"><a class="markdownIt-Anchor" href="#多周期cpu设计"></a> 多周期CPU设计</h2>
<p>下面以实现一个简单的指令系统为例，讲解多周期CPU的设计</p>
<blockquote>
<p>这个指令系统不用记！！！</p>
</blockquote>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250428112505398.png" alt="image-20250428112505398" /></p>
<p><strong>多周期的数据通路</strong></p>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250428112702885.png" alt="image-20250428112702885" /></p>
<h3 id="指令执行的过程"><a class="markdownIt-Anchor" href="#指令执行的过程"></a> 指令执行的过程</h3>
<blockquote>
<p>Note: 多周期的CPU的时钟周期取的是任何一条指令、所有阶段中最长的那一个；在下面的各种阶段中，取指令阶段因为涉及到一次存储器访问和一次寄存器保存过程，因此耗时最长（访问寄存器的耗时比较长，可以参考<a href="#q">上面的例题</a></p>
</blockquote>
<h4 id="取指令并计算下条指令地址"><a class="markdownIt-Anchor" href="#取指令并计算下条指令地址"></a> 取指令并计算下条指令地址</h4>
<p>该阶段对应状态记为IFetch。因为采用定长指令字，故PC增量操作可在取指令阶段完成。取指阶段的功能是：将PC内容作为地址访问主存以取出指令，将指令存入指令寄存器IR中，并将PC+4作为下条指令地址送PC。实现上述功能的有效控制信号及其取值如下。</p>
<ul>
<li>R[IR]&lt;-M[PC]:PCout=1,MARout=0,MemWr=0,IRWr=1。</li>
<li>PC&lt;-PC+4:Add1MUX=0,Add2MUX=1,PCWr=1。、</li>
<li>其他寄存器写使能信号(如MARWr、CCWr、MDRWr、ALUoutWr、RegWr)全部为0。</li>
</ul>
<hr />
<h4 id="译码并取数"><a class="markdownIt-Anchor" href="#译码并取数"></a> 译码并取数</h4>
<p>将IR中的op段送入控制器，得到控制信号；将Rs,Rt输入到寄存器组的Ra，Rb端；</p>
<p>同时会进行“投机计算”：计算Load、Store指令中的地址，并且存放在MAR中。</p>
<h4 id="执行指令"><a class="markdownIt-Anchor" href="#执行指令"></a> 执行指令</h4>
<p>3)执行指令<br />
控制部件对指令译码后，会和条件码中的标志信息组合生成控制信号，从而使CPU在控制信号的控制下执行指令。针对不同指令的功能，其对应的有效控制信号如下。</p>
<ol>
<li>
<p>R-型指令：R[Rt]-R[Rs]op R[Rt]<br />
R-型指令的执行需要两个时钟周期，对应状态分别记为RExec和RFinish。</p>
<ul>
<li>RExec状态的功能为：进行ALU运算并将结果存入ALUout和CC寄存器。其有效控制信号及其取值为 BMUX=1,ALUOp=xxx,ALUoutWr=1,CCWr=1,其他寄存器写使能信号全部为0。其中，ALUOp的取值由指令操作码决定，以控制ALU进行不同的运算。</li>
<li>RFinish状态的功能为：将ALUout的内容存入Rt。其有效控制信号及其取值为：RegMUX=1,RegWr=1,其他寄存器写使能信号全部为0。</li>
</ul>
<p>问题：为什么不把这两个阶段给合并？如果两个周期合并，可能来不及把异常结果转去进行异常处理，就可能把错误结果写入寄存器了如果Rfinish之后再进入溢出异常处理状态，则需要保证RegWr修改为0；简而言之：为了异常处理。</p>
</li>
<li>
<p>I-型运算指令：R[Rt]←R[Rs]op EXT[imm16]<br />
I-型运算指令的执行需要两个时钟周期，对应状态分别记为IExec和IFinish。</p>
<ul>
<li>IExec状态的功能为：进行ALU运算并将结果存入ALUout和CC寄存器。其有效控制信号及其取值为：ExtOp=0或1,BMUX=0,ALUOp=xxx,ALUoutWr=1,CCWr=1,其他寄存器写使能信号全部为0。与R-型指令一样，ALUOp的取值由指令操作码决定，不同的取值控制ALU进行不同的运算。</li>
<li>IFinish状态的功能为：将ALUout的内容存入Rt。其有效控制信号及其取值为：RegMUX=1,RegWr=1,其他寄存器写使能信号全部为0。经分析可知，IFinish和RFinish两个状态的功能完全一样，因此，可以将两个状态合并成一个状态：RIFinish。</li>
</ul>
</li>
<li>
<p>Load指令：R[Rt]-M[R[Rs]+SEXT[imm16]]<br />
Load指令的执行包含三个子功能，需要三个时钟周期。因为在“译码并取数”阶段已经计算出地址并存入MAR中，因而还需要两个时钟周期，对应状态分别记为lwExec和lwFinish。</p>
<ul>
<li>lwExec状态的功能为：读主存内容并保存到MDR。其有效控制信号及其取值为：MARout=1,PCout=0,MemWr=0,MDRMUX=0,MDRWr=1,其他寄存器写使能信号全部为0。</li>
<li>lwFinish状态的功能为：将MDR内容存入Rt。其有效控制信号及其取值为：RegMUX=0,RegWr=1,其他寄存器写使能信号全部为0。</li>
</ul>
</li>
<li>
<p>Store指令：M[R[Rs]+SEXT[imm16]]-R[Rt]</p>
<p>Store指令的执行包含三个子功能，需要至少三个时钟周期。因为在“译码并取数”阶段已经计算出地址并存入MAR中，因而只需要两个时钟周期，对应状态分别记为swExec和swFinish。</p>
<ul>
<li>swExec状态的功能为：将Rt存入MDR并直送总线。其有效控制信号及其取值为：MDRMUX=1,MDRWr=1,MARout=1,PCout=0,MemWr-0,其他寄存器写使能信号全部为0。</li>
<li>swFinish状态的功能为：将MDR送入总线的数据写入主存。其有效控制信号及其取值为：MARout=1,PCout=0,MemWr=1,其他寄存器写使能信号全部为0。</li>
</ul>
</li>
<li>
<p>Jump指令：PC+PC+SEXT[imm16]<br />
Jump指令的功能为：进行转移目标地址计算并送PC。它只需要一个时钟周期，对应状态记为JFinish。</p>
<ul>
<li>其有效控制信号及其取值为：ExtOp=1,Add1MUX=0,Add2MUX=0,PCWr=1,其他寄存器写使能信号全部为0。</li>
</ul>
<p>根据上述对每条指令执行过程的分析，得到一个状态转换图。图8.32是一个支持R-型指令、I-型运算指令、Load/Store指令和Jump指令执行的状态转换示意图。</p>
<p>图中每个状态用一个状态编号和状态名标识，例如，0:IFetch表示第0状态，执行取指令(IFetch)操作，圆圈中示意性地给出了该状态下部分控制信号的取值，其中，有取值为0和取值为1的两种有效控制信号，以及多值有效控制信号ALUOp,ALUOp=xxx表示根据操作码OP译码得到的一个ALU操作控制信号取值为xxx。此外，图中的x表示取值为任意的无效控制信号。</p>
<p>在图8.31所示的多周期数据通路中，每条指令的执行过程就是图8.32所示的状态转换过程。每来一个时钟，进入下一个状态。从图8.32可看出，R-型指令、I-型运算指令、Load和Store指令的CPI都为4,跳转指令Jump的CPI为3。如果不在译码/取数阶段“投机”计算访存地址，则Load和Store指令的CPI为5。</p>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250428115548563.png" alt="image-20250428115548563" /></p>
</li>
</ol>
<hr />
<blockquote>
<p>五一假期结束，现在看不懂自己的笔记了</p>
</blockquote>
<p>时钟周期的= clock-to-q+setup+longest-delay</p>
<p>注意无论是那一条指令，都有两个步骤是相同的，即IFetch和RFetch/ID，其中IFetch进行取指令，并且计算PC+4；RFetch/ID有‘投机计算’</p>
<p>状态1之后，按照指令的译码进入不同的指令。</p>
<p>除了Jump指令是3个周期之外，所有的指令都是4个周期，即除了Jump的CPI为3其他都是为4</p>
<blockquote>
<p>如果没有投机计算，那么lw和sw的CPI为5</p>
</blockquote>
<h3 id="pla控制器的设计"><a class="markdownIt-Anchor" href="#pla控制器的设计"></a> PLA控制器的设计</h3>
<p>PLA控制器又称为组合逻辑控制器，或者硬连线控制器。</p>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250509104343151.png" alt="image-20250509104343151" /></p>
<p><strong>下一状态是当前状态和操作码的函数</strong></p>
<p>我们可以画出一个状态转换表来实现PLA电路，</p>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250509104713007.png" alt="image-20250509104713007" /></p>
<p>硬连线方式可以自行看ppt了解，因为不是重点，故不在这里展示。</p>
<p>特点是：1. 速度快 2. 硬件实现复杂、灵活性差。</p>
<h3 id="微程序控制器设计"><a class="markdownIt-Anchor" href="#微程序控制器设计"></a> 微程序控制器设计</h3>
<blockquote>
<p>这是一个很有趣的思想，尽管在这里用不上。</p>
</blockquote>
<p>基本思想：用微程序来描述机器指令，每一个微程序都有多个微指令，微指令有多个微命令。</p>
<p>每一条微指令和一个状态对应（这里的状态指的是上述的状态转换图的圈圈图）</p>
<p>所有的微程序只存出在制度存储器中，称为控制存储器，Control Storage 简称控存CS。</p>
<hr />
<h4 id="执行指令-2"><a class="markdownIt-Anchor" href="#执行指令-2"></a> 执行指令</h4>
<ul>
<li>从CS中取出微程序</li>
<li>执行微程序也就是执行其中的微指令</li>
<li>对微指令译码就是产生对应的微命令-控制信号</li>
<li>按照微命令来执行程序</li>
</ul>
<p>可以了解一下微程序控制器的基本结构：</p>
<p>其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>μ</mi></mrow><annotation encoding="application/x-tex">\mu</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">μ</span></span></span></span> 开头的代表<strong>微</strong></p>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250509110118838.png" alt="image-20250509110118838" /></p>
<h4 id="微指令的设计"><a class="markdownIt-Anchor" href="#微指令的设计"></a> 微指令的设计</h4>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250509113020592.png" alt="image-20250509113020592" /></p>
<blockquote>
<p>在这里我就想吐槽了： 也没有铺垫，也没说为什么要在这里将异常处理机制</p>
</blockquote>
<h3 id="异常处理机制"><a class="markdownIt-Anchor" href="#异常处理机制"></a> 异常处理机制</h3>
<h4 id="带异常处理机制的数据通路设计"><a class="markdownIt-Anchor" href="#带异常处理机制的数据通路设计"></a> 带异常处理机制的数据通路设计</h4>
<p>添加，两个寄存器EPC和Cause，前者存储断点，后者存储异常状态；</p>
<p>同样的，需要添加这两个寄存器的写使能信号，</p>
<ul>
<li>EPCWr：在保存断点的时候有效，存入断点的PC</li>
<li>CauseWr： 发现异常的的时候有效，将异常类型存入Cause寄存器</li>
</ul>
<p>示意图：</p>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250509114300857.png" alt="image-20250509114300857" /></p>
<p>重点关注其中有关Casue和EPC的部分，是在原先的数据通路下添加的。</p>
<h4 id="带异常处理机制的控制器设计"><a class="markdownIt-Anchor" href="#带异常处理机制的控制器设计"></a> 带异常处理机制的控制器设计</h4>
<p>前面数据通路使用到的新的寄存器写使能端信号需要由控制器生成，并且需要设计两个异常状态。</p>
<p>加入异常和中断事件后的状态转换图：</p>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250509114755501.png" alt="image-20250509114755501" /></p>
<h3 id="多周期和时钟周期的cpu比较"><a class="markdownIt-Anchor" href="#多周期和时钟周期的cpu比较"></a> 多周期和时钟周期的CPU比较</h3>
<p><strong>多周期的时钟周期是所有阶段的最长值</strong> (就是上面的那个图中所有最长的周期！)</p>
<p>单周期的时钟周期是所有指令中的最大值。（一般是lord指令）</p>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250509114657162.png" alt="image-20250509114657162" /></p>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250509114650257.png" alt="image-20250509114650257" /></p>
<hr />
<h2 id="流水线cpu的设计"><a class="markdownIt-Anchor" href="#流水线cpu的设计"></a> 流水线CPU的设计</h2>
<p>前面提到，多周期CPU并不能很明显地提升性能，下面介绍流水线CPU。</p>
<h3 id="核心思想"><a class="markdownIt-Anchor" href="#核心思想"></a> 核心思想</h3>
<p>流水线CPU的核心思想是，将指令分成不同的阶段，在前一个指令的某一个阶段完成之后，紧接着开始执行下一个指令的这一个阶段。如图，以load指令为例。</p>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250509115710725.png" alt="image-20250509115710725" /></p>
<blockquote>
<p>必须保证不同阶段不会冲突，即不会用到相同的部件，比如在夏木木寄存器堆的读和写是分开的，可以看成两个独立的部件</p>
<p>结构冒险：同一个时钟周期内，多个指令都使用了同一个部件。</p>
</blockquote>
<blockquote>
<p>流水线每一个阶段的时间是相同的（都是所有阶段的最大值），应该很好理解，因为是并行执行不同指令的不同阶段，所以必须满足最大的时间要求。</p>
</blockquote>
<h3 id="与其他cpu比较"><a class="markdownIt-Anchor" href="#与其他cpu比较"></a> 与其他CPU比较</h3>
<p>性能比较：</p>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250509115926577.png" alt="image-20250509115926577" /></p>
<p><strong>流水线能够大大提高指令的吞吐率</strong>(单位时间内执行的指令条数)</p>
<blockquote>
<p>在理想状态下（忽略流水线启动的初始4个周期），流水线一直都是五个部件，每一个周期都有指令执行完成，也有指令开始执行；</p>
<p>因此流水线CPU的理想下的CPI为1，虽然每一条指令都需要5个周期，但是同时可以执行5个指令，因此CPI为1。</p>
<p>回顾： 1. 单周期CPU的CPI为1，以最长的指令load来取周期宽度。  2. 流水线的CPU的CPI为1，周期宽度为5个阶段最长的那个（实际执行的时候每一个阶段都会占用一个周期的时间） 3.多周期的CPI需要知道不同指令的比例，jump指令占用3个周期，其他的指令占用四个周期，需要知道比例进行计算。多周期的时钟周期宽度为最长的那个。</p>
</blockquote>
<h3 id="指令执行分析"><a class="markdownIt-Anchor" href="#指令执行分析"></a> 指令执行分析</h3>
<p>流水线CPU将指令分成以下五个阶段：</p>
<p>Ifetch,Reg/Dec (取数和译码),Exec(执行), Mem（读存储器）, Wr（写寄存器）</p>
<p>先以load指令为例：</p>
<blockquote>
<p>load rs1 rs2 imm12 RTL功能为 R[rs1]&lt;-M[R[rs2]+STEX(imm12)]</p>
</blockquote>
<ul>
<li>Ifetch： 取指令、计算PC+4，需要用到指令存储器、Adder</li>
<li>Reg/Dec : 取数并且译码，需要用到寄存器、指令译码器</li>
<li>Exec：执行，ALU、扩展器</li>
<li>Mem： 数据存储器</li>
<li>Wr： 写使能端</li>
</ul>
<blockquote>
<p>流水线CPU设计使得每一条指令的执行的时候占用的资源都是不一样的。</p>
<p>同一个功能部件</p>
<p>同时被多条指令使用的现象叫做<strong>结构冒险</strong></p>
<p>为了流水线能够正常地工作，我们规定：</p>
<ul>
<li>每一个功能部件在一条指令中 只能使用一次</li>
<li>每一个部件使用的时候必须在同一个阶段</li>
</ul>
<p>我们需要设计每一种类型的指令，使得所有的指令都能符合这个规定</p>
</blockquote>
<hr />
<h4 id="r-type"><a class="markdownIt-Anchor" href="#r-type"></a> R-Type</h4>
<p>R型指令因为不需要进行</p>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250516105219861.png" alt="image-20250516105219861" /></p>
<p>Ifetch: 取指令</p>
<p>Reg/Dec：取操作数rs1 rs2，指令译码</p>
<p>Exec：进行运算，使用ALu</p>
<p>Wr：将结果写入目的寄存器</p>
<hr />
<h4 id="store"><a class="markdownIt-Anchor" href="#store"></a> Store</h4>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250516110435256.png" alt="image-20250516110435256" /></p>
<p>Ifetch：取指令并计算PC+4 （写入PC）</p>
<p>Reg/Dec： 从寄存器（rs1）取数，同时指令在译码器进行译码</p>
<p>Exec：12位立即数（imm12）符号扩展后与寄存器值（ rs1 ）相加，计算主存地址Mem：将寄存器（rs2）读出的数据写到主存</p>
<hr />
<h4 id="i-type"><a class="markdownIt-Anchor" href="#i-type"></a> I-Type</h4>
<hr />
<h4 id="beq"><a class="markdownIt-Anchor" href="#beq"></a> Beq</h4>
<p>与其他指令不同的区别是，Beq中间的Exec阶段需要用到ALU和adder，因此必须单独加上一个adder，防止和其他指令冲突</p>
<blockquote>
<p>每一个功能部件只能在同一阶段使用、每一个周期只能用一次。即上述的adder只能在第三周期使用。</p>
</blockquote>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250516105727514.png" alt="image-20250516105727514" /></p>
<p>Ifetch: 取指令并计算PC+4 （写入PC，但后续可能需要修改PC）</p>
<p>Reg/Dec:从寄存器（rs1，rs2）取数，同时指令在译码器进行译码</p>
<p>Exec:  执行阶段ALU中比较两个寄存器（rs1，rs2）的大小（做减法）Adder中计算转移地址（PC+SEXT（imm12）&lt;&lt;1）</p>
<p>Mem: 如果比较相等, 则：转移目标地址写到PC</p>
<blockquote>
<p>这里转移目标地址的方法可以参考单周期的相关指令，通过控制信号生成下一个PC地址</p>
</blockquote>
<h4 id="j-type"><a class="markdownIt-Anchor" href="#j-type"></a> J-Type</h4>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250516110036021.png" alt="image-20250516110036021" /></p>
<p><code>Ifetch</code>: 取指令并计算PC+4 （写入PC ，但后续肯定需要修改PC ）</p>
<p><code>Reg/Dec:</code>从寄存器取数，同时指令在译码器进行译码</p>
<p><code>Exec</code>:  执行阶段ALU中计算PC+4（准备写入rd）Adder中计算转移地址（PC+SEXT（imm20）&lt;&lt;1）</p>
<p><code>Mem</code>:把转移地址写入PC</p>
<blockquote>
<p>PC可以修改多次，因为更新PC的时候前一个PC已经没有用了，不会出现冲突。</p>
</blockquote>
<p><code>Wr</code>: 把ALU运算结果（PC+4）写入rd.</p>
<hr />
<h3 id="数据通路设计"><a class="markdownIt-Anchor" href="#数据通路设计"></a> 数据通路设计</h3>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250516111552870.png" alt="image-20250516111552870" /></p>
<p>和单周期的区别在与中间的<code>流水段寄存器</code>，用于保存每一个周期的执行结果，属于内部寄存器，可以理解为，每一个寄存器里面存储的都是某一条指令的当前状态（寄存器和它右边的部分属于当前状态）。</p>
<blockquote>
<p>“The pipelined datapath consists of combination logic blocks separated by pipeline registers. If you get rid of all these registers (not the PC), this pipelined datapath is reduced to the single-cycle datapath.”</p>
</blockquote>
<blockquote>
<p>ppt中还提到了其他的一个细节：下一个clock tick来临之后需要一个clock-to-Q才能进行下一阶段（或者说写入下一个阶段）</p>
</blockquote>
<h4 id="iunit设计"><a class="markdownIt-Anchor" href="#iunit设计"></a> IUnit设计</h4>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250516114408758.png" alt="image-20250516114408758" /></p>
<p>在IF/ID寄存器中存储有PC和指令</p>
<p>IF段的功能PC+4、取指令</p>
<h4 id="regdec"><a class="markdownIt-Anchor" href="#regdec"></a> Reg/Dec</h4>
<p>在ID/EX寄存器中，存储<code>R[Rs1], R[Rs2], Rd, Imm, PC</code></p>
<h4 id="exec-unit的设计"><a class="markdownIt-Anchor" href="#exec-unit的设计"></a> Exec Unit的设计</h4>
<blockquote>
<p>详细内容请见ppt，不同的指令需要的信号来自不同的地方</p>
<p>可以留心的是，这里使用了Adder和ALu，进行并行计算，因为前面有一个步骤在这里需要同时进行两个计算（如果都用ALU算的话，显然会冲突）。</p>
</blockquote>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250516115523660.png" alt="image-20250516115523660" /></p>
<p>在EX/M寄存器中存储了，跳转地址、Zero、ALU运算结果、busB、rd</p>
<hr />
<h4 id="m段"><a class="markdownIt-Anchor" href="#m段"></a> M段</h4>
<blockquote>
<p>没来得及做笔记，下同</p>
</blockquote>
<h4 id="wb写回段"><a class="markdownIt-Anchor" href="#wb写回段"></a> WB写回段</h4>
<blockquote>
<ol>
<li>M段有PC写回的操作，出现数据回流，可能出现结构冒险</li>
<li>WB段可能有写入寄存器的操作，也可能会出现结构冒险的问题</li>
</ol>
</blockquote>
<hr />
<h4 id="流水线中的control-signals"><a class="markdownIt-Anchor" href="#流水线中的control-signals"></a> 流水线中的Control Signals</h4>
<ol>
<li>PC不需要写使能</li>
<li>流水段寄存器不需要写使能信号</li>
</ol>
<p>在流水线中的控制信号：</p>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250523104536906.png" alt="image-20250523104536906" /></p>
<ol>
<li>每一个时钟周期到来，五个流水段寄存器都会进行更新，所有的控制信号在ID阶段<strong>一次性生成</strong>，main control的设计和单周期的控制器设计原理一模一样。</li>
<li>任何一条指令在执行的过程中，其信号是不变的（在ID阶段一次性生成，之后不需要的信号不再保存）</li>
</ol>
<h4 id="流水线举例"><a class="markdownIt-Anchor" href="#流水线举例"></a> 流水线举例</h4>
<p>最开始的时候，将流水段寄存器都初始化为0，保证了不会出现错误的写入等等。</p>
<p>以下面的这个流水线为例</p>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250523105300126.png" alt="image-20250523105300126" /></p>
<p>分析指令的运行结果：</p>
<ol>
<li>第一周期</li>
<li>第二周期</li>
<li>第三周期</li>
<li>第四周期</li>
<li>第五周期</li>
<li>第六周期</li>
<li>第七周期</li>
</ol>
<p>注意：</p>
<ol>
<li>只有在B、J型指令在M阶段的时候才会将新的PC更新为Target，此后下一个周期新出现的指令就是target对应的指令。也就是和target指令之间间隔了3个指令。（取错了3个指令，称之为<code>控制冒险</code>）</li>
<li>load指令尽管在第一周期就被取出，但是数据在第五周期才写入，在第六周期才能使用，期间可能会错误访问这个数据得到的不是目的结果，称为<code>数据冒险</code></li>
</ol>
<h4 id="单周期vs流水线计算机的性能比较"><a class="markdownIt-Anchor" href="#单周期vs流水线计算机的性能比较"></a> 单周期vs流水线计算机的性能比较</h4>
<p><strong>流水线除了要考虑每一个阶段的最多时间，但是还要考虑流水段寄存器的延迟，具体看是不是</strong></p>
<h3 id="流水线的冒险和处理"><a class="markdownIt-Anchor" href="#流水线的冒险和处理"></a> 流水线的冒险和处理</h3>
<blockquote>
<p>这里是本书最后一个知识点，最后一个高级CPU不会涉及</p>
</blockquote>
<p>hazard：流水线无法正确执行后续指令，或者执行了不该执行的指令。</p>
<p>冒险有：</p>
<ol>
<li>结构冒险：同一部件在同时被多个指令所使用</li>
<li>数据冒险：后面的指令使用用到了前面还没有生成的数据</li>
<li>控制冒险：在跳转或者处理异常的步骤中，后续指令仍然被错误地取出</li>
</ol>
<h4 id="结构冒险的解决"><a class="markdownIt-Anchor" href="#结构冒险的解决"></a> 结构冒险的解决</h4>
<p><strong>确保每一个指令只会在特定的阶段被使用</strong></p>
<h4 id="数据冒险的解决"><a class="markdownIt-Anchor" href="#数据冒险的解决"></a> 数据冒险的解决</h4>
<p>给定下面的一串指令序列</p>
<img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250523113752599.png" alt="image-20250523113752599" style="zoom:25%;" />
<p>由于add指令需要在第五个周期才能写入新的数据，此时xor指令在IF阶段，到了第六周期的时候，xor指令处于ID阶段，从寄存器堆中取数计算。</p>
<hr />
<h5 id="解决方法一硬件阻塞stall"><a class="markdownIt-Anchor" href="#解决方法一硬件阻塞stall"></a> 解决方法一：硬件阻塞stall</h5>
<p>硬件上强制要求阻塞，效率低下</p>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250523114516205.png" alt="image-20250523114516205" /></p>
<h5 id="解决方法二软件上插入无关指令"><a class="markdownIt-Anchor" href="#解决方法二软件上插入无关指令"></a> 解决方法二：软件上插入无关指令</h5>
<p>在编译器中插入空指令NOP，在会出现数据冲突的时候插入空指令。编译时间增加，速度也不是很快。</p>
<h5 id="解决方案三同一周期内寄存器先写后读"><a class="markdownIt-Anchor" href="#解决方案三同一周期内寄存器先写后读"></a> 解决方案三：同一周期内寄存器先写后读</h5>
<blockquote>
<p>“合理优化寄存器的读写操作”前半周期写、后半周期读，但是不能用解决所有的数据冒险，只能解决需要写入和读取的情况（貌似是，请看ppt进行回顾）。只有上面两个解决方法才能解决全部的数据冒险问题。</p>
</blockquote>
<p>方案三需要和1或者2合作，改为阻塞两个周期，因为要求先写后读，这样使得ID段指令读到的值是当前M段指令写入的值。</p>
<h5 id="解决方案四转发"><a class="markdownIt-Anchor" href="#解决方案四转发"></a> 解决方案四：转发</h5>
<p>将ALU的A，B端增加mux，允许从其他的流水段寄存器（第五阶段<code>WB</code>在写的时候已经有数据了，可以将这个数据送到前面去）进行读取数据，进行运算。</p>
<p>ppt中介绍了三种转发的情况。（这几种情况都是在Exec/M寄存器存储</p>
<blockquote>
<p>**无法转发的情况（load-use）：**在书上还提到了<code>load-use</code>这一个特殊的情况，也就是前一个指令是load、下一个指令需要用到load的数据的话，无法通过转发进行解决： load在<code>M</code>段之后才能得到数据，而下一个指令在load执行<code>M</code>段的时候正在执行<code>Exec</code>，需要用到数据，冲突无法解决。</p>
<p>不过需要注意：使用了寄存器前半后半分开+数据转发可以分别解决load指令之后第三个指令和第二个指令的毛线问题；load-use冲突指的是，load和接下来的紧接着的指令一定会冲突（即使使用了<code>数据转发</code>和寄存器前<code>半后先写</code>后读优化）</p>
</blockquote>
<p><strong>解决Load use</strong>问题:</p>
<ol>
<li>
<p>检测什么时候需要阻塞</p>
<img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250530103937038.png" alt="image-20250530103937038" style="zoom:33%;" />
<p>也就是说：在第三周期执行的过程中，检查是否前一个指令为load，并且load的Rd为下一个指令的Rs1或Rs2</p>
<blockquote>
<p>检测是否需要阻塞的原理和检测是否需要转发类似</p>
</blockquote>
</li>
<li>
<p>修改数据通路来实现阻塞</p>
<ul>
<li>流水段寄存器加上写使能信号，当需要延迟一个周期的时候，控制相关流水段寄存器不变</li>
</ul>
</li>
<li>
<p>通过编译优化，避免出现load-use的情况</p>
<p>参考这里的例题：</p>
<blockquote>
  <img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250530105205351.png" alt="image-20250530105205351" style="zoom:50%;" />
<p>左侧的Slow code的前提是硬件做了专门的修改，实现阻塞才能这样做；否则必须在编译的源程序就要加上NOP指令（替换硬件的阻塞）</p>
<p>右侧的指令是进行优化之后的结果。</p>
</blockquote>
</li>
</ol>
<p><strong>总结：</strong></p>
<ol>
<li>修改硬件和插入nop指令可以彻底解决问题，但是通常配合其他的方法</li>
<li>同一周期寄存器先读后写可以使得只需要在两条数据冲突的指令插入两个nop指令</li>
<li>使用数据转发可以解决除<code>load-use</code>之外的数据冲突问题，load-use的冲突解决，可以通过编译器调整指令的顺序、插入nop指令来解决</li>
</ol>
<h4 id="控制冒险的解决"><a class="markdownIt-Anchor" href="#控制冒险的解决"></a> 控制冒险的解决</h4>
<p>延迟损失时间片C：发生转移的时候，给流水线带来的损失（CPU错取的指令数）</p>
<h5 id="解决方法一-硬件阻塞"><a class="markdownIt-Anchor" href="#解决方法一-硬件阻塞"></a> 解决方法一： 硬件阻塞</h5>
<p>修改数据通路，强制阻塞三个周期。延迟损失时间片C=3；</p>
<h5 id="解决方法二nop指令"><a class="markdownIt-Anchor" href="#解决方法二nop指令"></a> 解决方法二：NOP指令</h5>
<p>由编译器插入三条NOP指令，无需修改数据通路；延迟损失时间片C=3；</p>
<h5 id="解决方法三分支预测"><a class="markdownIt-Anchor" href="#解决方法三分支预测"></a> 解决方法三：分支预测</h5>
<p>分支预测成功，那么branch指令只需要一个周期；否则branch指令需要<code>1+分支延迟槽</code>个周期；</p>
<p>Jump指令不能预测，需要两个周期。<strong>总要等到译码阶段结束才能得到转移地址</strong></p>
<ol>
<li>
<p>静态检测</p>
<blockquote>
<p>总预测条件不满足(not taken)，即：不跳转<br />
可加启发式规则：<br />
在特定情况下总是预测满足(taken)，其他情况总是预测不满足<br />
如：循环顶部（底部）分支总是预测为不满足（满足）。能达65%-85%的预测准确率<br />
<strong>预测失败时，需把流水线中三条错误预测指令（C=3）丢弃掉</strong><br />
将被丢弃指令的控制信号值或指令设置为0<br />
（注：涉及到当时在IF、ID和EX三个阶段的指令）</p>
</blockquote>
</li>
<li>
<p>动态检测</p>
<p>原理比较复杂，我不是很理解为什么可以预测？</p>
<p>一位预测图：</p>
<ul>
<li>如果是1，那么预测发生（跳转）；否则预测不发生（跳转）</li>
<li>如果预测正确，那么不变；如果预测错误，那么改变</li>
<li>其实就是：如果上一次跳转了，那么我这一次也要预测跳转；如果预测错误，那么修改预测图。（也就是说，在一个很长的loop，只有第一次和最后一次跳转回预测错误；到那时如果是双重loop，第一次外循环的时候只有一次预测错误、之后每一次外循环都回产生两次预测错误）</li>
</ul>
<p>两位预测图：</p>
<ul>
<li>用一个状态图来表示：</li>
<li>
<img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250530114024656.png" alt="image-20250530114024656" style="zoom:33%;" />
</li>
</ul>
</li>
</ol>
<h5 id="解决方法四延迟分支"><a class="markdownIt-Anchor" href="#解决方法四延迟分支"></a> 解决方法四：延迟分支</h5>
<p>注意：C值是可以改变的：</p>
<p>越早判断是否需要转移，付出的代价越低。将跳转判断的逻辑往前移，就能降低相关的C值</p>
<p>详细见ppt</p>
<p><strong>填充C</strong>： 将分支指令前面和分支指令无关的指令转移到跳转指令之后的指令执行（如果不够的话，用nop指令填充）</p>
<blockquote>
<p>前面多次提到了用nop填充，比如处理load-use的数据冒险的时候， 可能会出现</p>
</blockquote>
<blockquote>
<p>Jump和Branch指令不涉及到寄存器堆的操作，因此寄存器先读后写对其没有影响</p>
</blockquote>
<p><strong>至少要学会看是否出现冒险</strong></p>
<p>比如：在左侧，如果时间片为3的话，lw x3 0(x2)和add x3 x3 x2出现了数据冒险，但是如果时间片为2（比如实现了寄存器的先读后写功能的话）</p>
<p><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250530114645722.png" alt="image-20250530114645722" /></p>
<blockquote>
<p>注意：这里十分的细节！！在这里beq本来是 跳转4*2=8，也就是2个指令，但是在调度之后，beq后面加上了两个指令，因此需要将原先的4改成8，这样的话，额外增加了4 *2=8位，即2条指令</p>
</blockquote>
<h5 id="异常-中断导致的控制冒险"><a class="markdownIt-Anchor" href="#异常-中断导致的控制冒险"></a> 异常、中断导致的控制冒险</h5>
<p>只需要知道，内部异常和外部中断会引起控制冒险即可</p>
<h3 id="比较单周期-多周期-流水线cpu"><a class="markdownIt-Anchor" href="#比较单周期-多周期-流水线cpu"></a> 比较单周期、多周期、流水线CPU</h3>
<blockquote>
<p>感觉这个题目很重要，一定要学会！！！</p>
</blockquote>
<p>采用转发处理数据冒险-&gt;需要</p>
<p>跳转需要的</p>
<p>注意：</p>
<p>流水线的CPU在非理想条件下（数据冒险、控制冒险等）的指令CPI不是都等于1！！！</p>
<p>JUMP不能预测！！！</p>
<p>Branch可以预测！！预测成功则1个时钟，否则2个时钟</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://yama-lei.top">Yama-lei</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://yama-lei.top/posts/ae827a2f0766/">https://yama-lei.top/posts/ae827a2f0766/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://yama-lei.top" target="_blank">YamaBlog</a>！</span></div></div><div class="tag_share"><div class="post-share"><div class="social-share" data-image="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/yama.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/posts/298d0f5f96cc/" title="《孙吧老哥爱上小红书仙女》"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">《孙吧老哥爱上小红书仙女》</div></div><div class="info-2"><div class="info-item-1">作者：知乎用户NAh5fc 链接：https://www.zhihu.com/question/53943602/answer/3499174416 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 《孙吧老哥爱上小红书仙女》 1V1，高甜，双向奔赴（感谢1.6万赞！4.8已更新两章）   一.相遇 这是孙啸川第一次看见季莓。 他脑子里面嘭嘭的，心好像随着融化了的脑浆热热腾腾地往下冲，到了底又涌上小头，“轰”的一下，眼花耳热，头昏脑涨。 于是他连夜敲响了村里虎屠户的门，约定了三后送肉上门。正宗大肥猪肉，三百斤。  二.孙坝 孙啸川住在的孙坝村以前有一条姬家人修的大坝，坝上刻满了春秋战国的大家浮雕。后来上游的红薯村在一个雨夜开了闸，一时间洪水滔滔，孔子被冲毁了，庄子被卷走了，老子没了，姬坝没了，只剩下了孙子。 从此姬坝改名孙坝。  三.觉醒 多年以后，面对红薯村，季莓将会回想起，自己从产道滑出来后宣布与生理父母划清界限的那个下午。 那些长久以来无故承担这两个庸俗称谓带来压力的陌生男性女性围着沾满血污的产床，热泪盈眶，为季莓鼓起代表觉醒的掌声。 不过季...</div></div></div></a><a class="pagination-related" href="/posts/bbb2a202562a/" title="Chapter7 | 指令系统"><div class="cover" style="background: var(--default-bg-color)"></div><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">Chapter7 | 指令系统</div></div><div class="info-2"><div class="info-item-1"> 概述与指令系统设计 指令的执行过程  一条指令必须明显或隐含包含的信息：   操作码：指定操作类型 (操作码长度：固定／可变)   源操作数参照：一个或多个源操作数所在的地址 （源操作数或其地址，由取址方式决定） (操作数来源：主(虚)存/寄存器/I/O端口/指令本身）   结果值参照：产生的结果存放何处（目的操作数） (结果地址：主(虚)存/寄存器/I/O端口)   下一条指令地址：下条指令存放何处 (下条指令地址：主(虚)存) (正常情况隐含在PC中，改变顺序时由指令给出）(PC会自动改变)    ISA的要素：指令集 指令的要素：操作码，地址码 CPU执行指令的步骤：读取指令、译码、取操作数、运算、存数、读取下一条指令。  操作码和译码、运算有关   指令按照地址码的字段个数可以分为0地址操作码，1地址操作码，等等。RISC-V的风格是三地址指令。OP A1 A2 A3.  指令设计的要求：  一个编码对应唯一的操作码 长度是字节的整数倍    操作数类型和存储方式：   操作数类型：  地址 数值数据 位串等 布尔数据    操作数可以存放在：1. 寄存器 2. 内存单...</div></div></div></a></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/yama.webp" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">Yama-lei</div><div class="author-info-description">记录一个NJUCSer的学习</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">105</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">9</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">21</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/yama-lei"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/yama-lei" target="_blank" title="Github"><i class="fab fa-github" style="color: #24292e;"></i></a><a class="social-icon" href="mailto:your@email.com" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #4a7dbe;"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss" style="color: #FFA500;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">博客正在建设中...能看就行...😋😋😋</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#cpu%E6%A6%82%E8%BF%B0"><span class="toc-number">1.</span> <span class="toc-text"> CPU概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E4%BA%94%E5%A4%A7%E7%BB%84%E6%88%90%E9%83%A8%E4%BB%B6"><span class="toc-number">1.1.</span> <span class="toc-text"> 计算机的五大组成部件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AFdatapath%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">1.1.1.</span> <span class="toc-text"> 数据通路Datapath的基本结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E5%92%8C%E6%97%B6%E5%BA%8F%E6%8E%A7%E5%88%B6"><span class="toc-number">1.1.2.</span> <span class="toc-text"> 数据通路和时序控制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%80%A7%E8%83%BD"><span class="toc-number">1.2.</span> <span class="toc-text"> 计算机性能</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E5%91%A8%E6%9C%9F%E7%9A%84cpu%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.</span> <span class="toc-text"> 单周期的CPU设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E6%B5%81%E6%B0%B4%E7%BA%BFcpu%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.1.</span> <span class="toc-text"> 单流水线CPU的设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AB%8B%E5%8D%B3%E6%95%B0%E6%89%A9%E5%B1%95%E5%99%A8"><span class="toc-number">2.1.1.</span> <span class="toc-text"> 立即数扩展器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#alu-%E7%AE%97%E6%95%B0%E9%80%BB%E8%BE%91%E9%83%A8%E4%BB%B6%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.1.2.</span> <span class="toc-text"> ALU 算数逻辑部件的设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%96%E6%8C%87%E4%BB%A4%E9%83%A8%E4%BB%B6-instruction-fetch-unit"><span class="toc-number">2.1.3.</span> <span class="toc-text"> 取指令部件 Instruction Fetch Unit</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#r%E5%9E%8B%E6%8C%87%E4%BB%A4%E7%9A%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF"><span class="toc-number">2.1.4.</span> <span class="toc-text"> R型指令的数据通路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#i%E5%9E%8B%E6%8C%87%E4%BB%A4%E7%9A%84%E5%9E%8B%E5%8F%B7%E9%80%9A%E8%B7%AFori"><span class="toc-number">2.1.5.</span> <span class="toc-text"> I型指令的型号通路（ori)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#u%E5%9E%8B%E6%8C%87%E4%BB%A4%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%80%9A%E8%B7%AF"><span class="toc-number">2.1.6.</span> <span class="toc-text"> U型指令的信号通路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#loadstore%E6%8C%87%E4%BB%A4%E7%9A%84%E4%BF%A1%E5%8F%B7%E9%80%9A%E8%B7%AF"><span class="toc-number">2.1.7.</span> <span class="toc-text"> Load&amp;Store指令的信号通路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#b%E5%9E%8B%E6%8C%87%E4%BB%A4%E7%9A%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF"><span class="toc-number">2.1.8.</span> <span class="toc-text"> B型指令的数据通路</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#j%E5%9E%8B%E6%8C%87%E4%BB%A4"><span class="toc-number">2.1.9.</span> <span class="toc-text"> J型指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.2.</span> <span class="toc-text"> 控制器的设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%8F%96%E5%80%BC%E5%88%86%E6%9E%90"><span class="toc-number">2.2.1.</span> <span class="toc-text"> 控制信号的取值分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%92%9F%E5%91%A8%E6%9C%9F%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.2.2.</span> <span class="toc-text"> 时钟周期的设计</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E5%91%A8%E6%9C%9Fcpu%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.</span> <span class="toc-text"> 多周期CPU设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">3.1.</span> <span class="toc-text"> 指令执行的过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%96%E6%8C%87%E4%BB%A4%E5%B9%B6%E8%AE%A1%E7%AE%97%E4%B8%8B%E6%9D%A1%E6%8C%87%E4%BB%A4%E5%9C%B0%E5%9D%80"><span class="toc-number">3.1.1.</span> <span class="toc-text"> 取指令并计算下条指令地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%91%E7%A0%81%E5%B9%B6%E5%8F%96%E6%95%B0"><span class="toc-number">3.1.2.</span> <span class="toc-text"> 译码并取数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%8C%87%E4%BB%A4"><span class="toc-number">3.1.3.</span> <span class="toc-text"> 执行指令</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#pla%E6%8E%A7%E5%88%B6%E5%99%A8%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.2.</span> <span class="toc-text"> PLA控制器的设计</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E7%A8%8B%E5%BA%8F%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.3.</span> <span class="toc-text"> 微程序控制器设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%8C%87%E4%BB%A4-2"><span class="toc-number">3.3.1.</span> <span class="toc-text"> 执行指令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AE%E6%8C%87%E4%BB%A4%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.3.2.</span> <span class="toc-text"> 微指令的设计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">3.4.</span> <span class="toc-text"> 异常处理机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E7%9A%84%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.4.1.</span> <span class="toc-text"> 带异常处理机制的数据通路设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6%E7%9A%84%E6%8E%A7%E5%88%B6%E5%99%A8%E8%AE%BE%E8%AE%A1"><span class="toc-number">3.4.2.</span> <span class="toc-text"> 带异常处理机制的控制器设计</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%91%A8%E6%9C%9F%E5%92%8C%E6%97%B6%E9%92%9F%E5%91%A8%E6%9C%9F%E7%9A%84cpu%E6%AF%94%E8%BE%83"><span class="toc-number">3.5.</span> <span class="toc-text"> 多周期和时钟周期的CPU比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BFcpu%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.</span> <span class="toc-text"> 流水线CPU的设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B8%E5%BF%83%E6%80%9D%E6%83%B3"><span class="toc-number">4.1.</span> <span class="toc-text"> 核心思想</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%8E%E5%85%B6%E4%BB%96cpu%E6%AF%94%E8%BE%83"><span class="toc-number">4.2.</span> <span class="toc-text"> 与其他CPU比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%88%86%E6%9E%90"><span class="toc-number">4.3.</span> <span class="toc-text"> 指令执行分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#r-type"><span class="toc-number">4.3.1.</span> <span class="toc-text"> R-Type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#store"><span class="toc-number">4.3.2.</span> <span class="toc-text"> Store</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#i-type"><span class="toc-number">4.3.3.</span> <span class="toc-text"> I-Type</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#beq"><span class="toc-number">4.3.4.</span> <span class="toc-text"> Beq</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#j-type"><span class="toc-number">4.3.5.</span> <span class="toc-text"> J-Type</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%80%9A%E8%B7%AF%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.4.</span> <span class="toc-text"> 数据通路设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#iunit%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.4.1.</span> <span class="toc-text"> IUnit设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#regdec"><span class="toc-number">4.4.2.</span> <span class="toc-text"> Reg&#x2F;Dec</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exec-unit%E7%9A%84%E8%AE%BE%E8%AE%A1"><span class="toc-number">4.4.3.</span> <span class="toc-text"> Exec Unit的设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#m%E6%AE%B5"><span class="toc-number">4.4.4.</span> <span class="toc-text"> M段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#wb%E5%86%99%E5%9B%9E%E6%AE%B5"><span class="toc-number">4.4.5.</span> <span class="toc-text"> WB写回段</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%B8%AD%E7%9A%84control-signals"><span class="toc-number">4.4.6.</span> <span class="toc-text"> 流水线中的Control Signals</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%B8%BE%E4%BE%8B"><span class="toc-number">4.4.7.</span> <span class="toc-text"> 流水线举例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E5%91%A8%E6%9C%9Fvs%E6%B5%81%E6%B0%B4%E7%BA%BF%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%9A%84%E6%80%A7%E8%83%BD%E6%AF%94%E8%BE%83"><span class="toc-number">4.4.8.</span> <span class="toc-text"> 单周期vs流水线计算机的性能比较</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84%E5%86%92%E9%99%A9%E5%92%8C%E5%A4%84%E7%90%86"><span class="toc-number">4.5.</span> <span class="toc-text"> 流水线的冒险和处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E5%86%92%E9%99%A9%E7%9A%84%E8%A7%A3%E5%86%B3"><span class="toc-number">4.5.1.</span> <span class="toc-text"> 结构冒险的解决</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%86%92%E9%99%A9%E7%9A%84%E8%A7%A3%E5%86%B3"><span class="toc-number">4.5.2.</span> <span class="toc-text"> 数据冒险的解决</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E4%B8%80%E7%A1%AC%E4%BB%B6%E9%98%BB%E5%A1%9Estall"><span class="toc-number">4.5.2.1.</span> <span class="toc-text"> 解决方法一：硬件阻塞stall</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E4%BA%8C%E8%BD%AF%E4%BB%B6%E4%B8%8A%E6%8F%92%E5%85%A5%E6%97%A0%E5%85%B3%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.2.2.</span> <span class="toc-text"> 解决方法二：软件上插入无关指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E4%B8%89%E5%90%8C%E4%B8%80%E5%91%A8%E6%9C%9F%E5%86%85%E5%AF%84%E5%AD%98%E5%99%A8%E5%85%88%E5%86%99%E5%90%8E%E8%AF%BB"><span class="toc-number">4.5.2.3.</span> <span class="toc-text"> 解决方案三：同一周期内寄存器先写后读</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E5%9B%9B%E8%BD%AC%E5%8F%91"><span class="toc-number">4.5.2.4.</span> <span class="toc-text"> 解决方案四：转发</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A7%E5%88%B6%E5%86%92%E9%99%A9%E7%9A%84%E8%A7%A3%E5%86%B3"><span class="toc-number">4.5.3.</span> <span class="toc-text"> 控制冒险的解决</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E4%B8%80-%E7%A1%AC%E4%BB%B6%E9%98%BB%E5%A1%9E"><span class="toc-number">4.5.3.1.</span> <span class="toc-text"> 解决方法一： 硬件阻塞</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E4%BA%8Cnop%E6%8C%87%E4%BB%A4"><span class="toc-number">4.5.3.2.</span> <span class="toc-text"> 解决方法二：NOP指令</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E4%B8%89%E5%88%86%E6%94%AF%E9%A2%84%E6%B5%8B"><span class="toc-number">4.5.3.3.</span> <span class="toc-text"> 解决方法三：分支预测</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%E5%9B%9B%E5%BB%B6%E8%BF%9F%E5%88%86%E6%94%AF"><span class="toc-number">4.5.3.4.</span> <span class="toc-text"> 解决方法四：延迟分支</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8-%E4%B8%AD%E6%96%AD%E5%AF%BC%E8%87%B4%E7%9A%84%E6%8E%A7%E5%88%B6%E5%86%92%E9%99%A9"><span class="toc-number">4.5.3.5.</span> <span class="toc-text"> 异常、中断导致的控制冒险</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AF%94%E8%BE%83%E5%8D%95%E5%91%A8%E6%9C%9F-%E5%A4%9A%E5%91%A8%E6%9C%9F-%E6%B5%81%E6%B0%B4%E7%BA%BFcpu"><span class="toc-number">4.6.</span> <span class="toc-text"> 比较单周期、多周期、流水线CPU</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/66b650927646/" title="多维数组">多维数组</a><time datetime="2025-09-30T16:00:00.000Z" title="发表于 2025-10-01 00:00:00">2025-10-01</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/66c438509deb/" title="多模态综述">多模态综述</a><time datetime="2025-09-30T13:14:40.000Z" title="发表于 2025-09-30 21:14:40">2025-09-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/54b78cdb42c3/" title="无标题">无标题</a><time datetime="2025-09-30T01:58:28.349Z" title="发表于 2025-09-30 09:58:28">2025-09-30</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/posts/0ac3e125560f/" title="Riscv介绍">Riscv介绍</a><time datetime="2025-09-29T16:00:00.000Z" title="发表于 2025-09-30 00:00:00">2025-09-30</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div id="ft"><div class="ft-item-1"><div class="t-top"><div class="t-t-l"><p class="ft-t t-l-t">格言🧬</p><div class="bg-ad"><div>记录一个NJUCSer的学习历程 · 代码改变世界，技术创造未来</div><div class="btn-xz-box"><a class="btn-xz" href="/about/">了解更多</a></div></div></div></div></div><div class="ft-item-2"><p class="ft-t">推荐友链⌛</p><div class="ft-img-group"><div class="img-group-item"><a href="/links/" title="广告位招租"><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/zhaozu.jpg" alt="广告位招租"/></a></div><div class="img-group-item"><a href="/links/" title="更多友联"><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/zhaozu.jpg" alt="友链"/></a></div></div></div></div><div class="copyright"><span><b>&copy;2025</b></span><span><b>&nbsp;&nbsp;By Yama-lei</b></span></div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Less is more · © YamaBlog</div><div id="workboard"></div><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" title="博客框架为Hexo"><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://img.shields.io/badge/Frame-Hexo-blue?style=flat-square" alt="Hexo"/></a><a class="github-badge" target="_blank" href="https://butterfly.js.org/" style="margin-inline:5px" title="主题版本Butterfly"><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://img.shields.io/badge/Theme-Butterfly-6513df?style=flat-square" alt="Butterfly"/></a><a class="github-badge" target="_blank" href="https://github.com/yama-lei" style="margin-inline:5px" title="源码托管于GitHub"><img src="/%E5%9B%BE%E7%89%87%E6%AD%A3%E5%9C%A8%E5%8A%A0%E8%BD%BD%E4%B8%AD..." data-lazy-src="https://img.shields.io/badge/Source-Github-d021d6?style=flat-square" alt="GitHub"/></a></p></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"></div><script src="/js/custom.js"></script><script src="/js/footer-enhance.js"></script><script src="/js/homepage-enhance.js"></script><script defer src="/js/runtime.js"></script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><i class="fas fa-spinner fa-pulse" id="loading-status" hidden="hidden"></i><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="text-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据加载中</span></div><div class="local-search-input"><input placeholder="搜索..." type="text"/></div><hr/><div id="local-search-results"></div><div class="ais-Pagination" id="local-search-pagination" style="display:none;"><ul class="ais-Pagination-list"></ul></div><div id="local-search-stats"></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div></body></html>