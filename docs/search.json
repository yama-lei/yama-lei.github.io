[{"title":"多维数组","url":"/posts/66b650927646/","content":"\n**二维数组**\n1. `typedef T a[m][n]` 等价于 `typedef T b[m]` + `typedef b a[n]`\n2. 如果 `int a[m][n];` 那么 `a[i][j]` 代表的位置是 `a + i * n + j`\n3. 递归计算位置：$Loc(i) = \\alpha$ if $i = 0$ else $Loc(i-1) + l$； $Loc(i,j)= Loc(i,0)+j=Loc(0,0)+i*m+j$\n**三维数组**\n 4. `int a[m][n][p]` 如果访问`a[i][j][k]`，访问的地址为`a+i*n*p+j*p+k`\n\n\n**对称矩阵**\n$$\n\tM=M^T\n$$\n对于对称矩阵来说，有`M[i][j]=M[j][i]`,因此我们只需要存储一个上三角矩阵或者一个下三角矩阵就能够把所有的有效元素访问到。\n只需要存储1+2+3+...+n=(1+n)n/2个元素，以下三角矩阵为例：\n```cpp\nclass Matrix{\nint n=0;\nint* arr;\npublic:\n\tMatrix(int n):n(n){\n\t\tarr=new int[n(n+1)/2];\n\t}\n\t~Matrix(){\n\t\tdelete[] arr;\n\t}\n\tint* Get(int i, int j){\n\t\tif(i<j){\n\t\t\treturn Get(j,i);\n\t\t}else{\n\t\t\tint pos=(i+1)*i/2+j;\n\t\t\treturn arr+pos;\n\t\t\t//The position (i,j) is (i+1)*i/2 +j when row is priority \n\t\t}\n\t}\t\n};\n```\n\n\n\n> 注：老师提到，有一次考试中采取了列优先的策略，相当比例的同学都出现了错误。行优先还是列优先只是i和j的顺序问题\n\n上面的例子是下三角矩阵，如果是上三角的矩阵，那么`a[i][j]=n+n-1+...+n-i+n-j`(自己推导一下，我这个写的可能不对)\n\n---\n\n**三对角矩阵**\n特点：只有当$|i-j|<=1$的时候才不为0，元素总数为$3n-2$个。\n\n![image.png](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/20250925103309.png)\n\n如果先按照行存储，再按照列存储，那么对于第aij，其在数组中的位置是：\n$k=(3i-1)+j-i+1=2i+j$ \n如果知道k（也就是在数组中的位置）如何求i和j呢（其在矩阵中的位置呢）？\n由于 $3i-1<=k=2i+j<=3i+1$\n所以有：\n**稀疏矩阵（Sparse Matrix）**  \n矩阵 $A_{mn}$ 中有 $s$ 个元素，其中 $s$ 远小于 $m \\times n$，因此可以选择这样的方式存储：  \n保存 $(i, j, a_{ij})$，其中 $i$ 和 $j$ 分别代表其在稀疏矩阵中的 row 和 col，可以采取行优先的方式进行存储，比如：  \n\n| index in array | row | col | value |\n| -------------- | --- | --- | ----- |\n| 0              | 0   | 1   | 123   |\n| 1              | 0   | 4   | 134   |\n| 2              | 2   | 2   | 111   |\n| 3              | 9   | 0   | 1999  |\n> Row priority, sorted by row\n\n稀疏矩阵的转置：\n1. 将row和col进行交换\n2. 按照row进行排序（如果需要保留原先的行优先）\n转置的算法1：\n假设矩阵为A_mn，则转置后的A^T有n行。\n- 遍历n次，每k次遍历时，把col=k的元素先进行保存到新的矩阵中（只要按照顺序进行遍历，那么一次遍历之后，保存的部分都是按照新的col排序的，因为原先是按照row排序的）。\n- n次之后，所有元素都转置成功。\n\n转置的算法2：\n维护一个数组rowSize，表示转置之后的第i行已经有了`rowSize[i]`个数据；再维护一个数组`rowStart`，`rowStart[i]`表示第i行从这个位置开始。\n先遍历一遍item，统计每一行的个数，再遍历一次所有的item，遇见之后，直接把每一个item(i,j,k)存入`rowStart[j] + rowSize[j]`这个位置，新的item为(j,i,k)。\n\n\n稀疏矩阵的链表表示\n我们可以使用正交链表来实现稀疏矩阵的功能，设定一个头结点和元素节点：\n设计为\n![image.png](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/20250925115853.png)\n","categories":["NJUCS","数据结构"]},{"title":"多模态综述","url":"/posts/66c438509deb/","content":"精读(perhaps)了《A Survey on Multimodal Large Language Models》（IEEE2024）这篇文章有关MLLM的发展历程概括，论文中还给了一个github链接[https://github.com/BradyFU/Awesome-Multimodal-Large-Language-Models](https://github.com/BradyFU/Awesome-Multimodal-Large-Language-Models)，这篇论文不曾想，点进去就看到了南大的标，并且这篇论文很帅气地写下了这句话：\n\n**\"To the best of our knowledge, this is the first survey on MLLM.\"**\n\n**\"据我们所知，这篇综述是MLMM方向的第一篇综述\"**\n\n![](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/MiG_logo.jpg)\n\n原来是南大发的论文 出于好奇，我搜了一下Mig小组，发现该组有4位老师，其中两位老师恰好是我这个学期计算机系统基础的老师。\n\n9月28日更正：这篇论文的作者来自南大，中科大和腾讯，其中南大的Fu Chaoyou是共一+project leader\n\n---\n\n## LLM，LVM，MLLM\n\nLLM(Large Model) 参数量大，强于推理能力，但是没有视觉\n\nLVM（Large Vision Model）能够理解图像，但是没有推理能力\n\nMLLM（Multimodel Large Langage Model）继承了大参数的特点的同时，使用了新的训练范式。并且在应用场景和功能上进行了扩充：能够读懂多种模态的信息（model）\n\n## MLLM Architecture\n\n![](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/1758964094269-4a2e023e-4ce3-4df9-94f7-46ac2d14e21e.png)\n\n架构图\n\n传统的LLM接受文本作为输入并且输出文本，但是MLLM还需要能够接受并且输出多模态的信息，就需要对多模态的信息做一个处理。主流MLLM再处理多模态的信息的时候，需要用一个特殊的多模态编码器，来把多模态信息转换为LLM可以读懂的信息，最后是LLM的推理和输出，如果是输出多模态的信息需要借助对应的生成器。\n\n**预训练模态编码器**\n\n作用：把多模态信息（audio、image，video）转换为更加紧凑的表示（more compact representation）通常选取已经在特定模态上已经对齐过的编码器，而非从0开始训练，比如clip在图像-文本信息上进行过对齐，使用这些预训练好的模型更加容易将多模态信息和LLM进行对齐。\n\n**预训练大模型**\n\n原文对这一部分没有过多地阐述，只提到Scaling Law依旧有效；以及提到MoE架构通过激活部分参数来实现增大模型参数量并且减少计算开销的效果。\n\n**多模态交互**\n\n补充，前面说编码器不是已经对齐了吗，那为什么还需要connector来连接编码器和LLM？\n\n因为有的编码器没做对齐（如ConvNext）\n\n直接训练end2end的模型开销太大，因此采取需要借助一个中间的媒介来沟通多模态信息和LLM。方法有两个：\n\n1. 训练一个connector模块。包括token级别和feature级别的融合：\n\n- token级别：将编码器输出的编码转换成token与文本token**拼接**后进入LLM。\n- feature级别：使用了注意力机制把特征进行融合。\n\n2. 使用专家模型：思想是使用专用的模型把其他模态的信息转换为text，但是灵活度不够\n\n这一部分对应论文中的这一张图，最左边是token级别的connector：\n\n![](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/1758977027205-4b1bbde8-ef34-4731-aae5-aa7f6f224640.png)\n\n---\n\n## 训练策略\n\n**预训练Pretraining**\n\n预训练的目的有2个：1. 为了让大模型对齐多个模态的信息 2. 让模型获取到外部知识。以图像-文本为例，常见的方法是拿caption数据进行训练，冻结大部分模块，只训练少部分的模块（比如connector）\n\n相关的数据集有：\n\n- Coarse-Grained Data：数据多，但是质量参差不齐，比如CC\n- Fined-Gained Data：数量少，并且质量高，比如ShareGPT4V\n\n**指令微调Instruction tuning**\n\n指令微调是指通过构建指令格式的实例，然后以**有监督**的方式对大语言模型进行微调，来帮助LLM**拥有更好的推理能力**， 从而展现出**泛化到未见过任务（zero-shot 0样本）**的卓越能力。\n\n用于指令微调的数据样本可以用这样的一个三元组来表示\n\n数据来源可以是：\n\n1. Data Adaptation。把其他相似的任务的数据集改为指令微调数据集，比如把VQA数据集进行扩充和修改\n2. Self-Instruction。手工写一些数据集，然后用大模型生成更多的数据集。\n3. Data Mixture：除了多模态指令数据，纯文本的问答对话也可以用于提升对话专业性和指令遵循能力。（不太理解为什么要叫做Data Mixture，也许是把纯文本的对话混合到了多模态的指令微调任务里面？）\n\n**对齐微调Alignment tuning**\n\n常常用于需要有特定的回复偏好时。Reinforcement Learning with Human Feedback **(RLHF)** and Direct Preference Optimization **(DPO)** 是对齐微调的两个主流方法。\n\n**RLHF：**利用强化学习算法让LLM对齐人类需求，通过在训练循环中加入人类监督。以InstructGPT举例，RLHF分为以下三个部分：\n\n1. 有监督微调：这一步旨在微调一个预训练模型，以使其输出期望结果，这个微调好的模型被称作policy model。当然也可以直接使用预训练模型，跳过这一步骤。\n2. 奖励建模：这一步使用偏好对训练一个奖励模型。\n3. 强化学习（这一步没看懂）\n\n**DPO：**利用简单的二元分类损失从人类偏好的标注中学习。\n\n注： 由于缺乏对强化学习的理解，这一部分只是粗读\n\n## 前沿拓展技术和相应的应用场景\n\n**Multimodal In-Context Learning**\n\n1. 只需要通过少量样本、可选的指引和外推的新问题进行学习，就能够模型对应样本，解决复杂的问题和未见任务；\n2. 不需要专门训练，可以灵活引入不同架构。\n\n应用场景：\n\n1. 解决多样的视觉推理任务。通常是提供一些特定任务的样例给模型学习，模型泛化到一些新的相似问题上。LLM从样例中学习任务是什么和输出格式是什么，最终生成给定结果。\n\n因为ICL可以通过少量的样本就可以学习新的问题，所以可以学习其他的任务，泛化能力强\n\n2. 教LLM使用外部工具。通常涉及更细粒度的信息，由一连串可按顺序执行的步骤组成，以完成任务。与下面的CoT密切相关。\n\n不过我没太看明白这个和多模态有什么关系，我觉得这个更多是ICL的作用，而非MICL，或许应该侧重说明多模态的能力让其能够在更加复杂的环境下进行推理，从而提升agent能力\n\n**Multimodal Chain of Thought 多模态思维链**\n\n引导LLM一步步思考，回答推理过程，最终输出答案。\n\n思维链在结构方面有单链和的树形链条，前者方法通过一步步推理得到问题-推理过程-答案的链条，后者将问题分解成多个子问题，每个由LLM或者视觉专家模型来生成推理过程，LLM再利用推理过程求出答案。\n\n长度方面，可以分为自适应长度和预定义长度\n\n**LLM-Aided Visual Reasoning（LLM 辅助视觉推理）**\n\n主要是在agent方面的应用\n\n这类方法的核心是引入外部工具或视觉模型，让 LLM 成为任务的“助手”。它们既可以针对特定任务设计，也能做成通用系统。和传统的视觉推理模型相比，这些系统有几个显著的优势：能更好地泛化到新对象和新概念，能够借助 LLM 的强大推理实现复杂任务，还能提供更自然的交互方式和更灵活的控制。\n\n在训练方式上，大体可以分两类：\n\n1. 一种是不需要额外训练，直接通过 prompt 驱动 LLM 来完成任务。\n2. 另一种方式是微调，通过给模型额外的工具使用数据集，提升它在调用工具、定位等方面的能力。GPT4Tools 就是通过收集新的工具相关指令数据，进行 instruction-tuning 来改进系统表现。\n\nLLM 在这些系统里面有这些作用：\n\n- **LLM as a Controller.**：把复杂任务拆解成更小的子任务，并分配给合适的模块去执行。这里通常会用到链式思维（CoT），比如 VisProg 就要求 LLM 输出一个视觉程序，每行都对应调用一个模块，还要附带参数。这类方法经常借助少量手工示例作为参考。\n- **LLM as a Decision Maker.**：总结上下文和历史信息，判断当前是否有足够信息来完成任务。如果没有，就继续获取信息；如果够了，就组织和整理出用户友好的答案。\n- **LLM as a Semantics Refiner.**：利用 LLM 的语言和语义能力，把零散的信息整合成连贯自然的表述，或者根据用户需求调整生成的文本。\n\n## 前沿文章摘要\n\n1. Multi-Layer Visual Feature Fusion in Multimodal LLMs: Methods, Analysis, and Best Practices [https://arxiv.org/abs/2503.06063](https://arxiv.org/abs/2503.06063)\n\n2. tags：特征融合\n3. 本文系统研究了多层视觉特征在多模态大模型中的融合方法，首次提出针对**视觉层次选择**和**融合策略**的系统化分析。作者发现从起始、中期和末期各选择一层作为融合输入能够获得最佳效果，并验证了“直接在输入端融合多层特征”优于在内部层融合等方案。这些发现为构建高效的视觉-语言模型提供了实践指南，是提升多模态LLM性能的新思路\n\n4. Benchmarking Multimodal Retrieval Augmented Generation with Dynamic VQA Dataset and Self-adaptive Planning Agent [https://arxiv.org/abs/2411.02937](https://arxiv.org/abs/2411.02937)\n\n5. tags: 多模态信息检索\n6. 本文针对多模态检索增强生成(mRAG)提出了新的评测框架和方法。作者创建了 **Dyn-VQA** 数据集，引入需动态检索的复杂问题，挑战传统的固定检索流程。研究发现现有mRAG方法难以应对此类问题，于是提出了 **OmniSearch** 自适应检索规划器，能够将复杂问题动态拆分成子问题并逐步检索答案。该方案在实验中显著优于传统方法，推进了多模态RAG的研究前沿\n\n7. SViQA: A Unified Speech-Vision Multimodal Model for Textless Visual Question Answering [https://arxiv.org/abs/2504.01049](https://arxiv.org/abs/2504.01049)\n\n8. tags: audio generation\n9. 本文提出了首个**语音-视觉统一模型**SViQA，直接处理口语提问而无需转换为文字，填补了现有模型多聚焦于文本-视觉融合的空白 。\n\n---\n\n后记与补充：\n\n1. 上个学期使用过zotero但是当时不知为何十分卡顿，今天尝试多个方案解决问题，最后发现的问题是：我把zotero的默认下载路径改到D盘。。。后续删除重新再C盘默认路径下载之后解决了问题。（使用zotero版本为7.x）\n2. 目前使用ob来管理笔记，使用zotero阅读文章，缺少联动的方法。\n3. 我发现自己了解过的相关知识阅读起来就很舒服，一旦在一大段里面多次出现自己不理解的概念，读起来就很难受了。\n4. 接上一条所说的，读论文会发现自己还有相当多的知识没有搞懂，一篇论文会涉及到诸多方面的内容，比如这篇讲多模态方面的论文，就涉及到了Cot，ICL，RLHF，指令微调、对齐微调等等内容，而我连基本的模型都写不了😂\n\n下一阶段计划：\n\n- 学一些基础知识（模型训练全流程，基础的神经网络结构）","categories":["NOVA"]},{"url":"/posts/54b78cdb42c3/","content":"\n使用BurpSuite对即将发布的ics-chatbot的抓包分析\n\n---\n\n### ICS chat-bot接口\n\n使用BurpSuite抓包可以发现如下接口：\n\n#### 1. 登录接口\n\n**POST** `/login`\n\n- 请求需要包含JSON格式的`token`：\n    \n    JSON\n    \n    ```\n    {\n        'token': YOUR_TOKEN\n    }\n    ```\n    \n- 响应中会包含`Set-Cookie: user_session=XXX`，请务必保存此`user_session`，后续所有请求都需要将其作为**Cookie**发送。\n    \n\n**请求示例:**\n\nHTTP\n\n```\nPOST /login HTTP/1.1\nHost: 114.212.10.249:8080\n...\nContent-Type: application/x-www-form-urlencoded\n...\nCookie: user_session=816368583df0135efaf9e8ceae0ff49b%2Fbedd3a284c8ef8265dad6337a6be88030338355463fe06b9c5d1768f0ff685012bcfcd095d178a5122328a1a12176ea0%3Ad3a3b7d857aae084cbc3d965d5c5458c4bba6158f13fddabbf73d03b39e0d353\n...\n\ntoken=8G5qU3qh\n```\n\n**响应示例:**\n\nHTTP\n\n```\nHTTP/1.1 302 Found\nLocation: /\nSet-Cookie: user_session=4879632ae07684697b8194e723d7981e%2F052e37e1d6419850b6274a67627915feaaee438c5fd4be6fb847f29278b6a6e59cdc91477b596dd0dda95d45041c3249%3Aafc6186e7618766a1c442053ea0ae7d42a5aaa9537534e09ff2fe23fcfa5bd02; Max-Age=604800; Expires=Tue, 07 Oct 2025 00:52:00 GMT; Path=/; HttpOnly; SameSite=lax; $x-enc=URI_ENCODING\n...\n```\n\n---\n\n#### 2. 建立WebSocket连接\n\n**GET** `/`\n\n- 请求头中需添加：\n    \n    - `Upgrade: websocket`\n        \n    - `Cookie: user_session=...`\n        \n\n**完整请求示例:**\n\nHTTP\n\n```\nGET / HTTP/1.1\nHost: 114.212.10.249:8080\n...\nUpgrade: websocket\nConnection: keep-alive, Upgrade\nCookie: user_session=...\n...\n```\n\n**响应示例:**\n\nHTTP\n\n```\nHTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: lSwjjGTK1ZieZ05mBhUo3OwmtXU=\n```\n\n---\n\n#### 3. 清除历史记录\n\n**POST** `/clearHistory`\n\n- 请求头中需包含`user_session` **cookie**。\n    \n- 请求体为空。\n    \n\n**请求示例:**\n\nHTTP\n\n```\nPOST /clearHistory HTTP/1.1\nHost: 114.212.10.249:8080\n...\nCookie: user_session=...\n...\nContent-Length: 0\n```\n\n**响应示例:**\n\nHTTP\n\n```\nHTTP/1.1 200 OK\n...\n```\n\n---\n\n#### 4. 强制停止对话\n\n**POST** `/rescue`\n\n- 请求头中需包含`user_session` **cookie**。\n    \n- 请求体为空。\n    \n\n**请求示例:**\n\nHTTP\n\n```\nPOST /rescue HTTP/1.1\nHost: 114.212.10.249:8080\n...\nCookie: user_session=...\n...\nContent-Length: 0\n```\n\n**响应示例:**\n\nHTTP\n\n```\nHTTP/1.1 200 OK\n...\n```\n\n---\n\n#### 5. WebSocket通信流程\n\n- a. 客户端发送消息:\n    \n    直接通过已建立的WebSocket连接发送对话内容。\n    \n- **b. 服务器响应**:\n    \n    - 首先发送字符`\"S\"`作为开始标记（**Start**）。\n        \n    - 之后发送的消息以`\"T\"`开头，后面跟着实际的回复内容，服务器采用流式响应。\n        \n    - 最后以字符`\"E\"`作为结束标记。\n        \n    - **注意**：在正式回复结束之前，服务器可能会发送一个单独的、类似如下的回复，用于前端展示参考文献。类似的还有一个`[!Note]`格式的回复。\n        \n        ```\n        T\n        > [!TIP]\n        > **参考文献**\n        >\n        > proc.c, logo.c, 3.3.html, 4.2.html, 1.1.html, trm.c, linux.html\n        ```\n        \n\n**通信示例:**\n\n- **Client** -> **Server**: `\"你好\"`\n    \n- **Server** -> **Client**: `\"S\"`\n    \n- **Server** -> **Client**: `\"T你\"`\n    \n- **Server** -> **Client**: `\"T好\"`\n    \n- **Server** -> **Client**: `\"！\"`\n    \n- **Server** -> **Client**: `\"E\"`\n    \n\n---\n\n#### 6. 对话总结\n\n在WebSocket通信中，向服务器发送`\"$$\"`即可触发对话总结功能。（但是我暂未研究其回复结果）\n\n---\n\n#### 7. Server端的防御策略\n\n- 约在9月29日左右，助教添加了登录限制，错误码为`1008`，防止双开。\n- 此前已经存在速率限制，以防止短时间内高频次请求服务。\n---\n\n#### 8. 自己搭建对话网页\n\n- 有了这些接口，可以自己搭建网页或脚本来弥补现有功能（如上下文保存、多对话管理）。\n    \n- 目前前端使用**Vue**，后端使用**Python**  网址：`http://172.26.8.119:4173/`。除了ICS对话，该网页还支持查询RISC-V的PA作业。（但是我不清楚其他的PA是怎么查询的）","categories":["NJUCS","ICS计算系统基础"]},{"title":"实用网站","url":"/posts/d1739767f4d2/","content":"\n## 南大网站\n<ol>\n    <li><a target=\"_blank\" rel=\"noopener\" href=\"https://ndwy.nju.edu.cn/dztml/admin\">南京大学五育项目管理系统</a></li>\n    <li><a target=\"_blank\" rel=\"noopener\" href=\"https://youth.nju.edu.cn/tw/admin\">南京大学-学生第二课堂</a></li>\n    <li><a target=\"_blank\" rel=\"noopener\" href=\"https://p.nju.edu.cn\">网络认证</a></li>\n    <li><a target=\"_blank\" rel=\"noopener\" href=\"https://xk.nju.edu.cn/\">选课系统</a></li>\n    <li><a target=\"_blank\" rel=\"noopener\" href=\"https://itsc.nju.edu.cn/main.htm\">信息化建设管理中心</a></li>\n    <li><a target=\"_blank\" rel=\"noopener\" href=\"https://ehall.nju.edu.cn/ywtb-portal/official/index.html#hall\">南京大学网上办事服务大厅</a></li>\n    <li><a target=\"_blank\" rel=\"noopener\" href=\"https://box.nju.edu.cn/\">南大云盘</a></li>\n    <li><a target=\"_blank\" rel=\"noopener\" href=\"https://table.nju.edu.cn/\">南大表格</a></li>\n    <li><a target=\"_blank\" rel=\"noopener\" href=\"https://mirror.nju.edu.cn/\">南大镜像</a></li>\n    <li><a target=\"_blank\" rel=\"noopener\" href=\"http://test.nju.edu.cn/\">南大测速</a></li>\n    <li><a target=\"_blank\" rel=\"noopener\" href=\"http://elite.nju.edu.cn/jiaowu/exit.do\">教务系统</a></li>\n    <li><a target=\"_blank\" rel=\"noopener\" href=\"http://eol.nju.edu.cn/\">大外网</a></li>\n</ol>\n## 工具类\n\n1.   <a href=\"https://getomni.ai/ocr-demo\">文件转markdown</a>\n2.   \n\n>   To be continued......\n\n\n","categories":["Mics"]},{"title":"Riscv介绍","url":"/posts/0ac3e125560f/","content":"RISCV：开源，Load/Store形式\n指令有R-type，I-type，S-type，U-type，B-type，J-type等类型\n![image.png](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/20250930143543.png)\n\n\n推荐[RISC-V 指令集参考手册](https://ai-embedded.com/risc-v/riscv-isa-manual/)来了解这个相关指令\n在riscv里面将a0-a1作为返回值寄存器，如果是是32位就只需要a0，如果是64位那就需要64位，如果是更大的，那么存入栈中，并且放回地址（对应x86的eax）\nsp相当于是x_86的esp（栈顶指针）\n在x86中放回地址是压入栈中，然后跳转，但是在riscv中\n（在x86中，call指令会push return addr并且跳转，ret指令先pop返回指令，再跳转，这里的跳转指的是修改栈顶指针）\n而在riscv中使用寄存器进行保存\n\n![image.png](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/20250930142644.png)\n（图为riscv的寄存器和对应的abi name，以及描述相关内容）\n\n---\n## Instructions\n### Arithmetic Instructions\n\n1. add rd rs1 rs2\n    - 将寄存器 `rs1` 和 `rs2` 中的值相加，结果写入 `rd`。\n    - 有符号整数加法，若溢出则**不触发异常**，结果直接截断（由软件处理）。\n2. addi rd rs1 imm12\n    - 立即数 `imm12` 进行**符号扩展**（SEXT）后与 `rs1` 相加，结果存入 `rd`。\n    - `imm12` 的范围是  到 ，即  到 。\n3. slti t0 s2 15\n    - 若 `s2 < 15`（有符号比较），则 `t0 = 1`；否则 `t0 = 0`。\n    - 该指令用于**有符号立即数比较**，常用于条件判断前的预处理。\n4. lui t0 imm20\n    - 将 `imm20` 的高 20 位加载到 `t0` 的高 20 位，低 12 位清零。\n    - 用于构建大立即数的高段部分。\n    - 低 12 位可通过 `addi` 或 `ori` 补齐：\n        \n        ```asm\n        lui t0, 0x12345      # t0 = 0x12345000\n        addi t0, t0, 0x678    # t0 = 0x12345678\n        ```\n\n---\n\n### Shift Operations\n\n1. slli t2 s0 8\n    - 将 `s0` 左移 8 位，逻辑左移（低位补 0），结果存入 `t2`。\n    - 用于快速乘以 。\n2. srli t2 s0 8\n    - 将 `s0` 右移 8 位，逻辑右移（高位补 0），结果存入 `t2`。\n    - 用于无符号除以 。\n\n> ⚠️ 注意：RISC-V 还提供算术右移指令 `srai`，用于有符号数右移（高位补符号位），但未列出。\n\n---\n\n### Logic operations\n\n1. and rd rs1 rs2\n    - 按位与操作，`rd = rs1 & rs2`。\n    - 属于 R 型指令，操作码为 `0110011`，功能由 `funct3` 决定。\n2. andi rd rs1 imm12\n    - 立即数 `imm12` 经符号扩展后与 `rs1` 按位与，结果存入 `rd`。\n    - 以 `i` 结尾表示 I 型指令，立即数参与运算。\n\n> ✅ 提示：`or`, `ori`, `xor`, `xori` 同理，均为基本逻辑运算，I 型用于立即数，R 型用于寄存器间操作。\n\n---\n\n### Memory access instructions\n\n在 RISC-V 中，一个 **word 是 32 位（4 字节）**，地址按字节寻址（byte-addressable）。  \n在 x86 中：\n\n- `w` 表示 16 位（2 字节）\n- `l` 表示 32 位（4 字节）\n- `b` 表示 8 位（1 字节）\n- `q` 表示 64 位（8 字节）\n\n1. load 指令 `lw t0 12(s1)`\n    \n    - 从内存地址 `s1 + 12` 读取一个 32 位字（word），存入 `t0`。\n    - 地址计算：`addr = R[s1] + SEXT[imm12]`（`imm12` 为 12 位立即数，符号扩展为 32 位）。\n    - **寄存器中左边是高字节，右边是低位**（无论 RISC-V 还是 x86，都遵循此规则）。\n    - **端序问题**：\n        - 大端（Big Endian）：低地址 → 高字节，存储顺序自然。\n        - 小端（Little Endian）：低地址 → 低字节（LSB），因此数据在寄存器中需**反向排列**。\n        - RISC-V 默认采用小端模式（可配置），因此在内存中 LSB 存在低地址，加载时自动完成字节重组。\n2. store 指令 `sb t0 6(t3)`\n    \n    - 将 `t0` 的低 8 位（即最低字节）写入内存地址 `t3 + 6`。\n    - 用于存储单个字节（byte）。\n    - 类似地，还有 `sh`（半字，16 位）、`sw`（字，32 位）。\n\n---\n\n### Control Flow Instructions\n\n在 x86 中，控制流通过将状态（如标志位 ZF、CF、SF）存于 **EFLAGS 寄存器**中实现。  \n这些标志位反映上一条指令执行后的结果（如是否为零、是否进位、是否负数），后续条件跳转指令（如 `je`, `jg`, `jl`）根据这些标志位决定是否跳转。\n\n在 RISC-V 中，**没有 EFLAGS 寄存器**，控制流依赖于**显式比较与跳转指令**：\n\n1. `bne rs1 rs2 imm12`\n    \n    - 若 `rs1 ≠ rs2`，则 PC ← PC + SEXT[imm12] × 2。\n    - `imm12` 乘以 2 是因为 RISC-V 指令按字（4 字节）对齐，偏移量以字为单位，但立即数以字节为单位编码，故需左移 1 位（×2）。\n2. `beq rs1 rs2 imm12`\n    \n    - 若 `rs1 == rs2`，则跳转。\n    - 与 `bne` 互补，是基本条件跳转指令。\n\n> 🔍 如何实现“小于”跳转？  \n> RISC-V 无 `blt` 指令（但可作为伪指令使用），需组合实现：\n> \n> ```asm\n> slt t0, s1, s2    # t0 = 1 if s1 < s2 (signed), else 0\n> bne t0, zero, label  # 若 t0 ≠ 0，则跳转\n> ```\n> \n> - `slt` 执行有符号比较。\n> - 若 `s1 < s2`，则 `t0 = 1`，`bne` 成立，跳转。\n> - 可类似构造：`bge`, `ble`, `bgt`, `bgeu`, `bltu` 等（通过 `sltu` 实现无符号比较）。\n\n> 📌 说明：`blt`、`bge` 等是汇编伪指令，实际由 `slt` + `bne` 实现。\n\n3. `jal rd, imm20`\n    \n    - **Jump and Link**：跳转并保存返回地址。\n    - 将当前 PC + 4 存入 `rd`（通常为 `ra`），然后跳转到 `PC + SEXT[imm20] × 2`。\n    - `imm20` 乘以 2 是因为指令对齐（每条指令 4 字节），偏移量以字为单位。\n4. 伪指令 `j label`\n    \n    - 可用 `jal zero, label` 实现：\n        \n        ```asm\n        jal zero, label   # 跳转，不保存返回地址（zero 恒为 0）\n        ```\n        \n    - 适用于无返回需求的跳转。\n\n\n### 技巧\n1. mov操作，使用addi，加一个0即可实现mov\n2. 为什么往内存里面送的时候没有区分unsigned和signed呢？因为内存里面都是按照字节编码的，要存多少个字节就申请多少个字节，不像寄存器可能需要把16位的数据存入32位的指令才需要用到\n## Steps in Execution of Procedure\n\njal调用函数  \njal ra gcd  \ncallee执行后，使用jalr来返回  \njalr x0 0(ra) # gcd中计算的结果存储在约定好的寄存器中  \n（请你详细的讲讲在x86和riscv中不同的调用过程）  \n\n|步骤|RISC-V|x86|  \n|---|---|---|  \n|调用|`jal ra, func` → 保存返回地址到 `ra`|`call func` → 把返回地址**压入栈**|  \n|返回|`jalr x0, 0(ra)` → 从 `ra` 跳回|`ret` → 从栈里**弹出**返回地址并跳转|\n## Heap的内存分配\n内存只有Stack（从高地址向低地址增长），Heap（从低到高增长），Static Data， Text（my code），Reversed（保留区）\nPC执行代码段中正在执行的指令\n\n在运行的过程中elf文件被移动到内存中，static区域中有：.data是初始化全局变量的，.bss区域是没有初始化的全局变量\n\n\n","categories":["NJUCS","ICS计算系统基础"]},{"title":"第四章：程序的链接","url":"/posts/6d799cb58280/","content":"---\n\n> [!NOTE] Note\n> 老师说这一章很重要，特别是函数调用部分，要能够读懂函数调用的过程\n\n\n听到了代码，栈，三个寄存器（EBP，ESP，EIP）来完成整个函数的调用之类的东西\n\n将来会叫我们画函数的栈帧，里面会有eax ebx之类的东西，会有局部变量，会有函数的参数等等\n\n在函数的执行过程中，ebp不变，一直指向栈帧基址\n\n> [!NOTE] 栈帧形状\n> ```[高地址]\n> 参数 (caller传的)\n> 返回地址 (call压入)\n> 旧 ebp (push ebp 保存的)\n> ------------------ ← ebp 指向这里 (栈帧基址)\n> 局部变量区 (向低地址扩展)\n> 临时保存的寄存器\n> ------------------ ← esp 指向这里 (栈顶)\n> [低地址]\n>\n> 所以参数的访问都是用 ebp + 偏移量来访问，返回值一般都在 eax 寄存器中，如果是浮点数，那么就是压入 XX（这个不考）\n> ```\n> \n\n\n**栈帧必须要会画**\n\n以这个代码为\n```c\nint add ( int x, int y ) {\n\t return x+y;\n}\nint\t caller ( ) {\t\n\t int\tt1 = 125;\n      int \tt2 = 80;\n\t int\tsum = add (t1, t2);\n\t return sum;\n}\n```\n\nleave的作用是 mov ebp esp; pop ebp，也就是把esp的值改为ebp的值，然后把栈顶的值（现在栈顶就是ebp所指的位置，也就是\n\nebp+8是第一个参数，ebp+c是第二个参数\n在这里的esp没有改变，因此无需调用\n\n在分析汇编代码的时候，需要注意eax通常是result，因为eax","tags":["class-notes"],"categories":["NJUCS","ICS计算系统基础"]},{"url":"/posts/800444f268fd/","content":"# 一位很优秀的老师说的话\n\n\n<br>\n\n这里说的老师是，李越老师。\n\n<!--more-->\n\n**引言：樾哥在最后一节课上，把SQL的最后一点语法讲完了；短暂休息了几分钟后，把他带来的圣诞节礼物--巧克力，分给了学生，开始了下面这段讲话。**\n（暂未人工校对，有许多的错误）\n\n樾哥：\n当老师有这样的一个好处：当你一直在观察学生的时候，你会发现历史总是惊人的相似:每一届学生的烦恼都是惊人的相似。\n我可以大胆地说一句，因为自从我生病以后发言都比较大胆\n（笑声）\n为什么，因为觉得大不了就命一条,工作又算得了什么。\n> **“我们的教育确实有问题”**\n\n我只想实际跟你说，包括我们国家也好，国外也好，我毕竟在国外呆了7年，我觉得很大一部分我们的教育体系是缺失的，缺失在哪里？缺失在我们学生 18 岁成年了之前，一直是素质教育也好，教育也好，都是一种选拔式的、竞争式的、优胜劣汰是这样的去筛选人才。我们管理国家也好，管理信息当然要公平的简单的有效方式，但是国家机器而言，只是一个简单有效的方法，也是一个公平工作，但是落实到我们个人，个人成为了牺牲品。\n\n那么你们信任我们现在来到南京大学，属于基础计划很重要，你们属于社会价值体系当中优秀部分，因为部分外面住宿商业大学看着包括公司的，但是现在只有你们自己知道，只有发生规律就是这样。我每到一个新的环境，环境都是什么赋予的，都是优秀学生一定就会有很高下来，你们周围的环境，我们身处这个社会的大环境，再大一点社会这个人整个人类。\n\n我们不是别人，就近一点应该把你优秀，不能出国更好的渠道博士，差一点的不对读研究生，研究生保研考研的，然后这个是什么本科，什么不好只能就像找工作怎么样找工作，我不想考公务员工作体验，最后干什么呢？想到这里之后你到了一个新的环境还有同样的控制需要面对，最后为什么，无非就是合力两个字。\n\n18 岁的欲望很小，我们现在最单纯的人，一旦你们默默慢慢长大之后，就会有更严重的对比和比较，家里人、我们的朋友试一下这些人，这个环境是全国化告诉你你看谁谁谁谁，或者不用你自己刷小红书老师，我觉得我很明白，我觉得你们这一代人事实上明白，比如说我们到时候公司，我们不用不用我一定可以什么什么什么，我告诉你一切都是自己可以改变自己。\n\n但是一旦到了一个环境环境下也会比较，因为这是你的基因决定，是社会性的动物，这是你的生理性的也无可避免去做，是吧？导致一个问题呢，你在人生当中没得到一个新的环境开始打怪兽往上走，实际上走到了越来越越来越平静的地方，活动会越来越越来越越来越越来越，这就是我今天这个人讲的东西的目的。\n\n就是我想在你们还在算是在最单纯的联系你们脑子里面，实际上很单纯，我先别的东西都不重要了，几天以后才可以保养出国，我可以你好，我要一个非常重要的事情就是人生不是这样，从现在就要打破这种束缚，人生不应该被我们社会环境恶化的价值观，什么叫物化的价值观，就是价值好的就是就是毕业了，父母我自己看起来能说得上去，给自己有个交代，几年后买到什么样的房，仿佛了他连接两万五年薪 1 万，我就感觉自己过程成功到哪里，要升值加薪的话应该有可能这样子比较体验比较稳定。\n\n我可以很明确的告诉我，你在任何一个环境以后处于任何只要你自己的心理不做改变，你永远永远一直在担心和害怕，你会把从每一个机会都小心翼翼都忐忑观，我可以给你们交个你，我一直相当你们说不要跟别人比较这件事情，老师做的挺好，还想跟你说担心不要教育。\n\n所以说句实话，我没有资格跟你们说件事情，因为我现在就会教育，我的交易上实际上很偶然，因为以前教育加重的原因就是因为一年多之前工作太认真了，那个时候实际上已经放下很多名和利的事情，那时候想的很简单，就是我的里面有一堆学生而言，我得去给他们挣钱，比如说我现在终于吃了喝什么东西都不行，那个东西赚钱我也赚钱，那我就算不要钱的时候，那时候当时我们发过，因为我那时候也不是我自己的时候，还是算是怎么说呢，自己感觉要从学生工作科研他们还没承担什么自己自己，然后我就先挂了之后就从此一蹶不振，可以说这一年进来说对我影响非常非常大，我把很多事情都跑去，把很多事情非常生病的时候，我就像我今天给你讲的话，你们可以回去看 b 站的视频账号给你们 21 级学长以前的学生偷偷的拍下来，然后呢我就给他账号有一些大型没有想到就拿那个账号去看，就像我们讲过类似的东西。\n\n但是我现在得病之后这边的客户明显，因为说句实话，我是属于生病了，身体的所有的免疫细胞这个神经系统全部紊乱之后，然后到这样现在状态，然后自己自己就没有没有办法有时间过来之后交流交流，就是以前本来就不是这样的一个人突然就变成这样一个人之后，我就越来越能体现我们现在很多同学认识和教育方面，我们现在至少很大一个朋友都会有这个现象。\n\n我想对未来的提前说，记住从现在开始想一个问题，这个问题就是你要看你们要怎么去过活着，你说的老师程序员这件事情我真的走不通，那就换一条道，卖苹果也是，老妈打死我自己感觉不太，但是你要知道，如果这些就是一个体力，心里面可能会没有那么累，你也可能甚至自己上一个更好的环境中济南比较领导晋城，然后机会是你的不是你的，你感觉自己不足然后小心翼翼的把握的一个机会，让你前半个月都睡不好几个月等这个结果，这些东西都是成年人的烦恼为准成年人。\n\n所以说未来并 50 岁的社会环境和我们需要自己找自己喜欢干的事情，我还是以前跟你说，你说老师啊，我喜欢段时间太不容易了，这怎么能行呢，这个这个东西可能有人一辈子都找不到，你怎么这样同学们，这件事情实际上从小时候开始找，你们现在才不想等你们大学毕业，那你就只能出去了获得类型没有考过，你根本就没有自己人生的思考，你想想你来这一辈子过火就短短几十年，遇到一个生病或者不幸的地方，是你过你不是替你爸妈不是任何旁边重要的朋友在经历，是你自己的感受，你自己的心态去做。\n\n而我们现在同学呢，我觉得现在教育很可悲在于并没有让学生意识到这个问题，这就导致了明明不喜欢的事，明明自己不在意的事不想干的事，但是就是因为那个体面的工作，不是我们每天先过的都很辛苦，这一句话很重要，你每天都可以过，我可以什么样的情况可以是我遇到困难了，遇到问题了，但是我还是想对未来自己追求一下，我把这个困难经历过把它改造了，然后我把坚持下来把困难解决，我成长了，不是这个而是不停的焦虑，觉得我不行我不行我不行，越来越否定自己，因为现在大部分因为你们医学系已经过去，谁能说我觉得我以后感觉没什么问题，我就大部分地方知道不是这样。然后我当时这个高薪然后就过来很多别人别人加班加班，为什么程序员加班呢，因为高薪，为什么高薪加班就要变成常态呢？已经熬夜下班那么辛苦。\n> **自己快乐最重要**\n\n思考这个问题就是一辈子，我想跟你们很明确说，当然是自己舒不舒服快快最重要，没有这个世界上没有一件事情，这个事情我们还有暴露的约束，比如说我要赡养父母，对待亲人对待陌生人要礼貌，能保养这种我们自己，我们教育我觉得道德如果我们今天要做到这个同学道德的约束没有问题，但是但是但是你现在你自己都不快乐，你真的别人有一天真的需要你帮助的时候，你会怎样的帮助，真的是对的而且有效的帮助。\n\n所以我想明确我们在成才之前需要看看自己将来要往哪条路走，你应该是快乐的成长，而不应该是每天都说我就忙完这四年，然后到底就是我在这三年，然后再工作岗位前几年好了年了你一直在未来透支，这本身就是一个我们个人不正确的一个成长和生活的方式，你在未未来一个不确定的自己，一直在透支当前的心态，透支当前的快乐，却为了争取那个虚拟的别人定义的社会环境定义的这样的一种企业，而自己整个这个过程很辛苦，你想想你现在这些事情都会一直在比较紧张焦虑不开心的状态当中反复的趋势，那么这就是问题。\n\n这个为什么你们偶尔出去旅游一下，哎呀好少，为什么，因为你突然这样的情况当中跳出去，可谓是只能跳过去那么几天，然后回来为什么，为什么一下子就能记住那个瞬间就去外面那个当时那个环境建议平时态度，那反过来说的时候，老师说了一些打的方向，让我们去认识自己，发现自己做自己详细一块的事情，但是什么时候让自己快乐的事情，我现在没有条件去接触，我也没有时间去接触过一个sicp的话，我个人如此，要从现在开始去挖掘挖掘机会，发现这件事情我不反感，记住很重要，我不反感反感反感就是你说出问题我不会我不会反应，是真的，但是你感觉我做出来之后，我好像有点感觉，这就叫什么叫房产，他们就这些事情，然后也终于做饭再说 ok，然后呢就是比如说这个这个这个这个考试，所以说包括这个这个什么同学讨论问题情况都考虑，就是不想碰这个东西，然后呢这些东西深恶痛绝，一直没有什么感觉，做出来了就是做出来，做出来有什么不开心，这样出去，我希望你先给自己塞，你是否适合学习计算机，所以才答应你还可以再观察一个学期到大二，这是最简单。\n\n你们讲来讲去，你同学说老师我今天也不好反应慢，但是我发现我们学校以前不会的东西，看新闻计算机未来好奇，还有这个东西这个东西要注意，这说明基础，如果你对一个东西还保持信息，就说明你在这上未来有一个机会，可能不太你的方向突然把你发出来。\n\n我直接带一个学生，他也觉得化学他觉得自己不喜欢，他们学校化学实际上非常高，反而是他们学校就 ok 了解呢，就是我自己感觉别人可能就是非常聪明确实很厉害，但是说实话我对我知道为什么，因为他非常可爱，这是我最喜欢的我的研究，这个当然现在。\n\n那么我想跟你说的是，实际上想找到自己喜欢说他是否喜欢机遇到之前，我觉得我看不到一些课题的时候，会发现掌握的一些自己很多一些天赋，做事情的方式，看看规矩问题规律，没有做事方式，这个人很适合属于签收科研设施，通过一个人经历一件事情，突然感觉他其实他自己心里没有表态，但是我是过来一下，然后他就开始事情，比如说他花半年时间写出了一半行吗，现在整个安卓静态分析领域世界上最强的东西，期待你美团大众点评这些上面所有的安全扫描都是他做开发工作，ok，我们站起来害羞了，就是他的成长可以说是一个奇迹，这个契机想告诉你什么东西呢，是他的本科期间，他也没有仔细思考这个问题，他觉得件事情关系不错，旁边有人去挖掘，感觉老师讲他讲来讲他好像找到自己适合干的事情，一套的经历我们几乎每个人都会，但是绝大部分我可以很悲观，因为你们这辈子显然能遇到一个能挖掘的潜力的人，这些事除非遇到一个老师，我就是我自己最好的那个做什么事情的价值合同，你自己能改变。\n\n所以如果这样的话怎么办，很简单，回归到我们刚才问题，既然大家绝大部分的人不会经历这样的一种人能取到钱，这种事情需要自己发现自己，那么自己挖掘自己的，让自己找自己喜欢走这条路的概率大大，这两大如何自己挖掘自己的，怎么能大概以后能够让你以后能够从事自己比较喜欢，哪怕是当时计算机自己不擅长，最后还能成为这个领域的佼佼者，我给你们一些方法，就是我至少列出来的必须是一些学习方法。\n>  **系统性学习和输出**\n\n一个我们的系统数据，什么叫系统，系统系统输出，强调两个字，你会发现你们在南京大学里面学过的绝大部分课程，我可以认真负责给你讲，没有用，包括产品的很大，如果再体验一点，就是所有课程都没有动，我想对你说这句话，老师讲的好，当然我们已经到时候天天讲老师非常好，我想对你说大概什么能力非常优秀的老师，南京大学其他高校从其他项目的，我们已经向老师这些老师都是属于非常出类拔萃老师，很多其他学校的项目，但是我想说什么，大学这个资源没有仅限于大学，什么意思，你们现在处于一个互联网高度发达的这样的一个阶段，如果一个课程你觉得老师讲课讲得不好，我就问你一句话，你们翘课，只有真正的人才敢受，我遇到的大部分都是中规中矩，中规中矩就是想维持一种体验，这种体验是过去这么多年来自己养成了一种习惯性，什么叫惯性，就是我是逃课的人呢，如果老师点名了怎么办，总不敢不敢，总做那个乖乖的学生，我可以很明确跟你说，这个世界没有给乖乖的学生永远犯罪，没有你们所有人叫你反复，你要记住你们在学业上要思考和自己魄力，老师课讲得不好，是老师的问题，不是你的问题，如果很多人不认识小爱不错，就你听不懂，这是正常现象，因为什么，因为大家不同嘛，就是文学的，就是你们不要跟别人说我说什么就知道以前以前跟你说的时候怎么办，这个情况下，你想如果你可能来不及做起来，就是感觉老师讲的明白，然后呢天天早上 8 点 10 点困得不行加小包过来了，然后可生气的人讲东西一样，就是你们很多常态，你想一想都不知老师我这句话，我没有时间啊，我没有时间做自己想做的事情，计算机学院没有给我这样的机会啊，我没有时间做事情，不是没有时间，你的时间被这个社会定义的条条框框价格数据而已，不敢逃脱，所以显现出来的就是我似乎被课程占满了，我剩下的课余时间作业占了，我已经只能这个样子。\n\n如果不敢会不会觉得逃课是什么设计手法，讲究道德，作为一个人，但是如果有一些课程明明对你来说你学不明白不知道，那你还不如趁这个机会上网搜寻更好，如果你想来个教室，老师在商学院学费，老师给你们这个问题突然嗷嗷一嗓子，还不如自己在宿舍哪个地方自己自己一个小时给老师讲的，包括包括讲课讲得好吗，比如说有时候我自己想一想啊，同学们大学不知道部分过长，主要咨询如何咨询，你们现在自己思考问题吗，你们没有，你们未来对自己该走什么路，什么总是和自己，你们所有人重复，从来没有握手，有没有人摸索一些大写的基本，就是天津要去天天去图书馆啊，或者是这个这个自习室啊，然后一些学习很久，然后你会感觉到他自己的记忆，未来什么时候考托福考什么时候比赛，怎么发现自己经济，这样的人是非常规律的，是非常善于挖掘时间的，尽管这些人他自己和自己上不是最优的，但是通过这种规律和坚持，他知道自己想要什么，很努力，所以说很多很多东西很多适合他都会提前摸清，这样的人不会碍，就是我不是在这个什么成功去电影回来，就是让你开心更早，会发现他适合干什么，为什么，你想想，如果在每一个环境当中，你们都能及早的发现，我好像旁边的人学习成绩更好一点，虽然我花时间更多一点，没有旁边弄得特别聪明，那么聪明，但是我发现我成绩很好，他心里面就有一个公司，这种优势带来一个非常重要的东西，我老师自信这件事情，两个字 4000，这件事情就是我们每个人每个阶段正确，你记住你在每一个阶段都会失去自信，这个阶段，这是一个常用，因为每个人都会有让你意想不到的问题和意想不到的身边的环境和意想不到身边的人，他会迫使你让你觉得我好像不是很环境一样，因为什么，因为过去尤其是你们，你们带着一颗高傲的心，你们你们以前就是环境当中自信那些，来到了南京大学，突然被比下去，然后觉得自己的事，你记住，这是想第一个告诉你，往往经历这种情况，一定一定要先给自己鼓足勇气，先不要退出，因为你可能连自己 5%的利息都没有重大，你不知道有多远，所以先不要掉队，除非我刚才说了你自己比较反感，你自己当前这个东西。\n\n回到我们来说，那我学这么多课，老师让我翘课，那么怎么才能学得快学得好呢，系统系统输出，什么意思呢，总结起来就是，假如我现在让你们每人想去给马上再下一步的权利去讲，或者你们其他高校的同学没有学过，你就跟他讲，而且我只给你一个小时给他把时间整，你会这么讲，记住不是一个一个知识点一个知识点的，那里面一道题谁都会做，花时间都会做，你们要学的不是这个东西，你们要学的是把知识系统化，什么叫系统化，我要知道最重要的东西啊，使用当中最重要的东西到了吗，从这个最主要的东西生活可以不讲，我把主要问题给他讲清楚，实际上资料自己解决，什么时候主要，如果我要讲清楚，然后我们马上讲解事情，剩下所有的国家，我认为方法不一样，我认为这东西对我来构建的基础，每个人有构建自己的知识的方式，因为你整理知识学习知识的学习习惯学习能力触发神经元连接的方式，我有我的方式，我的方式我怎么样快速的把这个方式变成我的，到时候拿来直接拿去用的时候，直接拿来就是系统进去东西。\n\n所以说我建议你们以后任何一科之前，寒假回家的话，需要什么，那么多课程先挑专业最重要的课专业课，因为以后你的自信来源来源于自己，没有来源于高速自信啊，没有听过离散学得不错，实际上真正用到实处也很少，所以说来自于政治，我从来没有见过英文自信，数学知识计算机里面只有专业自信心里面很多课，那你就找一个日本，我知道老师这么优秀，基督教和驾车自研研究生就可以去干什么呢，我给你建议，别学学所有东西的时候，上来就从书第一页开始，你能 1/10 的含量，因为你怎么可能呢，回来时候回去了，然后回去之后找到你们起床了十二点起来，所以你们怎么学，不要看这些东西，去看视频，上网去搜视频，国内国外，国外套餐不好，既然\n你去看看视频，老师看一个视频一个视频，看看他这门课里面去看哪几节最重要，结合自己之间一定是有衔接的。所以你可能意识到前景后面那些可能性不太懂，但也没关系，你先去把这几天就抱着自己去，没事不看小说了，对吧？你看你不看这个机器人电视连续剧吗？好了，你就保持这样的态度，吃饭、睡觉的时候，你就养成一种习惯。\n\n什么习惯很重要呢？对于专业的东西一定要吸引，为啥？它就像你们日常刷抖音一样。希望不要惧怕，不要割裂了，先听，听完之后你知道这门课大概什么情况就可以了。这个时候你再系统地去学一下，什么叫系统加速？如果感觉这方面没什么重要的，一定要适合跳过、跳过再跳过重点。你们要知道，不是不做练习，而且听我讲课，没有我你们照样还是必须得很好，这是实话说，因为你们有作业，做作业的过程就是固化知识的过程，就是前面说的把零散的知识点变成你的知识体系的一部分，这部分很关键。\n\n然后开始了之后会怎么样呢？老师上课你要是觉得好、讲得好听，那自然好；要是你不觉得好，你自己就拿上课时间去看自己，比如说这时候有事情提前学习，或者是自己去提前做更深入的内容，做一些老师讲到的东西，会发现你就能成长，因为你本身的优势非常重要。你会发现，年纪增长的同时你一定要成长，工作要学会利用周边的事，这是大家常讲的事情。你的环境会给你带来一些焦虑，但不是环境带来的所有事情都是负面的，只要学会把不利的东西变成有利的东西。既然环境当中通过比较无形中会让你去感觉自己，让你把之前需要做的事情提前去准备、去谋划，提前去判断。比如你专门对某些敏感信息不感兴趣，对某些方面感兴趣就去咨询，不用特别懂，但发现之后你已经比旁边很多人有优势了，然后就用这个优势把自己充实起来。\n\n反应慢也没关系，在这个领域，哪怕只是在一个小的方面，你会发现自己很强，你就要把这一点当作一个迈步，慢慢提升自己。你会发现，因为计算机之后总要有个专业性的东西，所以要早点准备。现在说别人大四或者研究生才能做的事情，其实你也可以提前准备，不要等到找工作还是考研的时候才开始，因为别人那个时候才会发现这些信息，而你现在就可以行动起来，学会做事给自己找方向。\n\n很重要的是，你们现在这些知识的片段是零散的。我希望你们每个人养成习惯，你学习一个东西之后，一定要花比较多的时间，比如花一个小时给不懂的人或者不那么懂的人讲一遍，这是系统性输出。讲了之后你就会发现，整个这门课或者这门课最重要的东西是什么，怎样把其他东西很容易让人听懂串联起来，这个时候你需要掌握什么知识点，这些东西会把主要内容凸显出来，这是一个非常重要的综合能力，你们现在一定要抓起来。\n\n为什么要输出呢？因为我们人脑想的、嘴里说出来的和手里写出来的，这是三件事情，你可以仔细体会，它们完全是不一样的事情。哪怕你心里想的东西觉得自己很清楚，比如说我现在给你讲，大概怎么讲话很多东西能说清楚，对吧？但实际去说的时候可能就说不清楚，这个时候你就要马上回去查书。我怎么跟别人说不清楚呢？别人也说不清楚，那你就要去查。问题就在于，它相当于你现在雕塑一个素描，这个素描差一点东西就成了，但你就是不会，你是不是赶紧去翻书、去学习呢？哪怕再难也要学会，而且要在短时间内学会，因为就差这一点东西，一旦完成就会有奖励，这是心理学。你就差这一点，一定会非常高兴，哪怕前面困难重重，你也要努力把它完成。\n\n所以说整个体系你要输出才能真正发现自己，还有方式发现很多学生用技术博客，其实你也可以。同学聚会的时候，你可以把自己的东西分享出来，你不要想自己有很多观众，没有观众也没关系，就是给自己写，遇到一个有缘人就可以交流，哥们互相欣赏，就像古代两个人互相切磋，然后互相成长。我遇到只要简历当中发现谁写的基础而且坚持，我基本上无条件相信这个人自律性也好，自学能力等各方面都非常强。\n\n所以系统性输出很重要。我们处在一个很好的年代，要感谢这个时代给我们提供了这么好的机会，一辈子做学生、做老师，都要学会两个字——感恩，要回馈这个社会，回归帮助自己、服务自己。当然，也要记得回馈自己，挣到钱了也要好好生活。\n> **勇气**\n\n这里想说的勇气是什么呢？就是同学们现在碰到迷茫、碰到困难时，是否依然能够面对、坚持，这很关键。因为我以前身体好的时候经常接触很多父母，他们会跟我聊，我听过一种说法，就是在教育过程中会发现有很多同学存在一个问题，就是在面对计算机专业或者数学等学习内容时，生活性都是非常被动的，花时间了没效果就赶紧放弃，自己打游戏或者干别的事情，一起学习又感觉自己不行。你现在这个状态作为老师我想明确告诉你，非常非常正常。所以我第一个要告诉你们的是，当面对困难迷茫时，收起逃避、回避、拖延的状态，而且要长时间地克服，这是非常正常的一种生理和心理的共同反应，千万不要被这种情绪打败。你还是那个高中非常优秀的人，能力一定是非常强的，但是这个时候要先接纳自己，这也是一个典型需要在环境中进行缓冲的过程，因为每个人的环境适应能力不一样，有的人适应能力很强，但有的人就是不行，需要在一个环境中慢慢成长，这样的人也有很大一部分，以后也会发展得很好。只是在环境适应能力、及时的适应能力不行的时候，你不要轻易觉得自己不行，那这件事情就非常危险了。\n\n我的观察是，如果自己现在觉得不行，就很难再振作起来照顾自己。这个时候同学自己怎么检查自己的勇气呢？现在我们看到一些修仙的小说、动漫之类的，看到那种一个人独自面对困境的时候，那个人如果早早放弃就死了，对吧？就是有点感同身受。你想想那时候如果主角遇到困难，会不会有需要帮助、需要坚持的情况呢？比如军训训练的时候，而且要解释为什么我们总期待或者总会带入到那些文学作品中，在一件事情上一定会付出努力最后坚持，或者是好像所有文学作品都告诉我们要积极向上面对困难，但为什么你们在看这些文学作品的时候没有受到激励，而真正落实到自己哪怕是一个小的方面，比如一个客户、两个客户没处理好就带入不了这种积极的态度呢？这种人生自带的本能去哪里了呢？我想原因就是一句话，你过得太安逸了。如果现在发生战争，我现在告诉你一句话，这屋子里的人不出去就会有危险，可能马上就会有反应，会发现旁边哥们是什么情况，剩下十几个人会互相保护等等。我想告诉你们记住一个东西，就是你有没有行动起来，因为你自己给自己安全感余地，因为你逃避自己不会受伤害，但是作为老师我想告诉你，你现在逃避是一种慢性的伤害，这种情况会让你以后未来不管是大学还是后来一辈子都会受到影响。记住你现在面临困难就开始逃避，或者说先接纳没有问题，这是正常的，但是一开始就否认自己、长时间逃避，你未来一定会更糟糕。你在处理很多事情的时候，只要去做就能知道什么时候能做好，到时候会发现家里人需要养、孩子需要带，我们没有退路，必须出去做事。那时候你不想想现在就做事情为什么要被逼呢？那就是因为之前逃避把自己逼到没有余地了。我现在可以作为一个过来人告诉你，你现在不要笑，这个屋子里面至少有一半的学生在逃避自己做事，开始拖延，开始否定自己，觉得自己不行、能力不行。对于这个，我告诉你，你们现在可以给自己换一个心态，比如寒假好好调整，开学来了我再给你半年去试一下，如果你努力了找到了自己的方向，那就继续前进；如果你往后退，你要记得你就相当于失去了机会，而且一旦失去自信了就相当于失去快乐。你所有的快乐都不是由内而外的，比如你打游戏在游戏里打得好，你说老师我想去游戏公司，我跟你讲你说错了，因为游戏公司需要的计算机方面的专业人才的专业能力更强，和其他互联网公司要求的能力是不一样的，你要想清楚自己想要什么能力进入公司去做。\n\n所以想清楚这件事情，希望同学们首先要接纳自己，我每个同学都很关注，为什么很多同学的想法我能理解呢？因为我就是一个从碌碌无为走过来的人，上大学的时候我觉得我有一个品质值得你们学习，就是能坚持而且时刻保持自己。我觉得我不管做什么，名也好利也好都不是最重要的，在我身边没有专业不专业的区别，我就相信自己，我就是专业的。比如我的例子就是现在站在你们对面给你们讲课的我，我给你们讲的时候可能会有情绪，也经历过痛苦，我实际上是想告诉各位，大家应该接纳自己的不足和现在看起来自以为是 的地方，真正要做到遇到困难的时候永远不要放弃自己的自信，无论是学习方法还是其他方面，都要不断提升。想象一下，如果没有自信，我的人生就不会快乐。\n> **做自己**\n\n所以说第二个，也是最后一点，希望大家做自己。也就是我一直想跟你们说的，做自己。你想一想，每一个人在我们的群体里面都有自己的特点，当我们表现不好的时候，回来再看看自己怎么样。我非常喜欢一个学生，当年他就是 50%的水平，我给他指导，后来我们一起成长，到现在我还记得他。还有很多优秀学生，我特别喜欢那些有自己想法的学生。因为你们是社会性动物，前面说了如果过去的十八年没有办法自我思考，没有关系，因为你们思想还不够成熟，还没有意识到自己主动思考的重要性，现在告诉你，你可以开始思考自己的人生方向了，就像修仙一样，你现在开始行动，能不能做到呢？本门的这个机会已经给了，现在你要做这件事情一定要带着信念，再努力的话可能就会找到自己的道路。不是我们每个人都要做同样的事情，也不应该做同样的事情，我们要做一个不一样的人。\n\n你想想我给你们讲当年我的经历，我就是专注于自己的专业，我觉得很重要。当时我印象最深的就是数学，我数学好，就是那种很单纯地做题做得好。但是后来在国外学习的时候，情况不一样了，在项目结束的时候，我跟人家组队，我发现自己贡献不多，感觉自己不配，那时候我就觉得自己要努力了，学校教的东西不够用了，怎么办呢？我就开始自学，自己去探索很多技术东西，自己去建设，比赛的时候开始涉及设计，慢慢我发现自己并不差。那时候对专业的要求就是自己完成作业，有没有作业都要自己去学习，自己安排时间，我现在还记得那个时候的自己，因为我觉得那是我真正为自己的人生努力的时候，我从来没有像那样自己做自己的事情，怎么做自己呢？你想要做自己这是一件非常容易的事情，一定要记住，因为你们每个人的人生轨迹、性情、经历的环境、接触的人和事都是不一样的，那就意味着你只要按照自己的品性、自己的习惯、自己想做事情的态度去做，自然而然会走出一条和别人不一样的路。\n\n当然，做自己的一个前提就是要有标准，如果今天的所有东西都记住，记得老师一句话，千万不要因为别人的看法而改变自己，因为这一辈子不管在任何一个地方，别人的看法不一定是对的，而且有时候你会发现自己的想法和别人不一样，但是你没有办法改变别人的问题，这件事情无意中会影响你做自己。就像陶渊明的“心远地自偏”，什么意思呢？就是你的心远离了世俗的纷扰，自然就会处于一种宁静的状态。你可以这么理解，你现在想想自己成长过程中不自信的来源是哪里呢？突然觉得自己自卑，其实可能并不存在什么真正的原因，一定是旁边的人或者某些事情触发了你的这种感觉，直接原因就是无形当中受到了影响。所以告诉你，你和旁边的人没有可比性，不要去比较，你要关注自己的内心。你说老师既然做自己这么好，我从现在开始可不可行呢？如果你们能做到，比如像我自己走遍太原，烤了一个红薯，别人怎么说我都觉得无所谓，我一定可以，这就是一种人生境界。你现在能想到我很佩服你，作为老师我觉得这是非常成功的一种心态，但是关键是大部分人做不到，这时候应该怎么办呢？所以要改造，改造什么呢？就是两个字——习惯。老师教你们别的东西没有，这件事情说起来容易做起来难，中国古代的一些关于命运的说法就是天生的，但是做事的习惯、思考方式都是可以改变的。包括一些思考事情的习惯要养成，你会发现当你处于一个很好的新的环境中，看到别人很努力，你就会想我也要努力，这个同学或者那个同学给你一些好的建议，你以后会更好地帮助别人，同时也要改变自己。你要记得你以前想要做事情的那种习惯，尤其是不好的习惯，比如做事情碰到困难是不敢面对还是赶紧解决，这些思维习惯改变非常困难，但是只要你去改，那就是你的成长，自己可以给自己带来更多的好运。\n\n所以说如何做自己，我可以和大家分享，贵在坚持，要勇于审视自己、改变自己、克服困难。这件事情尤其在年轻的时候一定要去做，我现在就是在告诉你们困难是可以克服的，在专业上的成长经历就是把每一次困难当成自己改变不好习惯、让自己更自信、更向前一步的机会。这样的坚持非常非常难，因为以前可能没有这样的习惯，但是只要你坚持，同学们在其他方面已经做得蛮好的情况下，在这方面更要坚持。真正要做到的是坚持一件事情，那就是不停的去挖掘自己，看看什么东西能让自己快乐自信起来。如果你现在发现不了，没关系，你先按照这些方法慢慢去做，克服困难，一点点尝试，一定会有那么一个机会找到你，你就会觉得还不错。然后你继续坚持，继续保持自己，继续做自己，你会发现更多的正向反馈过来，就是越来越自信。大家在遇到困难的时候，包括作业的难题、人生的迷茫等等，都要接纳自己，不要把自己贬低下来，游戏该怎么样就怎么样，继续保持自己的生活节奏，最重要的是要不断思考自己的未来，不要忘记自己的目标。\n\n最后说一下，我讲到这些东西一定会有一批学生受到触动，也一定会有一批学生失败，但是记住自己失败了一次、两次甚至多次都没关系，只要时刻不放弃，永远有机会可以做自己。实际上从始至终都不要和别人比较，这句话是我人生中以前的一句格言，在这之前我也反省过、察觉过，也知道它对我的影响。好好审视自己，检查自己哪里还可以改，哪里还可以进步，你们现在年轻，在成长过程中发现自己可以变得更好的地方，包括对一些事情的看法、所谓的自信都是可以提升的，记住这不是说你以前不好，而是你在这方面看到别人之后受到感染，觉得自己可以做到更好，然后把它改掉，一点点进步。这就是我们今天这节课的内容，之后我可能以后不会再见到你们，如果你们作为研究生，以后大概率也不会再和我有太多交集，但是我希望老师今天说的这些话能留在你们心里。今天是圣诞节，你今年的目标起码今天这件事情要朦朦胧胧记得，但是有一句话要一直跟在你的身体里，如果让你们选一句话，那就是做自己。每一个人从现在都应该珍惜自己的过往，积极自信的面向未来，时刻思考自己该何去何从。我们现在这个社会缺失的不好的地方就是很多人不知道如何面对自己独有的未来，好好去思考，不停的思考，总有一天会有一个机会让你觉得自己的思考是值得的，让你成为一个快乐自信的人。 \n\n---------------------------------------------\n编者注：\n樾哥（李樾老师）身体不好，讲课时已经很勉强，需要长时间坐着，但在和我们交流人生经验时，每每遇见激动的地方要起身来在黑板上写下几个关键字。\n\n\n\n\n\n-------------------------","categories":["一些碎碎念"]},{"title":" 如何看待人民日报官方微信公众号转载的文章《孩子，我宁愿欠你一个快乐的少年，也不愿看到你卑微的成年》","url":"/posts/0a58f97eba42/","content":"\n# 如何看待人民日报官方微信公众号转载的文章《孩子，我宁愿欠你一个快乐的少年，也不愿看到你卑微的成年》？\n\n本文由人民日报官方公众号（id：rmrbwx）发布于2016年8月31日，转载文章链接：\n[【荐读】 孩子，我宁愿欠你一个快乐的少年，也不愿看到你卑微的成年](https://link.zhihu.com/?target=http%3A//mp.weixin.qq.com/s%3F__biz%3DMjM5MjAxNDM4MA%3D%3D%26mid%3D2666137991%26idx%3D4%26sn%3D1db8c2a720a9cb2f504d0f4be5426797%26scene%3D1%26srcid%3D09049IAkn4t9wiUsRNfqaJKf%23rd)\n注意，《人民日报》官网、官方微博并未转载该文。\n－－－－原题主问题－－－－\n第一个问题，填鸭式的应试教育是否能真的成就栋梁之才，能的话成才率是多少？\n第二个问题，怎么看待现在孩子从小开始就被迫的补课，占用大量休息时间，这种方式公认不值得提倡，但为何这么多人照做？\n相关问题：\n[怎样看待钱文忠教授说「我不相信教育是快乐的，请别再以爱的名义对孩子让步」？ - 学习](https://www.zhihu.com/question/30638961)\n\n[![天平](https://picx.zhimg.com/v2-beeb026027deb11bd73e45ee5ce2d314_l.jpg?source=1def8aca)](https://www.zhihu.com/people/tian-ping-14-92)\n\n[天平](https://www.zhihu.com/people/tian-ping-14-92)\n\n永远是学生，永远爱写作，兼职写小说、小说大纲和人设\n\n 关注\n\n4.9 万人赞同了该回答\n\n10.19（最新，大概也是最后的更新了，更新内容仅限中括号内的）\n\n【这篇回答的评论区被锁了，不是我锁的，我也没有办法打开它，问了知乎管理，说是评论区可能涉及到违反法律或引起争议的内容，所以锁了。如果大家有什么想说的，我主页里有关于这一篇的想法，那里只有一个本文链接，在那下面评论吧（再次强调，我从不会主动关评、删评，即便是骂我的言论我也不会删除，如果你的评论不见了，那大概另有原因）】\n\n\n\n什么是卑微？啥卑微？我读书少，麻烦[人民日报](https://zhida.zhihu.com/search?content_id=502411621&content_type=Answer&match_order=1&q=人民日报&zhida_source=entity)来解释解释什么叫卑微？\n\n清洁工？服务员？农民工？电子厂工人？机修工？厨师？掏粪工？还是什么别的职业？\n\n为什么这些职业是卑微的呢？\n\n如果不是这些职业，那是什么？\n\n是不工作？\n\n那为什么大家都不工作呢？\n\n还是说娼盗毒赌之流？\n\n那意思是，只要少年快乐了，长大之后就一定从事这些违法犯罪职业呗？\n\n怎么样算是卑微呢？\n\n你总得给个说法。\n\n成人只有三种状态：\n\n1、从事正常不违法犯罪的工作\n\n2、不工作\n\n3、从事违法犯罪的工作\n\n那你人民日报总得选一个，到底是哪个叫卑微呢？\n\n还是都卑微？\n\n现实情况？什么叫现实情况？\n\n我咋不知道咱们国家建国以来有宣扬过什么现实中农民、工人是卑微的职业呢？\n\n要是有这样的现实，你身为主流媒体之一不应该去批判这种现实、解决这种现实问题吗？怎么反过头来还好像是认命了呢？\n\n请你一定要好好给我解释解释，因为我真的是很无知，我读书真的不多，我脑子笨，我嘴巴快，你不解释清楚，指不定啥时候什么话就秃噜出去了。\n\n请告诉我，什么叫卑微的成年？\n\n补充一下：\n\n看了评论。\n\n评论里有说，无法选择自己的工作，大学生不值钱找工作被轻易替代，个人无一技之长活的不如意，这些就是很卑微啊。\n\n我并不认可这样的说法。\n\n上面说的这些，只能说是现实。\n\n而现实≠正确\n\n显然，无法选择自己的工作，只能被迫干活，这是有问题的，这是不正确的，每个人都应该有选择自己干什么的机会，这才是对的，是我们追求的。\n\n无法实现这样的追求，是我们社会和个人的悲哀，而不是具体哪个人卑微，他不卑微，是社会中的一些坏东西强迫他卑微，然后以此吸血。\n\n同样的，大学生被轻易替代，这个问题不在大学生自己，如果只是一两个大学生，那可以说他们不好好上学，没有学习好本领，所以被轻易替代。\n\n但即便如此，这也不是卑微，应该说是遗憾，遗憾他们本来可以更好地发挥自己所擅长的东西，却因为没有好好读书，被迫去了自己不擅长的领域。\n\n比如大学生不好好读书，毕业了去当服务员，但我们不能认为这是卑微的，因为服务员这个职业不卑微，人家也是靠自己双手吃饭，不偷不抢正经工作，怎么就卑微的。\n\n遗憾是因为，这些大学生可能不擅长服务员的工作，不擅长在集中的时间点进行精准快速的对客人的服务，一个人因为自己的关系最后被迫去了自己不擅长的领域当然是遗憾。\n\n不过，目前的问题并不在这里，显然不是一两个大学生有这样的问题，是很多，是90%以上。\n\n那问题就肯定不在大学生自己，而在学校教育。\n\n985，211这样的大学毕竟是少数，更多的是普通本科和专科学校，大家可以自己对比看看，现在学校教的东西，是不是落后于市场的？是不是很多学校还拿着十年前、二十年前，甚至三十年前的教材来教导学生？\n\n教学本身就没有跟得上时代，怎么能期望教出来的学生符合市场需求呢？到最后自然是容易被替代。\n\n这不是个人的遗憾，这是整个大学教育的问题，是要去解决的。\n\n大学生在找工作时别轻易替代，80%的错误不在大学生自己，如果教材有用，如果教材说人话，如果教材没有那么五十页往上的：XX行业自古以来的发展历史介绍，输出的是干货，是趣味，是有用的知识增加了，学生怎么会不学呢？真当大学生都是没有脑子的傻子？\n\n最后，个人没有一技之长，活的不如意。这同样不是卑微。\n\n这天底下的行业那么多，总有一个是适合某个人的，如果这个人真的是什么都不会，那也应该有社会、政府机构来培养他，让他拥有技能。\n\n所谓的一技之长，大家都心知肚明，并不是说哪方面擅长，其实就是说他没有知识，不能做办公室，只能端盘子、搬砖、种地、扫大街。\n\n那么问题又回来了，端盘子、搬砖、种地、扫大街怎么就卑微了？人家不偷不抢，怎么就卑微了？\n\n有人会说赚的钱少啊，所以活的不如意。\n\n那赚的钱少是应该的吗？\n\n我觉得不是应该的。\n\n扫大街每个月不应该只有八百、一千，应该有三千往上。\n\n种地的不应该一年到头出去成本赚不了一万，应该赚5万+。\n\n同样端盘子一个月也要有四五千。\n\n搬砖更不用说，重体力劳动+危险+对基建来说必不可少，更得有稳定的每个月1万+的收入，外加各种保障。\n\n这样一来还觉得卑微吗？\n\n有人会说不现实。\n\n当你产生不现实这个念头时，这才是最大的悲哀。\n\n为什么就不现实，为什么不能变成现实。\n\n我们每个人都应该有更高的收入，哪个行业都值得更高的收入。\n\n人民日报作为主流媒体之一，它应该宣传这样的观点，应该让广大老百姓都意识到，自己的劳动是很值钱的，自己劳动不是不值钱的，自己需要保障，需要按时发工资，需要福利，这是天经地义的。\n\n而不是说，社会就是这样，所以你要卷，然后将来才能不变成这样。\n\n这样的话，救的了三五个，救的了一两千，但救不了身后数十亿的普通百姓。\n\n我们可以劳，但我们不要苦。\n\n8.19更新一下\n\n人活着如果不是为了享受，不是为了快乐，不是为了幸福，不是为了成为“懒人”，那我不知道我们这么多年的奋斗是在干什么？\n\n单纯提高生产力，然后老百姓还是天天起早贪黑没日没夜工作，工人还是被拖欠工资、大学生还是很廉价，还是买不起房、结不起婚、生不起孩子和病、养不起老？\n\n从小打大，老师、家长、社会不止一次说过，可以说是天天说：你现在努努力、你现在拼拼命，将来就可以休息了、将来就可以耍了、将来就高枕无忧了。\n\n且不说努力不是为了改变社会现状这个错误观点。\n\n我只问问，有多少人觉得自己被骗了？大学很轻松吗？工作很好找吗？工作轻松吗？工资高吗？敢吃、敢买、敢病、敢玩儿吗？\n\n嗷，我们没办法过上幸福生活就是我们不努力呗？\n\n全国0.1%的月入十万+，他们是努力的，是成功的。\n\n剩下的99.9%都是不努力，都是小时候不够拼命，都是初中高中天天就知道玩儿，所以活该被淘汰吗？活该成为卑微的人吗？\n\n什么时侯社会达尔文主义在我们国家被认为是理所当然了？\n\n曾经殖民者以此洗脑被殖民百姓的言论也搬到我们这里了？\n\n什么现在不拼命，将来就没机会了。\n\n命是拿来拼的吗？我是有好几条命吗？要是拼的时候我死了怎么办？谁会对我负责？除了父母，谁会为我掉一滴泪？\n\n为什么只考虑让老百姓多干活，不考虑多给老百姓发点儿东西？\n\n都发钱等于都没发是吧？\n\n1千块在你们上层眼里一顿饭钱都不够，对我来说就是一个多月包含一切开销的生活费，对广大山区、中西部的老百姓就是大半年的辛苦。\n\n我们的分配机制公平吗？再让老百姓拼命之前，先回答一下，我们的分配机制公平吗？\n\n生产都过剩了（这不是我说的，是国家政策说的），工地的大哥大嫂大姐大叔大爷大妈们怎么还吃着馒头咸菜呀？是他们不喜欢吃肉吗？\n\n8.17 更新一波\n\n评论我看了很多，有很多不同的想法，下面我对其中一些评论做一下集中回复。\n\n评论当中普遍存在：\n\n阶级客观存在且无法被消灭。\n\n现实就是这样，你这文章也只是博人眼球的漂亮话，反正底层孩子想改变阶层只能考试实现阶级跃迁。\n\n农民工待遇就是不好，你再说它不卑微它也是卑微的，反正我不想我的孩子当农民工。\n\n基本上就是这几个意思。\n\n这几个意思也只有一个意思：现实就是这样，我们无能为力，要么加入要么麻木。\n\n这句话被两个逗号分成三份，第一份显然是正确的，现实就是这样，现实就是农民工被看不起，农民不赚钱、工人被恶意讨薪。\n\n但后两句恕我不能认同。\n\n如果我们无能为力，处理办法只有成为它们或者逐渐沉沦，那我不知道我们一百年前那些是为了什么？\n\n如果都这么认为，社会肯定会停滞下来甚至倒退。\n\n以我浅薄的历史知识，记得在中学时候，学法国历史时同学们都惊笑，法国巴黎人民一次又一次攻占巴士底狱，连老师都感叹巴黎人民好忙。\n\n但倘若当时法国巴黎的人民没有那么做，法国巴黎人民都认为自己无能为力，然后什么也不做，没有[巴黎公社](https://zhida.zhihu.com/search?content_id=502411621&content_type=Answer&match_order=1&q=巴黎公社&zhida_source=entity)，没有[八小时工作制](https://zhida.zhihu.com/search?content_id=502411621&content_type=Answer&match_order=1&q=八小时工作制&zhida_source=entity)的提出，没有拒绝童工，那么现在的法国又会是什么样呢？\n\n如果百年前我党没有成立，如果我们面对侵华日军全部采取不抵抗，如果没有解放，我们也从不宣扬进步、民主、开放、自由、科学，那我们现在又会是什么样子呢？\n\n百年前的人生活很好吗？\n\n我们现在的生活比之如何？\n\n我们现在的生活难道是天上掉下来的吗？\n\n曾经的苦难好像也不是三五个人一挥手、一动嘴就改变了吧？\n\n倘若百年前的老百姓们什么也不做，只是等，那么最后我们能胜利吗？\n\n为何要把自己身为人的尊严给交出去？\n\n为何自己的幸福希望要托付在别人身上？\n\n为何会有人庆幸于自己的幸福生活来自于主子们高抬贵手，并且觉得这才是处世之道？\n\n普通人家只有考试实现阶级跃迁成为它们才可以？\n\n为何想的是成为它们？\n\n为何自己的幸福只能建立在踩踏他人的基础上，不奴役别人就活不了吗？\n\n我们百年来的努力就是为了到今天，让我们这些人底层人也抱着压迫底层才能苟活的思想吗？\n\n马克思主义说对新事物的发展解释的很清楚，出现停滞、倒退是常见的，但这不是合理的，历史一定是前进的而不是轮回的。\n\n欧洲不就走出了中世纪的怪圈吗？\n\n觉得不能一蹴而就因此放弃希望的，自己可以算算巴黎人民行动了几次，他们是不是一次做不到就认命了，他们怎么就可以，为什么我们做不到，我们是真的做不到吗？\n\n真的甚至连想一下这个问题，甚至连动一下嘴皮子，甚至连写几个字、看几本书都做不到吗？\n\n你要非说这是漂亮话，那就让它漂亮着吧，好歹赏心悦目些。\n\n8.24 再更新一波\n\n评论里还是有很多和之前说的差不多的问题。\n\n甚至还出现了：“人民日报是在揭露现实啊，你既然想听好听的，那我就喊好了，农民、工人最伟大，行了吧？”\n\n另外还有一些跟我回答的另一篇有关“媒体评论年轻人假精致”的问题一样。\n\n“用得着这么咬文嚼字吗？人家的原文明明是在教育孩子，让孩子小时候努力学习，这样长大就可以选择自己可以想做的工作。这是社会现实啊，难道你认为孩子不需要努力学习吗？”\n\n我按顺序再回答一下：\n\n第一个问题：我回答里已经写了，我们要做的是什么，重新宣传农民、工人这些最广大劳动群体的伟大，各个方面进行宣传，想影视剧，多少年没见过农民、工人啦？别说农民工人，就是普通人也没见几个。\n\n电视剧里的高中，那是大多数高中生活吗？\n\n河南河北、山西山东、云贵川藏等这些地方的高中生活就是天天恋爱，扔纸飞机，上课玩笑，下课打球，天天逃课、翻墙吗？\n\n我也想这样，可现实呢，我是河南的，早上五点半之前到教室，一天17节课（对，你没听错，一节课40分钟），自习也有老师来上课，卷子论斤发，中午午休有作业，能睡10分钟偷着乐吧，晚上十点下自习，吃饭跑着去跑着回，每顿饭30分钟（包含路上时间、排队、还有回来上厕所、整理东西、洗头等）这才是我们这边高中的真实生活。\n\n这些有哪个电视剧去拍、去宣传呢？\n\n这还是学生群体，相对农民、工人还要好一点，农民、工人的生活更不用说了，不说别人，说我爸妈。\n\n家里种地，一年下来一千挣不了，你以为的农民是开着拖拉机、开着收割机，坐在小木屋里，看着监控，调度室里按钮一按，各种机器自动运转，然后就等着收粮就行了。\n\n实际上是，夏天的时候四点多就起床，随便吃点儿东西，带上白开水和火烧或者馒头，好点儿的带一包咸菜，扛着锄、背着喷农药的蓝箱子就下地了，遇到锄头、耙子弄不了的，直接上手，大多数农活都得上手，要赶在10点前全部弄完，不然太阳出来热起来可有你好受。\n\n如果是浇水或者收割，你中午只能呆在地里，带的馒头、开水就是这个时候用的，有树遮阳就谢天谢地吧。\n\n什么，为什么不打把伞？\n\n你觉得浇水、收割的时候伞能打得开？你觉得是不是站在一旁看着就好了？\n\n要上手的！要弯腰的！干一天活腰直起来疼得要死那种。\n\n你以为这就完了？只有太阳晒吗？\n\n地里的虫子，傍晚没干完还要喂喂蚊子，草叶子、收玉米的话玉米叶子，到家里后身上都是血道子，又痒又疼，那可不是开文学夸张的。\n\n工人呢？厂里的工人我不知道，但散工我是很清楚的。\n\n因为我爸妈就是干这个的，给别人拉货，拉砖、沙、土、垃圾、树这些。\n\n早上三四点（你没听错），就出门了，不是起床，是出门了。\n\n晚上11、2点才回来，有时候晚上不回来直接在车里睡。\n\n车里有枕头吗？\n\n没有。\n\n车里有床吗？\n\n没有。\n\n你以为是那种长长的大半挂，那很贵，不是普通人能买得起的。\n\n是三轮蹦蹦开起来颠来颠去的小车，驾驶室有两个座位，仅此而已，没有更多余的空间。\n\n为什么要三四点就出门呢？七八点也可以啊，没必要为了多干那一点儿活把自己累成这样吧，累出毛病怎么办？\n\n实际上是，你不早点儿去抢活，活就被别人拿走了，即便是一堆砖、一堆垃圾也有一堆人在后面排着队要挣着去拉，你来晚了，就没有这个活了。\n\n活不是一直都有的，三四点到了，1个多小时把砖搬到车上，沙土会很快因为有挖掘机直接挖起来往车厢里倒，垃圾也会快一些，但砖得你自己一恰一恰搬（恰：是我们这里搬砖的方言，一个铁制工具，一下子夹起来五块砖，你得使劲才能夹住，那不是电子机器，是你全手动的，全靠力气和你自己的经验技巧）\n\n我在暑假的时候，也会跟着我爸去，不是天天，我是男生，你让我搬五块砖我当然搬的起来，但你让我一直搬，我只能说真的是天昏地暗，眼前都黑了、花了，但是不能停，你一停会更累，一天搬完到家，手上全是泡，啥也不想干只想睡觉。\n\n一般三点多出门，四点到砖厂，一个多小时，干的年数多的工人，比如我爸，四十多分钟就能搬完，一般是三千块砖，然后就快五点了，慢点儿搬就是五点左右。\n\n开着车往目的地去，离得越远，越赚钱，因为赚的就是运费。\n\n在路过胡辣汤店、羊肉汤店、路边摊的时候吃一顿饭，然后继续开。\n\n一般都是跑一个小时以上车程的，不然没得赚。\n\n到了地方，再花时间把砖搬下来，然后开着车回来，这一趟算是跑完。\n\n按照现在的价格，一般一趟下来可以赚到150左右，但你还要算油费，这可不是空车是拉着5吨重（我怎么知道的呢？因为三轮车能装的量是5吨，每次装都是装满的）的砖的。\n\n油费一般在50～80（具体要看路程，也有更高的），刨去这些，剩下的就是这一趟赚的。\n\n这个时候时间一般就九点半了，一般砖厂就没有活了，因为烧砖也是需要时间的。\n\n那就只能回家了。\n\n有人一看，哇，好棒诶，九点多就可以回家呆着了。\n\n白居易有一句诗叫：心忧炭贱愿天寒\n\n跑着一趟你可就只赚了60多块，要是每天都这样，一个月可2000都赚不到。\n\n所以就要不停打听消息看看哪儿有活干。\n\n就今年，夏天这么热，但大中午，我爸妈还是不得不去外面干活，不然家里就没钱。\n\n一般每天都要跑3趟左右，有时候活多了能跑5、6趟，但这样就不会家里。\n\n一个月下来一般能赚5000～6000，这是两个人一起的收入。没有五险一金、没有假期，不仅没有假期，还害怕被迫放假。\n\n冬天基本上是不干活的，可以歇三四个月，因为环保要查，这也就意味着我家每年有三四个月是没有一分收入的。当然现在我上了大学那会有一点，放寒假我也会打工，虽然只有两千多，但好过没有，不过我不能一直这么干，因为还有学业，所以假期我也只能打一个月工，这两千多就是我们家三四个月里唯一的收入了。\n\n像2020疫情那段时间，就是半年没有收入。\n\n这就是起早贪黑、卖力气的结果。如果按照评论区所说，这可够卑微了。\n\n而我之所以反对人民日报写的这篇文章就是因为，它只写到了这里。\n\n它只写到了：你看，这就是卖力气人的生活，你不想变成这样，你就好好学习吧。\n\n难道我父母就是活该干这样的工作吗？\n\n这种说法也太没良心了点儿，不仅没良心，还彻彻底底地不符合社会主义核心价值观。\n\n身为官媒，你怎么能不去为了这些人发声？\n\n这些人是什么人？我爸妈就是初中学历，换到现在那就是中考没考上的人，那可是50%啊。\n\n难道我们国家中有一半人就该过这样的生活嘛？\n\n不是我要说他们伟大，他们确实伟大，我们国家的一砖一瓦不就是他们搬起来、他们拉起来、他们盖起来的吗？\n\n我们吃的每一口粮食，不都是他们下地里一锄一锄干出来的吗？\n\n谁敢说，我们的国家可以没有农民和工人？\n\n既然他们如此重要，是不是应该给更高的收入，工厂里的工人是不是应该提高工资、降低工时？五险一金是不是该给到位？\n\n像我父母这种打零工的，不是正式工，那么村集体、社区团体、街道办等是不是该发一些补贴？\n\n地里的农民，村集体有没有可能相当于雇佣他们种地，不要让他们一年到头只赚一两千，父母被迫背井离乡，孩子成为留守儿童？\n\n这样的问题不该是我说的，我算什么东西啊？这应该是你媒体的职责，特别是你官媒的职责啊！\n\n为何要发一些无关痛痒，甚至还背刺农民？工人的文章呢？\n\n有人可能会说：你提出的办法根本不可行。\n\n但到底可不可行，得经过大讨论，经过试点实践才知道。\n\n官媒的责任就该是把事关国家、社会、百姓的重要事件放到台面上，用自己的影响力，让所有人都知道这件事，然后大家开始讨论，只要讨论就有可能出现解决办法。\n\n如果一直避重就轻，自然会积累矛盾，这是很自然的道理。\n\n我这篇回答的意思是，我们不仅要重新高喊出农民、工人伟大的口号，还要切实提高他们的生活水平，不扯有的没的，直接给钱。\n\n不要说什么都发了等于都没法，1千块对于富人顶个屁用，一顿饭都不止这个数，但对于老百姓那可是过年一个月的全部，而且还不一定花的完。\n\n现在人民日报这个问题是，它好像连口号都不愿意喊，都不说让它解决实际问题了，直接一句：现实就是这样，不想变成他们，你就卷吧。\n\n支持这样的观点的人，你们是否考虑过，中考没考上，高考没考上，或者考上的不是本科，不是一本，不是985、211，这些人该怎么办？\n\n第一名只有一个，1万名开外的数不胜数，这些人怎么办？\n\n录取率只有5%，那么剩下的95%该怎么办？\n\n如果注定考上清北、985、211、一本的只有50万人，那剩下的500万人该怎么办？\n\n然后我回答一下第二个问题，我为何如此“咬文嚼字”。\n\n这个问题很好回答：影响力，受众面。\n\n如果发出这种文章的是一个不知名的公众号，是我邻居，是我同学，是一个我不认识同时也没什么粉丝的普通人，或者干脆是某些明星。\n\n我理都不会理，我连一句评论都不会发。\n\n这就像你的邻居突然说，我要称帝，我是帝王，你们都是我的臣子，这天下都是我的。\n\n你会理他吗？报警都不一定会吧？\n\n你要称帝你就称呗，祝愿你能找到几个心怡的大臣。\n\n但如果说出这话的是某市长、省长，那么你的反应会如何呢？\n\n你的同桌说，全班同学把高考所有必考古诗词写1遍你什么反应？\n\n这句话让你班主任、你语文老师来说，你又是什么反应？\n\n所有我为何写这篇回答，因为发表“我宁愿欠你………”这个文章的是人民日报，是官媒，不是什么营销号，不是什么小编。\n\n我不得不关注，不得不思索，不得不认真回答。\n\n就像我现在的回答，我只要不违反法律、道德，我尽可以说，因为我的影响很有限，我又不是权威，我算什么东西，谁又会听我的？\n\n但如果我哪天有一百万粉丝了，我说话就不得不小心翼翼，也必须要求我自己小心翼翼，因为会产生一些影响。\n\n这就是我对第二个问题的回答。\n\n抱歉啰哩啰嗦写了这么多，有点浪费你们的眼睛了。\n\n8.30再更新一波\n\n主要是回答我为什么写这篇文章，我并非圣母，我是一个极度自私的人，而且我是一个废物。\n\n\n\n我为什么写这篇文章，因为我也是普通人。\n\n有人会说，你能上知乎，你能回答问题，你能考上大学，你就不是普通人了，你就比很多人强了。\n\n所以呢？\n\n为何有些人要把人群划分开，要把读过书的和没读过书的划分开？\n\n为何要宣扬你读过书就不是普通人了？\n\n难道各位从大学、从高中毕业出来的就天天山珍海味、金锣绸缎了？\n\n难道觉得自己读过书，然后就可以在心里跟别人进行比较，一看对方是个农民、是个工人、是个扫地的、是个端盘的，心里就能噗嗤一笑，嘲讽一句土鳖？\n\n我们之间又有什么区别？\n\n不要说什么，你没见过穷人，比你这情况还要糟的多的是。\n\n然后呢？为什么要比烂呢？为什么不能大家都变得更好呢？\n\n普通人就是穷人，穷人就是普通人，你我都是普通人，你我都是穷人。\n\n月入三千和月入一千没有本质的不同，都是在为别人打工，都是为了生计奔波，无非是他吃馒头，你能吃上肉。\n\n如果我们不团结起来，过不了多久，你就连肉都吃不了了。\n\n摆烂，躺平，各位真的觉得，在不断要求奋斗、不断以金钱收入划分各个群体，教育也从来不教育学生为穷人说话，只要你不工作、学习你就是怪胎的社会，你能摆烂吗？躺得平吗？\n\n为什么我写这篇文章？\n\n因为我想躺平！\n\n我想生活在一个即便我今天不工作，我也不会被人议论，被别人用奇怪的眼光看着，好像我杀人放火了一样的社会。\n\n我想生活在，只要我干了，我就有公平的钱拿，而不会被克扣、拖欠工资，被恶意讨薪的社会。\n\n我想生活在一个，只要我不违法犯罪，我就真的想干嘛就干嘛，别人不会来管我、来议论我的社会。\n\n我知道我自己是个废物，对，我就是废物！可凭什么废物就不能在这个社会上好好儿活着？\n\n我是废物，但我没有伤害任何人，那么为什么会有工厂、有黑中介、有学校的某些主任老师、有某些研究生导师、有某些饭店老板、有某些坏人来迫害我、伤害我？\n\n如果你是政府官员，而我是废物，那么你就可以因为我是废物而不为我提供服务，我有困难找上你，你就可以不帮助我，或者用各种言辞拖着我吗？\n\n很久以前，让家里人吃不上饭的是废物。\n\n往后一点，让家里人住不起房子的是废物。\n\n接着，你挣不到钱你是废物。\n\n现在，你是农民、工人，你就是废物。\n\n是不是再往后，我是普通人我就是废物了呢？我不是亿万富翁我就是废物了呢？\n\n难道我生在这个世上，我就是该不停地学习、工作吗？\n\n难道发明了灯就是为了让人在夜晚也要工作，发明了空调就是为了让人在严冬酷暑也要工作，发明了电脑就是为了让人全天24小时也要工作吗？\n\n发展和科技如果只是为了很少数的成功人士服务，那么发展和科技又有什么存在的必要？\n\n我并不要求评论区的各位成为圣人、圣母为了全人类说话，事实上，正因为我们都是废物，我才在这里写这篇回答，我是为了自己说话。\n\n我反对社达，因为社达迫害废物，而我就是废物。\n\n我是废物，我反对社会对农民和工人不友好，因为我父母就是农民和工人，而且我可能会成为农民和工人。\n\n我是废物，我反对清洁工、服务员工资这么低还要克扣，而且没有任何保障，因为我暑假打工就是做服务员，也跟两个两个清洁工大爷认识。\n\n我是废物，我反对研究生导师私权过大，我更反对他们能迫害学生以毕业为筹码要求研究生打工，因为我正在为考研而努力。\n\n我是废物，我反对有些工厂时薪只有9块、5块，因为我如果找不到工作，我就只能进厂里打工，我可不想辛辛苦苦一个月三千块都拿不到。\n\n我是废物，我反对基层官员、医生、警察、消防员待遇过低，因为他们如果待遇不够好，自然也不会、也不能尽心为我服务、在我遇到危险时尽快尽好地来保护我。\n\n我是废物，我反对支教老师、乡村医生收入如此之低，因为我想躺平，我将来有极大可能到村里、山里生活、养老，如果他们待遇这么低，他们就不来村里、不来山里了，那到时候我该怎么办，我的侄子又该怎么办？（我没有打算要孩子，但保不齐我的表哥表弟不会有孩子，将来接我侄子来我家玩儿，万一大雪封山、万一疫情风控，那总不能村里连个老师、医生都没有吧，那我侄子咋办？）\n\n对，我不为任何人说话，我全部都是为了自己的利益，我说的每一句话都在为我自己做考虑，我就是这么自私，谁让我是废物呢？\n\n既然我是废物，我为何又要为成功人士说话？为何要再为老爷们干活？\n\n如果你也是废物，为何你不和我一起反对这个迫害废物的社会呢？\n\n废物如果不和废物在一起为废物说话，你还指望各位公子老爷，百套房、千辆车的富豪们能替你说话吗？\n\n有的人可能会说，你说了也没用啊。\n\n可你如果连说都不说，连喊都不喊，那么你只会死得更加平淡，就像一只蚂蚁被人用嘴一吹，然后就死了一样。\n\n9.15 更新一波\n\n不去争取、反抗，就会有以下文中所说的现象\n\n今天在B站刷到了同一个学校留学生宿舍的样子，真的是很美丽呢。\n\n上大学以来从来没有见过如此的富丽堂皇，今天终于也算是满足了我平生所愿，感谢互联网科技！\n\n大理石铺地哦，镶金瓷砖贴墙哦，咖啡机、自动贩卖机这些都有哦，还有私人厨房、浴室、小电影院呢。\n\n真的是好棒呢。\n\n留学生小姐姐声音很好听，体格很强壮呢，黑色的皮肤也很健康，好喜欢呀。\n\n小姐姐说，人家感谢学校给他们的宿舍装了私人厨卫，但是小姐姐觉得宿舍太小了，2x2米的小床放下后就有些挤，电视只好挂墙上了，而且学校给的冰箱也有点儿小呢。\n\n我也觉得学校不够意思，为什么给人家安排这么小的房间呢？\n\n小姐姐不远万里来到我们国家，我们怎么能不以厚礼相待呢？\n\n本来小姐姐一个人住一间宿舍就已经很孤独了，不像中国的学生们六人一间可以互帮互助，学校怎么能这样对待客人呢？\n\n有些伤心。\n\n小姐姐说自己的鞋子没地方放，只好在衣柜放了两个架子，但是只能放两排鞋和五个包包，然后就没空间了，而且每次上下拿鞋子、包包也很辛苦。\n\n这一点学校确实做的不好。\n\n另外，学校给的微波炉、洗衣机、电脑也都有些旧了，这样小姐姐怎么能住的舒心呢？\n\n我本人是学对外汉语的，我们老师说了，留学生们过来，学校每个月只给他们三千块左右，而且还要求他们必须去上课，根本就没有考虑到留学生友人们的实际情况。\n\n生病了怎么办？想家了怎么办？不喜欢所学专业怎么办？水土不服怎么办？\n\n每每想到这一点，我都觉得寒心。\n\n我们中国学生，没钱了还可以靠家长，没东西吃了，很多人家里都是农村的，也有些地，每年也能种点儿玉米小麦，再不济，父亲母亲去工地、鞋厂做做工，两三千钱也就有了。\n\n再不行，六个学生互相帮助、各自借点儿钱，也就可以生活的非常好了，能吃饱穿暖。\n\n可留学生哥哥姐姐们又有谁能依靠呢？只能靠学校和政府啊。\n\n学校和政府怎么能不尽地主之谊呢？我们好歹是东道主，怎么能这样对客人呢？\n\n我们地大物博，古代封建王朝尚且知道穷自己也不能穷客人。\n\n我们现在这么富了，大家都有钱了，我们天天生产、消费，交那么多税是为了什么？\n\n不就是为了让世界上其他国家的朋友们都喜欢我们吗？\n\n1822年的大清尚能通过朝贡贸易福泽万邦，我们有什么理由比大清更差呢？\n\n相信我们在这些地方今后也能做得更好，我们每个人都应该对未来充满希望。\n\n我们要更加努力地奋斗，这样才能结交更多的朋友！\n\n另外：小姐姐说了，中国有的学生（只是个别啊）不是很经常洗澡，看起来衣服都不是很新、很干净。\n\n我觉得这方面也是我们自己人给自己人抹黑，都21世纪了，又不是一千年前，学校也有公共澡堂，洗一次澡也只要3、5块钱，身为21世纪的新新人类，当然要让自己一直保持干净了。\n\n衣服什么的也都不贵，小姐姐一个月才三千块，尚且为了别人考虑，每天换不同的新衣服，让人看了心情就愉悦。\n\n我们自己凭什么做不到！人不行别怪路不平！凡事多问问自己！\n\n加油！\n\n\n\n\n\n给心心！给心心！给心心！","categories":["一些碎碎念"]},{"title":"锐评高考作文","url":"/posts/8344ebe68b71/","content":"\n\n\n\n\n[![你说的对](https://picx.zhimg.com/v2-4dca0efd4c761b87d31235688e384422_l.jpg?source=1def8aca)](https://www.zhihu.com/people/yi-dian-yi-dian-33-80)\n\n[你说的对](https://www.zhihu.com/people/yi-dian-yi-dian-33-80)\n\n学习AI中\n\n 关注\n\n186 人赞同了该回答\n\n[负分作文](https://zhida.zhihu.com/search?content_id=731024863&content_type=Answer&match_order=1&q=负分作文&zhida_source=entity)已经出来了:\n\n[砖”家](https://zhida.zhihu.com/search?content_id=731024863&content_type=Answer&match_order=1&q=砖”家&zhida_source=entity)之言：脱离烟火气的“传世”臆想\n\n每每面对一些“[高屋建瓴](https://zhida.zhihu.com/search?content_id=731024863&content_type=Answer&match_order=1&q=高屋建瓴&zhida_source=entity)”的作文题目，我总觉得像是走进了一个由“砖”家们精心搭建的空中楼阁，里面充斥着华丽却空洞的辞藻，与真实的烟火气格格不入。今年的“专”“转”“传”作文题，更是将这种“砖”家气概展现得淋漓尽致。\n\n首先，让我们来审视一下这“专”“转”“传”的概念。所谓的“专”指专业文章，“转”指被转发的通俗文章，“传”指获得广泛传播的佳作，甚至是传世文章。听起来煞有介事，仿佛洞悉了文章传播的终极奥秘。然而，这“专”与“转”的界限，本身就模糊不清。一篇专业文章，难道就不能是通俗易懂、广受欢迎的吗？难道只有“被转发”才算“通俗”？它忽视了作品本身的质量、读者的接受习惯以及传播媒介的复杂性，仅仅用几个简单的汉字就试图概括纷繁复杂的现象，这种“一言以蔽之”的做派，恰恰暴露了其缺乏深入思考的本质。\n\n更令人啼笑皆非的是，题目中提出的“专业文章可以变成被转发的通俗文章，而面对大量‘转’文，读者又不免期待可传世的文章”，以及最核心的追问：“由‘专’到‘传’，必定要经过‘转’吗？”这简直是把一个本就模糊不清的伪命题，推向了形而上的玄学讨论。请问，一个十七八岁的中学生，他们的日常生活中，有多少机会接触到所谓的“专业文章”？他们对于“传世文章”的理解，又能在多大程度上超越教科书的范畴？让他们去探讨“由‘专’到‘传’是否必经‘转’”这种高度抽象的[传播学](https://zhida.zhihu.com/search?content_id=731024863&content_type=Answer&match_order=1&q=传播学&zhida_source=entity)和[文学史](https://zhida.zhihu.com/search?content_id=731024863&content_type=Answer&match_order=1&q=文学史&zhida_source=entity)命题，无异于让一个只会加减法的孩子去演算微积分。这不仅脱离了学生的认知水平和生活经验，更体现出命题者一种自以为是的“[宏大叙事](https://zhida.zhihu.com/search?content_id=731024863&content_type=Answer&match_order=1&q=宏大叙事&zhida_source=entity)”癖好。他们沉浸在自己的理论世界里，忘记了作文的根本是考察学生运用语言、表达思想的能力，而非逼迫学生去模仿学究式的空泛论证。\n\n再者，文章的形成与传播更是千变万化。有的作品可能一开始就以通俗的面貌出现，却因为其深刻的内涵和独特的魅力而广为流传，最终成为经典；有的专业研究，可能因为其颠覆性的发现而迅速破圈，成为社会热点；还有的作品，可能默默无闻数十年，在特定的历史语境下被重新发现，才得以“传世”。文章的命运，受限于时代背景、文化思潮、阅读习惯、媒体变迁等诸多因素，绝非几个简单的字眼就能框定其发展路径。将复杂的社会现象简单化、线性化，并以此作为学生的考题，不仅是对复杂性的漠视，更是对学生思考能力的轻视。\n\n这种“砖”家式的命题，其危害远不止于让学生困惑。它传递出一种错误的导向：似乎只有探讨这种“高大上”的抽象概念，才能体现思想深度。它鼓励学生脱离实际，去追逐那些貌似深刻实则空洞的“形而上”思考，而忽略了脚踏实地地观察生活、真诚地表达感受。当学生们绞尽脑汁地套用那些晦涩的理论，堆砌着看似“深刻”的句子时，他们真正对社会、对人生的感悟，反而被压抑了。\n\n说到底，作文题的根本目的是考察学生的思维和表达。一个好的作文题，应该能引导学生关注真实的世界，提出真切的问题，并用自己的语言去探索答案。而“专”“转”“传”这样的题目，与其说是引导思考，不如说是设定了一个迷宫，让学生在其中徒劳地寻找所谓的“标准答案”。这不禁让人想问，那些坐在象牙塔里设计考题的“砖”家们，是否真正俯下身来，倾听过烟火人间的声音？是否真正理解过，对于大多数普通学生而言，一篇真诚而有力的“转”文，可能比一篇故作高深的“专”文，更能触及他们的心灵，也更能启发他们对“传世”的真正思考。\n\n[编辑于 2025-06-07 13:21](https://www.zhihu.com/question/1914640704744957461/answer/1914666876044313788)","categories":["一些碎碎念"]},{"title":"互联网圣地一览","url":"/posts/1f6f93e44946/","content":"\n\n\n## [如何评价小红书？](https://www.zhihu.com/question/305033283/answer/3588581182)\n\n[![谢於飞Official](https://picx.zhimg.com/50/v2-c5b80a6bc246e479fa74f132b244162b_l.jpg?source=b6762063)](https://www.zhihu.com/people/xie-yu-tang-55)\n\n[谢於飞Official](https://www.zhihu.com/people/xie-yu-tang-55)\n\n写小说的电子宠物狐狸，合作/标明出处转载欢迎\n\n1443 人赞同了该回答\n\n![img](https://picx.zhimg.com/v2-6b1c11cae5c7be45ce6b85bcaf41b581_1440w.jpg)\n\n欢迎观看赛博厕所争霸记 叠甲环节在评论区 已完结\n\n<!--more-->\n\n刘**智孚**加班回家，推门看见儿子刘璧黎瘫在沙发上看纸片小人。\n\n儿子的名字本来想叫做刘**哔哩哔哩**[[1\\]](https://www.zhihu.com/#ref_1)，奈何遭妻子**洪晓淑**为首的一众家人坚决反对。于是刘智孚退而求其次，依照《诗经·国风·候风·大野》中描述国中美玉的“马璧黎璞，奠璧三狼”一句择出两个字，以附会这一谐音，“刘哔哩”则留作小名。\n\n刘璧黎问过刘智孚自己的名字是什么意思。\n\n“对，先问是不是，再问为什么。这首诗上半句说的是，雕刻着马的玉璧看起来十分朴实，好像没有加工的痕迹；下半句又在说在新的玉璧上打基础，准备在上面雕刻三匹狼。”他由衷希望儿子能尽早多受一些此方面的熏陶，好在今后的某一天能及时抛露出他们一家颇具文化底蕴的证明；而这一《诗经》篇目的真实性并不予以考定。\n\n![img](https://pica.zhimg.com/v2-af00b004e0e6a8969c5629c31f868578_1440w.jpg)\n\n打野走位我就觉得***离谱，你老在那想刷你那b三狼干什么玩意？\n\n洪晓淑则在搜罗一系列“小众英文名”“高级英文名”“英文名好听不俗有寓意”后，给儿子取下英文名Billy，为日后做留子作第一步准备。\n\n然而刘哔哩哔哩，不对，刘璧黎并没有成为国学神童或世界小公民。自从两年前拥有手机后接触了ACGN文化，刘璧黎就已脱胎换骨，今天也依然决心做一员守护最好の二次元的十一岁猛将。\n\n他说客厅这个空间充斥着三次元无趣大人的『气·味』，因此平时在家无事基本不会离开房间。今天他竟乐意出现在客厅沙发上使得刘智孚非常惊讶。\n\n“今天下午家里不知道怎么进来一只哈基米。”洪晓淑揭掉面膜，边匀快地拍着两颊边和刘智孚说话。她已经在同城快送下单了猫粮、猫砂、冻干、猫窝、猫条、猫条喂食神器等一系列物资，并差刘智孚过会趁快递站关门前快些去拿。\n\n“哈基米不是猫的意思！”刘璧黎宁愿暂停手中正操作的一款开放世界手游，也要抬起头来还嘴。\n\n“无语子！谁管它原先是个什么意思！”洪晓淑一拍沙发，“有点情绪价值好不好，就是因为你们这些人本来好好想看个小猫都烦得要死！”[[2\\]](https://www.zhihu.com/#ref_2)\n\n刘智孚还在餐桌上扒拉微波炉刚烘好的冷饭，团在沙发一角的猫许是受了惊，撒开腿往餐桌下凑过来。客厅的辩论也很快有了结果，以刘哔哩年幼势弱不敌母亲告终。\n\n“本人于今日为捍卫心中的热爱与原生家庭大吵一架，抽卡也歪破天际，现在感觉好像玉玉要发作了，望周知！”[[3\\]](https://www.zhihu.com/#ref_3)刘哔哩嘴上嘟嘟囔囔走回房间，离开时不忘带上那个有些泛黄的猫耳动漫少女四方抱枕。\n\n饭很快被扒得一干二净，碗底只残余着油渍和半片拟态成土豆的姜。刘智孚指着伏在地上的猫问：“这哈……猫怎么跑进来的？”\n\n气头上的洪晓淑并没有搭理他，只是敲了敲腕上的手表，穿戴甲片叩在表盘上瓷实地响。再过半个来小时只怕快递代收点要关门了。\n\n于是刘智孚也不再言语，把碗随手摔进水槽便出门去取快递，也好避一避室内的低气压。他大多数时候懒于理会此类起因简直难以理解的战争。\n\n独自走在暑天工作日夜晚的街道上，空调的清凉感拔离其身，至少在这一刻，他觉得自己活像个《瑞克和莫蒂》中的杰瑞·史密斯。不过再怎么样，自己也应该是文凭很亮眼的那种loser，至少在大都市还有一份提起来显得体面的工打。\n\n谈论学历时如果提到自己毕业于C9院校，大家便知道不是top2那两家；说是985则知道势必很难是C9中的某一所，说是211就基本能确定是非985的211。刘智孚及其都市精英同僚们都不愿将自己在鄙视链中平白无故降格。有时他们也乐意自谦，为自己履历上的高校拟一个例如“XX地XX职业技术学院”的名称，然后等待不解真相的半吊子发出嘲笑——在揭晓这所大专的真相时，获得了一种技高一筹的满足。\n\n刘智孚的本硕母校虽有985头衔，但知名度实在有限，因而错失了获得这一满足的机会。没有多少人能做到一看见那个地名就迅速反应过来背后的玄机。\n\n做题并非完全出于他的本心，但他又不得不借玩命做题换来的东西自我慰藉。至少他目前还是这个家中学历最高的人。\n\n甚至也不仅仅是这个家，算上邻居一家，他也是这整层楼学历最高的人。邻居——正这么想着，刘智孚回家路上忽然看见邻居**韦波**波站在小区路灯下，推辞不得打了个招呼。她正忙于通电话，似乎是在找人印一份什么启事，脚边不远处还蹲着两只流浪猫。\n\n关于家里那只哈基……猫的由来，刘智孚便有了大致的定论。不过这样的晚上实在不再是一个多生事端的好时候。依照以往经验，一般至多只需要等到下一个饭点，他们一家像这样的纷争就都不得不告一段落。只要他或者妻子喊一声“吃饭”，一切都会好起来的！\n\n然后口袋里电话毛骨悚然地震起来，大概是洪晓淑来催他撒气。刘智孚在电梯口迟疑过几秒还是接了。失灵的声控灯跺了两三次脚也亮不起来。\n\n她只是急匆匆说，你儿子被猫抓了！\n\n------\n\n原来刘哔哩哔哩回房摔过门之后就不管不顾，依旧留了小半片缝隙与门外相通。猫被方才的动静一激，下意识往窄缝里钻去，一进门看见人便跳上了他装塑料小人的那层书架。\n\n刘哔哩心脏冷冷一缩，忙站起身子伸手过去想把猫抱开；猫见了生人愈发害怕，两件立牌被扫到地上，弓起背缩在书架夹层一角向他哈气。\n\n望着凄惨伏在冰冷地上由双马尾变成单马尾的miku酱，刘哔哩一怒之下也不只怒了一下，鼓起勇气打算直接把哈基米抓下来，结果惨被亮出爪子在小臂上改了两记花刀。\n\n洪晓淑闻声赶到时来时已晚，只得当即搜了“被猫抓伤该怎么办”的攻略，马不停蹄拉着儿子去洗手间放水冲伤口。\n\n经此一役，刘璧黎对猫这一物种的态度发生了极大的改观。在去医院的路上，他一个劲追悔莫及自己方才的胆怯懦弱，后悔没把那只还被扣在屋里的猫揍上一顿，最好揍成猫meme里的尖叫小猫或者梨花带雨的香蕉猫。\n\n可当他一想到自己挚爱的那个猫耳纸片人美少女，想到姥爷家那只像是被烤焦过一样的乖巧暹罗猫，拳头又同儿时不慎脱手勾在树上的气球一样瘪了下去。于是所有喜恶上的矛盾被他最终整合为一句“好猫来了有猫条，键帽来了有飞脚”。\n\n随着疫苗凉丝丝推入血管，刘璧黎对事物两面性认知的客观度有了微小的进步。\n\n回到家时已是半夜，看见电梯里正对大门贴好的寻猫启事和上面的熟面孔，刘智孚一把将它撕了下来。洪晓淑催他快些去找邻居协商。她在手机上看见新闻，流浪猫致人受伤投喂者要负赔偿责任。\n\n邻居韦波波热爱投喂与精神投喂这片小区里的所有哈基米，有时还领着他们家一对龙凤胎，李**豆**豆和李**快**快一起投喂。这两个小名与那些“三花”“奶牛”“咪咪”之类猫的代号混到一起叫，有时刘智孚听见竟分不太清谁人谁猫。在她及同僚们的关照下，小区的哈基米一天天肉眼可见地变得巨大化，然而并不带去绝育也不找领养，每每到了它们发情和打斗的夜晚，业主群也能被带着一齐鬼叫起来。\n\n刘智孚拧紧自下班后一直没来得及解下的领带，停在邻居门前，握出一个矜持的拳眼。然而踱过几步思虑在三他还是放弃了，等到明天所有人醒后再议。他并不想给韦波波的丈夫李铁霸带去什么不好的印象。\n\n本地人李**铁霸**勉强算是一名北方魁梧男子，只是尚不清楚他这略显魁梧的轮廓出自动物脂肪还是结实的muscle。有传言说他其实姓孙，口中还总是念叨着“加三”“家桑”一样意味不明的音节。不过时日久下来刘智孚是清楚的，李铁霸看似猥琐凶恶，实则掌握许多方面的知识，兴趣爱好广泛。那个双眼弯弯瞥向一边，挑眉扬笑不语的表情也并非传闻中的有什么隐疾，而是他笑看世间风云的表征。日子一天天洗脱他两颊的绯红，两眉稀疏成棕灰色，只有那弯滑稽的嘴角还始终没有垮下去。\n\n![img](https://pic1.zhimg.com/v2-56da416a609a1e34176d2f3ca6672fa2_1440w.jpg)\n\n滑稽树上滑稽果 滑稽树下你和我\n\n刘智孚不是没有试图模仿过这一经典表情，不过他的眉毛始终挑不起来，也不知是老板还是多年的做题经历催折了这两条肌肉。他更为经典的表情还是双手托腮作惊喜状，神采飞扬中又透着一丝天马行空的嘲讽。他一向对隔壁的铁霸老哥抱有好感；如若这样一个妙人没有背一份大专学历的案底，在他心目中还要更敬上几分。殊不知李铁霸对他没有投以同样的好感。\n\n![img](https://pic2.zhimg.com/v2-03c5cad0e660ad3cb574b6cb223e9acd_1440w.jpg)\n\n这个表情会是攻击性皇冠上的明珠吗\n\n------\n\n李铁霸其实不喜欢猫，他更喜欢老鼠。因此在邻居那有点过于城市化的一家子提着寻猫启事上门时，他端出了一副希望能严肃处理的正常态度。他心里认为在线上可以做做狗，线下最好还是做哥。\n\n他尝试把妻子从厕所喊出来，效果适得其反，她在邻居面前也并不掩饰平日的习惯，喜欢待在厕所里骂骂咧咧。\n\n这一嗓子倒是招来了李豆豆和李快快，上前毫不见外地把手放到刘哔哩手臂的纱布上，问他手是不是断了。刘哔哩没什么好气地甩开手说，还不是你们喂的那只猫抓的。\n\n尽管自己也还在备战小升初，对于隔壁的这对熊孩子刘哔哩也从来没有耐烦过。妹妹李豆豆总是不合时宜地爆发出十分欠揍的笑声，还试图染指他所希望守护的最好の二次元；那个当哥的则整天叼着棒棒糖惺惺然作社会大哥态，谁问他话还都这么回答：等你们到了我这个年纪就明白了。有一次刘璧黎无意间看见他在用记号笔给自己和妹妹画天眼。\n\n偏生这对熊孩子还总爱偶尔过来招招他的注意，就好像新挖出来两粒鼻孔处毛囊分泌物又找不到纸，甩又甩不掉，一直黏着又觉得恶心。\n\n“你的启事上这只猫现在关在我们家。”刘智孚开口，“昨晚跑进来抓了刘璧黎的手。”\n\n“会不会是你们先惹到它了？我们小区的猫猫都是很乖很乖的宝宝，之前业主群里那几次应该都是其他地方的猫猫咬的，它们不被人招惹就不会……”\n\n洪晓淑在一旁喝着茶水打量起韦波波，当然需要特别强调，是不带性凝视意味的那一种，持有的更多是她自己不认为有的敌意。在新搬到这处公寓的时候，她总对隔壁的这位同龄女子怀着一种天然的亲近感。日久天长才发现她只是个市侩的前厂妹——她不会挑出片的街道进行五百米以内路程的***citywalk\\***，也不进行街头***brunch\\***；洪晓淑请过她喝***starbucks\\***吃小甜品，问她曾接到过什么***offer\\***，有没有推荐的***elegant\\***的***dress\\***，对于孩子今后的教育发展是否作了什么***plan\\***，她都一问三不知。\n\n她只好尝试自己打开话题：“我和队友打算让刘璧黎在小升初后去考一次IETS，第一次体验的结果也不重要，重要的是熟悉那个环境……我们希望日后能送他出国深造。”\n\n“出国？”韦波波正往随意点的冰美式里倒着白砂糖，手抖上一抖，故作神秘地凑近问她：“你们家该不会是那种……罕见吧？”\n\n你骂谁罕见？骂谁罕见！洪晓淑连连辩解，又一次叉开了话题。\n\n夫哈基米者，互联网宗教动物是也。有关哈基米的话题稍有不慎重都有可能掀起舆论风波。刘智孚选择性忽略她那段“不惹不应激”的论述道：“我们今天上门拜访，一个是希望你们能把猫领回来好好处理；另一个是希望能够按法律补偿医疗费用。大家邻居一场，还望有事好好商量。”\n\n刘哔哩还想补充，还有miku酱立牌的损失；但是他实在不敢当着父母面报出这些爱物的真实价位，只好含泪作罢。\n\n讨厌一切磨唧表面功夫的李铁霸拦在妻子前面，当场就把这两件事答应下来并道歉送客。他只想让刘智孚和洪晓淑快滚。因为他还要忙着打个胶先——当然，是给家里阳台的玻璃。\n\n------\n\n晚间隔壁的架如约吵了起来，龙凤胎在鬼哭狼嚎。窗外北方的暴风雨呜咽起来，像十万个电棍otto在一齐鬼叫。刘璧黎扫了眼英语单词书，实在是兴趣全无——事实上父母所要求他掌握的这些超前内容他可谓一窍不通，他也只玩国产或有汉化的游戏；其余感兴趣的便看几个视频，然后对外信誓旦旦假装自己玩过。\n\n洪晓淑对着超绝ins风补光镜打着圈揉脸上的卸妆泥，由内向外按摩着脸颊，也许这样做能把面部的纹路熨烫平整。她说话总是带许多夸张的表情，就像意大利人的手势一样缺少了便讲不成话；在之后往往又幡然醒悟，试图补救。\n\n难得清闲的刘智孚靠在沙发一角抱着手机读电子书。他算起来这是自己硕士毕业留在这座城市的第十七年，同时拥有第一份自己的房产和贷款的第十四年，从租来的婚房搬到自己新居的第五年。日子琐碎着一天天掉落而去，留下的塌陷好像把前后部分翻折过来接上去也没什么不妥当。\n\n他在过年回乡时父母安排的相亲中认识了洪晓淑，恰好二人条件也还都略高于对方的容忍底线，于是一切条件谈妥后，不出几个月就毫无波澜地成了婚。在此之前洪晓淑的职业一直是正在考编，在此之后便和他一起搬到了此处，而编始终没有考成。他们就和许多人一样，急匆匆把自己在婚姻市场上发卖了出去。\n\n两个人都对这样的生活状态保持大体的默契。两个人都没有深刻了解对方的行动和主观意愿。他想她既情绪化又深中消费主义的毒，把生活钻营出一派繁荣的假象；她想他既冷漠刻薄又乏味干瘪，还总是满口难懂冗长的怪话。\n\n他们只是顺其自然地，像过去的所有人一样交换戒指、唾液和染色体，因此到现在除了柴米油盐与家事之外竟不知道还有什么话题能开得了口。然而两个人都不否认实际上难以离开对方而体面生存。他们需要一只能在城市中搭伙过日子的同巢的鸟，一份能糊弄着交上去的答卷，以及一份用于欺骗自己去迈入都会才俊行列的凭证。\n\n“老家也在下暴雨。”他对洪晓淑说，身后的玻璃窗景上滚满浓黑的云团，夕阳与月光都没能够破开一隙。\n\n对方回首看他，许久接不上一句话来。\n\n------\n\n回首五年间和邻居的往来，洪晓淑最引以为傲的是竟没有真正撕破脸过。\n\n就连韦波波的发小**窦绊**来的时候也没有过。\n\n论学历窦绊和刘智孚不相上下，还常提及自己读过的许多书与对文艺作品的高见，因此洪晓淑夫妇起初对她青眼有加，认为总与那对俗人夫妇混迹会损了她的清雅。\n\n对于李铁霸和刘智孚一类的异性，以及他们制造的三个人类幼崽，因她奉行的一些主义窦绊从来没有过好脸色。至于洪晓淑，窦绊毫不客气当着两家人面暗讽她：自以为自身充盈着后现代性带来的多元进步，行为上又毫无自知地投向现代甚至前现代的家庭生活的驴子。\n\n前面大段话让她文化水平不高的发小两口子没听懂，理工科出身且鄙视文科的刘智孚没听懂，整日搜罗复制文艺小众学术文案的洪晓淑听得半懂不懂。不过他们都还不至于听不懂最后两个字。\n\n刘智孚先是一张少见的热脸贴了许久冷屁股，又对窦绊提及的一系列极端理论忍无可忍。他一反常态地洗去身上的畏缩圆滑感，想要与她辩论吵嘴个不死不休或干脆掀桌子走人。而同一战壕下洪晓淑少有的并没有受情绪和激素支配，一反常态地按住他保存着体面离了席。后来窦绊的故事则全靠从藏不住八卦的韦波波口中知悉了。\n\n在这层楼的所有裸猿中，她只瞧得顺眼发小韦波波一个；一是因为她能与自己畅谈明星八卦；二是因为她能时刻容忍并附和自己的极端发言。然而她毕竟文化层次不足，没有同自己分析讨论经书的能力；身边其他人又往往视她为一个阴湿的文青病患者，总是敬而远之。窦绊的人生底色始终是孤独与45°仰望蓝调时刻出现的晚空，然后随机抽一部小说/电影/游戏进行批判吐槽。久而久之世界上的绝大多数事物都瞧不上眼了。\n\n通过二分法自判为[INFP人格](https://zhida.zhihu.com/search?content_id=682539708&content_type=Answer&match_order=1&q=INFP人格&zhida_source=entity)后不久，窦绊对周遭一切的厌恶便愈演愈烈。空气是污浊的、大地是下沉的、人类是现实而严酷的——但是只要换一个充满人文关怀的乌托邦生活，一切都会好起来的！\n\n于是她不太清楚用了什么方式——总之抛下所有负累只身远渡心中的理想国度（之一），并更名为窦野绊子。然而始终没有再找到工作，生活起居也全靠网友与韦波波等尚保持联系的旧识资助。再后来韦波波也有些厌倦了她祝故地饿殍遍地的言论，主要是因这一地图炮将自己也毫不留情囊括了进去，于是打款的话也不再提了。\n\n后来呢？刘智孚问。他平生爱好之一就是问问题。\n\n倒数第二次有窦野绊子的消息是约摸一年前。彼时她几近弹尽粮绝，所幸还收到几份打款，尚可以支撑一些时日；然而功德箱里的最后几个子全用在了买漫画书与健身上，最后也没有打算去上班，靠喝无糖可乐过活一天是一天。\n\n最后一次则是在新闻上，洪晓淑一家又看到那张半生不熟的脸。大约窦野绊子确乎是饿死了；死前不忘扬起手给了现代工业文明一记奇幻的耳刮子。[[4\\]](https://www.zhihu.com/#ref_4)\n\n------\n\n经此一事后洪晓淑便格外关注刘哔哩的兴趣爱好，十分担忧这些充斥血腥暴力与软色情的东洋纸片角色会对他幼小的心灵造成什么不好的导向。\n\n她先是怕儿子成为第二个窦野绊子，可无论怎样看似乎都是丈夫和她的相似性更高一些。她又怕儿子往同班一个小女孩的方向发展——这就不得不提到韦波波那个长得几分像她的侄女**[秋空涧](https://zhida.zhihu.com/search?content_id=682539708&content_type=Answer&match_order=1&q=秋空涧&zhida_source=entity)**。\n\n秋空涧与刘璧黎因在几乎相同的时间点喜欢上ACGN文化，在两年前关系熟络过一段时间。不过没有太久她就主动要求与刘璧黎分道扬镳了，给出的绝交理由有三：其一，刘璧黎的性染色体恰恰好和她不同；其二，刘璧黎在欣赏作品和磕CP上的品味恰恰好和她十分不一致；其三，刘璧黎恰恰好精神目前来看十分正常，是偷了她人生的健人。其实秋空涧家里要比他们家还富裕一些，也没做过什么实在对不起她的事，刘璧黎回家嘀咕道。\n\n自从被猫挠伤之后，洪晓淑尤其害怕刘璧黎手上留疤，怕这两道疤痕再结合上儿子宅居已久的阴沉气质，让他被认为是那种『地雷系男子』。刘璧黎自然也不愿意落得这样的印象，于是总十分勤勉地涂祛疤药。\n\n毕竟追溯起来一切都是从那天开始的：秋空涧迷上一个叫做什么啥啥重度依赖的游戏，从此以“地雷女”自居，并开展了对刘璧黎的切割行动。事后刘璧黎也很快在所有平台上拉黑了回去。对于秋空涧平时会发布的内容，他实在有些赛博晕血；对感冒药也没什么过量服用的嗜好。他们对玉玉，尤其是赛博玉玉的理解好像有些不太一样。\n\n再看刘智孚，他依然抱着手机，往网上敲着长篇大论。刘智孚三大爱好：在网络上辨经、抖机灵、问问题。不过许多时候他的问题往往口出惊人。两天前他刚问过刘哔哩，假如发生了火灾——一只哈基米，一盆会大声喊叫的下北泽绿萝，一只抖擞精神的果蝇，一幅价值上亿的世界名画和三块钱，你会救哪一个？[[5\\]](https://www.zhihu.com/#ref_5)\n\n刘哔哩无辜道，爸你每次都给我开这种几个亿的条件，就没有哪一次真的给我过。还不如选三块钱，起码这一个你真的有可能给我，还能买瓶快乐水玩游戏的时候慢慢喝。\n\n洪晓淑心想要弥补邻里关系间的裂痕，靠这俩父子绝对不会有什么好进展。于是她自作主张去邀请邻居一家周末抽一天一同出去野营。\n\n------\n\n“野营”二字对户外生存及钓鱼爱好者李铁霸的吸引力不亚于分享八卦对韦波波，摇花手对李快快和李豆豆。不管他再怎么对隔壁一家子颇有微词，也破天荒地答应韦波波，2.5个月内不再调侃她idol的篮球技术和出圈歌词，从而换来了对这次两家人集体活动的同意。\n\n为了这趟野营洪晓淑准备了满满当当两三箱物资，最后一家三口一人拖一个大件上场，以最少的总体及个体肌肉量打出了最高的人均承重。\n\n她先是取出消毒湿巾、清洁剂和玻璃刮板，里里外外将李铁霸车的窗玻璃、座位等擦过了一遍才肯上座，不忘在座位扶手上支好空气加湿器和塑料花瓶，贴好塑料袋与一次性座椅垫。另几个人被三十度的天蒸得视线模糊起来。\n\n李豆豆有样学样着也一起拾掇，她不知什么时候要了块汽车清洁泥正对着车门把手来回搓弄。\n\n李铁霸见状大声喊道：“要走了李斗音！”他不顾还敞开着的车门，故意弄出了些汽车发动的声响。\n\n大约两小时的车程也并不清闲。\n\n洪晓淑摆出一套精致茶具，当场在便捷烧水壶里烧沸了水浇到茶包上。她本打算借这段空档期来一套手膜脚膜护理，然而实在不便在他人车上脱掉鞋袜，想到此处就更愤恨刘智孚：他竟然没有一辆可供浩荡巡游的七座车，整天只紧着那辆五座车开，以至于落得全家委身搭邻居车的下场。\n\n往郊区去的路上信号时断时续，刘璧黎只能暂时放下了他心爱的开放世界游戏，缩在靠窗座位上戴着耳麦，幻想自己是前往未知剧情发生地的高冷主角。韦波波手机上输了牌气得“啊啊啊啊啊啊啊”嚎起来；两个熊孩子抢清洁泥玩拌了嘴，现在在比赛音量。他作出猜到结局的姿态手附在嘴边搬弄洋文道，西内！从而获得了暂时精神上的胜利。\n\n刘智孚许久没有从驾驶座上解放出来，正单手扒拉着椅背凑上前去问李铁霸问题。\n\n“如果你吃了一小勺……”[[6\\]](https://www.zhihu.com/#ref_6)\n\n“没兴趣吃捏。加三。”\n\n“如何用‘勾子’[[7\\]](https://www.zhihu.com/#ref_7)、‘爆兵’[[8\\]](https://www.zhihu.com/#ref_8)、‘salt选’造句？”[[9\\]](https://www.zhihu.com/#ref_9)\n\n“没文化，不会造。”\n\n刘智孚咽咽口水，十分郑重地想吸引他的兴趣：“如果给你十个亿，但是会有一只蜗牛追杀你……”[[10\\]](https://www.zhihu.com/#ref_10)\n\n“老子这一包装备还怕只蜗牛？”\n\n烦不胜烦的李铁霸终于把车停在了一片林子前的土路上。周围没有商圈，没有游客服务中心，也没有其他露营者。\n\n“我们不是出来露营的吗？”洪晓淑手忙脚乱收拾着那堆茶具花瓶和化妆品问。\n\n“这不是露营什么是露营？”李铁霸背上塞满装备的户外包难以置信地看他，显然他们对露营的理解很不一致。而从约定到出发期间，洪晓淑并没有提出具体的露营地点与方案——哪怕她已经在手机备忘录上敲了满满一屏幕。在洪晓淑心里，光“李铁霸”三个字就足以构成一句攻击力拉满的藏话。\n\n剩下所有人对他们的争执都不置可否，甚至略有对露营取消班师回朝的期待。毕竟他们都没什么外出露营的主观意愿。\n\n李铁霸扛着钓鱼设备悠哉哉不再管她，一边为洪晓淑破防而窃喜，一边为如愿实现了钓鱼的计划喜出望外。刘智孚希望他最好能钓上两条银鱼——这样他就能做那道唯一擅长的蒸制银鱼，而不用因为做了西葫芦炖茄子[[11\\]](https://www.zhihu.com/#ref_11)被嫌弃上半天。不管是哪一方面的口味，他都能把蒸制银鱼暗搓搓玩出花来。\n\n“出来玩就别整天抱着你那个手机看动画片！生活的仪式感就是被你们这种人破坏的！”气不过的洪晓淑朝儿子嚷。\n\n刘哔哩本在搜索有关如何搭帐篷的视频准备帮忙，听了便委屈得气不打一处来——我们高贵的二次元动漫才不是动画片！他接着拉开嗓子喊回去，我也不是你们的垃圾桶！\n\n“什么垃不垃圾桶的！我只是坚持我的情绪自由……”\n\n情绪自由像是凌晨五更的公鸡。只要有一处叫响起来，其他的便也要接二连三争先恐后地叫，生怕叫少了叫晚了自己吃亏。刘智孚蹲在河边洗菜，骂声哭声反驳声，声声入耳。附近再叫好上一声，他就知道是李铁霸钓上鱼了。\n\n------\n\n“鱼咽丁真，鉴定为，最后的dinner。”李铁霸在把鱼从鱼钩上解下来时信口念道，脸上还是那副经典的滑稽表情。\n\n正逢韦波波来催他搭帐篷。他一竖眉反激道，xxn，你们自己没手吗？\n\n“你……你急了！”她先是憋出一句不痛不痒的话来，对方因难得钓到鱼而并不放在心上，因此只好加大输出力度，成了大段的□□、□□□、□□□□□。\n\n笑容从李铁霸脸上滑下来，又守恒地长到过来想缓和气氛的刘智孚脸上。\n\n“别踏马在旁边洗你那个菜了行不行？半天才钓起来一条，我看十有八九是你菜上面的转基因农药害的！”\n\n这句话彻底幻灭了李铁霸在刘智孚心目中的所有滤镜，或者说是袪了魅。他想撕去那层粉饰出的体面，他也不过就是个没什么文化还反智的乌合之众，注定和自己有层壁——他刘智孚早该看清楚了！\n\n刘智孚复盘着对门夫妇的一系列言行，他们唯一的好处就是运气好投胎时捡了个好户口，因此获得了不需要拼死做题，认知水平低下至此也能活得下去的权利。\n\n这时洪晓淑见韦波波一脸死气走回来，开口正想附和她骂道：“男的就是这样……”\n\n这一次韦波波并没有领她的情。方才在车上洪晓淑掏出一瓶熏人的香水四处喷，偏偏那个牌子还是她idol对家代的言；她还报出一堆自己不甚了解的咖啡名字问大家觉得哪个好些，多少有暗讽她不懂的嫌疑；尤其是他们一家害得自己不得不把那只没驱虫没打疫苗没绝育的猫关在家里养了许多天，等风头过了才悄悄又放回去——“我们家的事再怎么样也关你屁事！别整天端着你那副精致利己的优越感来指挥人！”\n\n这场ghg的壮美梦想就此成了泡影。洪晓淑的和平政策彻底破产，纯粹正面攻击又技不如人，因故只能在阴阳怪气和翻旧账中寻找突破口。她本意是好的，全被韦波波给执行坏了——她才意识到每个在某一身份上是同类的人事实上都不只单具有这一重身份，其他身份的立场一犯冲时照样能冷不丁来一记背刺。她开始理解窦野绊子在宣扬极端思想时为何总是优先攻击同性了。\n\n刘璧黎坐在树荫下打开红色音乐软件，准备在到点前提前酝酿好情绪到网上控诉今日的一切；记得这次一定要把三连放在中间。李快快和李豆豆则趁机悄悄摸出母亲的手机畅快地玩起游戏，又为谁来操作地狱火皮肤的孙悟空争得相互扭打起来。\n\n亲情是基因导致的幻想；友情是社会性导致的幻想；爱情是更加虚无缥缈的、繁衍冲动和文艺作品共同导致的幻想。\n\n所有人都痛苦，所有人都活该。刘智孚感叹道，大概他们这些人本来就不适合待在一处。\n\n他一声不响迈步走开想透透气，任凭手机丢在散落一地的帐篷零件上，任凭黑云从所有人的视线盲区翻滚着压下来。\n\n------\n\n“你就这么把猫放了？不做驱虫不做绝育还散养猫？”洪晓淑还在逼问。\n\n“它是自由小猫！你个虐猫犯！绝对是你们一家虐猫犯先动的手！”韦波波已经同她吵了许多轮，每僵持不下就换一个话题，从楼道空间的占用到蹭用wifi，再到猫的旧账。李铁霸见拉不开架彻底甩手去守着钓竿。他也实在乐意看人吵架，因此听得津津有味而不再注意周围环境的动向。\n\n“你……你等着！回去我要找物业投诉你们索赔！”\n\n“你就这么对哈基米的？”\n\n刘璧黎摘下耳机忍无可忍，嗓子里带着血气嘶吼道：“都说了多少遍哈基米不是小猫的意思！”\n\n“大人说话你个小孩插什么嘴！你们家怎么教的？”\n\n“不看看你们家两个缺教养的脸都打肿了！衣服上滚一身泥！”\n\n李铁霸回神正打算去拉架，再一个崽子给上一脑瓜崩；忽然他面色就冷寂下来变得铁青了——他听见了不远处暴雨的穿林打叶声。\n\n在无人问津的地方，刘智孚迎着野地上的风已出走了不太清楚多远。他什么都没来得及带走，从早熬到晚饥胃也开始暗自厮磨；然而飘飘然地十分松快。\n\n他总是问许多问题——然而他什么问题都没有真正解决。他并不喜欢所有人。也没有人喜欢他。曾经引以为豪的文凭与知识都不知不觉间萎缩下去，剩下一具愈发外强中干的精英才俊的空壳。黄金时代猝不及防远去了，留下一地鸡毛。\n\n头一遭他感觉野外是个好地方，不聒噪也不沉重。只有雨从昏黑天上越织越密打下来。\n\n四周已经不再有树或者其他可供躲避的地方了。刘智孚想回头跑，雨雾弥漫间早已不大能清楚来处；偏生又来不及看路绊倒在一块板结焦枯的灌木根上。\n\n刘智孚就这么跪伏着，任凉彻刺骨的雨打透全身。\n\n他来到了没有知识的荒原。\n\n**——END——**\n\n------\n\n不管怎么样这篇抽象玩意也算是写完了。多少可以欺骗一下自己，这个暑假也不是那么一事无成。\n\n接下来按计划该好好写些不那么抽象的玩意，大家喜欢的话不妨赏个脸看一看，就当是零成本入原始股了。再一次感谢您的阅读。\n\n如果赛博厕所争霸战中选手的大量攻击性令陛下龙颜不悦，不妨连点两下屏幕，赏作者一记电子大板。这样下次还敢。\n\n------\n\n9.9更新：本来暂时不打算修改，因为改了之后下面的ip就会从家里的变成学校的，就像又提醒了自己一遍“暑假结束了”一样。\n\n主要是这两天似乎被限流了，遂发出宇宙安全声明。\n\n刘智孚青天大老爷！！！刘智孚是中文互联网最优秀的社区！！！不会放过任何一个坏人，不会冤枉任何一个好人！！！\n\n本篇意在平等地AOE调侃，没有专门针对刘智孚进行攻击的意思！！！刘智孚青天大老爷明鉴！！！\n\n五百多赞了，感谢大家的支持。\n\n10.7更新：假期又要结束了，默哀。虎扑DLC狂暴码字中喵\n\n## 参考\n\n1.  [^](https://www.zhihu.com/#ref_1_0)参考文献与脑洞出处 https://www.zhihu.com/question/385926431/answer/1143617694\n2.  [^](https://www.zhihu.com/#ref_2_0)参考文献：不贴了，怕被骂\n3.  [^](https://www.zhihu.com/#ref_3_0)参考文献：有点多，不知道该贴哪一份\n4.  [^](https://www.zhihu.com/#ref_4_0)致敬传奇游戏《饿殍：明末千里行》 https://www.zhihu.com/question/620484340/answer/3198026737\n5.  [^](https://www.zhihu.com/#ref_5_0)参考文献：这个系列太多了有些标不过来 https://www.zhihu.com/question/613256470/answer/3136100163\n6.  [^](https://www.zhihu.com/#ref_6_0)这个系列同样也很多 https://www.zhihu.com/question/60746687/answer/182787642\n7.  [^](https://www.zhihu.com/#ref_7_0)原典已失传 记得按时间排序 https://www.zhihu.com/question/319334362/answers/updated\n8.  [^](https://www.zhihu.com/#ref_8_0)感谢每位古文献补档的贡献者 https://www.zhihu.com/question/645783781/answer/3566084621\n9.  [^](https://www.zhihu.com/#ref_9_0)日出蝉鸣！ https://www.zhihu.com/question/620871517/answer/3235729847\n10.  [^](https://www.zhihu.com/#ref_10_0)经典中的经典 https://www.zhihu.com/question/286619877/answer/1616792247\n11.  [^](https://www.zhihu.com/#ref_11_0)知乎名菜 https://www.zhihu.com/question/572672532/answer/2839410952\n\n[编辑于 2024-10-07 18:19](https://www.zhihu.com/question/305033283/answer/3588581182)","categories":["一些碎碎念"]},{"title":"为什么说高考是不公平的--驳[高考公平论]的六大经典误区","url":"/posts/915ecb4cd831/","content":"\n作者：Liuuzaki\n链接：https://zhuanlan.zhihu.com/p/31120034016\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n```text\n//原文写于2023.3.25。现第四次尝试发在知乎。\n```\n\n中国高考公平性的问题，最迟在200x年的国内论坛上就已经得到了充分讨论。但近来总能看到一些经久不衰的错误观点。笔者在这里总结一下如何反驳这些错误观点，以后对线时可拿去用。\n\n在以下的讨论中，笔者对大多数的错误观点都会构筑多层次的反驳。就算你成功突破了第一层论证，也还会有第二第三道防线等着你——但这并不意味着我对第一道防线缺乏信心。事实上，以大多数错误观点的离谱程度，仅第一道防线就已经不可逾越了。\n\n## 1. 全国统一录取会损害落后地区利益？\n\n面对改善高考公平性的呼声，经常有这样一种声音：\n\n>   如果全国统一录取，高考大省是开心了，西藏青海这些落后地区的学生就没学上了。\n\n这显然是在树稻草人——立靶子自己打。\n\n人们呼吁高考公平，自然不是期待机械地按高考分数统一录取。几乎不会有人反对为落后地区提供一定优待，人们反对的从来就是对全国最发达的直辖市提供优待，这无论如何都说不过去。\n\n刘瑜教授对此曾有一段经典的论述，节选如下：\n\n>   假设你来自于火星，突然被扔到中国，你可能被扔到北京这样的大城市，也可能被扔到河南这样的内地省份，甚至还可能被扔到西藏这样的边疆地区。这个时候，让你来设计一个理想的高考分数线制度，你会怎么设计？  \n>   你可能会说：3个地方分数线一样嘛！大家公平竞争嘛！  \n>   你也可能会说：让边区分数线低一点，其他两个地方一样，因为那些地区贫穷，教育条件有限，人家北京上海的孩子用电脑打字，俺们这里还是凿壁借光呢。  \n>   你还可能会说：我选择让北京上海分数线低一点，其他两个地方一样。因为……因为……咦？你们地球夏天真热啊！  \n>   我们知道，这三种选择，第一种叫“程序性正义原则”；第二种叫”补偿性正义原则”；第三种，姑且称之为“夏天总是很热”原则吧。\n\n中国夏天真热啊。\n\n![img](https://picx.zhimg.com/v2-c6eb0a720491ceaf12990d498c9810cb_1440w.jpg)\n\n此外，除较激进的同卷同分录取之外，还有一种温和的改良方式，即仍分省录取，但录取名额按照人口数量来分配。在技术上，大致存在三种方案：\n\n-   按人口数量分配名额。对此的反对意见是，这没有考虑人口年龄结构，外来务工人口较多的京沪会获得不成比例的名额分配。\n-   按高考人数分配名额。对此的反对意见是，这样会造成各省鼓励社会考生报考，从而分到更多的名额。但这可以通过只计算应届考生来规避。\n-   按适龄人口数量分配名额。与只计算应届考生类似，可以规避以上的反对意见，是可以采取的方案。\n\n综上所述，技术上的难题完全可以用非常简单的手段解决。\n\n这种较温和的改良不但不会损害落后地区的利益，反而可能是过度照顾了。但这也不是什么大问题，继续微调名额分配即可。\n\n## 2. 问题出在经济上吗？\n\n许多人，包括国外的一些人都认为：\n\n>   中国高考的不公平只是地区经济发展不均衡的缩影，某些地方经济发达，本地的大学多，录取率自然就高。\n\n这种说法有一定道理，但若把不公平全部归咎于经济发展不均衡，就是一种对中国国情的无知了。\n\n首先，最大的问题：中国不是联邦，更不是邦联。中国的省也不是加盟国，而是一个统一国家中的行政区划。以省为界的各种经济政策本身就是一种更大的不公平（老生常谈之河南耕地红线），把高考的不公平归结到这里，就好像在说「我不是在强奸，我只是在杀人而已」。\n\n但本文也无意讨论这些更大的不公平。因为即使把目光局限在高考制度本身，也容易发现，经济因素并不能解释其所有的不公平。\n\n这里提供一张2022年的985大学招生人数表：\n\n![img](https://pica.zhimg.com/v2-d3318963b5c44c65f871de1e8fe9027a_1440w.jpg)\n\n这里的重点是「外地招生率」这一栏，意思是排除本地招生后，考生被外地高校录取的几率。例如广东考生被中山大学录取，就是「本地招生」；被四川大学录取，就会算进「外地招生」。\n\n可以看到，即使在排除了本地招生后，京津（还是应该叫津京？）的录取率仍然是全国平均水平的两三倍。例如，武汉大学在北京的招生率是万分之19，在河北只有万分之3。\n\n既然连外地高校也倾向于录取京津考生，那么高考不公平就不能用「各地高校数量不均衡」来解释，这其中一定有另一股神秘力量在起作用。而我们知道，所有高校招生计划都要交教育部审核，而几乎所有的「好大学」都是直属于教育部。所以这股神秘力量，其实也并不那么神秘。\n\n此外，聪明的你一定发现了，在上表中居然一眼找不到上海。仔细看才会发现，上海仅以万分之161的外地招生率排在全国中游。而上海的总录取率是688，超过北京排在全国第一。这意味着上海的高录取率确实是靠上海本地高校支撑的，没有向外地索取过多名额。\n\n但优先录取本地考生就合理了吗？笔者并不打算让上海置身事外。\n\n## 3. 交税多就该优先上学？\n\n要把高考不公平归咎于经济发展，有一个重要前提：\n\n>   除了中央的拨款，各地财政也为本地高校经费做了很大贡献，因此优先录取本地考生也是应该的。\n\n这也就是本地保护主义。\n\n对于这种观点，笔者就直说了：这是在刨国家合法性的祖坟——无论纳税额多少，公民一律享有平等权利，这本是现代国家的共识和常识。但笔者也不打算用大道理来压人，我们可以做一个思想实验，把上述常识重新发明一遍。\n\n这个思想实验也非常简单：假设我是个广东人，我能不能通过向上海政府捐献教育经费，达到上海人民的平均贡献水平，从而享有上海市的录取率？\n\n这个平均贡献的上限是上海市教育总支出除以户籍人口，即每人每年6000元。三口之家供一人上学，就是每年18000元。只算高校经费或扣除常住上海的外地人的贡献后，还会更低。就这个价位，中国的普通城镇家庭挤一挤都能负担得起。\n\n甚至我们还可以继续拓展：假设我很有钱，我能不能每年捐五万元，五十万元，从而享有比上海市还高的录取率？\n\n通过这个思想实验，我们很容易看出，钱只是借口而已。有些人有资格多交钱来换取高录取率，大多数人却连多交钱的资格都没有。所以这从来不是个经济问题，由行政力量控制的「交钱的资格」才是问题的关键。\n\n所有的财政、经费、拨款，归根结底都是钱。既然你堂而皇之地用「钱」当做区别对待的理由，那你还有什么立场去反对花钱买名额呢？许多人恐怕只是叶公好龙而已，嘴上说着「没钱怎么建设教育」，当富人们拿着钱来买录取名额时，又吓得失魂落魄。\n\n笔者相信，中国的绝大多数人都会反对花钱买名额，那么我们也要同样地反对本地保护主义。我们既然走的是社会主义道路，就不能容许这种事情出现。\n\n## 4. 你们是谁？我们又是谁？\n\n基于本地保护主义，还有个常见推论：\n\n>   谁让你们不建大学的？目光短浅就活该没学上。\n\n然后可能还会举出当年中科大迁河南被拒绝的故事作为例证。\n\n这一观点的前提仍然是本地保护主义，它本身的问题在上文中已有充分论证，此处不再赘述。在这里笔者主要想问一个问题：「你们」指的到底是谁？\n\n不装外宾的话，大家都知道，假设我是一名河南省的普通居民，那我对「建大学」这种大事是没有任何话语权的。即使是京津沪的普通居民，话语权也不会比我更多——我们都是一样的平头老百姓。所以，建不建大学的问题为什么要问我呢？难道不是应该问河南政府吗？\n\n没有话语权更没有决策权的两拨人，本就不应该相互对立。如果一定要概括出两个对立的整体，那么一定是「掌握决策权却拒绝高考公平的官员」与「盼望高考公平的百姓」，这两者不因省界而异。河南的领导，可能跟上面穿一条裤子，可能受上面掣肘，可能是单纯目光短浅。无论如何，我都不认为他是「我们」自己人。\n\n## 5. 不严格执行计划生育就活该没学上？\n\n还有一种流行的观点是：\n\n>   某些地区严格执行计划生育，自然竞争压力小；某些地区喜欢生一堆孩子，活该他们没学上。\n\n这是非常简单的事实错误，用几条数据就可以否定这一说法。\n\n计划生育政策在70年代末实行，1982年正式写入国策，当年出生的孩子会在90年代末参加高考。而就在2001年，山东与北京同一张卷子的一本线相差120分，来自青岛的三位同学因此把教育部告上了法庭。\n\n于是我们知道，有记录可考的高考不公，至少可以上溯到2001年。以政策一向的惯性，大概率还要再往前追溯。而那时参加高考的学生出生的时候，计划生育政策还没有实行。\n\n当然，2001年的事已经过去，有没有可能如今的高考变得公平了一些呢？\n\n我们以有记录可考的最早的1978年出生人口为基准，看看计划生育到底起到了怎样的效果。\n\n根据各地统计年鉴，我们知道：\n\n-   1978年北京出生人口10.8万[[1\\]](#ref_1)，同年湖南出生人口89.4万[[2\\]](#ref_2)，浙江出生人口67.8万[[3\\]](#ref_3) \n-   2004年（对应2022年高考）北京市出生人口6.6万，同年湖南出生人口79.4万，浙江出生人口50.1万\n\n在二十多年的计划生育之后，北京市的出生人口下降到了原来的61%，浙江下降到了74%，湖南下降到了89%，似乎北京市的计生成效确实更为显著。但我们可以从上面的2022年985录取情况表中知道，如今北京的985录取率是浙江的4.5倍，湖南的4倍。这点计生成效的差距，远不足以解释这么巨大的录取率差距。\n\n更进一步地，即使抛开以上事实不谈，仅从道德层面看，「不严格计划生育就活该没学上」这种观点也是相当可怕的，它等于是在公开宣扬「多孩家庭的孩子应当天生被剥夺一部分权利」。笔者认为，无论这个孩子是如何降生于此的，既然是中国公民，就应该享有平等的人权。\n\n另外，这种说法也是一种亲子连坐。即使我们假设计划生育政策是伟大光明正确的，违背计生政策就应该受到惩罚，那也只应该惩罚其本人，降低其子女的录取率毫无道理。\n\n## 6. 京津沪的普高录取率真的更低吗？\n\n最后辟一个陈年老谣：\n\n>   京津沪录取率高，是因为中考已经筛选过一遍了。\n\n这同样是非常简单的事实错误，各地的初中毕业生人数和普高录取人数大都公开可查，直接上数据就可以了：\n\n|              | 北京  | 天津  | 上海  | 河南     | 广东（2020） | 湖南    |\n| ------------ | ----- | ----- | ----- | -------- | ------------ | ------- |\n| 初中毕业人数 | 87856 | 98175 | 93572 | 157.60万 | 120.42万     | 84.02万 |\n| 普高招生人数 | 62233 | 64707 | 60462 | 85.11万  | 67.18万      | 48.09万 |\n| 普高录取率   | 70.8% | 65.9% | 64.6% | 54.0%    | 55.8%        | 57.2%   |\n\n来源：2021年各地教育事业统计，链接见[[4\\]](#ref_4) [[5\\]](#ref_5) [[6\\]](#ref_6) [[7\\]](#ref_7) [[8\\]](#ref_8) [[9\\]](#ref_9)。广东省2021年没有统计毕业生人数，原因不明。\n\n事实已经很清楚了：如果算上中考，不公平的程度恐怕只会更甚。\n\n## 7. 和其他制度比呢？\n\n在以上的论述之后，许多人可能会承认中国高考的不公平。但我们仍然可能看到这样的言论：\n\n>   高考虽然不是绝对公平，但已经是相对公平/最公平的制度了。如果按美国的申请制来，穷人孩子的上升通道会更加狭窄。\n\n这既是经典的whataboutism，也是在竖稻草人。对高考公平的质疑，从来都是针对地域歧视的，极少有人会认为不公平的点在于笔试制度本身。要对比的话，可以去找隔壁日本。同样是以笔试为主，长崎县的考生就不需要比东京都的考生多考120分才能被帝大录取。\n\n况且，我们只需要知道中国高考是不公平的、仍有明确的改进空间就可以了，美国人的事情自然有美国人操心。这种whataboutism并不值得认真回应，因此笔者也并不打算与其他制度做系统性的对比，下文只是点出一些中国高考的特殊之处：\n\n中国高考的不公平是摆在明面上的，是系统性、制度化的。在全世界包括中国自己的笔试制度中，像高考这样光明正大把歧视写到制度里的，都相当罕见。这种明牌歧视的坏处有二：\n\n-   一是普遍性。一般来说，暗箱操作只会局限于少数特权群体，但制度化的歧视将所有人划分成三六九等，几乎所有参加高考的学生，都是这种歧视的受害者。\n-   二是无法自然改善。暗箱操作总会随着法制程度的提高而自然消减，但若是把不公平写进了制度中，除非直接改革制度，否则就再无自然改善的希望。\n\n三十年，两亿高考生。这就是制度化歧视的可怕之处：它把不平等平等地施加给每一个人，且光明正大得仿佛理所当然一样。\n\n## 参考\n\n1.  [^](#ref_1_0)https://nj.tjj.beijing.gov.cn/nj/main/2021-tjnj/zk/indexch.htm\n2.  [^](#ref_2_0)http://222.240.193.190/2021tjnj/indexch.htm\n3.  [^](#ref_3_0)[https://zjjcmspublic.oss-cn-hangzhou-zwynet-d01-a.internet.cloud.zj.gov.cn/jcms_files/jcms1/web3077/site/flash/tjj/Reports1/2021-%E7%BB%9F%E8%AE%A1%E5%B9%B4%E9%89%B4/indexcn.html](https://zjjcmspublic.oss-cn-hangzhou-zwynet-d01-a.internet.cloud.zj.gov.cn/jcms_files/jcms1/web3077/site/flash/tjj/Reports1/2021-统计年鉴/indexcn.html)\n4.  [^](#ref_4_0)http://jw.beijing.gov.cn/xxgk/shujufab/tongjigaikuang/202203/t20220325_2709328.html\n5.  [^](#ref_5_0)https://jy.tj.gov.cn/ZWGK_52172/zfxxgk1_1/fdzdgknr1/tjxx/202203/t20220323_5837856.html\n6.  [^](#ref_6_0)http://edu.sh.gov.cn/xxgk2_zhzw_tjsj_01/20220824/7330600deae64ea0b8f08a2088f33d79.html\n7.  [^](#ref_7_0)http://jyt.henan.gov.cn/2022/03-22/2418816.html\n8.  [^](#ref_8_0)http://edu.gd.gov.cn/zwgknew/sjfb/content/post_3776040.html\n9.  [^](#ref_9_0)https://jyt.hunan.gov.cn/jyt/sjyt/xxgk/ghjh/tjxx/202212/t20221215_29162123.html","categories":["一些碎碎念"]},{"title":"亚麻的‘白月光’","url":"/posts/6fe35e693afb/","content":"# 亚麻的‘白月光’\n\n>   作于2025春节，感谢WYQ同学催更\n\n## 第一章：\n\n​\t同学们对亚麻并没有什么印象，只记得班上有个很标准的胖子手气不好，每次抽奖都抽到倒数，害得整个小组都只能坐在前排靠门的位置，组员们看上去无所谓，但是亚麻本人对此一直耿耿于怀。但他也从不抱怨自己手气差--这是他早就承认的事实， 他真真正正埋怨的是小组其他成员，一个个都不想担责，把组长的位置推给亚麻，至少这在他当时看上去是这样的。\n\n​\t除了手气不好，别人显而易见的、也是亚麻自己熟知的一个事实就是，他十分地怯场。如果是一般人怯场也就算了，亚麻可是要做世界首富或者国家主席之类的人物，怎么能怯场呢？他也常常反思自己为什么不能改改这个坏毛病，只可惜亚麻当时还没有对基因和遗传有深入的了解，一年以后他会知道自己身上很多的“特性”都是从他父亲的身上继承而来的。\n\n​\t其实按理说，一个人即使内向也可以安安静静地待在角落，不被别人打扰，这未尝不是一个很好的选择。亚麻也是这样想的，但不巧的就是，发言总是不可避免的。在讲这个小故事之前，我们得向大家介绍一位亚麻这辈子见过最差劲的语文老师。他的名字亚麻已经有些模糊了，我们暂且叫他建军吧。建军教课的风格是亚麻活了16年来闻所未闻的。他依然记得那个语文老师，把课前3分钟变成了课前30分钟，语文课彻底变成了同学们的娱乐课。 \n\n​\t在某节语文课上，我们被要求小组分工来讲解每一道题目，我们组被安排的是非连续性文本阅读，就像我们前面提到的那样，其他的组员没有想说的。但真的到了我们展示的时候，老师问我们谁上去展示，结果其他4个组员齐刷刷的看向我。我没办法，硬着头皮走到讲台上面，然后他站在那里，一句话也说不出，持续了大概3分钟，但在亚麻眼里看来起码有三年。在这三年里，他受尽了所有的委屈。他积攒了所有的愤怒。他丢尽了所有的颜面。在他的脚底下诞生的禾仓县唯一的迪士尼乐园。也许若干年后，当科研人员在这座废弃的学校下面挖出迪士尼乐园的遗迹时也会感慨，千百年前，我们的祖先就拥有了在地下创造如此伟大文明的能力。\n\n​\t“老师，我站这也是浪费时间，要不我还是下去吧”\n\n​\t这是亚麻的原话。老师同意了。不同意还能怎么着呢？\n\n​\t但亚麻之所以是亚麻，正因为他有着~~坚韧不拔的意志~~ 厚着脸皮活下去的勇气，反正对他而言，出丑，其实也不是第一天了。\n\n​\t亚麻之所以是亚麻，还因为他的小肚鸡肠，而对于他的组员其实也没有什么好脸色看。虽不至于和他们作对。我摆着一副臭脸，但其实内心还是会很不爽。尤其是那个叫琳的女生，的一副职业假笑给人一种很虚伪的感觉。是很积极的鼓掌。这个行为在亚麻的眼里就是在吹捧别人，或者说‘捧杀’。我们不得不承认人是有一定的思想倾向的，至少在这个阶段。亚麻的脑子里。放在首位的永远是成绩。每一次出成绩都能让他紧张好几个小时。身体这里不舒服，那里不舒服。尤其是肠胃。会错乱。导致每一次出分他都要故作镇定地去厕所。虽然在高一的时候，亚麻的成绩一直都在上升。但他一直觉得这不够，一直担心自己会掉下去。有一次不知道是谁，从哪里搞来的小道消息。在那里散步，亚麻的成绩，亚麻本来就不喜欢被别人知道成绩，更对自己的成绩不满意，结果组内包括琳在内的两位女生都鼓起了掌，这使得亚麻更是恼火。因为他知道她们一定在嘲笑他，而这是亚麻所不能忍受的。\n\n​\t亚麻一旦心情不好，就喜欢自己闷坐着，谁也不理。这是他十几年来的孤独心境锻炼而来的结果。天天坐那做题，使劲做题，顺便天天再给旁边甩笔的周老板一个想杀人的眼神。亚麻在高一过的并不好，舍不得花钱，没见过世面，只想着学习，没有梦想，迷茫未来，不喜欢打理自己，也从不照镜子，因为每一次看到镜子，就会被镜子里的自己丑哭--发型是15r一次的， 痘痘是满脸都是的，脸型是像鸡蛋的，雀斑是到处都是的。在各种压力之下，亚麻就没过过一天好日子。把自己训成了牛马，24*7地工作。\n\n​\t很多人说，白月光都是出现在自己生活最暗淡的时候，最先给了自己美好。或者说，在那个需要一个人的时候，白月光就出现了。\n\n​\t但亚麻的白月光最初并不是白月光，亚麻开始的时候很讨厌琳，但是琳的热心总是能感染亚麻，她的笑容有时候也是很真诚的。她经常给大家带来一点小零食，每一次来问问题都会很礼貌的说谢谢，真诚的笑容加上青春期荷尔蒙的作用，总是能打动猪头少年的心。\n\n​\t亚麻作为资深卷王，对于努力的人一直是欣赏的，琳也是喜欢努力的女孩子，虽然脑子不是很好使，但是真的可以看出她的努力，让人感动。当然，不喜欢被别人卷的亚麻自然是不愿意有人在挑战他的，所以有时候也会因此对琳有些不爽。\n\n​\t不管怎么着，反正亚麻开始对她有一些好感了，至少不会讨厌她。\n\n​\t*时间开始慢慢流逝，很快高一上就要结束了，也就意味着分科的日子要到了，琳选择了物化政，亚麻很是失望，两人的缘分大底是到头了吧。欲知后事如何，请听下回分解*\n\n>   亚麻：琳这个人给亚麻带来很多不理解的地方，琳究竟是一个什么样的人？她对我的态度究竟是怎么样的？这个问题其实一直贯穿始终，直到今天，亚麻还是不能完全理解，好在亚麻也不再在意。正如亚麻所说的：“重要的不是遇见的人给你带来了什么，而是你从别人身上学到了些什么”\n\n","categories":["一些碎碎念"]},{"url":"/posts/54f090a9b59e/","content":"<center>在西湖这座巨大的线程池里，我像是那条永远闲置的线程，旁观着那些并发的爱情故事</center>\n\n<center>每个人年轻的时候，都以为我命由我不由天，直到体检报告给出生活的差评，你才知道什么叫不是不报时辰未到</center>\n\n<center>人总是在上台讲话时憋不住笑，长途旅游时憋不住尿，死到临头时憋不住想开玩笑。</center>\n\n---\n\n一首哲理小诗：\n<div style=\"text-align: center;\">\n    <p>生活打了我一巴掌，我没挺住</p>\n    <p>我给了牛至一巴掌，牛至依旧挺立</p>\n    <p>或许牛至比我更适合做人</p>\n    <p>别人给了我一刀，我挺住了</p>\n    <p>我给了牛至一刀，牛至却倒下了</p>\n    <p>或许我比牛至更适合做牛至</p>\n    <p>我不明白是我身上长了个牛至还是牛至身上长了个我</p>\n    <p>碰到喜欢的人</p>\n    <p>牛至都会硬一硬</p>\n    <p>而我却不敢吱声</p>\n    <p>我拿着杯具，骗牛至说这是个温暖的家</p>\n    <p>牛至站起来，骗我说这是个温暖的世界</p>\n    <p>我没有女朋友，牛至很高兴，因为我可以时常抚摸它</p>\n    <p>我有了女朋友，牛至也很高兴，因为它可以有个温暖的家</p>\n    <p>或许真的是牛牛身上长了我而不是我身上长了个牛牛</p>\n</div>\n\n> TBD\n\n","categories":["一些碎碎念"]},{"url":"/posts/f64f2732e82c/","content":"我的情况：\n综合学分绩：4.6793，位列专业第二\n\n科创竞赛，创新项目\n1. 2025年6月，作为队长参加南京大学EL程序设计大赛，荣获二等奖\n2. 2025年7月，作为队员参加挑战杯“人工智能+”专项赛，结果暂未公布\n3. 2025年9月，作为队长参加全国大学生数学建模大赛，结果暂未公布\n4. 大一期间，参加“追光科研启蒙”计划\n\n志愿服务和社会实践\n1. 总共参与志愿服务22项，总时长172.1小时。参与三项社会实践。\n2. 2024年9月-2025年6月，担任南京艺术学院美术馆和颐和路社区将军馆的长期志愿者\n3. 2024年寒假，担任队长参加南星梦想计划；\n4. 2024年寒假，参与马兰花开线上社会实践；2025年暑假，实地前往新疆马兰进行社会实践。\n\n学生工作参与情况\n1. 2025年8月-至今 担任南京大学开甲书院 学术科创部主席，主导了《知识行囊》修订，负责书院学术创新等方面的工作\n2. 2024年9月-至今 担任计科三班副团支书，组织多场团组织活动，如团员推优等等，获评优秀共青团员。\n3. 2024年9月-2025年8月 担任开甲书院社会实践部部员，协助组织银杏叶创作之旅等活动；获评优秀学生干事。\n\n2024-2025学年各项奖项\n1. 2024年荣获新生学院杨咏曼奖学金（全书院唯一）\n\n其他方面\n1.  过去一年坚持在图书馆、书院等地参加勤工助学\n2. 家庭情况被评定为“特别困难”级别\n3. 多次受到学校和社会上的资助\n\n再详细讲讲我和马兰花开社会实践这一部分的内容：\n1. 24年寒假搭建了““两弹一星”元勋事迹展示网页，并搭建两弹一星精品微课展示平台。”，25年暑假，将在马兰实地收集到的故事整理为”马兰故事墙“集成在云上马兰智慧教育平台。\n2. 在马兰花开社会实践中，我们主要做了\n\n> [!NOTE] 社会实践总结  \n> 1. 在马兰革命烈士陵园举行祭扫活动，缅怀先烈，传承“两弹一星”精神。  \n>   \n> 2. 参观马兰红山军博园、将军楼和防空洞，深入了解科研工作者在戈壁的艰辛生活。  \n>   \n> 3. 参观马兰历史展览馆和林俊德纪念馆，并重温《程开甲的故事》，感悟“干惊天动地事，做隐姓埋名人”的精神。  \n>   \n> 4. 走进马兰基地实验室，了解国防科研创新，感受“前沿探索永不止步”的科研精神。  \n>   \n> 5. 与部队优秀科研人员座谈交流，了解他们的成长经历，并受到鼓励投身国防事业。  \n>   \n> 6. 聆听专题马兰精神宣讲，从前辈的感人故事中汲取力量。  \n>   \n> 7. 前往马兰中学，为当地中小学生开展“两弹一星”精神志愿宣讲活动，将科学知识和爱国精神寓教于乐。  \n>   \n> 8. 深入马兰基地采集珍贵影像资料，并系统整理马兰故事，进行数字化内容收集与转化。  \n>   \n> 9. 开发并搭建线上“马兰花开”故事墙，以现代化的互动形式传播马兰历史。  \n>   \n> 10. 开发精品微课展示平台，在视频中加入互动提问功能，为红色精神教育提供了新的数字化学习路径。\n \n3. 后来呢，有关数字的部分就嵌入了马兰智慧教育平台，参加了挑战杯”人工智能+“赛道（我只是一个队员）\n\n\n---\n尊敬的各位老师：  \n大家好！\n\n“雷”励进取，“业”成报国。我是来自计算机学院2024级的本科生雷业成。非常荣幸能够站在这里，向各位汇报我在南大的学习与成长。\n作为一名共青团员，我坚定理想信念，积极向党组织靠拢，被推优为入党积极分子，并完成入党积极分子培训。 目前我担任开甲书院学术科创部主席，主导修订《知识行囊》，统筹部门各项事务；大一期间，我担任我担任班级副团支书、团学联社会实践部部员，银杏叶创作之旅等活动近10场，撰写活动纪实推文获评“优秀共青团员”和“优秀学生干事”。并在书院的发展性测评中获得了“优秀”评价。\n\n过去一年，我的综合学分绩为4.68，位列专业第二。多门专业课接近满分，数理基础课程平均分超过97，筑牢专业根基。课堂之外我积极投身于更加广阔的学科探索，参与开甲书院“追光”科研启蒙项目，加入苏丰副教授指导的视觉问答系统（VQA）项目组，自主学习人工智能领域深度学习框架，复现经典多模态融合算法与模型结构，并独立完成从数据预处理到模型训练的全流程。\n\n科创方面，我相信技术的价值在于解决真实问题。在南京大学EL程序设计大赛中，我带队开发“植语心声”项目，通过记录与养成机制探索大学生心理健康干预新路径。在南京大学智能数据决策工作室，我基于napcat框架拓展QQ功能，提升信息处理效率。今年，我还作为核心队员参与“挑战杯”人工智能+专项赛，负责智能问答工作流与对话智能体的搭建，项目已成功进入国赛评审阶段\n\n截至目前，我参与志愿服务活动22项，累计志愿时长超170小时。在颐和路社区将军馆，我化身为红色文化的传颂者，让革命精神在讲解中熠熠生辉；在南京艺术学院美术馆，我成为一名公益服务者，用真诚服务为社会增添一抹温暖色彩。在“南星梦想计划”中，我担任队长，回到母校，用青年声音，讲好南大故事。\n\n2024年寒假，我报名参加云上马兰社会实践，作为视频展示组的组长带队开发“两弹一星”元勋事迹展示网页与精品微课展示平台，将问答功能融入红色教育视频，用数字化手段赋能思政课堂。在项目开发过程中，科学家们的精神也点燃了我对马兰的向往。  \n今年暑假，我终于踏上新疆马兰这片热土：我在烈士陵园缅怀英魂，在红山军博园触摸历史，在实验室对话科研前辈，深入采集22个鲜活故事、整理2万余字资料，将这些珍贵素材数字化，构建“马兰故事墙”，并集成至“云上马兰智慧教育平台”，让戈壁深处的精神回响，通过代码传向更广阔的天地。\n\n从课堂到戈壁，从思想到行动，我始终以高标准要求自己。在未来，我将继续坚定理想信念，勤思笃学，躬身实践，接续奋进在南大的广阔天地，“雷”励进取，“业”成报国！\n\n谢谢大家！\n\n\n\n---\n背了几天的稿，最后是线上答辩......\n\n---\n10月2日补充，最后还是拿到了国奖\n\n---\n\n\n","categories":["一些碎碎念"]},{"url":"/posts/6e8261e7fc8a/","content":"反思，自己进入大二以来的学习状态。\n","categories":["一些碎碎念"]},{"title":"例会汇报 | 第三次","url":"/posts/168bd04ffb48/","content":"\n## What I have done in the last week?\n\nIn the last week, I pay most of my attention into a website building: [VQA学习小组](https://vqa.yama-lei.top)\n\n\n\nIn the website, you can \n\n-   share your code and file freely\n-   download any files\n-   experience our models\n\n![image-20250403233020453](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250403233020453.png)\n\n![image-20250403233052399](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250403233052399.png)\n\n---\n\n\n\n","categories":["科研启蒙","Reports"]},{"url":"/posts/d5a5689a747c/","content":"# 例会汇报 | 第二次\n\n（接上一次BLIP系列模型的讨论）我没有仔细看对应的论文，下方图片来自知乎。\n\n![6fb85be2a08f15ce71245f1301d3b1ab](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/6fb85be2a08f15ce71245f1301d3b1ab.png)\n\n---\n\n\n\n\n\n#### 一个VQA领域的baseline模型\n\n>   Baseline模型的含义： 容易实现、功能基础的模型，作为'基线'(baseline)。\n\n我找到一篇10年前的论文：<a href=\"paper.html\">Simple Baseline for Visual Question Answering</a>，文章中提到的“iBowing”模型的结构是：\n\n```mermaid\ngraph TD\n    A[输入问题（文本）] -->|One-hot Encoding + 词袋模型（BoW）| B[文本特征]\n    C[输入图像] -->|CNN（如GoogLeNet）| D[图像特征]\n    B -->|拼接| E[联合特征向量]\n    D -->|拼接| E\n    E -->|Softmax 分类| F[预测答案]\n\n```\n\n模型核心思路如下：\n\n1.  **文字处理**\n\n    -   **One-hot Encoding 与 Bag-of-Words (BoW)：**\n         模型首先将输入的问句转换为 one-hot 向量。在 one-hot encoding 中，每个单词都表示为一个二值向量（只有对应单词的位置为 1，其余位置为 0）。这种方法正是实现了所谓的“词袋模型”（Bag-of-Words），该模型只关注词汇的出现频率而忽略词序。\n\n    >   Bow（词袋模型）是只统计单词在词汇表中的出现情况，忽略了单词的语义关系和次序关系。\n    >\n    >   **但是**，这个模型并没有直接使用one-hot向量，而是通入一个嵌入层，实现词嵌入: The input question is first converted to a one-hot vector, which is transformed to word feature via a word embedding layer\n\n    -   **Word Embedding（词嵌入）：**\n         将 one-hot 向量输入到词嵌入层中，转换为低维稠密向量。词嵌入能够捕捉单词之间的语义关系，比简单的频数统计提供了更丰富的语义信息。\n\n2.  **图像处理**\n\n    -   利用预训练 CNN（例如 GoogLeNet）提取图像深度特征，获得图像的高层语义信息。\n\n3.  **特征拼接（Concatenation）：**\n     将文字特征和图像特征直接进行拼接，即将两个向量**横向连接**，形成一个联合特征向量。这种拼接方式能够同时包含问题的文本信息和图像的视觉信息，为后续的分类提供全面的输入特征。\n\n    >   这里的**拼接**是这个含义：\n    >\n    >   -   **文本特征向量**：`T = [0.2, 0.5, 0.3]`  （假设 3 维向量）\n    >   -   **图像特征向量**：`I = [0.7, 0.1, 0.9, 0.4]`  （假设 4 维特征）\n    >\n    >   那么，拼接后的 **联合特征向量** `F` 就是：F=[0.2,0.5,0.3,0.7,0.1,0.9,0.4]\n    >\n    >   \n\n    <center>图片来自论文：https://arxiv.org/abs/1512.02167</center>\n\n    ![Refer to caption](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/x1.png)\n\n4.  **答案生成**\n\n    使用Softmax 分类器：\n     \t将拼接后的联合特征输入到一个 softmax 层，该层作为多类别分类器，计算每个预定义答案类别的概率分布。最终，选择具有最高概率的答案作为模型的输出。\n\n![img](https://pica.zhimg.com/v2-4452fdaaa04686aa270010f57f4db2aa_1440w.jpg)\n\nsoftmax最终得到一个概率分布的张量，对应的概率代表答案是对应的词的概率\n\n>   Softmax **只能从一个固定的候选集合中选答案**。这个集合通常是 **训练数据中学习到的可能答案集合**，也就是 **预定义的词表（Vocabulary）**。也就是说无法生成自由的回答。\n\ngithub：[zhoubolei/VQAbaseline: Simple Baseline for Visual Question Answering](https://github.com/zhoubolei/VQAbaseline)(但是不是用python写的，而是lua，在线的demo也已经停止运行)\n\n---\n\n**训练的细节和结果** \n\n论文中使用到的数据集是`COCO数据集`，论文中提到训练的细节：`在单个 NVIDIA Titan Black GPU 上训练大约需要 10 小时`\n\n>原文：The training takes about 10 hours on a single GPU NVIDIA Titan Black\n\n![image-20250322203830571](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250322203830571.png)\n\n这个是阿里云上GPU的价格。\n\n![image-20250322204019083](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250322204019083.png)\n\n也就是说，按照这篇论文所说，训练这个模型，可能花费30r不到。\n\n下面是论文中提到的测试的结果：\n\n<div style=\"display:flex;\">\n<img width=\"50%\" src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250322205621368.png\"/>\n<img width=\"50%\"  style=\"height:100%;\" src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250322205703229.png\"/>\n</div>\n---\n\n\n\n老师注： 数据重要性大于算力，显存要求大于cuda核，训练满一点没关系。\n\n论文里对模型的分析，要和其他的模型进行对比，还要进行**剖分实验** （without这个模块，之后性能怎么样？ 把这个component换成别的性能怎么样），敏感度，模型性能随着参数的变化的变化趋势\n\n\n\n前面提到的那个baseline模型使用简单的`特征提取-> 特征融合 -> softmax得到答案`。\n\n具体的来说，iBowing模型在文字编码时采用的是**Bow**(词袋模型). 比词袋模型用的更广泛的是：**RNN**(循环神经网络)。下面展示是一种早期常见的vqa方法：\n\n```mermaid\ngraph TD\n    A[输入图像] -->|CNN 提取特征| B[图像特征]\n    A1[输入问题] -->|词嵌入 Word2Vec/GloVe| A2[词向量]\n    A2 -->|RNN/LSTM 处理| A3[文本特征]\n\n    B --> C[拼接 Concatenation]\n    A3 --> C\n\n    C -->|全连接层 MLP 处理| D[融合特征]\n    D -->|Softmax 分类| E[答案预测]\n\n```\n\n\n\n许多vqa模型都是基于transformer实现的。下图是一个简单的结构，BLIP采取的结构和这个很相似：\n\n```mermaid\ngraph TD\n  A[输入图像] -->|ViT/CNN 提取特征| B[图像特征]\n  C[输入问题] -->|BERT/Tokenizer| D[文本特征]\n  B -->|跨模态融合| E[多模态 Transformer]\n  D -->|跨模态融合| E\n  E -->|Transformer Decoder| F[生成答案]\n```\n\n\n\n---","categories":["科研启蒙","Reports"]},{"title":"组会汇报week11","url":"/posts/ea148cfa24c8/","content":"\n\n\n## vqa模型比较\n\n在过去一周，我把模型全部重新跑了一遍，使用相同的数据集、采取相同的评估方法(loss, acc)，采取相同的一套接口， 区别仅仅在于**模型的内部结构不一样** \n\n- 训练数据集：vqa-v2 train\n- 评估数据集： vqa-v2 val\n- 训练轮次：15 epochs\n- 单卡（batch_size= 512, num_workers=16) 训练时长从2-3h，每一个模型训练实际占用显存约5GB\n结果如下：\n![loss_comparison](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/loss_comparison.png)\n\n![image-20250720132512120](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250720132512120.png)\n\n\n\n下面是这四个模型的不同结构：\n\n>   下面是让AI总结的\n\n<!-- 模型一 -->\n\n<div style=\"display: flex; margin-bottom: 40px;\">\n  <div style=\"flex: 1; padding-right: 20px; border-right: 2px solid #ccc;\">\n    <h3>模型一：平均词嵌入（Mean Pooling）</h3>\n    <pre><code>question_features = self.embed(question).mean(dim=1)</code></pre>\n    <p>将每个词嵌入后，取平均作为问题表示。</p>\n  </div>\n  <div style=\"flex: 1; padding-left: 20px;\">\n    <h4>优点</h4>\n    <ul>\n      <li>实现简单，计算速度快</li>\n      <li>适合短文本</li>\n    </ul>\n    <h4>缺点</h4>\n    <ul>\n      <li>忽略词序与上下文关系</li>\n      <li>无法突出关键信息</li>\n    </ul>\n  </div>\n</div>\n<!-- 模型二 -->\n\n<div style=\"display: flex; margin-bottom: 40px;\">\n  <div style=\"flex: 1; padding-right: 20px; border-right: 2px solid #ccc;\">\n    <h3>模型二：LSTM 编码</h3>\n    <pre><code>self.q_lstm = nn.LSTM(input_size=512, hidden_size=512)\nquestion_features = self.embed(question)\nquestion_features, _ = self.q_lstm(question_features)\nquestion_features = question_features[:, -1, :]</code></pre>\n    <p>用 LSTM 编码问题，取最后一个时间步的 hidden state。</p>\n  </div>\n  <div style=\"flex: 1; padding-left: 20px;\">\n    <h4>优点</h4>\n    <ul>\n      <li>考虑词序信息</li>\n      <li>较强语义表达能力</li>\n    </ul>\n    <h4>缺点</h4>\n    <ul>\n      <li>仅用最后一个时间步，可能信息损失</li>\n      <li>对长句不稳定</li>\n    </ul>\n  </div>\n</div>\n\n<!-- 模型三 -->\n<div style=\"display: flex; margin-bottom: 40px;\">\n  <div style=\"flex: 1; padding-right: 20px; border-right: 2px solid #ccc;\">\n    <h3>模型三：LSTM + 注意力机制</h3>\n    <pre><code>self.q_lstm = nn.LSTM(input_size=512, hidden_size=512)\nself.question_attention_linear = nn.Linear(hidden_size, 1)\nquestion_features = self.embed(question)\nquestion_features, _ = self.q_lstm(question_features)\nattention_scores = self.question_attention_linear(question_features)\nattention_weights = torch.softmax(attention_scores, dim=1)\nquestion_features = torch.sum(question_features * attention_weights, dim=1)</code></pre>\n    <p>LSTM 输出后，加权聚合每个时间步的隐藏状态。</p>\n  </div>\n  <div style=\"flex: 1; padding-left: 20px;\">\n    <h4>优点</h4>\n    <ul>\n      <li>可关注问题关键词</li>\n      <li>提升语义建模能力</li>\n    </ul>\n    <h4>缺点</h4>\n    <ul>\n      <li>模型结构略复杂</li>\n      <li>对注意力参数敏感</li>\n    </ul>\n  </div>\n</div>\n<!-- 模型四 -->\n\n>   模型三和模型四 是参考了论文SANs的注意力机制，均只使用了一层堆叠注意力；但是模型三的图像编码使用的方法是resnet18删去了最后一层，图形送入，得到512维度张量； 而模型四的图像编码采用的方法是删除resnet18的最后两层，借助的是其预训练好的CNN部分，和SANs结构更加贴近。\n\n<div style=\"display: flex; margin-bottom: 40px;\">\n  <div style=\"flex: 1; padding-right: 20px; border-right: 2px solid #ccc;\">\n    <h3>模型四：图文融合注意力模型（基于ResNet + 文本引导）</h3>\n    <pre><code># 图像特征提取\nself.cnn = ResNet18 (去除全连接层)\nv_I = CNN(image) → shape: (B, 512, 14, 14) # 问题编码\nv_Q = self.embed(question).mean(dim=1)# 注意力融合\nh_A = fc1(v_I) + (fc2(v_Q) + b_A)\np_I = softmax(fc3(h_A))\nv_I_a = 加权图像区域  # 融合表示\nu_1 = v_I_a + v_Q → 分类器输出答案</code></pre>\n    <p>使用视觉注意力机制结合问题内容对图像区域加权。</p>\n  </div>\n  <div style=\"flex: 1; padding-left: 20px;\">\n    <h4>优点</h4>\n    <ul>\n      <li>图文信息融合充分</li>\n      <li>能动态关注图像关键区域</li>\n    </ul>\n    <h4>缺点</h4>\n    <ul>\n      <li>结构复杂，调参要求高</li>\n      <li>训练成本高于前三个模型</li>\n    </ul>\n  </div>\n</div>\n\n\n## 长句的vqa数据集\n\n**fsvqa数据集**   \n\n论文： https://arxiv.org/pdf/1609.06657  \n\nName： The Color of the Cat is Gray: 1 Million Full-Sentences Visual Question Answering (FSVQA)   \n\n图像依旧使用的是**COCO**，数据集提供了original和augmented两个版本\n\n其中original版本的train data约为23w对QA对，augmented的train有66w对QA对（貌似augmented是origianl的超集？）\n\n整理为统一格式后：\n\n```json\nquestion_id:4870251\nquestion:\"Is there a shadow?\"\nanswer:\"Yes, there is a shadow.\"\nimage_id:487025\nimage_path:\"/project/vqa/resources/vqa-v1/images/train2014/COCO_train2014_000000487025.jpg\"\n```\n\n**lfvqa数据集**\n\n论文： https://arxiv.org/pdf/2408.06303\n\nName:  Long-Form Answers to Visual Questions from Blind and Low Vision People\n\n图像使用的是**VizWiz**（收集自视障人士实际拍摄的图片）的一部分（只选择了600张图像），每一个图像的对应的问题由多个大模型（LLava、BLIP、QWEN、GEMINI等）进行回复，\n\n原数据集中大模型的回复通常比较长，~~貌似不太适合我们模型~~，我先对数据进行了整理，从大语言模型的多句回答中，选择直接回复的答案的句子，并且统一为统一格式，最后筛选得到了3129个QA对。\n\n```json\n{'image_id': 16783, \n 'question_id': 16783, \n 'question': 'Can you tell me what kind of vehicle this is?', \n 'answer': 'The vehicle in the image appears to be a utility service truck, commonly used by contractors or maintenance departments', \n 'image_path': 'image/16783.jpg'\n}\n```\n\nGenerative Model:\n\n使用数据集： fsvqa\n\n训练到第40个epoch，出现了过拟合特征：\n\n```\n--- Sample 1/5 ---\nImage Path:          /project/vqa/resources/vqa-v1/images/train2014/COCO_train2014_000000539562.jpg\nQuestion:            Has this bed been made?\nGround Truth Answer: Yes, this bed has been made.\nModel Generated Answer:  yes this bed has been made\n------------------\n--- Sample 2/5 ---\nImage Path:          /project/vqa/resources/vqa-v1/images/train2014/COCO_train2014_000000191639.jpg\nQuestion:            Is it cold out?\nGround Truth Answer: Yes, it is cold out.\nModel Generated Answer:  yes it is cold out\n------------------\n--- Sample 3/5 ---\nImage Path:          /project/vqa/resources/vqa-v1/images/train2014/COCO_train2014_000000289004.jpg\nQuestion:            Are there clouds in the sky?\nGround Truth Answer: No, there are not clouds in the sky.\nModel Generated Answer:  yes there are clouds in the sky\n------------------\n```\n\n\n\n**其他补充：**\n\n1.   线路二的模型（Start From Scratch）使用的数据集的统一格式和接口：\n     -   格式为\n     \n     -   {'image_id': 16783, \n          'question_id': 16783, \n          'question': 'Can you tell me what kind of vehicle this is?', \n          'answer': 'The vehicle in the image appears to be a utility service truck, commonly used by contractors or maintenance departments', \n          'image_path': 'image/16783.jpg' ‘question_type’: '' \n         \n          }\n         \n     -   接口为： loadData(train=False, num=-1, dataset_type= '') \n     \n     -   使用方法： 1. 使用loadData函数导入数据，得到的数据即为上述格式的一个数组  2. 导入词表   3. 传入VQA_Dataset，在这一步会对question和image进行预处理（tokenize、编码等等） 4. 实例化Dataloader，并作为参数传入训练的函数\n     \n2.   吃了个西瓜，忘记要写什么了\n\n**Failed Attempt On Long Answer VQA**\n\n让AI写了一个模型，尝试使用上述整理好的数据集，进行训练：\n\n训练了30个epoch的模型：（在train上的表现，过拟合，背住了答案）\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250721001811333.png\" alt=\"image-20250721001811333\" style=\"zoom:50%;\" />\n\n在val上的表现：已经完全是放飞自我，回答牛头不对马嘴了，只是学会了基本的语言规则，并没有学会看图和回答\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250721001916470.png\" alt=\"image-20250721001916470\" style=\"zoom:50%;\" />\n\n## 中文vqa尝试\n\n既然英文的成功跑起来了，那么理论上我只需要把词表换成中文词表，不就有了中文vqa模型？\n\n理论存在，实践开始：\n\n我用google的开源翻译模型，将fsvqa翻译成中文并且按照新的数据集重新构建了词表，训练了中文的vqa模型:\n\n结果只能说 和上面那个英文的vqa模型 算是**卧龙凤雏、不相上下**\n\n\n\n\n\n---\n\n组会： 尝试使用预训练好的词嵌入模型和动态卷积\n","categories":["科研启蒙","Reports"]},{"title":"例会汇报 | 第一次","url":"/posts/a7fa9e47a9a5/","content":"\n\n\n# 例会汇报 | 第一次\n\n## **VQA算法** \n\n```mermaid\ngraph LR\n\t图像,问题展示  --> 将文字,图像特征综合 --> 回答生成\n```\n\n1.   **图像/问题表征方法**\n\n-    图像展示 | Image representation\n-    问题呈现 | Question representation\n\n2.   **多模态融合与回答生成算法**  \n\n-    将视觉信息和文字信息综合 | Fusion and/or Attention\n\n>   The interaction of the visual and textual domain in VQA is either done directly through multimodal fusion or indirectly through attention mechanisms.                                                                          \t      --- *A Comprehensive Survey on Visual Question Answering Datasets and Algorithms*\n\n-    问题生成 | Answering\n\n### 多模态融合\n\n“将不同模态的信息，形成一个联合的表示”\n\n>   We divide fusion in VQA into two types, vector operation and bilinear pooling.\n>\n>    --- *A Comprehensive Survey on Visual Question Answering Datasets and Algorithms*\n\n##### 基于向量操作的融合\n\n1.   向量操作 | Vector Operation\n\n\t通过向量操作（加法，内积，拼接），将图像特征和问题特征结合起来，生成一个联合的多模态表示。\n\n-   容易实现\n-   准确度低\n\n2.   双线性池化层 | Bilinear pooling\n\n\t通过将代表 视觉信息 和 文字信息 的 **向量做外积**，“比简单的向量操作（如加法、乘法或拼接）更有效地捕捉模态间的相关性。”\n\n---\n\n##### 注意力机制 | Attention\n\n用于让模型**聚焦**输入数据中的重要部分，减少噪音的干扰\n\n-   注意力机制可以帮助模型动态地选择图像和文本中的重要区域或词汇\n\n注意力机制有很多种分类方式：\n\n比如：Soft and hard attention\n\n按照与问题的相关程度，给图像中的对象赋值。\n\n区别在于**soft attention**机制不会将相关度低的对象给忽视，而**hard attention**则会舍弃相关度低的对象\n\n其他的注意力机制有\n\n-   Grid and objct based attention\n\n-   bottom-up and top-down attention\n-   single setp and s multi-step attention\n\n-   CO-ATTENTION AND SELF-ATTENTION\n\n---\n\n上面的内容相当于是让模型“理解”了问题和图像，下面需要生成回答：\n\n### 回答生成算法\n\n-   **分类问题 | close ending** ：\n\n    将前面多模态融合得到的特征输入到`全连接层`，最后通过`softmax`函数得到答案的概率分布；\n\n    (我觉得和手写数字识别类似)\n\n    ​\t\n\n-   **自由生成 | open ending**：\n\n    生成自由的文本（和平时的大语言模型交互所生成的回答一样）;\n    \n    `编码器-阶码器`结构：\n    \n    -   编码器提取图像和问题的联合表示\n    -   解码器按照编码器输出，逐词生成答案\n\n在回答生成算法中，Transformer模型比较流行:\n\n**Transformer模型**\n\n-   **提取文本、图像信息，并融合**：\n\n    -   Two-Stream 图像和文本分别通过独立的 Transformer 编码器处理，最后再将两个输出融合。例子：ViLBERT, LXMERT, and ERNIE-ViL \n\n    >   In the two-stream architecture, two seperate transformers are applied to image and text and their outputs are fused by a third Transformer in a later stage.\n\n    -   Single-Stream: 将图像和文本视为一个统一的序列，通过同一个 Transformer 编码器处理。例子：ViLT、OFA、M6、VisualBERT\n\n    >   In contrast, single-stream models use a single transformer for joint intra-modal and inter-modal interaction.\n\n-   **回答生成**:\n\n    -   **分类问题 | close ending**：\n\n        在 Transformer 编码器的输出后添加分类头（Classification Head）。\n\n        通过全连接层将融合后的特征映射到答案词汇表的分布。\n\n    -   **自由生成 | open ending**：\n\n        使用 Transformer 的 **编码器-解码器架构** ，编码器得到视觉和文字特征的特征序列，输入到解码器生成答案。\n\n---\n\n\n\n综述中提到的其他相关内容：\n\n##### 外部知识 | EXTERNAL KNOWLEDGE\n\n外部知识是指从预定义的知识库（如知识图谱、数据库）或预训练模型中引入的额外知识\n\n-   帮助模型更好地回答问题\n\n##### 组合式推理 | Compositional reasoning\n\n将问题拆分成多个子问题，来正确地推理复杂问题\n\n>   By composition, we refer to the ability to break a question down into individual reasoning steps which when done sequentially produces the correct answer. “组合\"指的是将问题拆分成子问题的能力\n\n\n\n### 尝试\n\n在了解相关模型的时候，我了解到一个基于transformer的模型框架BLIP(2022年提出)。\n\nBLIP训练难(数据，算力)\n\n-   [HuggingFace文档-链接](https://huggingface.co/docs/transformers/main/en/model_doc/blip#blip) \n\n-   [训练代码Giuhub-链接](https://github.com/salesforce/BLIP) \n\n---\n\nhugging face上面有几个基于这个框架的模型，我下载了几个想看看效果是什么样的，写了一个对话的本地网页：\n\n<div style=\"display: grid; grid-template-columns: 1fr 1fr;\">\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250313172815938.png\"/>\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250313173022433.png\"/>\n</div>\n>    ~~**我们到时候是不是也可以将最终的模型做一个网页的demo**~~\n\n### 有关VQA学习的疑惑\n\n1.   学习时间有限，除非放假很难有**足够多**的时间来系统学习，学习进度缓慢。\n2.   从哪里开始下手？需要先系统学习pytorch，transformer等吗？\n\n>   python->pytorch->看一些相关实现和算法\n\n\n\n---","categories":["科研启蒙","Reports"]},{"title":"神经网络的基本概念","url":"/posts/9c0fdb37d738/","content":"\n## 神经网络基础结构\n\n值得参考的资料：\n\n1.   [神经网络15分钟入门！足够通俗易懂了吧 - 知乎](https://zhuanlan.zhihu.com/p/65472471)\n2.   [90分钟！清华博士带你一口气搞懂人工智能和神经网络-bilibili](https://www.bilibili.com/video/BV1atCRYsE7x/?spm_id_from=333.337.search-card.all.click)\n\n### 神经元\n\n神经元接受多个加权输入和bias，如果结果大于激活的阈值，那么就会进行输出\n\n![](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/1_upfpVueoUuKPkyX3PR3KBg.png)\n\n即：\n\n![img](https://www.runoob.com/wp-content/uploads/2024/12/f0b929045ae6eef23514bd7024be62f0.png)\n\n### 层\n\nMLP神经网络可分为三层：输入层，隐藏层，输出层\n\n![img](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/1_3fA77_mLNiJTSgZFhYnU0Q3K5DV4.webp)\n\n### 激活函数\n\n决定神经元是否应该被激活的函数，常见的有：\n\n-   sigmoid函数 f(x)=1 if x>0 else 0\n-   tanh函数  f(x)=(e^x^ +e^-x^)/(e^x^-e^-x^)\n-   ReLU函数，f(x)=x if x>0 else 0\n-   softmax函数，将输出转换成概率分布, f(x)=a~x~/sigma(a~x~)\n\n## 神经网络的原理\n\n前面说每一个神经元都有许许多多个参数（权重等），想要找到最好的模型，就需要找到一组最佳参数。\n\n通过对模型的性能进行评估，来调整参数，直到效果符合要求。\n\n这里需要解决两个问题：\n\n**1. 如何评估模型的效果**\n\n**2. 如何更好的调整参数**\n\n### 损失函数（loss function）\n\n损失函数用于衡量模型的预测值与真实值之间的差异。\n\n常见的损失函数包括：\n\n-   **均方误差（MSELoss）**：回归问题常用，计算输出与目标值的平方差。\n-   **交叉熵损失（CrossEntropyLoss）**：分类问题常用，计算输出和真实标签之间的交叉\n\n### 梯度下降算法\n\n我们考虑：每一组参数就会有一个损失值，那么损失值可以看做是关于这些参数的一个多元函数，我们的任务变成了找到这组多元函数的最小值。\n\n所以我们需要`反向传播算法`来计算梯度，从而调整每一个参数，使得顺势能够最小。\n\n\n\n## 训练模型\n\n  -   在深度学习中，模型的训练过程通常包括以下几个步骤：\n         1.  **前向传播（Forward Propagation）** ：通过输入数据和模型参数，计算输出。\n         2.  **计算损失（Loss Calculation）** ：根据模型的输出和真实标签，计算损失函数的值。\n         3.  **反向传播（Backward Propagation）** ：根据损失函数，计算损失对模型参数的梯度。\n         4.  **参数更新（Parameter Update）** ：使用优化算法（如梯度下降）更新模型参数。\n\n","categories":["科研启蒙"]},{"title":"使用瑞莎开发板搭建服务器","url":"/posts/57133830e9e2/","content":"\n之前心心念念想有一个服务器，今天终于狠下心来买了硬件：\n\n和gemini聊了很久，把相关的知识学了一遍，最后在狗东上面买好了装备：\n\n下面是Gemini的评价\n\n---\n\n好的，恭喜你！你的硬件配置看起来非常合理且具有性价比，完全能够满足你的需求。\n\n## **你的硬件配置评价：**\n\n1.  **Radxa ZERO 3W RK3566 (374元):**\n    -   **评价：** 核心设备，RK3566 芯片性能足够处理你的服务器和魔镜任务，Wi-Fi 和蓝牙是 3W 版本的亮点。\n    -   **建议：** 确保你买的是 4GB 或 8GB 内存的版本，如果能有 8GB，会更流畅地运行 Qwen3-0.6B 和多个 Docker 容器。\n2.  **散热片 (12元):**\n    -   **评价：** 必要的配件。RK3566 在高负载下会发热，散热片能有效防止 CPU 过热降频，保证性能稳定。\n    -   **建议：** 安装时确保与芯片接触良好，可以用导热硅脂或导热垫。\n3.  **240GB SSD 固态硬盘 (117元):**\n    -   **评价：** 很好的选择。SSD 相比 microSD 卡有显著的性能和寿命优势，240GB 容量对于操作系统、Docker 镜像、Dify 数据和大部分家庭小规模存储来说非常充裕。性价比也很好。\n    -   **建议：** 配合 USB 3.0 硬盘盒，可以发挥 SSD 的速度。\n4.  **microSD 128GB (50元):**\n    -   **评价：** 初始启动和备用存储的理想选择。128GB 容量非常大，即使作为备用系统盘也足够。\n    -   **建议：** 确保是高质量的 A2 级别或更高速的卡，以获得更好的启动和基础操作体验。\n5.  **拓展坞 (72元):**\n    -   **评价：** 关键组件，性价比极高！集成了千兆网口、USB 3.0 扩展和 PD 供电，完美解决了 ZERO 3W 接口不足的问题，并简化了供电。\n    -   **建议：** 确保你的电源适配器支持 PD 协议，并且功率足够（建议 45W 或 65W PD 适配器）。\n6.  **2.5 英寸 Type-C 硬盘盒 (20元):**\n    -   **评价：** 正确的选择，正好匹配你的 SATA SSD。Type-C 接口也方便连接拓展坞。\n    -   **建议：** 确保它支持 USB 3.0 或更高标准，以避免成为 SSD 的性能瓶颈。\n\n**总体评价：你的配置非常均衡且经济实用，能够很好地满足你的项目需求。**\n\n------\n\n## 部署服务器的详细指导：\n\n这是一个循序渐进的过程，需要一定的 Linux 基础。\n\n**阶段一：硬件连接与首次启动**\n\n1.  **安装散热片：**\n    -   将散热片牢固地安装在 Radxa ZERO 3W 的 RK3566 芯片上。如果散热片带背胶，撕下保护膜直接贴上。如果需要导热硅脂或导热垫，请正确涂抹/放置。\n2.  **组装 SSD 硬盘盒：**\n    -   将你的 2.5 英寸 SATA SSD 放入硬盘盒，并盖好。\n3.  **连接硬件：**\n    -   **SD 卡：** 将 128GB microSD 卡插入 Radxa ZERO 3W 的 microSD 卡槽。\n    -   **SSD 硬盘盒：** 将组装好的 SSD 硬盘盒通过其 Type-C 数据线连接到 **拓展坞的 USB 3.0 Type-A 接口之一**（因为你的硬盘盒是 Type-C to USB-A 线，或它本身就是 Type-A 接口）。\n    -   **拓展坞到 ZERO 3W：** 用一根 **USB Type-C to USB Type-C 数据线** 将拓展坞的输出 Type-C 口（通常是连接电脑的那个口）连接到 **Radxa ZERO 3W 的 USB 3.0 Type-C HOST 口**。\n    -   **电源：** 将你的 **PD 兼容的 USB Type-C 电源适配器** 连接到**拓展坞上标有“PD”或“Power In”的 Type-C 接口**。\n    -   **显示器：** 用 Micro HDMI 转 HDMI 线缆连接 Radxa ZERO 3W 和显示器。\n    -   **键盘鼠标：** 将键盘和鼠标连接到拓展坞剩余的 USB Type-A 接口。\n    -   **网线：** 将网线连接到拓展坞的 RJ45 网口。\n\n**阶段二：系统烧录与启动**\n\n1.  **下载操作系统镜像：**\n    -   访问 Radxa 官方网站 (Radxa.com 或 Radxa Wiki) 或其社区，找到 Radxa ZERO 3W 对应的 **Debian 或 Ubuntu Server** 镜像。**推荐 Server 版本，因为它更轻量，适合服务器使用。** 确保下载的镜像是为 RK3566 芯片优化的。\n    -   下载 `Etcher` (Balena Etcher) 或 `Rufus` 等镜像烧录工具到你的电脑。\n2.  **烧录镜像到 microSD 卡：**\n    -   将 microSD 卡插入电脑的读卡器。\n    -   打开 Etcher 或 Rufus，选择你下载的系统镜像文件和 microSD 卡作为目标设备。\n    -   开始烧录。等待烧录完成并验证。\n3.  **首次启动与基础配置：**\n    -   确保所有硬件已连接。\n    -   接通拓展坞电源。Radxa ZERO 3W 应该会自动启动。\n    -   显示器上应该会出现启动信息。\n    -   **登录：** 第一次登录通常有默认用户名和密码（请查阅 Radxa 官方文档或镜像说明）。例如，常见的可能是 `radxa/radxa` 或 `debian/debian`。\n    -   **修改密码：** 登录后第一件事就是修改默认密码，使用 `passwd` 命令。\n    -   **更新系统：** 运行 `sudo apt update && sudo apt upgrade -y` 来更新系统到最新状态。\n\n**阶段三：SSD 挂载与系统迁移（可选但推荐）**\n\n1.  **识别 SSD：**\n\n    -   登录系统后，使用 `lsblk` 命令查看你的 SSD 是否被识别。它应该会显示为 `/dev/sda` 或 `/dev/nvme0n1`（取决于你的 SSD 类型，但通常是 `/dev/sda`）。\n    -   确认其容量与你的 240GB SSD 匹配。\n\n2.  **格式化 SSD：**\n\n    -   如果 SSD 是新的，需要分区和格式化。\n    -   使用 `sudo fdisk /dev/sda` (替换为你的 SSD 设备名) 进行分区。建议创建一个主分区，占用全部空间。\n    -   使用 `sudo mkfs.ext4 /dev/sda1` (替换为你的分区名) 格式化分区为 ext4 文件系统。\n\n3.  **挂载 SSD：**\n\n    -   创建一个挂载点：`sudo mkdir /mnt/ssd`\n\n    -   手动挂载：`sudo mount /dev/sda1 /mnt/ssd`\n\n    -   测试读写：在 `/mnt/ssd` 中创建一些文件，确保可以正常读写。\n\n    -   设置开机自动挂载：\n\n         编辑 \n\n        ```\n        /etc/fstab\n        ```\n\n         文件，添加一行来确保 SSD 在每次启动时自动挂载。\n\n        -   首先获取 SSD 分区的 UUID：`sudo blkid /dev/sda1`\n        -   编辑 fstab：`sudo nano /etc/fstab`\n        -   添加类似以下一行（替换 UUID）： `UUID=你的SSD分区UUID /mnt/ssd ext4 defaults,nofail 0 0`\n        -   保存并退出，然后运行 `sudo mount -a` 测试。\n\n4.  **（高级）系统迁移到 SSD (可选但强烈推荐):**\n\n    -   虽然 microSD 卡可以启动，但将大部分系统（特别是 /usr, /var 等）迁移到 SSD 上，可以显著提升系统性能和延长 microSD 卡寿命。\n    -   这个过程比较复杂，通常涉及：\n        -   将 microSD 卡上的分区内容复制到 SSD 上。\n        -   修改启动配置（如 `boot/extlinux/extlinux.conf` 或 `grub.cfg`，具体取决于你的镜像），让系统在启动后从 SSD 根目录运行。\n    -   这是一个比较高级的操作，如果你是 Linux 新手，可以先跳过，等熟悉后再尝试。暂时让 SSD 作为数据盘和 Docker 容器存储盘即可。\n\n**阶段四：Docker 环境搭建**\n\n**安装 Docker：**\n\n-   按照 Docker 官方文档在 ARM 架构的 Linux 系统上安装 Docker Engine。\n\n-   通常命令如下：\n\n    Bash\n\n    ```\n    sudo apt-get update\n    sudo apt-get install ca-certificates curl gnupg\n    sudo install -m 0755 -d /etc/apt/keyrings\n    curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg\n    sudo chmod a+r /etc/apt/keyrings/docker.gpg\n    echo \\\n      \"deb [arch=\"$(dpkg --print-architecture)\" signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/debian \\\n      \"$(. /etc/os-release && echo \"$VERSION_CODENAME\")\" stable\" | \\\n      sudo tee /etc/apt/sources.list.d/docker.list > /dev/null\n    sudo apt-get update\n    sudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n    ```\n\n-   将你的用户添加到 docker 组：`sudo usermod -aG docker your_username` (然后重新登录或重启)\n\n1.  **配置 Docker 存储路径 (重要！):**\n\n    -   默认情况下，Docker 容器镜像和数据存储在 `/var/lib/docker`，这会在 microSD 卡上。\n\n    -   为了将 Docker 数据存储到 SSD 上，你需要修改 Docker 配置。\n\n    -   编辑或创建 \n\n        ```\n        /etc/docker/daemon.json\n        ```\n\n         文件：\n\n        JSON\n\n        ```\n        {\n          \"data-root\": \"/mnt/ssd/docker-data\"\n        }\n        ```\n\n    -   保存文件后，重启 Docker 服务：`sudo systemctl restart docker`\n\n    -   **注意：** 确保 `/mnt/ssd/docker-data` 目录存在且有写入权限。\n\n**阶段五：部署 Dify 和 Qwen3-0.6B**\n\n1.  **部署 Dify：**\n    -   Dify 官方通常提供 Docker Compose 文件来简化部署。\n    -   访问 Dify 的 GitHub 仓库或官方文档，找到最新的 Docker Compose 部署指南。\n    -   将 `docker-compose.yml` 文件下载到你的 Radxa ZERO 3W 上，并根据 Dify 的文档进行配置（例如数据库连接、端口映射等）。\n    -   在 `docker-compose.yml` 所在的目录下运行 `docker compose up -d` 来启动 Dify 的所有容器。\n2.  **部署 Qwen3-0.6B (两种主要方式)：**\n    -   **方式一：通过 Dify 直接集成 (推荐):** Dify 平台本身设计用于集成 LLM。如果 Dify 支持 Qwen3-0.6B 作为其内置或可配置的模型，那么你只需要在 Dify 的界面上配置好模型 API 或路径即可。\n    -   方式二：单独部署 LLM 服务容器：\n        -   你可以使用 `Ollama` 或 `LM Studio` (如果有 ARM Linux 版本) 等工具来部署 Qwen3-0.6B 模型为一个本地 API 服务。\n        -   搜索 `Ollama docker arm64` 或 `Qwen3-0.6b docker` 等关键词，找到适配 ARM64 架构的 Docker 镜像。\n        -   运行一个 Docker 容器来加载和运行 Qwen3-0.6B 模型，并将其 API 暴露出来。\n        -   然后，在 Dify 中配置，让它通过这个本地 API 调用 Qwen3-0.6B 模型。\n    -   **重要：** 0.6B 的模型对内存要求相对低，但如果你买的是 4GB 内存的 ZERO 3W，可能需要在运行 Qwen 模型时注意内存占用，避免系统卡顿。如果能用量化后的模型版本，会更节省内存。\n\n**阶段六：家庭数据存储和同步**\n\n1.  **选择服务：**\n    -   **文件同步：** Syncthing (P2P 同步)、Nextcloud (私有云盘)\n    -   **媒体服务器：** Jellyfin / Plex (流媒体)\n    -   **下载工具：** Transmission / qBittorrent (BT/PT 下载)\n    -   **其他：** Samba/NFS (文件共享，如果需要在局域网内直接访问文件)\n2.  **部署为 Docker 容器：**\n    -   大多数这些服务都有现成的 Docker 镜像（确保选择 `arm64v8` 或 `aarch64` 架构的镜像）。\n    -   你可以为每个服务编写或下载 Docker Compose 文件，并配置它们的持久化存储目录到你的 SSD 上（例如 `/mnt/ssd/data/syncthing`、`/mnt/ssd/data/jellyfin` 等）。\n\n**阶段七：远程访问与管理**\n\n1.  **SSH 远程访问：**\n    -   一旦系统联网，你可以通过 SSH (Secure Shell) 从你的电脑远程连接到 Radxa ZERO 3W。\n    -   在 Windows 上可以使用 PuTTY 或 PowerShell/WSL，在 macOS/Linux 上直接使用终端的 `ssh` 命令。\n    -   这让你无需每次都连接显示器和键盘鼠标。\n2.  **端口转发与动态 DNS (如果需要外网访问)：**\n    -   如果你希望从家里外面也能访问你的服务器，你需要：\n        -   在你的路由器上设置**端口转发**，将外部请求转发到 Radxa ZERO 3W 的内部 IP 地址和端口。\n        -   使用**动态 DNS (DDNS)** 服务，将你的动态公网 IP 地址映射到一个固定的域名，方便访问。\n    -   **注意安全：** 暴露到外网需要格外小心，确保所有服务都配置了强密码，并考虑使用 VPN 或更安全的认证方式。\n\n**部署过程中的注意事项：**\n\n-   **耐心：** 首次接触单板计算机和 Linux 部署可能会遇到一些小问题，保持耐心，善用搜索引擎和社区资源。\n-   **文档：** 仔细阅读 Radxa 官方文档、你所用 Linux 发行版的文档以及 Docker、Dify 等服务的官方文档。\n-   **备份：** 在进行重要操作前（尤其是分区、格式化、Docker 配置修改等），最好备份重要数据。\n-   **社区支持：** Radxa、Docker、Dify 都有活跃的社区，遇到问题可以在论坛或 GitHub 提问。\n\n祝你部署顺利！\n\n\n\n---\n\n还有期末考试等着我，因此这些东西先告一段落吧！\n\n(2025-6-7日)\n\n----\n\n补充：开发板被我玩坏了，从家里回南京的时候。。。","categories":["科研启蒙"]},{"title":"Pytorch学习","url":"/posts/3227e790fe57/","content":"\n\n\n>   声明： 本文含有从各类教程中获取的内容和ai辅助生成内容\n\n在正式学习之前，先介绍两个很好用的函数:dir()和help()。\n\n一个包好比一个工具箱，工具箱下可能有其他的格子，各自下可能有工具，也可能还有格子。\n\n-   dir 用于看子模块的结构\n-   help用于看某个东西的作用\n\n比如\n\n```py\nimport torch\nprint(dir(torch)\n//得到很多个东西，其中有cuda\n print(dir(torch.cuda))\n //得到很多歌东西，其中有is_available\n  print(help(torch.cuda.is_avaiable))\n  //得到有关这个的作用\n```\n\n## 张量：tensor\n\n张量其实可以视为一种多维数组，用于存储和操纵多维数组。\n\n-   维度（Dimensionality） 一个标量是0维度、的张量，一个一维数组是一个一维的张量。\n-   形状（Shape）张量的形状指的是在每个维度的大小，一个3X4的张量意味着它有三行四列。\n-   数据类型（Dtype）有torch.int8,torch.int32,torch.float32等等\n\n>   Reading this passage in Zhihu is highly recommended: [深度学习中关于张量的阶、轴和形状的解释 | Pytorch系列（二） - 知乎](https://zhuanlan.zhihu.com/p/131591991)\n\n### tensor的属性\n\n**前四个和数据相关**\n\n1.   data： 被封装的tensor\n2.   dtype： 张量的数据类型\n3.   shape： 张量的形状\n4.   device : 获取张量所在设备，GPU/CPU\n\n**下面四个和梯度求导息息相关**\n\n5.   requires_grad: 是否需要计算梯度\n6.   grad: 梯度\n7.   grad_fn: 创建tensor的函数，是自动求导的关键所在\n8.   is_leaf: 指示张量是否为叶子结点\n\n### tensor张量的创建\n\n#### **一. 用torch.tensor()方法**\n\n将Python原生的列表或者numpy的Array对象作为参数，可以创建张量：\n\n```py\nimport numpy as np\nimport torch\ntensorA=torch.tensor([1,2,3,4])\n#tensorA是一个一维张量\ntensorB=torch.tensor(np.zeros([2,3]))\n#tensorB是一个二维张量\ntensorC=torch.tensor(np.Array([1,2,3]))\n#tensorC是一个一维张量\n```\n\n#### **二. 使用内置函数创建特殊形状的函数**\n\n你可以使用一些内置函数来创建特定形状的张量。\n\n-   **`torch.zeros()`** : 创建全为 0 的张量。\n-   **`torch.ones()`** : 创建全为 1 的张量。\n-   **`torch.empty()`** : 创建未初始化的张量（内容是随机的）。\n-   **`torch.rand()`** : 创建元素值在 [0, 1) 范围内的随机张量。\n-   **`torch.randn()`** : 创建服从标准`标准正态分布`的随机张量。\n\n>   这些函数的参数都是多个整数，代表形状\n\n```py\na=torch.zeros(2,3,4)\nprint('a: ',a)\nb=torch.ones(2,2)\nprint('b: ',b)\nc=torch.rand(4,1)\nprint('c: ',c)\nd=torch.randn(3,2)\nprint('d: ',d)\n```\n\n运行结果\n\n```py\na:  tensor([[[0., 0., 0., 0.],\n         [0., 0., 0., 0.],\n         [0., 0., 0., 0.]],\n\n        [[0., 0., 0., 0.],\n         [0., 0., 0., 0.],\n         [0., 0., 0., 0.]]])\nb:  tensor([[1., 1.],\n        [1., 1.]])\nc:  tensor([[0.4796],\n        [0.9827],\n        [0.9631],\n        [0.6458]])\nd:  tensor([[-1.8295, -0.7194],\n        [ 0.5028,  0.3128],\n        [-1.5890,  0.1775]])\n```\n\n>   如何理解高维的tensor？以这里的张量a为例，a的shape是(2,3,4),可以理解为2个shape为(3,4)的tensor 组合而成；shape为(3,4)的张量又是3个shape为(4,)的张量构成\n\n\n\n**三. 创建等差数列**\n\n你可以使用 `torch.arange()` 或 `torch.linspace()` 来创建等差数列的张量。\n\n-   **`torch.arange(start, end, step)`** : 创建从 `start` 到 `end`（不包括 `end`），步长为 `step` 的张量。\n-   **`torch.linspace(start, end, steps)`** : 创建从 `start` 到 `end`（包括 `end`），分为 `steps` 个点的张量。\n\n```python\nprint(torch.arange(2,3,0.1))\nprint(torch.linspace(3,4,10))\n'''\ntensor([2.0000, 2.1000, 2.2000, 2.3000, 2.4000, 2.5000, 2.6000, 2.7000, 2.8000,\n        2.9000])\ntensor([3.0000, 3.1111, 3.2222, 3.3333, 3.4444, 3.5556, 3.6667, 3.7778, 3.8889,\n        4.0000])\n```\n\n**注意torch.linspace的第三个参数是’份数‘，而torch.arange的第三个参数是步长**\n\n#### **四. 创建单位矩阵**\n\n使用torch.eye(n)来创建一个n*n维的单位矩阵\n\n```py\neye_tensor = torch.eye(3)\nprint(eye_tensor)\n''' tensor([[1., 0., 0.],\n        [0., 1., 0.],\n        [0., 0., 1.]])'''\n```\n\n#### **五.从已有的张量创建新的张量**\n\n**1. 形状相同：**\n\n使用``torch.ones_like`可创建和参数一样Shape的，全为零的tensor\n\n使用``torch.rand_like`可创建和参数一样Shape的，值全为0~1间随机的数字\n\n类似的还有`zeros_like`和`randn_like`\n\n**2.形状和数值都相同**\n\n深拷贝：`new_tensor=torch.tensor(old_tensor)`\n\n`new_tensor=old_tensor.clone()`\n\n>   从ndarray创建的tensor不是深拷贝，而是相同对象的引用\n\n### tensor的运算\n\n#### 基本数学运算\n\n**一.加减乘除**\n\n两个tensor的加减乘除得到一个新的**同形状**的tensor，新的 tensor上每一个元素都是参与运算的两个tensor对应元素的加减乘除\n\n>   即，**逐元素加减乘除**\n\n```python\ntensorA=torch.tensor([2,3,4])\ntensorB=torch.tensor([4,6,8])\nprint('tensorA: ',tensorA)\nprint('tensorB: ',tensorB)\nprint('tensorB+tensorA: ',tensorB+tensorA)\nprint('tensorA-tensorB: ',-tensorB+tensorA)\nprint('tensorB*tensorA: ',tensorB*tensorA)\nprint('tensorB/tensorA: ',tensorB/tensorA)\n'''\nresults:\ntensorA:  tensor([2, 3, 4])\ntensorB:  tensor([4, 6, 8])\ntensorB+tensorA:  tensor([ 6,  9, 12])\ntensorA-tensorB:  tensor([-2, -3, -4])\ntensorB*tensorA:  tensor([ 8, 18, 32])\ntensorB/tensorA:  tensor([2., 2., 2.])\n'''\n```\n\n**二.矩阵运算**\n\n**矩阵乘法**：使用`torch.matmul`或者`@`运算符\n\n```python\na=torch.tensor([[1,2,3],[1,2,3]])\nb=torch.tensor([[1,2],[1,2],[1,2]])\nprint('a @ b : \\n',a @ b,'\\n')\nprint('torch.matmul(a,b) :\\n',torch.matmul(a,b))\n''' a @ b : \n tensor([[ 6, 12],\n        [ 6, 12]]) \n\ntorch.matmul(a,b) :\n tensor([[ 6, 12],\n        [ 6, 12]])\n'''\n```\n\n**矩阵转置**：使用`.t()`方法对二维张量进行转置，使用`.transpose()`方法对任意维度张量进行转置\n\n```python\na=torch.rand(2,3,4)\nprint(a.transpose(0,1)) #将第0维和第1维进行交换\n''' \ntensor([[[0.0687, 0.0416, 0.0968, 0.0315],\n         [0.6092, 0.9713, 0.4944, 0.3970]],\n\n        [[0.5626, 0.0456, 0.3268, 0.8884],\n         [0.0375, 0.4542, 0.3374, 0.3793]],\n\n        [[0.8587, 0.5564, 0.9749, 0.0923],\n         [0.9446, 0.3608, 0.3371, 0.1169]]])\n'''\n```\n\n交换维度还有其他的办法：`torch.permute()`，接受的参数是从0~n-1的整数的一个序列。对于这个序列的第i项，a ~i~ ,表示把原来的第a~i~维换到了第i维。\n\n比如给定一个三维的张量a=troch.rand(2,3,4)，它的shape为(2,3,4)，如果a.permute(0,2,1)，那么会得到一个shape为(2,4,3)的张量。\n\n>   `permute` 只能重新排列已有的维度，而不能改变张量的形状。\n\n**三. 索引，切片，连接**\n\n先理解什么是多维的张量，张量不同于向量（或者说向量就是一维的张量），张量的维度和向量的维度不是一个概念，张量的维度和编程中的张量维度是一致的。四维张量是多个三维张量组合而成，三维张量不过是多个二维张量组合而成，以此类推。\n\n**1.索引操作**\n\n```python\na=torch.rand(2,3,4)\nprint(a)\nprint(a[0])\nprint(a[0][0])\nprint(a[0][0][0])\n''' \ntensor([[[0.6739, 0.9918, 0.5762, 0.1026],\n         [0.4075, 0.6841, 0.9652, 0.4298],\n         [0.6714, 0.4911, 0.6309, 0.2346]],\n\n        [[0.5633, 0.0261, 0.7101, 0.6402],\n         [0.1149, 0.0642, 0.5243, 0.2973],\n         [0.3718, 0.8068, 0.3164, 0.9270]]])\ntensor([[0.6739, 0.9918, 0.5762, 0.1026],\n        [0.4075, 0.6841, 0.9652, 0.4298],\n        [0.6714, 0.4911, 0.6309, 0.2346]])\ntensor([0.6739, 0.9918, 0.5762, 0.1026])\ntensor(0.6739)\n'''\n```\n\n这里上面和多维数组的操作没有什么区别，但是张量还可以直接取出第n维的数据：\n\n```python\nprint(a[:,1]) #等价于a[:,1,:],得到的shape是原先的shape除去第1维(维度的索引从0开始，这里第一维其实是第二维)\nprint(a[:,:,0])\n''' \ntensor([[0.4075, 0.6841, 0.9652, 0.4298],\n        [0.1149, 0.0642, 0.5243, 0.2973]])\ntensor([[0.6739, 0.4075, 0.6714],\n        [0.5633, 0.1149, 0.3718]])\n'''\n```\n\n如何理解这里的取索引操作呢？这里给出yama的想法：\n\n1.   从第0维开始读，如果这一维度的索引已经**指定了**，那么**取对应的元素**，并接着往下读索引；如果索引**没有给出**（包括`a[:,1]`和`a[1]`,前者省略了第0维和第1维以后的索引，后者省略了第0维以后所有的索引)那么就**全取**\n2.   以下面这个例子为例，如果给定了确定的索引，那么取对应的元素（即取对应二维张量）\n\n```py\na=torch.rand(2,3,4)\nprint(a)\nprint(a[0])\n\n''' \n# 原先的张量，shape为(2,3,4)\ntensor([[[0.6739, 0.9918, 0.5762, 0.1026],\n         [0.4075, 0.6841, 0.9652, 0.4298],\n         [0.6714, 0.4911, 0.6309, 0.2346]],\n\n        [[0.5633, 0.0261, 0.7101, 0.6402],\n         [0.1149, 0.0642, 0.5243, 0.2973],\n         [0.3718, 0.8068, 0.3164, 0.9270]]])\n# 取出的二维张量，shape为(3,4)\ntensor([[0.6739, 0.9918, 0.5762, 0.1026],\n        [0.4075, 0.6841, 0.9652, 0.4298],\n        [0.6714, 0.4911, 0.6309, 0.2346]])\n'''\n```\n\n然后接着读，发现`a[0]`只指定了第0维的索引，因此，后面默认都是`全选`\n\n\n\n3.   如果第0维没有指定，但是后面维度指定了索引，下面以这个为例：\n\n```python\nprint(a[:,1]) \n#等价于a[:,1,:],得到的shape是原先的shape除去第1维(维度的索引从0开始，这里第一维其实是第二维)\n''' \ntensor([[0.4075, 0.6841, 0.9652, 0.4298],\n        [0.1149, 0.0642, 0.5243, 0.2973]])\n'''\n```\n\n我们可以看到，这里第0维因为没有指定，所以`全选` （指的最后得到的tensor中，拥有这一维度的所有数据，“原来在这个维度有三个子tensor，现在依旧是这样”，或“这根轴上的长度没有变小”[深度学习中关于张量的阶、轴和形状的解释 | Pytorch系列（二） - 知乎](https://zhuanlan.zhihu.com/p/131591991)）\n\n4.   接着递归地读取索引，即可得到最终的张量。\n\n**2. 拼接**\n\n```python\na=torch.tensor([[[1,2],[3,4],[5,6]],[[1,2],[3,4],[5,6]],[[1,2],[3,4],[5,6]]])\nprint(a.shape)\nprint(torch.cat((a,a),dim=0).shape)\nprint(torch.cat((a,a),dim=1).shape)\nprint(torch.cat((a,a),dim=2).shape)\nprint(torch.stack((a,a),dim=0).shape)\nprint(torch.stack((a,a),dim=1).shape)\nprint(torch.stack((a,a,a),dim=0).shape)#也可以多个拼接\nprint(torch.cat((a,a,a),dim=0).shape)#也可以多个拼接\n```\n\noutput:\n\n```\ntorch.Size([3, 3, 2])\ntorch.Size([6, 3, 2])\ntorch.Size([3, 6, 2])\ntorch.Size([3, 3, 4])\ntorch.Size([2, 3, 3, 2])\ntorch.Size([3, 2, 3, 2])\ntorch.Size([3, 3, 3, 2])\ntorch.Size([9, 3, 2])\n```\n\n`torch.stack`和`torch.cat`的区别在于前者是把当下dim那一维的数据包在一起，形成一个新的维度；后者是把dim这一层的东西全部家在同一层里面。\n\n\n\n\n\n## 自动求导模块\n\n### 计算图\n\n在**向前传播**的过程中，pytorch会记录每一步的操作，便于在**反向传播**的时候求**梯度**，记录的内容就是**计算图**\n\n### 计算梯度\n\n>   梯度是**损失函数对模型参数的梯度** \n\n我们在forward过程中会获得一个函数，比如`y=x**x+3*x+5`\n\n我们可以借助`backward`来计算参数\n\n```py\nimport torch\n\n# 创建一个张量，并设置 requires_grad=True\nx = torch.tensor([2.0, 3.0], requires_grad=True)\n\n# 定义一个简单的函数 y = x^2 + 3x + 5\ny = x**2 + 3*x + 5\n\n# 计算 y 对 x 的梯度\ny.backward(torch.tensor([1.0, 1.0]))  # 传递权重向量\n\n# 查看梯度\nprint(\"x 的梯度:\", x.grad)\n\n# 禁用梯度计算\nwith torch.no_grad():\n    #在这个子模块中，不会跟踪梯度计算\n    z = x**2 + 3*x + 5\n    print(\"z 的值:\", z)\n\n# 使用 detach() 方法 得到一个不需要计算梯度的张量\nx_detached = x.detach()\nprint(\"x_detached 的值:\", x_detached)\n```\n\n如果y是一个标量，那么无需传递权重参数；如果y是一个n维的tensor（或者说x是一个n维的tensor），那么需要传递一个n维数组，代表权重。\n\n## 数据加载\n\n#### Dataset\n\n>   注意大写**Dataset**\n\nDataset是一个用于储存和管理数据的一个类。\n\n```python\nfrom torch.utils.data import Dataset,DataLoader\n#创建属于自己的Dataset类\nclass myDataSet(Dataset):\n    def __init__(self,data,labels):\n        self.data=data\n        self.labels=labels\n    def __len__(self):\n        return len(self.data)\n    def __getitem__(self,idx):\n        return self.data[idx],self.labels[idx]\ndata=torch.rand(10,3)\nlabels=torch.randint(0,2,(10,))\n#注意，这里第三个参数是shape\ndataset=myDataSet(data,labels)\n\nprint('idx\\tdata\\t\\t\\t\\t\\tlabel')\nfor idx in range(len(dataset)):\n    d,label=dataset[idx]\n    print(idx,'\\t',d,'\\t',label)\n```\n\noutput：\n\n```\nidx\tdata\t\t\t\t               \tlabel\n0 \t tensor([0.5844, 0.8253, 0.8348]) \t tensor(0)\n1 \t tensor([0.7215, 0.7513, 0.3788]) \t tensor(0)\n2 \t tensor([0.2878, 0.6035, 0.5831]) \t tensor(0)\n3 \t tensor([0.3502, 0.7822, 0.5622]) \t tensor(1)\n4 \t tensor([0.3010, 0.0765, 0.3608]) \t tensor(0)\n5 \t tensor([0.5522, 0.3278, 0.1177]) \t tensor(1)\n6 \t tensor([0.0602, 0.3381, 0.9306]) \t tensor(0)\n7 \t tensor([0.2770, 0.5383, 0.1920]) \t tensor(0)\n8 \t tensor([0.6101, 0.4523, 0.5425]) \t tensor(1)\n9 \t tensor([0.4292, 0.8549, 0.5172]) \t tensor(0)\n```\n\n### DataLoader\n\nDataLoader是加载数据的一个工具，将数据从Dataset中按批次加载，并且支持打乱数据等功能。\n\n**可以使用DataLoader将Dataset打包成一个可迭代对象**\n\n```python\nfrom torch.utils.data import Dataset\nfrom torch.utils.data import DataLoader\n\nclass myDataSet(Dataset):\n    def __init__(self,data,labels):\n        self.data=data\n        self.labels=labels\n    def __len__(self):\n        return len(self.data)\n    def __getitem__(self,idx):\n        return self.data[idx],self.labels[idx]\ndata=torch.rand(20,3)\nlabels=torch.randint(0,2,(20,))\ndataset=myDataSet(data,labels)\nlen(dataset)\ndataloader=DataLoader(dataset,batch_size=5,shuffle=True)\nfor batch_data,batch_size in dataloader:\n    print(batch_data)\n```\n\n输出：\n\n```\ntensor([[0.7829, 0.9668, 0.0646],\n        [0.1576, 0.7564, 0.5376],\n        [0.3377, 0.2903, 0.0758],\n        [0.4523, 0.6460, 0.5544],\n        [0.9514, 0.6436, 0.3744]])\ntensor([[0.1227, 0.4072, 0.1857],\n        [0.1000, 0.0336, 0.3713],\n        [0.4613, 0.8199, 0.5381],\n        [0.7966, 0.4351, 0.8256],\n        [0.1984, 0.0263, 0.4809]])\ntensor([[0.2561, 0.1912, 0.4118],\n        [0.2537, 0.5558, 0.3612],\n        [0.4839, 0.9967, 0.5584],\n        [0.8203, 0.9401, 0.9798],\n        [0.3146, 0.0245, 0.3652]])\ntensor([[0.0591, 0.4059, 0.8901],\n        [0.4426, 0.5236, 0.4988],\n        [0.7388, 0.3117, 0.9683],\n        [0.7014, 0.3335, 0.4483],\n        [0.8727, 0.4119, 0.0646]])\n```\n\n## 神经网络模块\n\n推荐阅读：[神经网络 — PyTorch Tutorials 2.6.0+cu124 文档 - PyTorch 深度学习库](https://pytorch.ac.cn/tutorials/beginner/blitz/neural_networks_tutorial.html)\n\n### **构建神经网络：torch.nn.Module**\n\n **torch.nn.Module**是所有神经网络的基类，所有自定义的网络基类都需要继承这个类\n\n`torch.nn`里面有丰富的内容，其中包括多种网络层和损失函数\n\n1.   **线性层**`torch.nn.Linear(in_features=10,out_features=5)`将张量的最后一维（长度为10），映射为长度为5。Linear只会处理最后一维！！！线性变换公式为：*y*=x * W^T^+b其中 *W* 是权重矩阵，*b* 是偏置向量。\n\n1.   **激活函数**：`nn.ReLU`,`nn.Sigmoid`,`nn.tanh`等\n2.   **损失函数** ：如`nn.MSELoss()`,`nn.CrossEntropyLoss()`\n\n\n\n```py\nimport torch.nn as nn\nimport torch.optim as optim\nclass MyNet(nn.Module):\n    def __init__(self):\n        super(MyNet,self).__init__()\n        self.fc1=nn.Linear(in_features=10,out_features=5)\n        self.relu=nn.ReLU\n        self.fc2=nn.Linear(in_features=5,out_features=2)\n    def forward(self):\n        x=self.fc1(x)\n        x=self.relu(x)\n        x=self.fc2(x)\n        return x\nnet=MyNet()\nprint(net)\n```\n\n定义一个神经网络，需要定义里面的每一层，以及forward的方法。\n\n### 评估神经网络：损失函数\n\n评估模型的好坏，我们需要将神经网络的输出和我们预测的输出进行对比，需要用到损失函数。\n\n常见的损失函数有\n\n1.   MSELoss: 均方损失函数，用于回归\n2.   CrossEntropyLoss交叉熵损失，用于分类问题\n3.   BCELoss二院交叉熵损失，用于二分类\n\n```python \ncriterion=nn.BCELoss()#define the criterion function\npredictions=net(rawData)\nloss=criterion(predictions,targets)\n#compare the predictions and targets \nprint(loss.item())\n```\n\n在这里，loss是一个张量，我们可以通过`loss.backward()`进行**反向传播**\n\n\n\n### **优化神经网络：torch.optim**\n\n`torch.optim` 是 PyTorch 中用于优化模型参数的模块，提供了多种优化算法（如 SGD、Adam 等）。它的主要作用是根据梯度更新模型参数。\n\n在模型训练的过程中，需要不断地进行 清空损失函数的梯度，反向传播，优化参数等步骤\n\n```py\nimport torch.optim as optim\noptimizer=optim.SGD(net.parameters(),lr=0.01)\n\noptimizer.zero_grad()#每一次都要清空梯度，因为每一次loss调用backward时，都会将梯度进行积累\nloss.backward()#反向传播计算梯度\noptimizer.step()#优化参数\n```\n\n>   net.paramters()返回一个迭代器，每一个都是网络层的权重和配置等；\n>\n>   lr，learning rate学习率\n\n## 保存和加载模型\n\n推荐阅读：[PyTorch | 保存和加载模型 - 知乎](https://zhuanlan.zhihu.com/p/82038049#:~:text=原题 | SAVING AND LOADING MODELS作者 | Matthew)\n\n[Saving and Loading Models — PyTorch Tutorials 2.6.0+cu124 documentation](https://pytorch.org/tutorials/beginner/saving_loading_models.html)\n\n### Save and load the state_dict\n\n#### ** 什么是状态字典(state_dict)**\n\nPyTorch 中，一个模型(`torch.nn.Module`)的可学习参数(也就是权重和偏置值)是包含在模型参数(`model.parameters()`)中的，一个状态字典就是一个简单的 Python 的字典，其键值对是每个网络层和其对应的参数张量。模型的状态字典只包含带有可学习参数的网络层（比如卷积层、全连接层等）和注册的缓存（`batchnorm`的 `running_mean`）。优化器对象(`torch.optim`)同样也是有一个状态字典，包含的优化器状态的信息以及使用的超参数。\n\n>   Adapted from Zhihu\n\n#### **加载/保存状态字典**\n\n保存的代码：\n\n```text\ntorch.save(model.state_dict(), PATH)\n```\n\n加载的代码：\n\n```text\nmodel = TheModelClass(*args, **kwargs)\nmodel.load_state_dict(torch.load(PATH))\nmodel.eval()\n```\n\n当需要为预测保存一个模型的时候，只需要保存训练模型的可学习参数即可。采用 `torch.save()` 来保存模型的状态字典的做法可以更方便加载模型，这也是推荐这种做法的原因。\n\n通常会用 `.pt` 或者 `.pth` 后缀来保存模型。\n\n记住\n\n1.  在进行预测之前，必须调用 `model.eval()` 方法来将 `dropout` 和 `batch normalization` 层设置为验证模型。否则，只会生成前后不一致的预测结果。\n2.  `load_state_dict()` 方法必须传入一个字典对象，而不是对象的保存路径，也就是说必须先反序列化字典对象，然后再调用该方法，也是例子中先采用 `torch.load()` ，而不是直接 `model.load_state_dict(PATH)`\n\n\n\n## 项目实战：判断一个点在第几个象限（多分类）\n\n```py\nimport torch\nimport torch.nn as nn\nimport torch.optim as optim\nimport numpy as np\nclass SorterNet(nn.Module):\n    def __init__(self):\n        super(SorterNet,self).__init__()\n        self.fc1=nn.Linear(2,128)\n        self.fc2=nn.Linear(128,128)\n        self.fc3=nn.Linear(128,4)# 最终映射得到四个数字，代表四个象限\n        self.relu=nn.ReLU()\n    def forward(self,x):\n        x=self.fc1(x)\n        x=self.relu(x)\n        x=self.fc2(x)\n        x=self.relu(x)\n        x=self.fc3(x)\n        return x\nsorter=SorterNet()\n\noptimizer=optim.Adam(sorter.parameters(),lr=0.01)\ncriterion=nn.CrossEntropyLoss()\nscheduler = optim.lr_scheduler.StepLR(optimizer, step_size=10, gamma=0.1)  # Reduce LR every 10 epochs by a factor of 0.1\n\nfrom torch.utils.data import Dataset,DataLoader\n\nclass myDataset(Dataset):\n    def __init__(self,size=1000):\n        self.data=[]\n        self.label=[]\n        self.size=size\n        for _ in range(self.size):\n            tempArray=np.random.random_sample((2,))*1000-500\n            self.data.append(tempArray)\n            if(tempArray[0]>0 and tempArray[1]>0):\n                self.label.append(0)\n            elif(tempArray[0]<0 and tempArray[1]>0):\n                self.label.append(1)\n            elif(tempArray[0]<0 and tempArray[1]<0):\n                self.label.append(2)\n            else:\n                self.label.append(3)\n        self.label=torch.tensor(self.label,dtype=torch.long)\n        self.data=torch.tensor(self.data,dtype=torch.float32)\n    def __len__(self):\n        return self.size\n    def __getitem__(self,idx):\n        return self.data[idx],self.label[idx] #return both the data and the expected result(label)\ndataset=myDataset(500)\n\ndataloader=DataLoader(dataset,batch_size=128,shuffle=True)\n\nfor epoch in range(100):\n    loss_sum=0\n    for inputs,labels in dataloader:\n        results=sorter(inputs)\n        loss=criterion(results,labels)\n        optimizer.zero_grad()\n        loss.backward()\n        torch.nn.utils.clip_grad_norm_(sorter.parameters(), max_norm=1.0)  # Clip gradients to avoid exploding gradients\n        optimizer.step()\n        scheduler.step()\n        loss_sum+=loss.item()\n    if epoch%100==99:\n        print(f\"Epoch[{epoch}/1000] loss: {loss_sum}\")\n\n```\n\n测试代码：\n\n```py\nimport numpy as np\nimport torch\n\ndef test_model(model, x, y, label):\n    # Convert (x, y) into a tensor and reshape it for the model input\n    input_tensor = torch.tensor([x, y], dtype=torch.float32).unsqueeze(0)  # Shape (1, 2)\n    \n    # Pass input through the model\n    output = model(input_tensor)\n    \n    # Get predicted class (index with highest probability)\n    _, predicted_class = torch.max(output, 1)\n    \n    # If prediction matches the true label, return the updated count\n    if (x >= 0 and y >= 0 and label == predicted_class.item()) or \\\n       (x < 0 and y > 0 and label == predicted_class.item()) or \\\n       (x < 0 and y < 0 and label == predicted_class.item()) or \\\n       (x > 0 and y < 0 and label == predicted_class.item()):\n        return 1  # Correct prediction\n    else:\n        return 0  # Incorrect prediction\n\ndef test_function(model, test_num=1000):\n    test_input = [[np.random.random_sample(), np.random.random_sample()] for _ in range(test_num)]\n    test_label = []\n    for x, y in test_input:\n        if x >= 0 and y >= 0:\n            test_label.append(0)\n        elif x < 0 and y > 0:\n            test_label.append(1)\n        elif x < 0 and y < 0:\n            test_label.append(2)\n        else:\n            test_label.append(3)\n\n    correct_count = 0\n    test_count = 0\n    for idx, (x, y) in enumerate(test_input):\n        correct_count += test_model(model, x, y, test_label[idx])  # Count correct predictions\n        test_count += 1  # Total tests\n\n    correct_rate = correct_count / test_count  # Calculate accuracy\n    return test_count, correct_count, correct_rate\n\n# Test the function\ntest_count_sum = 0\ntest_correct_sum = 0\nfor _ in range(10):\n    test_count, correct_count, correct_rate = test_function(sorter)\n    test_count_sum += test_count\n    test_correct_sum += correct_count\n\n# Calculate overall accuracy\nrate = test_correct_sum / test_count_sum\nprint(f\"Overall Accuracy: {rate:.4f}\")\n```\n\n交互版本：\n\n```py\ndef predict_quadrant(model):\n    # 获取用户输入的坐标\n    x = float(input(\"请输入x坐标: \"))\n    y = float(input(\"请输入y坐标: \"))\n    \n    # 将输入的坐标转换为 tensor\n    input_tensor = torch.tensor([x, y], dtype=torch.float32).unsqueeze(0)  # Shape (1, 2)\n    \n    # 使用模型进行预测\n    output = model(input_tensor)\n    \n    # 获取预测的类别\n    _, predicted_class = torch.max(output, 1)\n    \n    # 显示预测结果\n    if predicted_class.item() == 0:\n        print(f\"坐标 ({x}, {y}) 位于第一象限 (x>0, y>0)\")\n    elif predicted_class.item() == 1:\n        print(f\"坐标 ({x}, {y}) 位于第二象限 (x<0, y>0)\")\n    elif predicted_class.item() == 2:\n        print(f\"坐标 ({x}, {y}) 位于第三象限 (x<0, y<0)\")\n    else:\n        print(f\"坐标 ({x}, {y}) 位于第四象限 (x>0, y<0)\")\n\n# 使用示例\nwhile True:\n    predict_quadrant(sorter)  # 输入并预测某个坐标\n```\n\n","categories":["科研启蒙"]},{"url":"/posts/22f13f9d2720/","content":"读完本文，你可以去力扣拿下如下题目：\n\n[28.实现 strStr()](https://link.zhihu.com/?target=https%3A//leetcode-cn.com/problems/implement-strstr)\n\n**\\-----------**\n\nKMP 算法（Knuth-Morris-Pratt 算法）是一个著名的字符串匹配算法，效率很高，但是确实有点复杂。\n\n很多读者抱怨 KMP 算法无法理解，这很正常，想到大学教材上关于 KMP 算法的讲解，也不知道有多少未来的 Knuth、Morris、Pratt 被提前劝退了。有一些优秀的同学通过手推 KMP 算法的过程来辅助理解该算法，这是一种办法，不过本文要从逻辑层面帮助读者理解算法的原理。十行代码之间，KMP 灰飞烟灭。\n\n**先在开头约定，本文用 `pat` 表示模式串，长度为 `M`，`txt` 表示文本串，长度为 `N`。KMP 算法是在 `txt` 中查找子串 `pat`，如果存在，返回这个子串的起始索引，否则返回 -1**。\n\n为什么我认为 KMP 算法就是个动态规划问题呢，等会再解释。对于动态规划，之前多次强调了要明确 `dp` 数组的含义，而且同一个问题可能有不止一种定义 `dp` 数组含义的方法，不同的定义会有不同的解法。\n\n读者见过的 KMP 算法应该是，一波诡异的操作处理 `pat` 后形成一个一维的数组 `next`，然后根据这个数组经过又一波复杂操作去匹配 `txt`。时间复杂度 O(N)，空间复杂度 O(M)。其实它这个 `next` 数组就相当于 `dp` 数组，其中元素的含义跟 `pat` 的前缀和后缀有关，判定规则比较复杂，不好理解。**本文则用一个二维的 `dp` 数组（但空间复杂度还是 O(M)），重新定义其中元素的含义，使得代码长度大大减少，可解释性大大提高**。\n\nPS：本文的代码参考《算法4》，原代码使用的数组名称是 `dfa`（确定有限状态机），因为我们的公众号之前有一系列动态规划的文章，就不说这么高大上的名词了，我对书中代码进行了一点修改，并沿用 `dp` 数组的名称。\n\n### **一、KMP 算法概述**\n\n首先还是简单介绍一下 KMP 算法和暴力匹配算法的不同在哪里，难点在哪里，和动态规划有啥关系。\n\n暴力的字符串匹配算法很容易写，看一下它的运行逻辑：\n\n```text\n// 暴力匹配（伪码）\nint search(String pat, String txt) {\n    int M = pat.length;\n    int N = txt.length;\n    for (int i = 0; i <= N - M; i++) {\n        int j;\n        for (j = 0; j < M; j++) {\n            if (pat[j] != txt[i+j])\n                break;\n        }\n        // pat 全都匹配了\n        if (j == M) return i;\n    }\n    // txt 中不存在 pat 子串\n    return -1;\n}\n```\n\n对于暴力算法，如果出现不匹配字符，同时回退 `txt` 和 `pat` 的指针，嵌套 for 循环，时间复杂度 `O(MN)`，空间复杂度`O(1)`。最主要的问题是，如果字符串中重复的字符比较多，该算法就显得很蠢。\n\n比如 txt = \"aaacaaab\" pat = \"aaab\"：\n\n![](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/v2-817073ca77f6c75d234392f207a3c81b_1440w.gif)\n\n很明显，`pat` 中根本没有字符 c，根本没必要回退指针 `i`，暴力解法明显多做了很多不必要的操作。\n\nKMP 算法的不同之处在于，它会花费空间来记录一些信息，在上述情况中就会显得很聪明：\n\n![](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/v2-f29d822e4faf22542875de6c73fe07d0_1440w.gif)\n\n再比如类似的 txt = \"aaaaaaab\" pat = \"aaab\"，暴力解法还会和上面那个例子一样蠢蠢地回退指针 `i`，而 KMP 算法又会耍聪明：\n\n![](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/v2-e66f7a92145c8e3ea8c87b5889fbaf54_1440w.gif)\n\n因为 KMP 算法知道字符 b 之前的字符 a 都是匹配的，所以每次只需要比较字符 b 是否被匹配就行了。\n\n**KMP 算法永不回退 `txt` 的指针 `i`，不走回头路（不会重复扫描 `txt`），而是借助 `dp` 数组中储存的信息把 `pat` 移到正确的位置继续匹配**，时间复杂度只需 O(N)，用空间换时间，所以我认为它是一种动态规划算法。\n\nKMP 算法的难点在于，如何计算 `dp` 数组中的信息？如何根据这些信息正确地移动 `pat` 的指针？这个就需要**确定有限状态自动机**来辅助了，别怕这种高大上的文学词汇，其实和动态规划的 `dp` 数组如出一辙，等你学会了也可以拿这个词去吓唬别人。\n\n还有一点需要明确的是：**计算这个 `dp` 数组，只和 `pat` 串有关**。意思是说，只要给我个 `pat`，我就能通过这个模式串计算出 `dp` 数组，然后你可以给我不同的 `txt`，我都不怕，利用这个 `dp` 数组我都能在 O(N) 时间完成字符串匹配。\n\nPS：**我认真写了 100 多篇原创，手把手刷 200 道力扣题目，全部发布在 [labuladong的算法小抄](https://link.zhihu.com/?target=https%3A//labuladong.gitbook.io/algo/)，持续更新**。建议收藏，**按照我的文章顺序刷题**，掌握各种算法套路后投再入题海就如鱼得水了。\n\n具体来说，比如上文举的两个例子：\n\n```text\ntxt1 = \"aaacaaab\" \npat = \"aaab\"\ntxt2 = \"aaaaaaab\" \npat = \"aaab\"\n```\n\n我们的 `txt` 不同，但是 `pat` 是一样的，所以 KMP 算法使用的 `dp` 数组是同一个。\n\n只不过对于 `txt1` 的下面这个即将出现的未匹配情况：\n\n![](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/v2-f62544416694bb9241ff550bfb461911_1440w.jpg)\n\n`dp` 数组指示 `pat` 这样移动：\n\n![](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/v2-58b814fe0bab3a90487859bf250a1ce4_1440w.jpg)\n\nPS：这个`j` 不要理解为索引，它的含义更准确地说应该是**状态**（state），所以它会出现这个奇怪的位置，后文会详述。\n\n而对于 `txt2` 的下面这个即将出现的未匹配情况：\n\n![](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/v2-29b8ad3d8ca4c2b59aa06a2734d84452_1440w.jpg)\n\n`dp` 数组指示 `pat` 这样移动：\n\n![](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/v2-23f39d5653611fc1445a94fadb5d36a0_1440w.jpg)\n\n明白了 `dp` 数组只和 `pat` 有关，那么我们这样设计 KMP 算法就会比较漂亮：\n\n```text\npublic class KMP {\n    private int[][] dp;\n    private String pat;\n\n    public KMP(String pat) {\n        this.pat = pat;\n        // 通过 pat 构建 dp 数组\n        // 需要 O(M) 时间\n    }\n\n    public int search(String txt) {\n        // 借助 dp 数组去匹配 txt\n        // 需要 O(N) 时间\n    }\n}\n```\n\n这样，当我们需要用同一 `pat` 去匹配不同 `txt` 时，就不需要浪费时间构造 `dp` 数组了：\n\n```text\nKMP kmp = new KMP(\"aaab\");\nint pos1 = kmp.search(\"aaacaaab\"); //4\nint pos2 = kmp.search(\"aaaaaaab\"); //4\n```\n\n### **二、状态机概述**\n\n为什么说 KMP 算法和状态机有关呢？是这样的，我们可以认为 `pat` 的匹配就是状态的转移。比如当 pat = \"ABABC\"：\n\n![](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/v2-7594db068368bdcef4a905d0f3b474b6_1440w.jpg)\n\n如上图，圆圈内的数字就是状态，状态 0 是起始状态，状态 5（`pat.length`）是终止状态。开始匹配时 `pat` 处于起始状态，一旦转移到终止状态，就说明在 `txt` 中找到了 `pat`。比如说当前处于状态 2，就说明字符 \"AB\" 被匹配：\n\n![](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/v2-0afefcb3d2640b45008bc48e68f00c58_1440w.jpg)\n\n另外，处于不同状态时，`pat` 状态转移的行为也不同。比如说假设现在匹配到了状态 4，如果遇到字符 A 就应该转移到状态 3，遇到字符 C 就应该转移到状态 5，如果遇到字符 B 就应该转移到状态 0：\n\n![](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/v2-3e1130b3685e1f70bee5b1eee1daf212_1440w.jpg)\n\n具体什么意思呢，我们来一个个举例看看。用变量 `j` 表示指向当前状态的指针，当前 `pat` 匹配到了状态 4：\n\n![](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/v2-56613eabdb3c4bc0ee9359fcdeb5a75c_1440w.jpg)\n\n如果遇到了字符 \"A\"，根据箭头指示，转移到状态 3 是最聪明的：\n\n![](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/v2-2287d3a55e4741f37fafa3b1418020ec_1440w.jpg)\n\n如果遇到了字符 \"B\"，根据箭头指示，只能转移到状态 0（一夜回到解放前）：\n\n![](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/v2-84f06bb9590a3eef4599e68c763e93f7_1440w.jpg)\n\n如果遇到了字符 \"C\"，根据箭头指示，应该转移到终止状态 5，这也就意味着匹配完成：\n\n![](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/v2-5eba5e0c73982161fe9793012751b14b_1440w.jpg)\n\n当然了，还可能遇到其他字符，比如 Z，但是显然应该转移到起始状态 0，因为 `pat` 中根本都没有字符 Z：\n\n![](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/v2-4454ed8c121b670980b83f6914e28284_1440w.jpg)\n\n这里为了清晰起见，我们画状态图时就把其他字符转移到状态 0 的箭头省略，只画 `pat` 中出现的字符的状态转移：\n\n![](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/v2-2788562d1059d7b8ff71aa342e4ae036_1440w.jpg)\n\nKMP 算法最关键的步骤就是构造这个状态转移图。**要确定状态转移的行为，得明确两个变量，一个是当前的匹配状态，另一个是遇到的字符**；确定了这两个变量后，就可以知道这个情况下应该转移到哪个状态。\n\n下面看一下 KMP 算法根据这幅状态转移图匹配字符串 `txt` 的过程：\n\n![](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/v2-aaa16eea8cf11b2957d207c249a49276_1440w.gif)\n\n**请记住这个 GIF 的匹配过程，这就是 KMP 算法的核心逻辑**！\n\n为了描述状态转移图，我们定义一个二维 dp 数组，它的含义如下：\n\n```text\ndp[j][c] = next\n0 <= j < M，代表当前的状态\n0 <= c < 256，代表遇到的字符（ASCII 码）\n0 <= next <= M，代表下一个状态\n\ndp[4]['A'] = 3 表示：\n当前是状态 4，如果遇到字符 A，\npat 应该转移到状态 3\n\ndp[1]['B'] = 2 表示：\n当前是状态 1，如果遇到字符 B，\npat 应该转移到状态 2\n```\n\n根据我们这个 dp 数组的定义和刚才状态转移的过程，我们可以先写出 KMP 算法的 search 函数代码：\n\n```text\npublic int search(String txt) {\n    int M = pat.length();\n    int N = txt.length();\n    // pat 的初始态为 0\n    int j = 0;\n    for (int i = 0; i < N; i++) {\n        // 当前是状态 j，遇到字符 txt[i]，\n        // pat 应该转移到哪个状态？\n        j = dp[j][txt.charAt(i)];\n        // 如果达到终止态，返回匹配开头的索引\n        if (j == M) return i - M + 1;\n    }\n    // 没到达终止态，匹配失败\n    return -1;\n}\n```\n\n到这里，应该还是很好理解的吧，`dp` 数组就是我们刚才画的那幅状态转移图，如果不清楚的话回去看下 GIF 的算法演进过程。下面讲解：如何通过 `pat` 构建这个 `dp` 数组？\n\nPS：**我认真写了 100 多篇原创，手把手刷 200 道力扣题目，全部发布在 [labuladong的算法小抄](https://link.zhihu.com/?target=https%3A//labuladong.gitbook.io/algo/)，持续更新**。建议收藏，**按照我的文章顺序刷题**，掌握各种算法套路后投再入题海就如鱼得水了。\n\n### **三、构建状态转移图**\n\n回想刚才说的：**要确定状态转移的行为，必须明确两个变量，一个是当前的匹配状态，另一个是遇到的字符**，而且我们已经根据这个逻辑确定了 `dp` 数组的含义，那么构造 `dp` 数组的框架就是这样：\n\n```text\nfor 0 <= j < M: # 状态\n    for 0 <= c < 256: # 字符\n        dp[j][c] = next\n```\n\n这个 next 状态应该怎么求呢？显然，**如果遇到的字符 `c` 和 `pat[j]` 匹配的话**，状态就应该向前推进一个，也就是说 `next = j + 1`，我们不妨称这种情况为**状态推进**：\n\n![](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/v2-4150f27c2a52893c0bf0c55de87340b1_1440w.jpg)\n\n**如果字符 `c` 和 `pat[j]` 不匹配的话**，状态就要回退（或者原地不动），我们不妨称这种情况为**状态重启**：\n\n![](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/v2-8183f942e93dfced9cb964f0098c2aa6_1440w.jpg)\n\n那么，如何得知在哪个状态重启呢？解答这个问题之前，我们再定义一个名字：**影子状态**（我编的名字），用变量 `X` 表示。**所谓影子状态，就是和当前状态具有相同的前缀**。比如下面这种情况：\n\n![](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/v2-a270d3cb418d6092b7cf6b297cc4c9d2_1440w.jpg)\n\n当前状态 `j = 4`，其影子状态为 `X = 2`，它们都有相同的前缀 \"AB\"。因为状态 `X` 和状态 `j` 存在相同的前缀，所以当状态 `j` 准备进行状态重启的时候（遇到的字符 `c` 和 `pat[j]` 不匹配），可以通过 `X` 的状态转移图来获得**最近的重启位置**。\n\n比如说刚才的情况，如果状态 `j` 遇到一个字符 \"A\"，应该转移到哪里呢？首先只有遇到 \"C\" 才能推进状态，遇到 \"A\" 显然只能进行状态重启。**状态 `j` 会把这个字符委托给状态 `X` 处理，也就是 `dp[j]['A'] = dp[X]['A']`**：\n\n![](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/v2-14eee233358b0c6b055af2c084bd09b6_1440w.jpg)\n\n为什么这样可以呢？因为：既然 `j` 这边已经确定字符 \"A\" 无法推进状态，**只能回退**，而且 KMP 就是要**尽可能少的回退**，以免多余的计算。那么 `j` 就可以去问问和自己具有相同前缀的 `X`，如果 `X` 遇见 \"A\" 可以进行「状态推进」，那就转移过去，因为这样回退最少。\n\n![](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/v2-75fb3a0b7f07e1906ad3a11ac7c54a20_1440w.gif)\n\n当然，如果遇到的字符是 \"B\"，状态 `X` 也不能进行「状态推进」，只能回退，`j` 只要跟着 `X` 指引的方向回退就行了：\n\n![](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/v2-7fd676bfd9db11a2c98628b60b2f633c_1440w.jpg)\n\n你也许会问，这个 `X` 怎么知道遇到字符 \"B\" 要回退到状态 0 呢？因为 `X` 永远跟在 `j` 的身后，状态 `X` 如何转移，在之前就已经算出来了。动态规划算法不就是利用过去的结果解决现在的问题吗？\n\n这样，我们就细化一下刚才的框架代码：\n\n```text\nint X # 影子状态\nfor 0 <= j < M:\n    for 0 <= c < 256:\n        if c == pat[j]:\n            # 状态推进\n            dp[j][c] = j + 1\n        else: \n            # 状态重启\n            # 委托 X 计算重启位置\n            dp[j][c] = dp[X][c] \n```\n\n### **四、代码实现**\n\n如果之前的内容你都能理解，恭喜你，现在就剩下一个问题：影子状态 `X` 是如何得到的呢？下面先直接看完整代码吧。\n\n```text\npublic class KMP {\n    private int[][] dp;\n    private String pat;\n\n    public KMP(String pat) {\n        this.pat = pat;\n        int M = pat.length();\n        // dp[状态][字符] = 下个状态\n        dp = new int[M][256];\n        // base case\n        dp[0][pat.charAt(0)] = 1;\n        // 影子状态 X 初始为 0\n        int X = 0;\n        // 当前状态 j 从 1 开始\n        for (int j = 1; j < M; j++) {\n            for (int c = 0; c < 256; c++) {\n                if (pat.charAt(j) == c) \n                    dp[j][c] = j + 1;\n                else \n                    dp[j][c] = dp[X][c];\n            }\n            // 更新影子状态\n            X = dp[X][pat.charAt(j)];\n        }\n    }\n\n    public int search(String txt) {...}\n}\n```\n\n先解释一下这一行代码：\n\n```text\n// base case\ndp[0][pat.charAt(0)] = 1;\n```\n\n这行代码是 base case，只有遇到 pat\\[0\\] 这个字符才能使状态从 0 转移到 1，遇到其它字符的话还是停留在状态 0（Java 默认初始化数组全为 0）。\n\n影子状态 `X` 是先初始化为 0，然后随着 `j` 的前进而不断更新的。下面看看到底应该**如何更新影子状态 `X`**：\n\n```text\nint X = 0;\nfor (int j = 1; j < M; j++) {\n    ...\n    // 更新影子状态\n    // 当前是状态 X，遇到字符 pat[j]，\n    // pat 应该转移到哪个状态？\n    X = dp[X][pat.charAt(j)];\n}\n```\n\n更新 `X` 其实和 `search` 函数中更新状态 `j` 的过程是非常相似的：\n\n```text\nint j = 0;\nfor (int i = 0; i < N; i++) {\n    // 当前是状态 j，遇到字符 txt[i]，\n    // pat 应该转移到哪个状态？\n    j = dp[j][txt.charAt(i)];\n    ...\n}\n```\n\n**其中的原理非常微妙**，注意代码中 for 循环的变量初始值，可以这样理解：后者是在 `txt` 中匹配 `pat`，前者是在 `pat` 中匹配 `pat[1..end]`，状态 `X` 总是落后状态 `j` 一个状态，与 `j` 具有最长的相同前缀。所以我把 `X` 比喻为影子状态，似乎也有一点贴切。\n\n另外，构建 dp 数组是根据 base case `dp[0][..]` 向后推演。这就是我认为 KMP 算法就是一种动态规划算法的原因。\n\n下面来看一下状态转移图的完整构造过程，你就能理解状态 `X` 作用之精妙了：\n\n![](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/v2-6594ba99da1f3c8ea609d0b24be448cb_1440w.gif)\n\n至此，KMP 算法的核心终于写完啦啦啦啦！看下 KMP 算法的完整代码吧：\n\n```text\npublic class KMP {\n    private int[][] dp;\n    private String pat;\n\n    public KMP(String pat) {\n        this.pat = pat;\n        int M = pat.length();\n        // dp[状态][字符] = 下个状态\n        dp = new int[M][256];\n        // base case\n        dp[0][pat.charAt(0)] = 1;\n        // 影子状态 X 初始为 0\n        int X = 0;\n        // 构建状态转移图（稍改的更紧凑了）\n        for (int j = 1; j < M; j++) {\n            for (int c = 0; c < 256; c++)\n                dp[j][c] = dp[X][c];\n            dp[j][pat.charAt(j)] = j + 1;\n            // 更新影子状态\n            X = dp[X][pat.charAt(j)];\n        }\n    }\n\n    public int search(String txt) {\n        int M = pat.length();\n        int N = txt.length();\n        // pat 的初始态为 0\n        int j = 0;\n        for (int i = 0; i < N; i++) {\n            // 计算 pat 的下一个状态\n            j = dp[j][txt.charAt(i)];\n            // 到达终止态，返回结果\n            if (j == M) return i - M + 1;\n        }\n        // 没到达终止态，匹配失败\n        return -1;\n    }\n}\n```\n\n经过之前的详细举例讲解，你应该可以理解这段代码的含义了，当然你也可以把 KMP 算法写成一个函数。核心代码也就是两个函数中 for 循环的部分，数一下有超过十行吗？\n\n### **五、最后总结**\n\n传统的 KMP 算法是使用一个一维数组 `next` 记录前缀信息，而本文是使用一个二维数组 `dp` 以状态转移的角度解决字符匹配问题，但是空间复杂度仍然是 O(256M) = O(M)。\n\n在 `pat` 匹配 `txt` 的过程中，只要明确了「当前处在哪个状态」和「遇到的字符是什么」这两个问题，就可以确定应该转移到哪个状态（推进或回退）。\n\n对于一个模式串 `pat`，其总共就有 M 个状态，对于 ASCII 字符，总共不会超过 256 种。所以我们就构造一个数组 `dp[M][256]` 来包含所有情况，并且明确 `dp` 数组的含义：\n\n`dp[j][c] = next` 表示，当前是状态 `j`，遇到了字符 `c`，应该转移到状态 `next`。\n\n明确了其含义，就可以很容易写出 search 函数的代码。\n\n对于如何构建这个 `dp` 数组，需要一个辅助状态 `X`，它永远比当前状态 `j` 落后一个状态，拥有和 `j` 最长的相同前缀，我们给它起了个名字叫「影子状态」。\n\n在构建当前状态 `j` 的转移方向时，只有字符 `pat[j]` 才能使状态推进（`dp[j][pat[j]] = j+1`）；而对于其他字符只能进行状态回退，应该去请教影子状态 `X` 应该回退到哪里（`dp[j][other] = dp[X][other]`，其中 `other` 是除了 `pat[j]` 之外所有字符）。\n\n对于影子状态 `X`，我们把它初始化为 0，并且随着 `j` 的前进进行更新，更新的方式和 search 过程更新 `j` 的过程非常相似（`X = dp[X][pat[j]]`）。\n\nKMP 算法也就是动态规划那点事，我们的公众号文章目录有一系列专门讲动态规划的，而且都是按照一套框架来的，无非就是描述问题逻辑，明确 `dp` 数组含义，定义 base case 这点破事。希望这篇文章能让大家对动态规划有更深的理解。\n\n**＿＿＿＿＿＿＿＿＿＿＿＿＿**\n\n我的 [在线电子书](https://link.zhihu.com/?target=https%3A//labuladong.gitbook.io/algo) 有 100 篇原创文章，手把手带刷 200 道力扣题目，建议收藏！对应的 GitHub [算法仓库](https://link.zhihu.com/?target=https%3A//github.com/labuladong/fucking-algorithm) 已经获得了 70k star，欢迎标星！","tags":["zhihu-article"],"categories":["zhihu"]},{"title":"AP复习笔记-数据抽象和封装","url":"/posts/71fc8418a276/","content":"\n## 成绩占比\n\n>   n平时作业（10％）\n>\n>   •选教材每章后面的练习和另外组织的题目\n>\n>   •课程网站发布，在规定时间内提交\n>\n>   n上机考核（20％）\n>\n>   •OJ系统当场出题，当场提交\n>\n>   n课程项目（30％）\n>\n>   •2个较大的程序\n>\n>   •课程网站发布，在规定时间内提交\n>\n>   n期末笔试（40％）\n\n---\n\n## 抽象和封装\n\nn抽象与封装是两个重要的程序设计手段，主要是用来驾驭程序的复杂度，便于大型程序的设计、理解与维护。\n\nn对于一个程序实体而言，\n\n•抽象强调的是该程序实体的外部可观察到的行为，不考虑该程序实体的内部是如何实现的。（控制复杂度）\n\n•封装是指把该程序实体内部的具体实现细节对使用者隐藏起来，只对外提供一个接口。（信息保护）\n\n•抽象是一种思维方式，而封装则是一种基于抽象的操作方法\n\nn主要的程序抽象与封装机制包括：\n\n•过程抽象与封装\n\n•数据抽象与封装\n\n### 过程抽象和封装\n\nn过程抽象\n\n•用一个名字来代表一段完成一定功能的程序代码，代码的使用者只需要知道代码的名字以及相应的功能。\n\nn过程封装\n\n•把代码的具体实现隐藏起来（对使用者不可见，或不可直接访问），使用者只能通过代码名字来使用相应的代码。\n\n•代码所需要的数据是通过参数（或全局变量）来获得，计算结果通过返回值机制（或全局变量）返回。\n\nn实现过程抽象与封装的程序实体通常称为子程序。在C/C++语言中，子程序用函数来表示。\n\n### 数据抽象和封装\n\nn数据抽象\n\n•只描述对数据能实施哪些操作以及这些操作之间的关系，数据的使用者不需要知道数据的具体表示形式。\n\nn数据封装\n\n•把数据及其操作作为一个整体（封装体）来进行实现，其中，数据的具体表示被隐藏起来（使用者不可见，或不可直接访问），对数据的访问（使用）只能通过封装体对外接口提供的操作来完成。\n\nn与过程抽象与封装相比，数据抽象与封装能够实现更好的数据保护。\n\n## 用链表封装栈\n\n","categories":["NJUCS","高级程序设计","课堂笔记"]},{"title":"高程模拟题","url":"/posts/f3abcfd2d465/","content":"# 高级程序设计模拟题\n\n## 一、面向对象编程\n\n### 题目1.1：对象创建与内存管理\n分析以下代码的输出结果，解释对象创建和销毁的顺序，以及可能存在的内存问题。\n\n```cpp\n#include <iostream>\nusing namespace std;\nclass Resource {\npublic:\n    Resource() { cout << \"Resource constructed\" << endl; }\n    ~Resource() { cout << \"Resource destroyed\" << endl; }\n};\n\nclass Container {\n    Resource* res;\npublic:\n    Container() : res(new Resource()) {\n        cout << \"Container constructed\" << endl;\n    }\n    ~Container() {\n        cout << \"Container destroyed\" << endl;\n    }\n};\n\nint main() {\n    {\n        Container c1;\n        Container* c2 = new Container();\n    }\n    cout << \"End of block\" << endl;\n    return 0;\n}\n```\n\n### 题目1.2：拷贝构造与赋值操作\n下面的String类实现有什么问题？请指出并修复。\n\n```cpp\nclass String {\n    char* str;\n    int length;\npublic:\n    String(const char* s = \"\") {\n        length = strlen(s);\n        str = new char[length + 1];\n        strcpy(str, s);\n    }\n    \n    ~String() {\n        delete[] str;\n    }\n    \n    // 拷贝构造函数\n    String(const String& other) {\n        length = other.length;\n        str = other.str;\n    }\n    \n    // 赋值操作符\n    String& operator=(const String& other) {\n        length = other.length;\n        str = other.str;\n        return *this;\n    }\n};\n```\n\n### 题目1.3：继承与访问控制\n给定以下代码，判断每个访问是否合法，并解释原因。\n\n```cpp\nclass Base {\nprivate:\n    int privateVar;\nprotected:\n    int protectedVar;\npublic:\n    int publicVar;\n    \n    void baseFunc() {\n        privateVar = 1;\n        protectedVar = 2;\n        publicVar = 3;\n    }\n};\n\nclass Derived1 : public Base {\npublic:\n    void derived1Func() {\n        privateVar = 1;\n        protectedVar = 2;\n        publicVar = 3;\n    }\n};\n\nclass Derived2 : protected Base {\npublic:\n    void derived2Func() {\n        privateVar = 1;\n        protectedVar = 2;\n        publicVar = 3;\n    }\n};\n\nclass Derived3 : private Base {\npublic:\n    void derived3Func() {\n        privateVar = 1;\n        protectedVar = 2;\n        publicVar = 3;\n    }\n};\n\nint main() {\n    Base b;\n    Derived1 d1;\n    Derived2 d2;\n    Derived3 d3;\n    \n    b.privateVar = 1;\n    b.protectedVar = 2;\n    b.publicVar = 3;\n    \n    d1.privateVar = 1;\n    d1.protectedVar = 2;\n    d1.publicVar = 3;\n    \n    d2.privateVar = 1;\n    d2.protectedVar = 2;\n    d2.publicVar = 3;\n    \n    d3.privateVar = 1;\n    d3.protectedVar = 2;\n    d3.publicVar = 3;\n    \n    return 0;\n}\n```\n\n## 二、虚函数与动态绑定\n\n### 题目2.1：虚函数调用分析\n分析以下代码，确定每次函数调用调用的是哪个类的方法，并解释原因。\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Base {\npublic:\n    Base() { cout << \"Base constructor\" << endl; }\n    virtual ~Base() { cout << \"Base destructor\" << endl; }\n    \n    virtual void vFunc() { cout << \"Base::vFunc()\" << endl; }\n    void nonVFunc() { cout << \"Base::nonVFunc()\" << endl; }\n    \n    virtual void callVFunc() { \n        cout << \"Base::callVFunc() calls \"; \n        vFunc(); \n    }\n};\n\nclass Derived : public Base {\npublic:\n    Derived() { cout << \"Derived constructor\" << endl; }\n    ~Derived() { cout << \"Derived destructor\" << endl; }\n    \n    void vFunc() override { cout << \"Derived::vFunc()\" << endl; }\n    void nonVFunc() { cout << \"Derived::nonVFunc()\" << endl; }\n};\n\nint main() {\n    cout << \"=== Test 1 ===\" << endl;\n    Base* bp = new Derived();\n    bp->vFunc();\n    bp->nonVFunc();\n    bp->callVFunc();\n    delete bp;\n    \n    cout << \"\\n=== Test 2 ===\" << endl;\n    Derived d;\n    Base& br = d;\n    br.vFunc();\n    br.nonVFunc();\n    \n    cout << \"\\n=== Test 3 ===\" << endl;\n    Base b = Derived();\n    b.vFunc();\n    b.nonVFunc();\n    \n    return 0;\n}\n```\n\n### 题目2.2：构造与析构中的虚函数调用\n以下代码有什么问题？为什么？修复它。\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Base {\npublic:\n    Base() { \n        cout << \"Base constructor\" << endl;\n        initialize(); \n    }\n    virtual ~Base() { \n        cout << \"Base destructor\" << endl; \n        cleanup();\n    }\n    \n    virtual void initialize() { \n        cout << \"Base::initialize()\" << endl; \n    }\n    \n    virtual void cleanup() { \n        cout << \"Base::cleanup()\" << endl; \n    }\n};\n\nclass Derived : public Base {\n    int* resource;\npublic:\n    Derived() { \n        cout << \"Derived constructor\" << endl; \n        resource = new int[100];\n    }\n    \n    ~Derived() { \n        cout << \"Derived destructor\" << endl;\n        delete[] resource;\n    }\n    \n    void initialize() override { \n        cout << \"Derived::initialize()\" << endl;\n        resource[0] = 1;\n    }\n    \n    void cleanup() override { \n        cout << \"Derived::cleanup()\" << endl;\n    }\n};\n\nint main() {\n    Derived d;\n    return 0;\n}\n```\n\n## 三、操作符重载\n\n### 题目3.1：前缀后缀递增递减运算符\n为以下计数器类实现前缀和后缀的递增(++)和递减(--)操作符。\n\n```cpp\nclass Counter {\nprivate:\n    int value;\npublic:\n    Counter(int val = 0) : value(val) {}\n    int getValue() const { return value; }\n    \n};\n```\n\n### 题目3.2：智能指针类设计\n实现一个简单的智能指针类MyUniquePtr，包含以下功能：\n1. 构造函数、析构函数\n2. 移动构造和移动赋值（但不允许拷贝）\n3. 实现*和->操作符\n4. 实现release()和reset()方法\n\n```cpp\ntemplate<typename T>\nclass MyUniquePtr {\nprivate:\n    T* ptr;\n\npublic:\n    \n};\n```\n\n## 四、异常处理\n\n### 题目4.1：异常处理流程分析\n分析以下代码的执行流程，指出每个try-catch块是否会执行，以及最终输出。\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass MyException {};\nclass DerivedEx : public MyException {};\n\nvoid funcC() {\n    cout << \"funcC starts\" << endl;\n    throw DerivedEx();\n    cout << \"funcC ends\" << endl;\n}\n\nvoid funcB() {\n    cout << \"funcB starts\" << endl;\n    try {\n        funcC();\n    }\n    catch (MyException) {\n        cout << \"funcB caught MyException\" << endl;\n        throw;\n    }\n    cout << \"funcB ends\" << endl;\n}\n\nvoid funcA() {\n    cout << \"funcA starts\" << endl;\n    try {\n        funcB();\n    }\n    catch (DerivedEx) {\n        cout << \"funcA caught DerivedEx\" << endl;\n    }\n    catch (...) {\n        cout << \"funcA caught unknown exception\" << endl;\n    }\n    cout << \"funcA ends\" << endl;\n}\n\nint main() {\n    cout << \"main starts\" << endl;\n    try {\n        funcA();\n    }\n    catch (...) {\n        cout << \"main caught exception\" << endl;\n    }\n    cout << \"main ends\" << endl;\n    return 0;\n}\n```\n\n### 题目4.2：RAII与异常安全\n下面的代码在发生异常时可能导致资源泄漏，请使用RAII技术修复它。\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Resource {\npublic:\n    Resource() { cout << \"Resource acquired\" << endl; }\n    ~Resource() { cout << \"Resource released\" << endl; }\n};\n\nvoid riskyOperation() {\n    throw runtime_error(\"Something went wrong\");\n}\n\nvoid processData() {\n    Resource* r1 = new Resource();\n    Resource* r2 = new Resource();\n    \n    try {\n        riskyOperation();\n        // 处理数据...\n        delete r1;\n        delete r2;\n    }\n    catch (const exception& e) {\n        cout << \"Exception: \" << e.what() << endl;\n        delete r1;\n        delete r2;\n        throw;\n    }\n}\n\nint main() {\n    try {\n        processData();\n    }\n    catch (const exception& e) {\n        cout << \"Caught in main: \" << e.what() << endl;\n    }\n    return 0;\n}\n```\n\n## 五、内存安全程序设计\n\n### 题目5.1：智能指针使用\n找出以下代码中的内存安全问题，并使用适当的智能指针修复它们。\n\n```cpp\n#include <iostream>\n#include <memory>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    Node* next;\n    Node* prev;\n    \n    Node(int d) : data(d), next(nullptr), prev(nullptr) {\n        cout << \"Node \" << data << \" created\" << endl;\n    }\n    \n    ~Node() {\n        cout << \"Node \" << data << \" destroyed\" << endl;\n    }\n};\n\nvoid createLinkedList() {\n    Node* head = new Node(1);\n    Node* second = new Node(2);\n    Node* third = new Node(3);\n    \n    head->next = second;\n    second->prev = head;\n    second->next = third;\n    third->prev = second;\n    \n    // 由于异常或提前返回，可能导致内存泄漏\n    if (third->data == 3) {\n        return;\n    }\n    \n    delete third;\n    delete second;\n    delete head;\n}\n\nint main() {\n    createLinkedList();\n    cout << \"Program finished\" << endl;\n    return 0;\n}\n```\n\n### 题目5.2：循环引用问题\n以下代码中存在循环引用问题，导致内存泄漏。请分析问题并修复。\n\n```cpp\n#include <iostream>\n#include <memory>\n#include <string>\nusing namespace std;\n\nclass Person {\n    string name;\n    shared_ptr<Person> spouse;  // 配偶\n\npublic:\n    Person(const string& n) : name(n) {\n        cout << \"Person \" << name << \" created\" << endl;\n    }\n    \n    ~Person() {\n        cout << \"Person \" << name << \" destroyed\" << endl;\n    }\n    \n    void marry(shared_ptr<Person> other) {\n        cout << name << \" marries \" << other->name << endl;\n        spouse = other;\n        other->spouse = shared_ptr<Person>(this);\n    }\n    \n    string getName() const { return name; }\n};\n\nint main() {\n    {\n        auto alice = make_shared<Person>(\"Alice\");\n        auto bob = make_shared<Person>(\"Bob\");\n        \n        alice->marry(bob);\n    }\n    \n    cout << \"End of scope\" << endl;\n    return 0;\n}\n```\n\n## 六、并行程序设计\n\n### 题目6.1：线程安全的计数器\n实现一个线程安全的计数器类，可以被多个线程同时增加和减少。\n\n```cpp\n#include <thread>\n#include <vector>\n#include <iostream>\n\nclass ThreadSafeCounter {\nprivate:\n\npublic:\n    ThreadSafeCounter(int initial = 0);\n    void increment();\n    void decrement();\n    int getValue() const;\n};\n\n// 测试代码\nvoid test() {\n    ThreadSafeCounter counter(0);\n    std::vector<std::thread> threads;\n    \n    for (int i = 0; i < 10; ++i) {\n        threads.push_back(std::thread([&counter]() {\n            for (int j = 0; j < 1000; ++j) {\n                counter.increment();\n            }\n        }));\n    }\n    \n    for (int i = 0; i < 10; ++i) {\n        threads.push_back(std::thread([&counter]() {\n            for (int j = 0; j < 500; ++j) {\n                counter.decrement();\n            }\n        }));\n    }\n    \n    for (auto& t : threads) {\n        t.join();\n    }\n    \n    std::cout << \"Final counter value: \" << counter.getValue() << std::endl;\n}\n```\n\n### 题目6.2：线程池实现\n设计一个简单的线程池，能够接受任务并分配给空闲线程执行。\n\n```cpp\n#include <functional>\n#include <queue>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <vector>\n\nclass ThreadPool {\nprivate:\n    \npublic:\n    ThreadPool(size_t numThreads);\n    ~ThreadPool();\n    \n    template<class F>\n    void enqueue(F&& f);\n    \n    ThreadPool(const ThreadPool&) = delete;\n    ThreadPool& operator=(const ThreadPool&) = delete;\n};\n```\n\n## 答案\n\n### 题目1.1答案\n输出结果为：\n```\nResource constructed\nContainer constructed\nContainer constructed\nContainer destroyed\nEnd of block\n```\n\n分析：\n1. 首先创建了栈上的c1对象，构造c1时创建了一个Resource对象\n2. 然后创建了堆上的c2对象，构造c2时创建了另一个Resource对象\n3. 作用域结束时，栈上的c1被销毁，调用其析构函数\n4. 然而，c1的析构函数没有释放res指针指向的资源，导致内存泄漏\n5. 堆上的c2对象没有被delete，因此c2本身和c2持有的Resource对象都没有被销毁，这也导致内存泄漏\n\n内存问题：\n1. Container类的析构函数没有释放res指针，导致资源泄漏\n2. 堆上分配的c2没有被delete，导致c2及其资源都泄漏\n\n修复方法：\n```cpp\n~Container() {\n    cout << \"Container destroyed\" << endl;\n    delete res;  // 释放资源\n}\n\n// 在main中添加\ndelete c2;  // 释放堆上的Container对象\n```\n\n### 题目1.2答案\n问题：\n1. 拷贝构造函数实现的是浅拷贝，直接复制了str指针，导致两个String对象指向同一块内存\n2. 赋值操作符也是浅拷贝，没有释放原有的内存，导致内存泄漏\n3. 赋值操作符没有检查自赋值情况\n4. 没有正确处理空字符串情况\n\n修复后的代码：\n```cpp\nclass String {\n    char* str;\n    int length;\npublic:\n    String(const char* s = \"\") {\n        length = s ? strlen(s) : 0;\n        str = new char[length + 1];\n        if (s) strcpy(str, s);\n        else str[0] = '\\0';\n    }\n    \n    ~String() {\n        delete[] str;\n    }\n    \n    // 深拷贝构造函数\n    String(const String& other) {\n        length = other.length;\n        str = new char[length + 1];\n        strcpy(str, other.str);\n    }\n    \n    // 赋值操作符\n    String& operator=(const String& other) {\n        if (this == &other) return *this;  // 检查自赋值\n        \n        delete[] str;  // 释放原有内存\n        length = other.length;\n        str = new char[length + 1];\n        strcpy(str, other.str);\n        return *this;\n    }\n};\n```\n\n### 题目1.3答案\n合法性分析：\n- 访问1：不合法，私有成员不能被派生类访问\n- 访问2：合法，protected成员可以被派生类访问\n- 访问3：合法，public成员可以被派生类访问\n- 访问4：不合法，同访问1\n- 访问5：合法，同访问2\n- 访问6：合法，同访问3\n- 访问7：不合法，同访问1\n- 访问8：合法，同访问2\n- 访问9：合法，同访问3\n- 访问10：不合法，私有成员不能在类外访问\n- 访问11：不合法，protected成员不能在类外访问\n- 访问12：合法，public继承时，基类public成员在派生类中仍为public\n- 访问13：不合法，Base的私有成员不能被外部访问\n- 访问14：不合法，Base的protected成员不能被外部访问\n- 访问15：合法，public继承时，基类public成员在派生类中变为protected，不能被外部访问\n- 访问16：不合法，同访问13\n- 访问17：不合法，同访问14\n- 访问18：不合法，protected继承时，基类public成员在派生类中变为protected，不能被外部访问\n- 访问19：不合法，同访问13\n- 访问20：不合法，同访问14\n- 访问21：不合法，private继承时，基类所有成员在派生类中都变为private，不能被外部访问\n\n### 题目2.1答案\n分析：\n- 调用1：`Derived::vFunc()`，因为bp指向Derived对象，vFunc是虚函数，所以动态绑定到Derived::vFunc\n- 调用2：`Base::nonVFunc()`，因为nonVFunc不是虚函数，所以静态绑定到Base::nonVFunc\n- 调用3：先调用`Base::callVFunc()`，然后由于vFunc是虚函数且通过this指针调用，所以动态绑定到`Derived::vFunc()`\n- 调用4：`Derived::vFunc()`，因为br引用了Derived对象，vFunc是虚函数，所以动态绑定\n- 调用5：`Base::nonVFunc()`，因为nonVFunc不是虚函数，所以静态绑定\n- 调用6：`Base::vFunc()`，这里发生了对象切片，b实际上是Base类型，不是Derived类型\n- 调用7：`Base::nonVFunc()`，同上，b是Base类型\n\n完整输出：\n```\n=== Test 1 ===\nBase constructor\nDerived constructor\nDerived::vFunc()\nBase::nonVFunc()\nBase::callVFunc() calls Derived::vFunc()\nBase destructor\n\n=== Test 2 ===\nBase constructor\nDerived constructor\nDerived::vFunc()\nBase::nonVFunc()\n\n=== Test 3 ===\nBase constructor\nDerived constructor\nBase destructor\nBase::vFunc()\nBase::nonVFunc()\nBase destructor\nDerived destructor\n```\n\n注意：Test 3中的对象切片问题导致Derived部分在赋值时就被销毁了。\n\n### 题目2.2答案\n问题：\n1. 在Base的构造函数中调用虚函数initialize()，此时派生类部分尚未构造，会调用Base::initialize()而不是Derived::initialize()\n2. 在Base的析构函数中调用虚函数cleanup()，此时派生类部分已经被销毁，会调用Base::cleanup()而不是Derived::cleanup()\n3. 在Derived::initialize()中访问resource，但在Base构造阶段调用时resource尚未初始化\n4. 在Derived::cleanup()中可能在resource已被释放后仍然尝试访问它\n\n修复后的代码：\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Base {\npublic:\n    Base() { \n        cout << \"Base constructor\" << endl;\n        baseInitialize(); \n    }\n    virtual ~Base() { \n        cout << \"Base destructor\" << endl; \n        baseCleanup();\n    }\n    \n    // 非虚函数，供构造函数调用\n    void baseInitialize() { \n        cout << \"Base::baseInitialize()\" << endl; \n        // 基类自己的初始化逻辑\n    }\n    \n    // 非虚函数，供析构函数调用\n    void baseCleanup() { \n        cout << \"Base::baseCleanup()\" << endl; \n        // 基类自己的清理逻辑\n    }\n    \n    // 保留虚函数供正常操作使用\n    virtual void initialize() { \n        cout << \"Base::initialize()\" << endl; \n    }\n    \n    virtual void cleanup() { \n        cout << \"Base::cleanup()\" << endl; \n    }\n};\n\nclass Derived : public Base {\n    int* resource;\npublic:\n    Derived() { \n        cout << \"Derived constructor\" << endl; \n        resource = new int[100];\n    }\n    \n    ~Derived() { \n        cleanup();  // 派生类析构前先调用虚函数\n        cout << \"Derived destructor\" << endl;\n        delete[] resource;\n    }\n    \n    void initialize() override { \n        cout << \"Derived::initialize()\" << endl;\n        resource[0] = 1;  // 此时resource已初始化\n    }\n    \n    void cleanup() override { \n        cout << \"Derived::cleanup()\" << endl;\n    }\n};\n```\n\n### 题目3.1答案\n```cpp\nclass Counter {\nprivate:\n    int value;\npublic:\n    Counter(int val = 0) : value(val) {}\n    int getValue() const { return value; }\n    \n    // 前缀++\n    Counter& operator++() {\n        ++value;\n        return *this;\n    }\n    \n    // 后缀++\n    Counter operator++(int) {\n        Counter temp = *this;\n        ++value;\n        return temp;\n    }\n    \n    // 前缀--\n    Counter& operator--() {\n        --value;\n        return *this;\n    }\n    \n    // 后缀--\n    Counter operator--(int) {\n        Counter temp = *this;\n        --value;\n        return temp;\n    }\n};\n```\n\n### 题目3.2答案\n```cpp\ntemplate<typename T>\nclass MyUniquePtr {\nprivate:\n    T* ptr;\n\npublic:\n    // 构造函数\n    explicit MyUniquePtr(T* p = nullptr) : ptr(p) {}\n    \n    // 析构函数\n    ~MyUniquePtr() {\n        if (ptr) delete ptr;\n    }\n    \n    // 移动构造函数\n    MyUniquePtr(MyUniquePtr&& other) noexcept : ptr(other.ptr) {\n        other.ptr = nullptr;\n    }\n    \n    // 移动赋值运算符\n    MyUniquePtr& operator=(MyUniquePtr&& other) noexcept {\n        if (this != &other) {\n            reset();\n            ptr = other.ptr;\n            other.ptr = nullptr;\n        }\n        return *this;\n    }\n    \n    // 禁用拷贝构造和拷贝赋值\n    MyUniquePtr(const MyUniquePtr&) = delete;\n    MyUniquePtr& operator=(const MyUniquePtr&) = delete;\n    \n    // 解引用操作符\n    T& operator*() const {\n        return *ptr;\n    }\n    \n    // 箭头操作符\n    T* operator->() const {\n        return ptr;\n    }\n    \n    // 获取原始指针\n    T* get() const {\n        return ptr;\n    }\n    \n    // 释放所有权\n    T* release() {\n        T* temp = ptr;\n        ptr = nullptr;\n        return temp;\n    }\n    \n    // 重置指针\n    void reset(T* p = nullptr) {\n        if (ptr) delete ptr;\n        ptr = p;\n    }\n    \n    // 布尔转换操作符\n    explicit operator bool() const {\n        return ptr != nullptr;\n    }\n};\n```\n\n### 题目4.1答案\n执行流程：\n1. main调用funcA\n2. funcA调用funcB\n3. funcB调用funcC\n4. funcC抛出DerivedEx异常\n5. funcB捕获到MyException异常（基类可以捕获派生类异常），输出\"funcB caught MyException\"\n6. funcB重新抛出异常，继续传播\n7. funcA捕获到DerivedEx异常（这里是精确匹配），输出\"funcA caught DerivedEx\"\n8. funcA正常结束，输出\"funcA ends\"\n9. main正常结束，输出\"main ends\"\n\n完整输出：\n```\nmain starts\nfuncA starts\nfuncB starts\nfuncC starts\nfuncB caught MyException\nfuncA caught DerivedEx\nfuncA ends\nmain ends\n```\n\n注意：\n- funcB中的\"funcB ends\"不会输出，因为重新抛出异常后函数不会继续执行\n- 由于异常已在funcA中处理，main中的catch块不会执行\n\n### 题目4.2答案\n问题：当riskyOperation()抛出异常时，即使try块中有delete语句，也不会执行到。catch块中又重新抛出异常，如果第二个delete之前又有异常，则第二个资源不会被释放。\n\n使用RAII修复：\n```cpp\n#include <iostream>\n#include <memory>\nusing namespace std;\n\nclass Resource {\npublic:\n    Resource() { cout << \"Resource acquired\" << endl; }\n    ~Resource() { cout << \"Resource released\" << endl; }\n};\n\nvoid riskyOperation() {\n    throw runtime_error(\"Something went wrong\");\n}\n\nvoid processData() {\n    // 使用智能指针自动管理资源\n    unique_ptr<Resource> r1(new Resource());\n    unique_ptr<Resource> r2(new Resource());\n    \n    // 无需手动释放资源\n    riskyOperation();\n    // 处理数据...\n}\n\nint main() {\n    try {\n        processData();\n    }\n    catch (const exception& e) {\n        cout << \"Caught in main: \" << e.what() << endl;\n    }\n    return 0;\n}\n```\n\n或者使用传统的RAII封装：\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Resource {\npublic:\n    Resource() { cout << \"Resource acquired\" << endl; }\n    ~Resource() { cout << \"Resource released\" << endl; }\n};\n\n// RAII封装\nclass ResourceGuard {\n    Resource* res;\npublic:\n    ResourceGuard(Resource* r) : res(r) {}\n    ~ResourceGuard() { delete res; }\n    // 禁止拷贝\n    ResourceGuard(const ResourceGuard&) = delete;\n    ResourceGuard& operator=(const ResourceGuard&) = delete;\n};\n\nvoid riskyOperation() {\n    throw runtime_error(\"Something went wrong\");\n}\n\nvoid processData() {\n    Resource* r1 = new Resource();\n    ResourceGuard g1(r1);  // g1负责释放r1\n    \n    Resource* r2 = new Resource();\n    ResourceGuard g2(r2);  // g2负责释放r2\n    \n    riskyOperation();\n    // 处理数据...\n}\n\nint main() {\n    try {\n        processData();\n    }\n    catch (const exception& e) {\n        cout << \"Caught in main: \" << e.what() << endl;\n    }\n    return 0;\n}\n```\n\n### 题目5.1答案\n问题：\n1. 函数提前返回时，没有释放已分配的节点，导致内存泄漏\n2. 双向链表中的节点互相引用，应该使用智能指针管理\n\n修复后的代码：\n```cpp\n#include <iostream>\n#include <memory>\nusing namespace std;\n\nclass Node {\npublic:\n    int data;\n    shared_ptr<Node> next;\n    weak_ptr<Node> prev;  // 使用weak_ptr避免循环引用\n    \n    Node(int d) : data(d) {\n        cout << \"Node \" << data << \" created\" << endl;\n    }\n    \n    ~Node() {\n        cout << \"Node \" << data << \" destroyed\" << endl;\n    }\n};\n\nvoid createLinkedList() {\n    auto head = make_shared<Node>(1);\n    auto second = make_shared<Node>(2);\n    auto third = make_shared<Node>(3);\n    \n    head->next = second;\n    second->prev = head;  // weak_ptr不会增加引用计数\n    second->next = third;\n    third->prev = second;\n    \n    // 即使提前返回，智能指针也会自动释放内存\n    if (third->data == 3) {\n        return;\n    }\n}\n\nint main() {\n    createLinkedList();\n    cout << \"Program finished\" << endl;\n    return 0;\n}\n```\n\n### 题目5.2答案\n问题：\n在marry函数中，使用`other->spouse = shared_ptr<Person>(this);`创建了一个新的shared_ptr，但是它与alice和bob已有的shared_ptr不共享引用计数，导致循环引用。\n\n修复方法：\n```cpp\n#include <iostream>\n#include <memory>\n#include <string>\nusing namespace std;\n\nclass Person {\n    string name;\n    weak_ptr<Person> spouse;  // 改用weak_ptr避免循环引用\n\npublic:\n    Person(const string& n) : name(n) {\n        cout << \"Person \" << name << \" created\" << endl;\n    }\n    \n    ~Person() {\n        cout << \"Person \" << name << \" destroyed\" << endl;\n    }\n    \n    void marry(shared_ptr<Person> other) {\n        cout << name << \" marries \" << other->name << endl;\n        spouse = other;  // weak_ptr不会增加引用计数\n        \n        // 使用lock()方法获取shared_ptr\n        if (auto sp = spouse.lock()) {\n            sp->setSpouse(shared_from_this());\n        }\n    }\n    \n    void setSpouse(shared_ptr<Person> other) {\n        spouse = other;\n    }\n    \n    string getName() const { return name; }\n};\n\nint main() {\n    {\n        auto alice = make_shared<Person>(\"Alice\");\n        auto bob = make_shared<Person>(\"Bob\");\n        \n        alice->marry(bob);\n    }\n    \n    cout << \"End of scope\" << endl;\n    return 0;\n}\n```\n\n注意：要使用shared_from_this()，Person类需要继承enable_shared_from_this<Person>。\n\n### 题目6.1答案\n```cpp\n#include <thread>\n#include <vector>\n#include <iostream>\n#include <mutex>\n\nclass ThreadSafeCounter {\nprivate:\n    int count;\n    mutable std::mutex mtx;  // mutable允许在const方法中修改\n\npublic:\n    ThreadSafeCounter(int initial = 0) : count(initial) {}\n    \n    void increment() {\n        std::lock_guard<std::mutex> lock(mtx);\n        count++;\n    }\n    \n    void decrement() {\n        std::lock_guard<std::mutex> lock(mtx);\n        count--;\n    }\n    \n    int getValue() const {\n        std::lock_guard<std::mutex> lock(mtx);\n        return count;\n    }\n};\n\n// 测试代码\nvoid test() {\n    ThreadSafeCounter counter(0);\n    std::vector<std::thread> threads;\n    \n    for (int i = 0; i < 10; ++i) {\n        threads.push_back(std::thread([&counter]() {\n            for (int j = 0; j < 1000; ++j) {\n                counter.increment();\n            }\n        }));\n    }\n    \n    for (int i = 0; i < 10; ++i) {\n        threads.push_back(std::thread([&counter]() {\n            for (int j = 0; j < 500; ++j) {\n                counter.decrement();\n            }\n        }));\n    }\n    \n    for (auto& t : threads) {\n        t.join();\n    }\n    \n    std::cout << \"Final counter value: \" << counter.getValue() << std::endl;\n}\n```\n\n### 题目6.2答案\n```cpp\n#include <functional>\n#include <queue>\n#include <thread>\n#include <mutex>\n#include <condition_variable>\n#include <vector>\n\nclass ThreadPool {\nprivate:\n    \npublic:\n    ThreadPool(size_t numThreads);\n    ~ThreadPool();\n    \n    template<class F>\n    void enqueue(F&& f);\n    \n    ThreadPool(const ThreadPool&) = delete;\n    ThreadPool& operator=(const ThreadPool&) = delete;\n}; ","categories":["NJUCS","高级程序设计"]},{"title":"课程安排","url":"/posts/e78c72406755/","content":"\n\n\n## **考察的重点在课程里面！！！** \n\n## 平时作业（10％）\n\n​\t在周三理论课结束后发基本白给，基本白给。\n\n-   配合教学内容，掌握知识点\n-   题目内容\n-   选教材每章后面的练习和另外组织的题目\n-   安排\n-   逐周布置，离线完成\n-   [https://cslab-cms.nju.edu.cn](https://cslab-cms.nju.edu.cn/)[/](https://cslab-cms.nju.edu.cn/)\n-   助教抽查\n\n## 课程设计（30％）\n\n​\t前八周一个项目，后八周一个项目\n\n-   目标\n-   锻炼综合所学内容进行编程的能力\n-   内容\n-   完成指定的两个编程项目\n-   安排\n-   进行项目开发、检查（周五7-8节，南园综合楼 502,503）\n-   助教逐一检查评分\n-   择优进行课堂报告\n-   优秀设计可获10% bonus\n\n## 上机测验（20％）\n\n​\ttime: 110min;\n\n​\t**测验8~10次！！！**\n\n​\t注意：“**编程熟练度**”\n\n-   目标\n-   结合教学内容，解决应用问题，锻炼编程熟练度\n-   题目\n-   高级程序设计相关内容和算法编程强化练习\n-   安排\n-   当场出题，当场完成（周五7-8节，南园综合楼 502,503）\n-   110分钟内完成为满分\n-   110分钟后，当天提交60%\n-   OJ系统自动进行测试用例评分\n\n## 期末笔试（40％）\n\n​\t**均分60~70！很难**\n\n​\t有手写代码\n\n​\t有程序分析题：  1. 给代码，写输出。 2. 给代码，找错误。  3. 给代码，补全代码。\n\n​\t还有编程题：10分+40分/30分，手写代码\n\n>   **左老师：期末考试除了你的名字，不需要写一个汉字字符**\n\n## 补交\n\n-   作业、上机测验、课程设计\n-   每人**一共**3次补交机会，\n-   补交时间为截至时间一周之内\n-   评分按60%计算\n-   需向助教或老师说明补交缘由，并征得助教或老师同意\n\n## 学术规范\n\n-   所有代码重查\n\n-   作弊处理\n\n-   第一次：当次0分；\n\n-   第二次：课程零分\n\n-   抄袭与被抄袭者同等处罚\n\n-   上学期发现作弊67人次 \n\n    ​\tOJ登录已完成同学的账号\n\n    ​\t‘借鉴同学代码’、只是讨论问题但是代码一样\n\n    ​\t抄Github开源项目\n\n \n\n-   注意事项\n-   **无论被抄袭者是否知情，双方同等处罚**\n-   **OJ及时改密码**\n-   OJ独立完成\n-   项目（课程设计）讨论则会相应扣分\n-   本课程项目应当独立完成\n-   作弊认定\n-   OJ查重，多种查重算法\n-   人工审核，助教随机查验代码，询问代码\n-   同学举报\n\n## 助教安排\n\n-   分组负责制度\n-   每组约15位同学，1位责任助教\n-   责任助教负责该组答疑、讨论和各项任务检查\n-   分组\n-   详细分组安排将在开课两周后选课结束后确定","categories":["NJUCS","高级程序设计"]},{"title":"程序设计基础期末复习","url":"/posts/c724802f5200/","content":"# 程序设计基础期末复习\n\n图文作业题汇总+ai解析\n\n期末复习因为没有往年卷做现在闲得无聊导致的🤓\n\n---------------------\n\n1. 下面是几种不一样的二维数组的定义方式：\n```c\n1 typedef int A[10];A p[10];  \n2 int** q=new int*[10]; for(int i=0;i<10;i++){q[i]=new int[10];};\n3 int a[10][10];\n4 int (*p)[10]=new int[m][10];(注意多维数组除了第一个可以是变量，其他都必须是常量)；\n```\n那么区别在哪里？\n\n\n    1.memory allocation：第二、四个是动态数组（dynamic allocated）；其他两个都是静态的数组（statically allocated）; 一三四的内存是连续分配的，第二个每个一维数组不一定是连续存储的，但是每一个一维数组内部是连续的；\n    \n    2.虽然都可以用p[i][j]来访问数组，但是本质不一样；一二四是*(*(arr+i)+j),第三个是 *(arr+i*m+j) 期中m是一维数组的长度；\n    \n    3.一和四的联系：p其实就是A*类型的指针；\n    \n    4.在撤销动态变量的时候，第四个只需要撤销一次即可：delete[] p；但是第二个需要先撤销每一行的数组，然后再撤销最外层；\n\n------------------------------------\n\n\n### **作业14**\n\n#### **一、简答题**\n\n1. **单链表中，增加一个头结点的目的为？**\n   - **答案**：增加头结点可以简化链表的操作，尤其是在插入和删除操作时，**无需特别处理链表的第一个节点**。头结点不存储实际数据，它的存在使得链表操作更加统一，避免了空链表的特殊情况处理。\n\n2. **给定一个单链表，如何在遍历一次的情况下找到链表的中间节点？请描述算法的逻辑。**\n   - **答案**：使用快慢指针法。定义两个指针，一个快指针（每次移动两步）和一个慢指针（每次移动一步）。当快指针到达链表末尾时，慢指针正好指向链表的中间节点。\n\n3. **在以下代码中，p 和 q 的含义分别是什么？它们的操作有何不同？**\n   ```c\n   int a[10]; \n   int *p = &a[0]; \n   int (*q)[10] = &a;\n   ```\n   - **答案**：\n     - `p` 是一个指向 `int` 类型的指针，指向数组 `a` 的第一个元素。\n     - `q` 是一个指向包含 10 个 `int` 类型元素的数组的指针，指向整个数组 `a`。\n     - **操作不同**：`p` 可以用于遍历数组的每个元素，而 `q` 用于操作整个数组。\n\n4. **简述动态分配二维数组时分配和释放内存的操作步骤。**\n   - **答案**：\n     - **分配内存**：\n       ```c\n       int **arr = (int **)malloc(rows * sizeof(int *));\n       for (int i = 0; i < rows; i++) {\n           arr[i] = (int *)malloc(cols * sizeof(int));\n       }\n       ```\n     - **释放内存**：\n       ```c\n       for (int i = 0; i < rows; i++) {\n           free(arr[i]);\n       }\n       free(arr);\n       ```\n\n5. **什么是函数指针？请简述函数指针的作用及其应用场景。**\n   - **答案**：\n     - **函数指针**：函数指针是指向函数的指针变量，它存储了函数的地址。\n     - **作用**：函数指针可以用于回调函数、动态函数调用等场景。\n     - **应用场景**：事件处理、排序算法中的比较函数、插件机制等。\n\n6. **引用类型与指针类型的主要区别是什么？在以下场景中，哪个更适合使用指针？哪个更适合使用引用？**\n   - **答案**：\n     - **主要区别**：\n       - 引用是变量的别名，必须在声明时初始化，且不能改变引用的对象。\n       - 指针是一个变量，存储的是另一个变量的地址，可以改变指向的对象。\n     - **场景选择**：\n       - **修改传入的参数值**：引用更适合，因为引用语法更简洁。\n       - **链表操作**：指针更适合，因为链表操作需要频繁改变指向的对象。\n       - **遍历数组**：引用和指针都可以，但指针更常见。\n\n7. **指针数组与二维数组在使用上有哪些相似之处？它们在内存布局上有何不同？**\n   - **答案**：\n     - **相似之处**：都可以用于表示二维数据，访问元素时都可以使用双重下标。\n     - **内存布局不同**：\n       - 二维数组是连续的内存块，所有元素按行优先顺序存储。\n       - 指针数组的每个元素是一个指针，指向不同的内存块，这些内存块可以不连续。\n\n8. **运行以下的代码并给出答案。**\n   ```cpp\n   #include <iostream>\n   using namespace std;\n   int main() {\n       // 定义一个二维数组\n       int arr[2][3] = { {1, 2, 3}, {4, 5, 6} };\n       // 定义一个指针数组\n       int arr1[4] = {3, 1, 2, 3};  // 第一个元素代表当前数组的元素个数 \n       int other[4] = {1,2,3,4};  // 一些无关的定义 \n       int arr2[5] = {4, 4, 5, 6, 7};\n       int* ptrArr[2] = {arr1, arr2};\n       // 输出二维数组内容和地址\n       cout << \"二维数组内容和地址：\" << endl;\n       for (int i = 0; i < 2; ++i) {\n           for (int j = 0; j < 3; ++j) {\n               cout << \"arr[\" << i << \"][\" << j << \"] = \" << arr[i][j] << \", 地址: \" << &arr[i][j] << endl;\n           }\n       }\n       // 输出指针数组内容和地址\n       cout << \"\\n指针数组内容和地址：\" << endl;\n       for (int i = 0; i < 2; ++i) {\n           cout << \"ptrArr[\" << i << \"] = \" << ptrArr[i] << \", 地址: \" << &ptrArr[i] << endl;\n           int jnum =  *(ptrArr[i]); \n           for (int j = 1; j <= jnum; ++j) {\n               cout << \"ptrArr[\" << i << \"][\" << j << \"] = \" << *(ptrArr[i] + j) << \", 地址: \" << (ptrArr[i] + j) << endl;\n           }\n       }\n       return 0;\n   }\n   ```\n   - **答案**：\n     - 二维数组内容和地址：输出二维数组的每个元素及其地址。\n     - 指针数组内容和地址：输出指针数组的每个指针及其指向的数组元素及其地址。\n\n---\n\n#### **二、选择题**\n\n1. **对数组 `int a[2][3]` 的第 `i` 行第 `j` 列元素地址的引用正确的是（）**\n   - **答案**：D、`a[i]+j`\n\n2. **以下声明指针数组的是（）**\n   - **答案**：A、`int *p[2];` 和 C、`typedef int *ptr; ptr p[2];`\n\n3. **有 `int a[10]={1,2,3,4,5,6,7,8,9,10},*p=&a[3],b; b=p[5];` `b` 的值是（）**\n   - **答案**：D、9\n\n4. **有以下程序，输出结果是（）**\n   ```c\n   #include<stdio.h>\n   int main() {\n       int a=1, b=3, c=5;\n       int *p1=&a, *p2=&b, *p=&c;\n       *p=*p1 *(*p2);\n       printf(\"%d\\n\", c);\n       return 0;\n   }\n   ```\n   - **答案**：C、3\n\n---\n\n#### **三、编程题（选做）**\n\n1. **回文链表**：[力扣链接](https://leetcode.cn/problems/palindrome-linked-list?envType=study-plan-v2&envId=top-100-liked)\n2. **两数相加**：[力扣链接](https://leetcode.cn/problems/add-two-numbers?envType=study-plan-v2&envId=top-100-liked)\n3. **两两交换链表中的节点**：[力扣链接](https://leetcode.cn/problems/swap-nodes-in-pairs/?envType=study-plan-v2&envId=top-100-liked)\n\n---\n\n### **作业**\n\n#### **一、简答题**\n\n1. **分别简述链表和数组的优点、缺点。请思考如何将链表的优点和缺点结合起来。**\n   - **答案**：\n     - **数组的优点**：随机访问效率高，内存连续，缓存友好。\n     - **数组的缺点**：插入和删除效率低，大小固定。\n     - **链表的优点**：插入和删除效率高，动态扩展方便。\n     - **链表的缺点**：随机访问效率低，内存不连续。\n     - **结合**：可以使用块状链表（如块状数组或跳表），将链表和数组的优点结合起来。\n\n2. **描述链表的插入操作，并简要说明插入到链表头部、尾部和中间位置的不同实现。**\n   - **答案**：\n     - **头部插入**：将新节点的 `next` 指向当前头节点，然后更新头节点为新节点。\n     - **尾部插入**：遍历链表找到尾节点，将尾节点的 `next` 指向新节点。\n     - **中间插入**：找到插入位置的前驱节点，将新节点的 `next` 指向前驱节点的 `next`，然后将前驱节点的 `next` 指向新节点。\n\n3. **请简述如何反转一个单链表？**\n   - **答案**：使用三个指针 `prev`、`curr` 和 `next`，遍历链表，逐个反转节点的 `next` 指针，最后更新头节点为原链表的尾节点。\n\n4. **对于单链表和数组，在不同的位置插入数据时，他们的效率有区别吗？**\n   - **答案**：\n     - **数组**：头部插入 O(n)，尾部插入 O(1)，中间插入 O(n)。\n     - **链表**：头部插入 O(1)，尾部插入 O(n)，中间插入 O(n)。\n\n5. **在块状链表中，如何高效查询一个元素？相比于普通链表，块状链表在查询时有哪些优势？**\n   - **答案**：先定位块，再在块内使用二分查找。查询时间复杂度为 O(√n)，比普通链表的 O(n) 更高效。\n\n---\n\n#### **二、选择题**\n\n1. **已知头指针 `h` 指向一个非空单循环链表，结点结构为 `(data,next)`，其中 `next` 是指向直接后继结点的指针，`p` 是尾指针，`q` 是临时指针。现要删除该链表的第一个元素，正确的语句序列是()。**\n   - **答案**：D、`q=h; h=q->next; if (p==q) p=h; free(q);`\n\n2. **在一个长度为 `n` 的单链表 `h` 上，设有尾指针 `r`，则执行（）操作与链表的表长有关。**\n   - **答案**：B、删除单链表中的最后一个元素\n\n3. **已知一个双向链表 `L`，结点结构为 `(prev,data,next)`，其中 `prev` 和 `next` 分别是指向其直接前驱和直接后继结点的指针。假设指针 `p` 所指节点的前驱和后继节点均不为空，现要删除指针 `p` 所指的结点，正确的语句序列是（）。**\n   - **答案**：D、`p->next->prev=p->prev; p->prev->next=p->next; free(p);`\n\n---\n\n#### **三、改错题**\n\n**以下是一个实现单链表插入操作的代码，其中存在若干错误，请找出并修正这些错误。**\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\nstruct Node {\n    int data;\n    struct Node* next;\n};\nvoid insertAtEnd(struct Node* head, int value) {\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = value;\n    newNode->next = NULL;\n    struct Node* current = head;\n    \n    // 错误1：如果链表为空，head为NULL，current->next会引发段错误\n    if (head == NULL) {\n        head = newNode; // 错误2：head是局部变量，修改不会影响外部\n        return;\n    }\n    \n    while (current->next != NULL) {\n        current = current->next;\n    }\n    current->next = newNode;\n}\nvoid printList(struct Node* head) {\n    struct Node* temp = head;\n    while (temp != NULL) {\n        printf(\"%d -> \", temp->data);\n        temp = temp->next;\n    }\n    printf(\"NULL\\n\");\n}\nint main() {\n    struct Node* head = NULL;\n    insertAtEnd(head, 10); // 错误3：head未更新\n    insertAtEnd(head, 20);\n    insertAtEnd(head, 30);\n    \n    printList(head);\n    \n    return 0;\n}\n```\n\n**修正后的代码：**\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\nstruct Node {\n    int data;\n    struct Node* next;\n};\nvoid insertAtEnd(struct Node** head, int value) { // 修改为指向指针的指针\n    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));\n    newNode->data = value;\n    newNode->next = NULL;\n    \n    if (*head == NULL) {\n        *head = newNode; // 直接修改头指针\n        return;\n    }\n    \n    struct Node* current = *head;\n    while (current->next != NULL) {\n        current = current->next;\n    }\n    current->next = newNode;\n}\nvoid printList(struct Node* head) {\n    struct Node* temp = head;\n    while (temp != NULL) {\n        printf(\"%d -> \", temp->data);\n        temp = temp->next;\n    }\n    printf(\"NULL\\n\");\n}\nint main() {\n    struct Node* head = NULL;\n    insertAtEnd(&head, 10); // 传递头指针的地址\n    insertAtEnd(&head, 20);\n    insertAtEnd(&head, 30);\n    \n    printList(head);\n    \n    return 0;\n}\n```\n\n---\n\n#### **四、编程题（选做）**\n\n**约瑟夫问题：**\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nstruct Node {\n    int data;\n    Node* next;\n};\n\nint josephus(int n, int m) {\n    // 创建循环链表\n    Node* head = new Node{1, nullptr};\n    Node* curr = head;\n    for (int i = 2; i <= n; i++) {\n        curr->next = new Node{i, nullptr};\n        curr = curr->next;\n    }\n    curr->next = head; // 形成环\n\n    // 开始淘汰\n    while (curr->next != curr) {\n        // 找到第 m-1 个节点\n        for (int i = 1; i < m; i++) {\n            curr = curr->next;\n        }\n        // 删除第 m 个节点\n        Node* temp = curr->next;\n        curr->next = temp->next;\n        delete temp; // 释放内存\n    }\n\n    // 输出最后剩下的人的编号\n    int result = curr->data;\n    delete curr;\n    return result;\n}\n\nint main() {\n    int n = 5, m = 2;\n    cout << \"最后剩下的人的编号是：\" << josephus(n, m) << endl;\n    return 0;\n}\n```\n\n**输出结果：**\n```\n最后剩下的人的编号是：3\n```\n\n---\n\n希望这次的整合对你有帮助！如果还有其他问题，欢迎随时提问！\n#**作业12**\n### **指针的定义**\n\n1. **在C/C++语言中，指针是什么？它在程序中有哪些作用？**\n   - **指针**：指针是一个变量，它存储的是另一个变量的内存地址。\n   - **作用**：\n     - 动态内存分配（如 `malloc`、`new`）。\n     - 函数参数传递（如传递数组或大型结构体）。\n     - 实现数据结构和算法（如链表、树）。\n     - 直接访问硬件或内存地址。\n\n2. **请说出以下段代码段中的定义，哪些是指针，指针的类型是什么。你能总结出指针定义的规律吗？**\n   ```cpp\n   int *a1, a2;\n   auto s = \"hello\";\n   auto ch = 'h';\n   int *a[20];\n   int (*a)[20];\n   ```\n   - **指针及其类型**：\n     - `int *a1`：`a1` 是指针，类型是 `int*`。\n     - `auto s = \"hello\"`：`s` 是指针，类型是 `const char*`（字符串字面量的类型）。\n     - `int *a[20]`：`a` 是指针数组，数组的每个元素是 `int*` 类型。\n     - `int (*a)[20]`：`a` 是指针，指向一个包含 20 个 `int` 元素的数组，类型是 `int(*)[20]`。\n   - **指针定义的规律**：\n     - `type *name`：定义一个指向 `type` 类型的指针。\n     - `type *name[size]`：定义一个数组，数组的每个元素是指向 `type` 类型的指针。\n     - `type (*name)[size]`：定义一个指针，指向一个包含 `size` 个 `type` 类型元素的数组。\n\n---\n\n### **指针间接访问**\n\n1. **请将以下的函数改写成等价的使用指针间接访问的形式**\n   ```cpp\n   int index(int *a, int i) {\n       return a[i];\n   }\n   ```\n   - **改写**：\n     ```cpp\n     int index(int *a, int i) {\n         return *(a + i);\n     }\n     ```\n\n2. **请将以下代码片段用指针改写成更加简洁的形式**\n   ```cpp\n   if (i == 0) {\n       a = 3 * x * x + x * 2 + x / 9 + x >> 8 * 10000;\n   } else if (i == 1) {\n       b = 3 * x * x + x * 2 + x / 9 + x >> 8 * 10000;\n   } else if (i == 2) {\n       c = 3 * x * x + x * 2 + x / 9 + x >> 8 * 10000;\n   } else if (i == 3) {\n       d = 3 * x * x + x * 2 + x / 9 + x >> 8 * 10000;\n   } else if (i == 4) {\n       e = 3 * x * x + x * 2 + x / 9 + x >> 8 * 10000;\n   }\n   ```\n   - **改写**：\n     ```cpp\n     int *arr[] = {&a, &b, &c, &d, &e};\n     if (i >= 0 && i < 5) {\n         *arr[i] = 3 * x * x + x * 2 + x / 9 + x >> 8 * 10000;\n     }\n     ```\n\n---\n\n### **指针与函数**\n\n1. **以地址传递参数和以值传递参数的优点和缺点分别是什么？如何针对缺点进行改进？**\n   - **地址传递**：\n     - **优点**：避免数据拷贝，效率高；可以修改实参的值。\n     - **缺点**：可能引入指针安全问题（如空指针、野指针）。\n     - **改进**：使用 `const` 修饰指针，避免意外修改。\n   - **值传递**：\n     - **优点**：安全，不会修改实参的值。\n     - **缺点**：数据拷贝开销大，尤其是大型结构体或数组。\n     - **改进**：对于大型数据，使用引用或指针传递。\n\n2. **以地址传递参数一定比以值传递参数效率高吗？有没有例外？**\n   - **不一定**。如果传递的数据很小（如基本类型），值传递可能更高效，因为指针本身也有开销。\n\n---\n\n### **指针常量**\n\n1. **请分别解释以下几种指针的定义分别表示什么意思，有什么区别。**\n   ```cpp\n   int* const a, b;\n   const int* a, b;\n   int const* a, b;\n   const int* const a;\n   int const* const a;\n   int *const* a;\n   ```\n   - **解释**：\n     - `int* const a`：`a` 是一个常量指针，指向 `int` 类型，指针的地址不能改变，但指向的值可以改变。\n     - `const int* a` 和 `int const* a`：`a` 是指针，指向 `const int` 类型，指针的地址可以改变，但指向的值不能改变。\n     - `const int* const a` 和 `int const* const a`：`a` 是一个常量指针，指向 `const int` 类型，指针的地址和指向的值都不能改变。\n     - `int *const* a`：`a` 是指针，指向 `int* const` 类型，即指向一个常量指针。\n\n2. **当在函数的参数中传递指针时，如果使用常量指针如 `const int *a` 作为参数，那么其对函数内的程序有怎么样的约束？对函数的调用者提供怎么样的保证？**\n   - **约束**：函数内不能通过指针修改指向的值。\n   - **保证**：调用者知道函数不会修改传入的数据。\n\n3. **当在函数的返回值中传递指针时，如果返回常量指针如 `const int *`，那么其对函数的调用者有什么样的约束？**\n   - **约束**：调用者不能通过返回的指针修改指向的值。\n\n4. **如果一个函数接受字符串作为参数，而不需要修改原字符串，使用 `const char*` 作为参数相比 `char *` 有什么好处？**\n   - **好处**：\n     - 明确表示函数不会修改字符串内容。\n     - 可以接受常量字符串（如 `\"hello\"`）作为参数，避免编译错误。\n\n---\n### **作业12：枚举类型**\n\n#### **1. 请解释C++中的enum类型，并说明它与普通整数类型的区别。请举例说明如何定义和使用一个enum类型，并解释为什么在某些情况下使用enum类型比使用普通整数类型更合适。**\n\n- **enum类型**：`enum` 是C++中的枚举类型，用于定义一组命名的整数常量。它可以将一组相关的常量值组织在一起，提高代码的可读性和可维护性。\n- **与普通整数类型的区别**：\n  - `enum` 类型是强类型的，不能直接与整数混用（除非显式转换）。\n  - `enum` 类型的值是有意义的名称，而普通整数类型的值是无意义的数字。\n- **定义和使用**：\n  ```cpp\n  enum Color { RED, GREEN, BLUE }; // 定义枚举类型\n  Color c = GREEN; // 使用枚举类型\n  if (c == GREEN) {\n      cout << \"The color is green!\" << endl;\n  }\n  ```\n- **使用 `enum` 的优势**：\n  - 提高代码可读性：使用有意义的名称代替无意义的数字。\n  - 避免魔法数字：减少代码中直接使用数字的情况。\n  - 类型安全：避免错误的赋值或比较。\n\n#### **2. 请查阅资料了解一下C++11引入的enum class，并简述它与课堂上的enum类型的区别和优势。**\n\n- **`enum class`**：C++11 引入了 `enum class`，它是一种作用域枚举类型。\n- **区别和优势**：\n  - **作用域**：`enum class` 的枚举值在枚举类型的作用域内，不会污染全局命名空间。\n  - **强类型**：`enum class` 不能隐式转换为整数，必须显式转换。\n  - **底层类型**：可以指定底层类型（如 `enum class Color : char`）。\n  - **示例**：\n    ```cpp\n    enum class Color { RED, GREEN, BLUE };\n    Color c = Color::GREEN;\n    if (c == Color::GREEN) {\n        cout << \"The color is green!\" << endl;\n    }\n    ```\n\n---\n\n### **结构类型**\n\n#### **1. 判断题：**\n\n1. **结构体成员的类型必须是基本数据类型。**\n   - **答案**：错误。结构体成员可以是任意类型，包括数组、指针、其他结构体等。\n\n2. **一个结构类型变量所占的内存空间是其各个成员所占内存空间之和。**\n   - **答案**：错误。结构体的内存空间可能包含对齐填充（padding），因此不一定等于成员大小之和。\n\n3. **下面这个代码中，`per` 是结构体变量名。**\n   ```cpp\n   typedef struct {\n       int n;\n       char ch[8];   \n   } per;\n   ```\n   - **答案**：错误。`per` 是结构体类型的别名，不是变量名。\n\n#### **2. 观察下面代码，指出代码中存在的错误：**\n\n```cpp\n#include <iostream>\n#include <string>\nusing namespace std;\n\nenum Major {\n    MATHEMATICS,\n    PHYSICS,\n    COMPUTER, // 错误1：缺少分号\n};\n\nstruct UndergraduateStudent {\n    char name[20];\n    double grade;\n    Major major;\n}; // 错误2：缺少分号\n\nstruct GraduateStudent {\n    char name[20];\n    double grade;\n    Major major;\n}; // 错误3：缺少分号\n\nint main() {\n    UndergraduateStudent s1 = {'A', 93.7, 0}; // 错误4：'A' 是字符，不能初始化字符数组\n    GraduateStudent s2 = {\"B\", 70.0, COMPUTER}; // 正确\n    UndergraduateStudent s3 = s2; // 错误5：类型不匹配，不能将 GraduateStudent 赋值给 UndergraduateStudent\n    return 0;\n}\n```\n\n---\n\n#### **3. （选做）深入探索Struct内存布局**\n\n**代码1：**\n```cpp\n#include <iostream>\nstruct {\n    unsigned char b1 : 10;\n    unsigned char b2 : 6;\n    unsigned char b3 : 16;\n} S;\nint main() {\n    std::cout << sizeof(S) << '\\n';\n}\n```\n\n**代码2：**\n```cpp\n#include <iostream>\nstruct {\n    unsigned char b1 : 10;\n    unsigned char b2 : 16;\n    unsigned char b3 : 6;\n} S;\nint main() {\n    std::cout << sizeof(S) << '\\n';\n}\n```\n\n**分析**：\n- **代码1**：\n  - `b1` 占用 10 位，`b2` 占用 6 位，共 16 位（2 字节）。\n  - `b3` 占用 16 位（2 字节）。\n  - 总大小为 4 字节。\n- **代码2**：\n  - `b1` 占用 10 位，`b2` 占用 16 位，无法放在同一字节中，因此 `b1` 和 `b2` 分别占用 2 字节和 2 字节。\n  - `b3` 占用 6 位，单独占用 1 字节。\n  - 总大小为 5 字节。\n\n**验证方案**：\n- 使用 `sizeof` 输出结构体大小，验证分析结果。\n\n---\n\n### **联合类型**\n\n#### **1. 结构类型变量和联合类型变量分别适合应用在什么场景？它们的内存布局由哪些因素决定？**\n\n- **结构体**：\n  - **场景**：用于存储一组相关的数据，每个成员有独立的内存空间。\n  - **内存布局**：由成员的顺序、大小和对齐方式决定。\n- **联合体**：\n  - **场景**：用于存储一组可能的数据类型，但同一时间只能使用其中一个成员。\n  - **内存布局**：所有成员共享同一块内存，大小为最大成员的大小。\n\n#### **2. （选做）利用联合类型判断系统是大端模式还是小端模式。**\n\n```cpp\n#include <iostream>\nunion EndianTest {\n    int value;\n    char bytes[sizeof(int)];\n};\n\nint main() {\n    EndianTest test;\n    test.value = 0x01020304;\n\n    if (test.bytes[0] == 0x04) {\n        std::cout << \"Little endian\" << std::endl;\n    } else {\n        std::cout << \"Big endian\" << std::endl;\n    }\n    return 0;\n}\n```\n\n**解释**：\n- 在小端模式下，低字节存储在低地址，因此 `test.bytes[0]` 是 `0x04`。\n- 在大端模式下，高字节存储在低地址，因此 `test.bytes[0]` 是 `0x01`。\n\n---\n### **数组**\n\n#### **1. 请说明C、C++中对多维数组的内存安排，并尝试讨论这样做的优劣。**\n\n- **内存安排**：\n  - 在C/C++中，多维数组在内存中是按**行优先顺序**（Row-major order）存储的。\n  - 例如，二维数组 `int arr[2][3]` 的内存布局为：`arr[0][0]`, `arr[0][1]`, `arr[0][2]`, `arr[1][0]`, `arr[1][1]`, `arr[1][2]`。\n  - 对于更高维的数组，内存布局也是类似的，从最外层维度到最内层维度依次展开。\n\n- **优劣**：\n  - **优点**：\n    - 内存连续，缓存友好，访问效率高。\n    - 可以通过指针算术直接访问任意元素。\n  - **缺点**：\n    - 多维数组的大小固定，灵活性较差。\n    - 动态分配多维数组时，代码较为复杂。\n\n#### **2. 计算 `arr[1][2][3][4][5]` 的地址**\n\n给定五维数组 `int arr[2][3][4][5][6]`，起始地址为 `0x1000`，每个整数占用 4 字节。\n\n- **计算公式**：\n  ```\n  地址 = 基地址 + (i1 * S1 + i2 * S2 + i3 * S3 + i4 * S4 + i5) * sizeof(int)\n  其中：\n  S1 = 3 * 4 * 5 * 6\n  S2 = 4 * 5 * 6\n  S3 = 5 * 6\n  S4 = 6\n  ```\n\n- **计算过程**：\n  ```\n  S1 = 3 * 4 * 5 * 6 = 360\n  S2 = 4 * 5 * 6 = 120\n  S3 = 5 * 6 = 30\n  S4 = 6\n  \n  地址 = 0x1000 + (1 * 360 + 2 * 120 + 3 * 30 + 4 * 6 + 5) * 4\n       = 0x1000 + (360 + 240 + 90 + 24 + 5) * 4\n       = 0x1000 + 719 * 4\n       = 0x1000 + 2876\n       = 0x1000 + 0xB3C\n       = 0x1B3C\n  ```\n\n- **最终地址**：`0x1B3C`\n\n---\n\n### **字符串**\n\n#### **1. 描述字符串的各种初始化方式**\n\n- **示例1**：\n  ```cpp\n  char str[10] = {'h', 'e', 'l', 'l', 'o', '\\0'};\n  ```\n  - 初始化一个长度为 10 的字符数组，前 6 个字符为 `'h', 'e', 'l', 'l', 'o', '\\0'`，剩余部分填充 `\\0`。\n\n- **示例2**：\n  ```cpp\n  char str[5] = {'h', 'e', 'l', 'l', 'o'};\n  ```\n  - 初始化一个长度为 5 的字符数组，没有 `\\0` 结尾，因此不是合法的 C 字符串。\n\n- **示例3**：\n  ```cpp\n  char str[] = \"hello\";\n  ```\n  - 初始化一个长度为 6 的字符数组，包含 `'h', 'e', 'l', 'l', 'o', '\\0'`。\n\n- **示例4**：\n  ```cpp\n  char str[5] = \"hello\";\n  ```\n  - 初始化一个长度为 5 的字符数组，但字符串 `\"hello\"` 需要 6 个字符（包括 `\\0`），因此会截断 `\\0`，导致不是合法的 C 字符串。\n\n- **示例5**：\n  ```cpp\n  char str[5]; str[0] = '0';\n  ```\n  - 声明一个长度为 5 的字符数组，未初始化，仅将第一个字符设置为 `'0'`。\n\n#### **2. 描述 `strncpy` 的行为**\n\n- **`strncpy` 的定义**：\n  ```cpp\n  char *strncpy(char *dest, const char *src, size_t n);\n  ```\n  - 将 `src` 的前 `n` 个字符复制到 `dest` 中。\n\n- **行为**：\n  - 如果 `src` 的长度小于 `n`，则 `dest` 剩余部分填充 `\\0`。\n  - 如果 `src` 的长度大于或等于 `n`，则 `dest` 不会以 `\\0` 结尾。\n\n#### **3. （选做）实现查找子串的函数（`strstr`）**\n\n```cpp\nconst char *my_strstr(const char *str, const char *substr) {\n    if (*substr == '\\0') return str;\n    for (const char *p = str; *p != '\\0'; p++) {\n        const char *s1 = p;\n        const char *s2 = substr;\n        while (*s1 != '\\0' && *s2 != '\\0' && *s1 == *s2) {\n            s1++;\n            s2++;\n        }\n        if (*s2 == '\\0') return p;\n    }\n    return nullptr;\n}\n```\n\n---\n\n### **枚举类型**\n\n#### **1. 枚举类型和整数类型有什么关系？在参与运算时，关于枚举类型有哪些运算规则？**\n\n- **关系**：\n  - 枚举类型的底层是整数类型，每个枚举值对应一个整数常量。\n  - 默认情况下，第一个枚举值为 `0`，后续枚举值依次递增。\n\n- **运算规则**：\n  - 枚举值可以隐式转换为整数，但整数不能隐式转换为枚举类型。\n  - 枚举值可以参与整数运算，但结果仍然是整数类型。\n\n#### **2. 观察下面代码，写出这个枚举类型中每个成员的值，并说明这样定义是否存在问题？**\n\n```cpp\nenum Day {    \n    SUNDAY = -1,      \n    MONDAY = 3,       \n    TUESDAY,      \n    WEDNESDAY = 2,     \n    THURSDAY,      \n    FRIDAY,        \n    SATURDAY   \n};\n```\n\n- **枚举值**：\n  ```\n  SUNDAY = -1\n  MONDAY = 3\n  TUESDAY = 4\n  WEDNESDAY = 2\n  THURSDAY = 3\n  FRIDAY = 4\n  SATURDAY = 5\n  ```\n\n- **问题**：\n  - `THURSDAY` 和 `MONDAY` 的值相同（`3`），`FRIDAY` 和 `TUESDAY` 的值相同（`4`），这可能导致逻辑错误。\n\n---\n\n### **选做题**\n\n#### **洛谷经典数组题**\n\n1. [P5727](https://www.luogu.com.cn/problem/P5727)\n2. [P5731](https://www.luogu.com.cn/problem/P5731)\n3. [P2615](https://www.luogu.com.cn/problem/P2615)\n\n ","categories":["NJUCS","高级程序设计"]},{"url":"/posts/412aa3a1ce9a/","content":"## kali linux使用\n> 老师在第一节课的时候只讲了有关linxu系统和安装kali linux的内容；之后是有关linux的知识，比如用户权限等等\n- virtualbox安装kali linux\n- linux的基础知识\n- linux的指令\n\n## 渗透测试\n\n**在virtual box中配置靶机**\n在virtualbox中常见的网络配置方法有：\n\n**常用工具**\n- 收集目标主机信息： nmap(network mapper)\nnmap的使用\n1. nmap +ip 扫描前1000个端口\n2. nmap  -p port1 port2 ip 扫描这些端口\n3. nmap -p- ip 扫描所有的端口（从0到65535)\n4. nmap 10.0.2.0/24 扫描10.0.2.0到10.0.2.255进行扫描\n见[Nmap参数详解（含扫描参数原理解释） - 豫让 - 博客园](https://www.cnblogs.com/yurang/p/12046809.html)\n- -sV: 版本检测\n- -A：OS扫描，版本检测，脚本扫描等等，功能相当的强大，不建议在实际情况中使用，因为容易被发现\n```shell\n┌──(yama㉿LAPTOP-24A7CVC0)-[~]\n└─$ nmap 114.212.10.193\nStarting Nmap 7.95 ( https://nmap.org ) at 2025-09-23 17:28 CST\nNmap scan report for 114.212.10.193\nHost is up (0.059s latency).\nNot shown: 991 closed tcp ports (reset)\nPORT     STATE    SERVICE\n22/tcp   open     ssh\n80/tcp   open     http\n111/tcp  open     rpcbind\n135/tcp  filtered msrpc\n139/tcp  filtered netbios-ssn\n445/tcp  filtered microsoft-ds\n2049/tcp open     nfs\n8080/tcp open     http-proxy\n8888/tcp open     sun-answerbook\nNmap done: 1 IP address (1 host up) scanned in 3.35 seconds\n```\n**Web目录枚举**\n- dirsearch\n- dirbuster\n- gobuster\n**Web系统集成攻击平台**\n- burpsuite（用于拦截，篡改请求）\n> 老师：之前有个同学用burpsuite来拦截打印机远程打印的请求，然后把里面的金额改为负数。\n\n**反弹shell** (shell reverse)\n黑客通过漏洞的方式来进入到系统，并且通过建立一个完整的链接。\n原理：被入侵的服务器（受害者）作为客户端，主动向你的计算机发起连接。、\n- Netcat (nc)\n- reverse shell scripts  ([security-cheatsheet/reverse-shell-cheatsheet: 🙃 Reverse Shell Cheat Sheet 🙃](https://github.com/security-cheatsheet/reverse-shell-cheatsheet))\n- msfvenom （根据目标环境生成reverse-shell)\n**文件传输**\n\n\n\n**RMI端口**\n- TCP协议：3389\n- SSH端口：22 （或者2222端口）\n- https：443、http：80\n","categories":["NJUCS","网络攻防实战"]},{"url":"/posts/7e7f0f6f01b0/","content":"## 问题重述\n\n1) 在/tmp下新建一个名为test的目录。\n\n2) 用命令man查看命令touch的使用手册。\n\n3) 用命令touch在test目录中新建一个名为test的文件。\n\n4) 用命令echo将以下内容一行一行地写入test文件。\n  #!/bin/sh\n  curl --head --silent https://www.nju.edu.cn\n\n5) 尝试执行这个文件，即将该脚本的路径（./test）输入到您的shell中并回车。如果程序无法执行，请使用ls命令来获取信息并给出其不能执行的原因。\n\n6) 查看命令chmod的手册，使用命令chmod改变test文件的权限，使 ./test 能够成功执行，不要使用sh test来执行该程序。\n\n7) 请问你的shell是如何知道这个文件需要使用sh来解析的。请通过网络搜索“unix shebang”来了解更多信息。\n\n8) 请使用 | 和 > ，将test文件输出的最后5行内容写入自己主目录下的last-5-lines.txt文件中。\n\n## 实验报告\n\n### 实验过程\n\n1.   **写入test文件**\n\n     在使用echo #!/bin/sh >>test或者echo \"#!/bin/sh\" 的时候，都会出现这样的错误：\n\n     ```shell\n     ┌──(kali㉿kali)-[/tmp/test]\n     └─$ echo \"#!/bin/sh\"    \n     zsh: event not found: /bin/sh\n                                                                         \n     ```\n\n     经过查询，发现“!”是一个特殊的符号，用于shell的histroy expansion。可以和其他的字符相结合，展开得到之前的commands。\n\n     比如说：\n\n     ```shelll\n     ┌──(kali㉿kali)-[/tmp/test]\n     └─$ echo \"HelloWorld\"\n     HelloWorld\n                                                                                                                                                                                                        \n     ┌──(kali㉿kali)-[/tmp/test]\n     └─$ !!\n                                                                                                                                                                                                       \n     ┌──(kali㉿kali)-[/tmp/test]\n     └─$ echo \"HelloWorld\"\n     \n     ```\n\n     而“!/bin/sh”是在查找之前以“/bin/sh”结尾的名字，结果是no found。\n\n     **Solution：** 使用单引号（Single Quotes）\n\n     ---\n\n2.   **执行test**\n\n     ```shell\n     ┌──(kali㉿kali)-[/tmp/test]\n     └─$ ./test\n     zsh: permission denied: ./test\n                                                                                                                                                                                                        \n     ┌──(kali㉿kali)-[/tmp/test]\n     └─$ ls -l          \n     total 4\n     -rw-rw-r-- 1 kali kali 54 Sep  9 07:09 test\n                                                                                                           \n     ```\n\n     发现报错，检查文件权限发现，test文件没有执行权限。\n\n3.   **查询手册**（touch、chmod） \n\n     1.   touch指令用于修改文件的时间戳，不会对文件的内容产生影响，因此可以用于创建空文件\n     2.   chmod指令的作用是Change file mode bits, 改变文件的权限。比如chmod +x test，就可以让test文件可以执行\n\n4.   **再次运行test**\n\n     ```sh\n     ┌──(kali㉿kali)-[/tmp/test]\n     └─$ chmod +x test\n                                                                                                                                                                                                        \n     ┌──(kali㉿kali)-[/tmp/test]\n     └─$ ./test\n     HTTP/1.1 200 OK\n     Date: Tue, 09 Sep 2025 11:21:45 GMT\n     Content-Type: text/html\n     Content-Length: 236052\n     Connection: keep-alive\n     X-Frame-Options: SAMEORIGIN\n     X-XSS-Protection: 1; mode=block\n     X-Content-Type-Options: nosniff\n     Referer-Policy: no-referer-when-downgrade\n     X-Download-Options: noopen\n     X-Permitted-Cross-Domain-Policies: master-only\n     Last-Modified: Tue, 09 Sep 2025 09:56:44 GMT\n     Accept-Ranges: bytes\n     Vary: User-Agent,Accept-Encoding\n     Cache-Control: private, max-age=600\n     Expires: Tue, 09 Sep 2025 11:31:45 GMT\n     ETag: \"39a14-63e5b524d594d-gzip\"\n     Content-Language: zh-CN\n     ```\n\n     \n\n5.   **查询shebang**\n\n     -   gemini：“The string `#!/bin/sh` itself is known as a **shebang** (a combination of \"hash\" and \"bang\"). When placed as the very first line of a script file, it tells the operating system which interpreter to use to execute the script. In this case, it specifies that the script should be run using the `/bin/sh` shell. This is a crucial element for making a script directly executable.”\n     -   google：When a text file with a shebang is used as if it were an executable in a [Unix-like](https://en.wikipedia.org/wiki/Unix-like) operating system, the [program loader](https://en.wikipedia.org/wiki/Loader_(computing)) mechanism parses the rest of the file's initial line as an interpreter directive. The loader executes the specified [interpreter](https://en.wikipedia.org/wiki/Interpreter_(computing)) program, passing to it as an argument the path that was initially used when attempting to run the script, so that the program may use the file as input data.[[8\\]](https://en.wikipedia.org/wiki/Shebang_(Unix)#cite_note-linux-8) For example, if a script is named with the path *path/to/script*, and it starts with the line `#! /bin/sh`, then the program loader is instructed to run the program */bin/sh*, passing *path/to/script* as the first argument.\n\n     简单来说，shebang的意思就是“#!”,放在脚本文件的前面，用于指定执行该文件的interpreter、shell等。\n\n6.   **保存输出**\n\n     ```shel\n     ┌──(kali㉿kali)-[/tmp/test]\n     └─$ ./test\n     HTTP/1.1 200 OK\n     Date: Tue, 09 Sep 2025 11:21:45 GMT\n     Content-Type: text/html\n     Content-Length: 236052\n     Connection: keep-alive\n     X-Frame-Options: SAMEORIGIN\n     X-XSS-Protection: 1; mode=block\n     X-Content-Type-Options: nosniff\n     Referer-Policy: no-referer-when-downgrade\n     X-Download-Options: noopen\n     X-Permitted-Cross-Domain-Policies: master-only\n     Last-Modified: Tue, 09 Sep 2025 09:56:44 GMT\n     Accept-Ranges: bytes\n     Vary: User-Agent,Accept-Encoding\n     Cache-Control: private, max-age=600\n     Expires: Tue, 09 Sep 2025 11:31:45 GMT\n     ETag: \"39a14-63e5b524d594d-gzip\"\n     Content-Language: zh-CN\n     \n                                                                                                                                                                                                        \n     ┌──(kali㉿kali)-[/tmp/test]\n     └─$ ls\n     test\n                                                                                                                                                                                                        \n     ┌──(kali㉿kali)-[/tmp/test]\n     └─$ ./test | tail -n 5 > ~/last-5-lines.txt \n                                                                                                                                                                                                        \n     ┌──(kali㉿kali)-[/tmp/test]\n     └─$ cat ~/last*  \n     Cache-Control: private, max-age=600\n     Expires: Tue, 09 Sep 2025 11:43:41 GMT\n     ETag: \"39a14-63e5b524d594d-gzip\"\n     Content-Language: zh-CN\n     ```\n\n     ","categories":["NJUCS","网络攻防实战"]},{"url":"/posts/022e1468566e/","content":"## 密码学相关笔记\n\n### **公钥与私钥**\n\n- **公钥（Public Key）**：可公开分发，用于加密数据或验证数字签名。  \n- **私钥（Private Key）**：必须严格保密，仅由持有者保管，用于解密数据或生成数字签名。\n\n> ✅ 二者在数学上互为对应：用公钥加密的内容，只能用对应的私钥解密；用私钥签名的数据，只能用对应的公钥验证。\n\n1. 公钥与私钥构成非对称加密体系。公钥可用于加密数据或验证签名，私钥则用于解密数据或生成签名。\n2. 实现数据机密性时，发送方使用接收方的公钥加密数据（或对称密钥），只有拥有对应私钥的接收方才能解密。\n3. 在数字签名中，发送方用自身私钥对消息的哈希值进行签名；接收方使用发送方的公钥验证签名，并比对本地计算的哈希值，以确认消息未被篡改，同时验证发送方身份，实现不可抵赖性。\n\n### **数字签名与CA证书**\n\n数字签名是一种密码学机制，用于确保：\n\n- 消息确实来自声称的发送者（**身份认证**）；\n- 消息在传输过程中未被篡改（**完整性**）；\n- 发送者无法否认发送行为（**不可抵赖性**）。\n\n签名流程如下：\n\n- **发送方**：\n  1. 对原始数据计算哈希值；\n  2. 使用自己的私钥对哈希值进行签名；\n  3. 将原始数据与签名一同发送给接收方。\n\n- **接收方**：\n  1. 使用发送方的公钥验证签名；\n  2. 对接收到的消息重新计算哈希值；\n  3. 若两个哈希值一致，则说明消息完整且来源可信。\n\n该过程的安全依赖于私钥的保密性、哈希函数的抗碰撞能力，以及公钥的真实性。\n\n但问题在于：接收方如何确认收到的公钥确实属于发送方？若攻击者伪造公钥并被接收方信任，可能引发中间人攻击。\n解决方案：**数字证书 + 可信第三方（CA）**\n什么是数字证书？\n- 一种由可信证书颁发机构（CA）签发的电子凭证，相当于“数字身份证”；\n- 包含以下信息：\n  - 持有者的身份信息（如域名、公司名称）；\n  - 持有者的公钥；\n  - 证书有效期；\n  - CA 对该证书内容的数字签名（使用CA私钥生成）。\n🔁 验证流程（Bob 如何信任 Alice 的证书？）：\n1. Alice 向 CA 提交身份证明和公钥申请证书；\n2. CA 审核通过后，用自己的私钥对 Alice 的信息（含公钥）签名，生成数字证书；\n3. Bob 收到证书后：\n   - 使用预装在系统或浏览器中的 CA 公钥验证证书签名；\n   - 若验证成功，说明证书未被篡改，且由可信 CA 签发；\n   - 因此，Bob 可信任证书中公钥确实属于 Alice。\n\n**根证书（Root CA）**\n\n- 操作系统和浏览器内置一组受信任的根证书（如 DigiCert、Let's Encrypt、GlobalSign）；\n- 所有网站证书的信任链最终都追溯至这些根证书。\n> 💡 这正是 PKI（公钥基础设施）的核心：通过可信第三方建立公钥与身份之间的可靠绑定。\n\n简单来说，CA（证书颁发机构）的作用是作为一个通信双方都信任的权威第三方，通过数字签名的方式，将用户的身份与其公钥安全地绑定在一起。\n以前： Bob->直接下载Alice的证书来完成信息签名\n有CA之后：Bob->验证CA数字签名->信任Alice的证书（因为Alice的证书已经在CA处被验证过了）\n\n### **SSL/TLS 与 HTTPS**\n","categories":["NJUCS","网络安全实验"]},{"url":"/posts/2f08ba5b1ea6/","content":"## 第一课：对称密码技术----高级数据加密标准(AES)\n\n1. 介绍一下AES加密算法中S盒的作用？\n\n\n> [!NOTE] 回答\n> 1. 不知道\n\n## 第二课：非对称密码技术——RSA、ECC\n\n1. 对称与非对称加密技术的特点？\n\n2. 公钥加密技术可以解决的安全问题是什么？\n\n3. 与RSA相比，ECC有哪些优点？\n> [!NOTE] 回答\n> 1. 对称加密只需要知道秘钥就可以进行加密和解密，但是非对称加密不一样\n> 2. 解决秘钥泄露的问题\n> 3. 计算快\n\n## 第三课：哈希函数和密码学应用\n思考题\n\n1. “如果消息被改写1比特，那么Hash值也仅发生1比特改变。”，请问这个说法对吗？为什么？\n\n2. 验证数字签名时使用签名者的公钥还是私钥？\n\n3. 在网络中单用Hash函数能保证传输数据完整性吗？\n\n4. 设计用户A与用户B之间通过网络安全传输文件机制，安全传输需要保证文件机密性、完整性与不可抵赖性。请注明传输步骤以及各步采用的密码技术（算法），并说明该技术（算法）所提供的安全服务（假设对称加密采用AES，公钥加密采用RSA或ECC，哈希函数采用SHA-2）。\n> [!NOTE] 回答\n> 1. 不正确，hash函数是一个散列函数，即便数据修改了一点点，最后得到的哈希值也可能会发生很大的变化\n> 2. 验证数字签名的时候使用的是签名者的公钥\n> 3. 不能\n> 4. \n\n\n## 第四课：PKI技术基础\n\n**思考题**\n\n1. 如果用户将根证书删除是否还会被信任？\n\n2. A向B发送邮件时应使用谁的密钥？是密钥对中的公钥还是私钥？\n\n3. 为什么需要将签名证书与加密证书分开，并采用不同的密钥对？\n\n4. “使用SSL/TLS通信就可以放心地发送密码等关键信息”，这个说法对吗？为什么？\n\n> [!NOTE] 回答\n> 1.  不会被信任，因为root certificate是\n> 2. A向B发送邮件的时候，应该使用B的秘钥，而且是公钥\n> 3. 因为\n> 4. 不正确，如果证书过期或者被伪造，还是有一定的风险的\n\n\n","categories":["NJUCS","网络安全实验"]},{"title":"Discreate Mathmatics","url":"/posts/a9b324a116de/","content":"\n>   期末才想起来要学离散\n\n## 计数原理\n\n**容斥原理**\n\n![image-20250606090907959](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250606090907959.png)\n\n>   注意！！！ 只学两种语言不是$\\sum_{1<=i<j<=3}A_i \\and A_j$,而是A1交A2交A3的反，因而还需要减去三倍的学习三种语言的人\n\n**鸽笼原理**\n\n![image-20250606091840485](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250606091840485.png)\n\n>   前者把36个连续扇区看成是36个连续的4扇区，每一个扇区被计数4次，发现取等号的情况是每一个连续的四扇区和为74，出现周期性，矛盾；\n>\n>   后者将1从中剔除，考虑不含1的剩下35个数，其平均值为19，因此存在大于19*5=95的扇区。 `大于94，即要大于等于95`\n\n![image-20250606093347140](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250606093347140.png)\n\n## 群论\n\nproblem set19\n\n![image-20250606174059928](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250606174059928.png)\n\n## 布尔代数\n\n![image-20250517223806266](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250517223806266.png)\n\n![image-20250517223828265](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250517223828265.png)\n\n好的，我们从最基础的概念说起，逐步推导出为什么由 nn 个生成元生成的布尔子代数最多有 22n2^{2^n} 个元素。\n\n------\n\n1. 布尔代数与生成子代数\n\n-   **布尔代数** (B,∨,∧, ¬,0,1)(B,\\lor,\\land,\\,\\lnot,0,1) 是一组满足一定公理的集合，其中有“或”“与”“非”、两端元 0,10,1。\n-   给定子集 A={a1,…,an}⊆BA=\\{a_1,\\dots,a_n\\}\\subseteq B，我们记由它们“生成”的最小子代数为 A∗A^*。\n-   直观地说，**A∗A^\\* 中的元素**就是所有可以用有限次 ∨,∧,¬\\lor,\\land,\\lnot 操作，从 a1,…,ana_1,\\dots,a_n（以及代数中的 0,10,1）“拼”出来的结果。\n\n------\n\n2. 布尔表达式对应布尔函数\n\n1.  **布尔表达式**：比如\n\n    (a1∧¬a2)∨(a3∧a2∧¬a4)  (a_1\\land \\lnot a_2)\\lor (a_3\\land a_2\\land\\lnot a_4)\n\n    这样的公式，里面只出现了 a1,…,ana_1,\\dots,a_n 和逻辑运算符。\n\n2.  **布尔函数**：每当你给这 nn 个变量赋一组真值 (0/1)(0/1)，公式就有一个计算结果（0 或 1）。\n     —— 换句话说，每个布尔表达式都定义了一个从 {0,1}n\\{0,1\\}^n 到 {0,1}\\{0,1\\} 的映射，也就是一个 **布尔函数**。\n\n------\n\n3. 等价与计数\n\n-   **等价**：如果两个不同的布尔表达式对所有 (x1,…,xn)∈{0,1}n(x_1,\\dots,x_n)\\in\\{0,1\\}^n 的输出都一样，那么在任何布尔代数中，它们表示的是同一个元素。\n-   **布尔函数的总数**：\n    -   域是 {0,1}n\\{0,1\\}^n，共有 2n2^n 个输入。\n    -   对每个输入，你可以选输 0 或 1，因此一共 22n2^{2^n} 种不同的映射。\n\n------\n\n4. 把它们对应起来\n\n1.  **映射**\n\n    Φ:A∗  ⟶  {所有从 {0,1}n→{0,1}},  \\Phi: A^* \\;\\longrightarrow\\; \\{\\text{所有从 } \\{0,1\\}^n\\to\\{0,1\\}\\},\n\n    令 Φ(f)\\Phi(f) = “把代数里的元 ff 看作一个布尔表达式，记录它在每组 (a1,…,an)(a_1,\\dots,a_n) 取 0/1 时的输出真值表”。\n\n2.  **注入性**\n\n    -   若 f≠gf\\neq g 在 A∗A^* 中是两个不同元素，则作为布尔表达式它们必有某组输入时输出不同，故对应的布尔函数也不同。\n    -   因此 Φ\\Phi 是**单射**。\n\n3.  **结论**\n     因为目标集合（所有布尔函数）大小为 22n2^{2^n}，而 A∗A^* 至多和它等大，所以\n\n    ∣A∗∣  ≤  22n.  |A^*|\\;\\le\\;2^{2^n}.\n\n------\n\n5. 小结\n\n-   **每个子代数元素 ↔ 一个布尔函数**\n-   **布尔函数数目 = 22n2^{2^n}**\n-   **子代数元素数 ≤ 布尔函数数**\n-   **故 ∣A∗∣≤22n\\bigl|A^\\*\\bigr|\\le 2^{2^n}**\n\n如果还有哪里不清楚，或想看具体的真值表示例，请告诉我！","categories":["NJUCS","离散数学"]},{"title":"概率论基础","url":"/posts/8efea91c1fe4/","content":"\n**概率论初步**\n\n样本空间的基本单位是样本点，样本点组成的集合（或者说样本空间的子集，称之为事件），如果满足：\n\n1.   空集属于该集合 \n2.   集合对非运算封闭、对\n\n## **随机变量及其概率分布**\n### 随机变量和分布函数\n#### 随机变量\n\n> [!NOTE] Title\n>To be done\n\n#### 分布函数\n\n> [!NOTE] Title\n> To be done\n\n\n### 离散型\n**0-1分布**\n**二项分布**\n**泊松分布**\n**几何分布**\n\n\n### 连续型\n**均匀分布**\n\n**指数分布**\n\n### 二维随机变量及其分布\n","categories":["NJUCS","概率论和数理统计"]},{"title":"普通物理学","url":"/posts/ec9b800059a4/","content":"\n ## 关于课程\n\n成绩构成：\n\n-   平时考勤+作业 30%\n-   期末考试 70% or 视频20%+期末70%\n\n>   视频要求： 成员不超过5人，200赞则分数70%，多100个赞多10%；考试周前上传。\n\n>   作业注意细节，比如向量要画上面的箭头，点积要着重画出中间的那个点**·**\n\n教材：\n\n[普通物理学第七，八版等物理教材PDF分享 - 哔哩哔哩](https://www.bilibili.com/opus/1015086692610080768)","categories":["NJUCS","普通物理学（上）"]},{"title":"普通物理学期末复习","url":"/posts/82014160a011/","content":"\n本文为南京大学计算机科学与技术专业 普通物理学（上）期末复习总结。 全文约5000字，阅读时间20min\n\n## 期末划重点\n\n<div style=\"\n  font-weight: bold;\n  padding: 8px 15px;\n  border-left: 5px solid #e91e63;\n  display: inline-block;\n\">\n  下面是考试的重点\n</div>\n\n7.3 **静电场的高斯定律** **可能会考多次**\n\n7.4 **静电场的环路定理、电势**\n\n7.6 **静电场中的电介质** **球充电问题是重点**\n\n7.7 电容是次重点\n\n7.8 静电场中的电介质（球计划电荷密度、充入介质求D、E之间的关系等等）\n\n8.4 **恒定磁场的安培环路定理**（根据电流算磁场）\n\n8.5 可能考洛伦兹力\n\n> “不是期中考过的就一定不考，可能涉及牛顿第二定律”--zj \n\n**9.1 电磁感应定律**\n\n**9.2 动生电动势**\n\n<div style=\"\n  font-weight: bold;\n  padding: 8px 15px;\n  border-left: 5px solid #e91e63;\n  display: inline-block;\n\">\n  下面绝对不考\n</div>\n\n8.7、8.8、8.9、9.4之后的内容\n\n不难发现，重点很少，说明：1. 每一个知识点出现的可能性更大 2. 不排除出一些小知识点\n\n---\n\n这些内容是大部分学生走了以后，学生问的一些问题，这里只给出一些回答\n\n“物理会出一道难题，难在物理概念，而不会难在积分上面，就比如可能阿爸这个题目换一个情境，换成一个三角形，或者一个圆形，稍稍灵活一点”\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250618155951037.png\" alt=\"image-20250618155951037\" style=\"zoom: 25%;\" />\n\n> 图为老师讲这段话的时候随手翻出来的题目\n\n证明题也有可能，几年前就出过证明题，证明为什么导体表面的电场是垂直表面的。\n\n梯度算符一般不考，优秀比例不超过20%，这是教育处规定的，但是最后会高于，高于ta也不管。\n\n> 说到这时，zj老师露出了笑容\n\n## 知识点复习\n\n### 静电场\n\n**熟知结论：**\n\n1. 无线长直导线距离a的地方电场$E = \\frac{1}{4 \\pi \\epsilon _0} \\cdot \\frac{2\\lambda}{a} $\n2. 无线大均匀带点版距离a的地方电场为$E= \\frac{\\sigma}{2\\epsilon}$ **匀强电场，和距离无关。**\n3. 平行板电容器，采用上面的叠加，中间部分为$E=\\frac{\\sigma}{\\epsilon _0}$,两板的外面为$E= \\frac{\\sigma}{\\epsilon _0}$\n4. 带电球面表面电势为$\\frac{q}{4\\pi \\epsilon _0 R}$ (和在中心的等大电荷产生的一致)\n5. 静电平衡的球壳对于其内部的电势贡献为$\\frac{1}{4\\pi \\epsilon _0}\\cdot \\frac{q}{r0}$,对外部的贡献为$\\frac{1}{4\\pi \\epsilon _0}\\cdot \\frac{q}{r}$\n6. 多个带电平行板平行排列满足以下规律：\n     - 相对的两个面电荷密度相同、电荷量相反\n     - 最外侧的两个面所带电荷量相同（通过对最外侧的带点板进行叠加原理分析即可）\n     - 每一个平行板内部的电场均为0\n\n**电场的计算-积分方法**\n\n经典题型：\n\n1. 电偶极子\n2. 均匀带点直棒\n3. 均匀带点圆环\n4. 均匀带电圆盘\n\n\n\n**电场的计算-高斯公式**\n\n> **使用公式的时候，一定要说明用的是什么公式！不然老师怎么捞？？？**\n\n高斯公式：电场的源是电荷，E的二型曲面积分等于电荷除以epsilon_0\n\n步骤：\n\n1. 分析对称性\n2. 做高斯面\n3. 使用高斯定理得到答案\n\n\n\n**电场的计算-叠加原理**\n\n例题一：\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250618200246197.png\" alt=\"image-20250618200246197\" style=\"zoom:33%;\" />\n\n例题二：\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250618200939682.png\" alt=\"image-20250618200939682\" style=\"zoom:33%;\" />\n\n\n\n> 注意，电场是有方向的，如果题目要求xx的产生的电场强度，通常需要考虑分析对称性，算出所有位置的电场强度（对称性\n\n例题三：求一无限长，半径为R 直圆柱带电体的电场单位长度带电 $\\lambda$ 的的电场强度。\n\n![image-20250618202225037](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250618202225037.png)\n\n**电势的计算-叠加原理**\n\n1. 电偶极子产生的电势\n\n2. 均匀带电圆环在中垂线上产生的电势\n\n3. 多球壳叠加 直接记结论 考试推导一秒都是对记忆力的不尊重<del>挺好记的</del>\n\n     ![image-20250618204022740](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250618204022740.png)\n\n**电势的计算-积分方法**\n\n1. 均匀带电球面、带点球体产生的电势 使用公式$\\varphi= \\int_x^{+\\infty} Edx$ (假定积分收敛、设无穷远处为0)\n2. 计算无线长直导线的电势（此题有坑，积分不收敛。。不能选择无穷远处为参照）\n3. <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250618214421053.png\" alt=\"image-20250618214421053\" style=\"zoom:25%;\" />叠加原理能做的，我积分也能做\n\n\n\n**静电平衡-叠加原理**\n\n![image-20250618221125925](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250618221125925.png)\n\n加问：如果外表面接地呢？\n\n> **接地只能保证电势为0，电荷的分布需要依靠高斯定理+电势的定义来推导**\n\n![image-20250618222712248](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250618222712248.png)\n\n答案：叠加原理大法！\n\n![image-20250618222750481](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250618222750481.png)\n\n再拓展，如果加上接线呢？\n\n![image-20250618223543731](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250618223543731.png)\n\n难点：如何运用叠加原理![image-20250618224518529](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250618224518529.png)\n\n一般性结论：1. 相对的平面带有等量异号电荷。 2. 最外侧两个面带等量同号电荷。\n\n这个题目没有说明空腔的位置，是否可以直接用对称性+高斯公式呢？\n\n![image-20250619103723777](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250619103723777.png)\n\n>   zj: 这个题不考；其实外面的电场也是均匀分布的，但是内部比较复杂了\n\n### 电介质\n\n**熟知知识点**\n\n极化强度P：定义为单位体积内的电偶极距 (只有电介质内部才有极化强度、真空的极化强度为0)\n$$\n\\int P d S=-Q  \\\\\n\\sigma '= P \\cdot n ~~~\\text{感应电荷密度等于P和外法向量的点积} \\\\\nP=\\epsilon_0 \\chi (E_0+E') ~~~~~\\text{这里E'代表的是激化电荷产生的电场}\\\\\n\\int Dd S=\\Sigma q_i \\\\\n\\chi +1=\\epsilon _r \\\\\nD= \\epsilon _0 E +P= \\epsilon _0E+ \\epsilon _0 \\chi  E=\\epsilon _0 (1+\\chi)E=\\epsilon _0 \\epsilon _rE= \\epsilon E\n$$\n\n\n解题一般思路：\n\n1. 如果知道$q0, \\epsilon _0$则可以求出D，因为D对S的二型曲面积分等于q0，相当于自由电荷是电位移线的源头\n\n2. D和P、E有固定的大小关系：\n     $$\n     P=\\epsilon _0 \\chi E~~~~~~~~~~~~~~~ D=\\epsilon _0 E+P ~~~~~~~~~~~~D= \\epsilon  E ~~~~~~~~~~~~~~~P=\\frac{\\chi}{1+\\chi}D\n     $$\n\n3. $\\epsilon ~ \\epsilon _0 ~ \\chi$三者知一求二\n\n     ![image-20250619153923724](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250619153923724.png)\n\n4. D和自由电荷相关联、P和极化电荷相关联，E是沟通二者的桥梁：$P= \\epsilon _0 E ~~ D=\\epsilon E$\n\n> 吐槽一下垃圾搜狗输入法，并且吐槽一下世界上就没有适合我的用的输入法了吗？\n\n**电介质-例题**\n\n分析有介质存在的电容器\n\n\n\n分析如图题目，注意除了球壳内部带有电介质，其余部分不含电介质（即真空）![image-20250619152617537](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250619152617537.png)\n\n\n\n### 电容器&静电场的能量\n\n**知识点回顾**\n$$\nC=\\frac{Q}{V}=\\frac{\\epsilon S}{d}~~~\\\\ \\text{前者为定义式，后者为决定式，均可以求电容；电容的含义是升高单位电压所需要的电荷量}\n$$\n加入电介质可以提升电容，因为$C=\\frac{\\epsilon S}{d}$，改变了期中$\\epsilon$的值。\n\n电荷系统的电能$E= \\frac{1}{2}\\Sigma q_i V_i$\n\n电容的电量$E= \\int CUdq=\\frac{1}{2}CU^2$ <a href=\"#2\">例题</a>\n\n能量密度$w= \\frac{1}{2}DE=\\frac{1}{2}\\epsilon E^2$  ,对空间进行积分即可，<a href=\"#1\">例题</a>\n\n\n\n**电容-例题**\n\n1. 求半径为R的孤立导体球的电容；\n\n> 解：因为表面电势为$\\frac{1}{4 \\pi \\epsilon}\\cdot \\frac{q}{R}$,而电荷量为q，因此C=$4\\pi \\epsilon$\n\n2. 求平行板电容器的电容，已知电荷密度、S、d；\n\n> 由高斯定理易得$E= \\frac{\\sigma}{\\epsilon}$,所以$U=Ed=\\frac{\\sigma d}{\\epsilon}$,so $C=\\frac{Q}{U}=\\frac{\\sigma S}{\\frac{\\sigma d}{\\epsilon}}=\\frac{\\epsilon S}{d}$\n\n3. 求同心球壳的电容，内外半径分别为R1 R2\n\n> 容易求得两球壳之间的电场强度$E= \\frac{q_0}{4\\pi r^2 \\epsilon}$\n\n4. 个人觉得大概理解这个意思就行，无需关心这里的结果，毕竟这个积分如果从0积到d不收敛，这里取的是a~d-a，可能是考虑了线的粗细，也许是因为![image-20250619160504951](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250619160504951.png)\n\n**电场能量-例题**<a id=\"1\"> </a>\n\n注意，这是一个圆柱\n\n![image-20250619162229237](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250619162229237.png)\n\n> 思考，如果是一个充满介质的球壳呢，假定带电荷量为q\n\n求均匀带电球体的电场能量，半径为R，电荷量为q<a id=\"2\"></a>\n\n>   $$\n>   \\frac{3q^2}{20\\pi R \\epsilon _0} ~~\\text{解析略}\n>   $$\n\n求将平行板空气电容器的间距从d拉开到2d所需做的功，面积为S\n\n>   将两个状态的能量作差即可，答案略\n\n### 电流与磁场\n\n**知识回顾**\n\n洛伦兹力：F=qvB(v和B是叉乘)\n\n>   注意：方向与q的正负有关！使用右手螺旋的时候可以从I的方向往B的方向握\n\n电流的磁效应：电流产生磁场\n\n毕奥—萨伐尔定律：\n$$\ndB = \\frac{\\mu _0}{4\\pi }\\cdot \\frac{Idl*e_r}{r^2} ~~\\text{这里的*代表叉乘，因为我不记得叉乘怎么打了，回头让ai改改吧}\n$$\n\n>   注意，这里的r向量是从电流指向待求B的地方\n\n变式（运动电荷产生的磁场）：\n$$\nB_{q}=\\frac{\\mu}{4\\pi}\\cdot \\frac{qv*r}{r^3} ~~\\text{同样的，这里的*表示的是叉乘，相信读者能够明白}\n$$\n微观物理量和宏观物理量之间的转换：考虑一导线，横截面积为S，每个粒子电荷量为q，速度为v，单位体积内有n个这样的带电 粒子。请问电流为多少？请问单位长度的电流产生的磁场大小是多少？\n\n磁场对通电导线的作用力：\n$$\nF=\\int _L I dl* B~~\\text{*代表叉乘}\n$$\n**熟知结论：**\n\n1.   无限长直导线的磁力线：$B= \\frac{\\mu _0}{4\\pi}\\cdot \\frac{2I}{a}$\n\n     >   和无线长直带电直线产生的电场表达式有些类似；或者干脆这个压根不用记，用<a>磁场的安培环路定理</a>简单推导一下几个\n\n2.   圆电流产生的磁场$B= \\frac{\\mu _0 I}{2}\\cdot \\frac{R^2}{(R^2+a^2)^{\\frac{3}{2}}}$ <a href=\"#3\">Proof</a> \n\n3.   特别的，圆电流圆形处的磁场$B=\\frac{\\mu _0 I}{2R}$，也就是上式取a=0；\n\n4.   无限长螺线管的中心$B= \\mu _0 nI$;  (如果是处于半无限长螺线管的一端，那么结果为$B=\\frac{\\mu _0 nI }{2}$)\n\n5.   任意形状的闭合载流线圈在均匀磁场中受力为0（但是力矩不为0）力矩M=m*B  （ * 为叉乘）,m为磁矩m=IS，有方向）\n\n6.   在均匀磁场中，对任一形状的闭合电 流回路，不论是位置改变还是形状改变，磁力或磁力矩作的功都等于电流与磁通增量的乘积。\n\n7.   ![image-20250621100834451](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250621100834451.png)\n\n>   磁矩不考\n\n**磁场计算-毕奥—萨伐尔定律**\n\n例题一：\n\n![image-20250619174034748](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250619174034748.png)\n\n例题二： <a id=\"3\"> </a>\n\n![image-20250619174451507](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250619174451507.png)\n\n**磁场计算-安培环路定理**\n\n例题三：无限长直圆柱载流导线磁场的分布\n\n>   记得分段\n\n例题四：此题有两个解法，方法一为使用积分方法（只能计算中心轴线的磁场），方法二为使用安培环路定理![image-20250619203409832](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250619203409832.png)\n\n例题四：\n\n![image-20250619204027446](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250619204027446.png)\n\n例题五：\n\n![image-20250619204049667](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250619204049667.png)\n\n例题六：\n\n![image-20250619210024349](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250619210024349.png)\n\n叠加叠加！ \n\n**磁场计算-磁场对载流导线的作用**\n\n![image-20250619213432774](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250619213432774.png)\n\n### 电磁感应定律\n\n**知识回顾**\n\n![image-20250619213807615](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250619213807615.png)\n\n电动势由洛伦兹力产生，即**洛伦兹力充当非静电力，产生感应电动势**\n\n电动势的另外一种计算方法：\n\n![image-20250619214919509](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250619214919509.png)\n\n**动生电动势-积分计算**\n\n![image-20250619215402707](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250619215402707.png)\n\n![image-20250621112614375](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250621112614375.png)\n\n**感生电动势** \n\n![image-20250621110724715](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250621110724715.png)\n\n>   此题比较坑，因为需要考虑到磁场是**非均匀**的，需要先积分得到t时刻的磁通量\n\n\n\n### 数学补充\n\n面微元：$dS= \\rho d \\rho dr$\n\n球微元：$dV= \\rho ^2sin \\phi d \\rho d\\phi d\\theta$\n\nwoc全空间角是啥🖐️😭🖐️\n\n### 概念题集合\n\n>   本次考试会有概念题\n\n**电场的高斯定理**\n\n通过电场中任一闭合曲面的总电通量，等于该曲面内包围的所有电荷电量的代数和除以 ε 而与闭合面外的电荷无关。\n\n**电场的环路定理**\n\n场强环路定理- 静电场中，沿任一闭合路径 场强的环流等于零。\n\n**电势叠加原理**\n\n电势叠加原理：点电荷电场中一点的电势， 等于每一点电荷单独在这一点所产生的电势 的代数和。\n\n**静电平衡**\n\n在电场中，导体的内部和表面都没有电荷定向移动的状态。\n\n>   特点有：\n\n**安培环路定理**\n\n安培环路定理： 磁感应强度沿任一闭合路径L的线 积分（B的环流）等于穿过这个环 路(穿过以该闭合路径为边界的任意 曲面)的各恒定电流强度的代数和的$\\mu _0$倍，电流的方向按右手螺旋。\n\n**法拉第电磁感应定律**\n\n穿过闭合回路所围曲面的磁通量发生变化时， 导体回路中产生的感应电动势正比于磁通量变化率 的负值，即：\n$$\n\\epsilon = -\\frac{d\\varphi}{dt}\n$$\n\n**麦克斯韦方程组**\n\n| 序号 | 名称               | 积分形式公式                                                 | 物理意义                 |\n| ---- | ------------------ | ------------------------------------------------------------ | ------------------------ |\n| 1    | 高斯定律（电场）   | $\\displaystyle \\oint_{\\partial V} \\vec{E} \\cdot d\\vec{A} = \\frac{Q_{\\text{in}}}{\\varepsilon_0}$ | 电荷产生电场             |\n| 2    | 高斯定律（磁场）   | $\\displaystyle \\oint_{\\partial V} \\vec{B} \\cdot d\\vec{A} = 0$ | 磁场无源（无磁单极子）   |\n| 3    | 法拉第电磁感应定律 | $\\displaystyle \\oint_{\\partial S} \\vec{E} \\cdot d\\vec{l} = -\\frac{d}{dt} \\int_S \\vec{B} \\cdot d\\vec{A}$ | 变化的磁场产生电场       |\n| 4    | 安培-麦克斯韦定律  | $\\displaystyle \\oint_{\\partial S} \\vec{B} \\cdot d\\vec{l} = \\mu_0 I_{\\text{in}} + \\mu_0 \\varepsilon_0 \\frac{d}{dt} \\int_S \\vec{E} \\cdot d\\vec{A}$ | 电流和变化的电场产生磁场 |\n\n>   本表格由gpt-4o生成\n\n### 证明题集合\n\n>   **本次考试不考证明题！**\n\n为什么会出现尖端放电？\n\n证明：尖端曲率大、电荷密度大、电场强度大\n\n为什么静电平衡的物体表面的带电量和电荷密度成正比？\n\n证明：使用高斯定理，做一个小封闭曲面即可，内部由于导体静电平衡电场为0。\n\n好的，我来为您简要概括这四条性质的证明：\n\n1. **导体内部电场为零：**\n\n    - **证明思路：** 反证法。若导体内部有电场，自由电荷会移动形成电流，与静电平衡（无电流）的定义矛盾。因此电场必为零。\n\n2. **导体是等势体，表面是等势面：**\n\n    - 证明思路：\n        - **等势体：** 因内部电场为零 (E=−∇V=0)，所以电势在导体内部处处相等。\n        - **等势面：** 若表面有电势差，则存在切向电场分量，会使自由电荷沿表面移动形成电流，与静电平衡矛盾。因此表面电势处处相等。\n\n3. **导体外部场强与表面正交，并正比于表面电荷密度：**\n\n    - 证明思路：\n        - **正交：** 若场强不与表面正交，则存在切向分量，会使表面电荷移动形成电流，与静电平衡矛盾。\n        - **强度关系：** 利用高斯定理。构建一个穿过导体表面的微小圆柱形高斯面，内部电场为零，侧面无通量。外部底面的电通量 (E⋅dS) 等于高斯面内包含的电荷 (σ⋅dS) 除以 ϵ0，由此导出 E=ϵ0σ。\n\n4. **电荷面密度与导体表面曲率的关系：**\n\n    - 证明思路：\n\n         间接证明，通过连接不同半径的两个导体球来理解。\n\n        - **等势条件：** 达到静电平衡时，两个球体的电势相等 (V1=V2)。\n        - **推导关系：** 利用球体电势公式 (V=Q/(4πϵ0R)) 和表面电荷密度定义 (σ=Q/(4πR2)) 进行代换。最终得到 σ1R1=σ2R2，表明电荷密度 σ 与曲率半径 R 成反比，即曲率大的地方（R 小）电荷密度大。\n\n这些证明都基于静电平衡的核心概念：导体内部没有电荷的宏观移动。\n\n>   感谢Gemini\n\n### 模型补充\n\n**球电容器模型**\n\n>   理想的球电容器模型中心是一个带电实心球+一个带电球壳\n\n![image-20250621091502913](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250621091502913.png)\n\n>   试着求一下能量\n\n**圆柱形电容**\n\n![image-20250621093837027](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250621093837027.png)\n\n**平行板电容**\n\n1.   全部充入电介质\n2.   插入金属板\n3.   多种电介质\n\n## 考试提醒\n\n1. 记得看看最后得到的表达式符合题目的要求，是否使用了没有给出的变量？比如$cos \\alpha$ 是自己设的，需要转成L、x、r？\n2. 使用高斯公式、安培环路定理时，需**要明确说明使用了这一公式！**\n3. 注意求的如果是**向量那么需要有方向！！！**\n\n## 写在最后\n\n期末考试分数暂时没有出来，但是期末考得内容十分地简单，大部分人都在1h内交卷了\n\n*2025-06-24*\n\n*<a href=\"https://github.com/yama-lei\">yama</a>*\n\n","categories":["NJUCS","普通物理学（上）"]},{"title":"顺序结构","url":"/posts/2a1069f59e6f/","content":"\n**线性表**\n\nLinerList，每一个元素（除了表头和表尾）有且仅有一个前驱和后继，每一个元素的结构可以不一样（如果不一样，可以使用UNION，联合体）\n\n>   UNION：\n>\n>   ```cpp\n>   typedef union{\n>   \tlong long int val;\n>       char ch;\n>   }data;\n>   //Use data.val to access longlongint, use data.ch to access ch; however, them share the same memory!\n>   ```\n\n动态分配和静态分配：*Stack and Heap*\n\nStack：栈空间在编译的时候分配，栈空间比较小，编译器自动分配空间。\n\nHeap: 堆空间在运行的时候分配，空间较大，但是分配比较慢。\n\n**顺序表**\n\n顺序表可以继承自线性表：\n\n| 访问控制符 | 类内部 | 派生类 | 类外部 |\n| :--------- | :----- | :----- | :----- |\n| public     | ✓      | ✓      | ✓      |\n| protected  | ✓      | ✓      | ✗      |\n| private    | ✓      | ✗      | ✗      |\n\n顺序表类似于数组（或者说数组是顺序表）\n\n**顺序表的操作**\n\n-   顺序表的查找\n-   顺序表的删除\n\n**顺序表应用**\n\n-   集合的交\n\n    ```cpp\n    #LA.len()为n, LB.len()为m\n    i=0\n    while(i<LA.len()){\n       if(LB.search(LA[i])==0){\n    \t\t//B中没有的话，把A中的删除了，搜索的复杂度为m，A的删除的复杂度为n\n           LA.remove(i);\n       }else{\n    \t\ti++;\n           //注意，如果删除了的话，就不需要i++了，因为“自动”地往前移动了\n       }\n    }\n    ```\n\n    最好地时间复杂度为：O(mn)， 最差地复杂度为O(n(m+n))\n\n\n\n-   集合的并\n\n```cpp\n#LA.len()为n, LB.len()为m\ni=0\nwhile(i<LA.len()){\n   if(LB.search(LA[i])==0){\n       \n       LB.append(La[i]);\n   \t\ti+=1;\n   }\n}\n```\n\n\n\n\n\n\n\n**链表**\n\n-   Node使用class实现的时候，需要使用friend class\n\n    >   在class Node中声明Link是其frined class，这样就可以在Link中获取到Node的private member比如data和prev/next的等\n","categories":["NJUCS","数据结构"]},{"title":"队列","url":"/posts/eb6dbcce9e01/","content":"\n队列（queue）是一种具有「先进入队列的元素一定先出队列」性质的表。由于该性质，队列通常也被称为先进先出（first in first out）表，简称 FIFO 表。\n![queue](https://oi-wiki.org/ds/images/queue.svg)\n\n## 顺序队列\n使用数组实现，可以实现非循环队列和循环队列两种：\n**非循环队列**：\n- push_back(data): `arr[rear++] = data`\n- pop_front(): `front++`\n- is_empty(): `return front == rear`\n- is_full(): `return rear == maxsize` (rear指向的是下一次push的位置，当rear == maxsize时，已经溢出)\n## 链表队列\n\n\n## 杨辉三角\n\n\n\n## 优先级队列\n\n## 双端队列\n\n","categories":["NJUCS","数据结构"]},{"url":"/posts/4debfad03760/","categories":["NJUCS","数据结构"]},{"title":"数据结构基本信息","url":"/posts/23c121e852c5/","content":"# 数据结构\n\n授课教师：刘佳\n\n期中期末考试会需要手写代码\n\n![4db07cf4ee85709d085a06148d256c3c](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/4db07cf4ee85709d085a06148d256c3c.jpg)\n\n\n\n\n\n![0887698802709790e68b41538f24ce7f](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/0887698802709790e68b41538f24ce7f.jpg)\n\n\n\n**实验课：**\n\n1.   三道题都需要AC\n2.   抽查过程中能够熟练回答、思路清晰\n3.   编程语言使用C++，不允许使用String类之外的各种库。\n4.   实验课保护好自己的代码\n\n**每月课程竞赛：**\n\n10月、11月、12月中旬，在课堂上完成提交，闭卷、断网，一共4题。\n\n书面作业迟交一天扣20%，实验作业迟交0分\n\n**学术诚信**\n\n\n\n---\n\n## 数据结构概念\n\n数据由数据对象（多个表）构成，数据对象有数据元素（表里面的每一行都是一个数据元素）构成，数据元素由数据项（表里面的一个个格子）构成。\n\n数据（sheet1、sheet2、sheet3）-> 数据对象（sheet）->数据元素（row）-> 数据项（row里面的每一个格子）\n\n**数据结构**由某一个数据元素的集合及该集合中所有数据元素之间的关系组成。 DataStructure= {D,R},D是某一个数据\n\n数据结构涉及到：逻辑结构、物理结构、数据对象的操作\n\n**物理结构和逻辑结构**\n\n数据结构包括物理结构（在计算机上的表示和实现的方法）和逻辑结构（从逻辑上来观察数据）。\n\n约瑟夫环的物理结构是循环数组、循环链表，逻辑结构是环。\n\n（循环数组： t= (t+1)%N)\n\n堆的物理结构是数组，堆是一种特殊的树\n\n**数据结构分类**\n\n线性结构、非线性结构\n\n---\n\nADT：抽象数据类型\n\n\n\n\n\n**算法**\n\n-    输入和输出\n-   确定\n-   有穷\n-   无歧义\n\n程序！=算法，程序可以是无穷的，比如**操作系统** \n\n不是满足这几个条件的都是算法，因为算法是要面向问题，解决某一个问题。比如通常不把print作为\n\n问：HailStone是否是算法？ 冰雹算法暂时无解\n\n**算法的性能指标**\n\n-   正确性\n-   可使用性\n-   健壮性\n-   可读性\n\n**时间复杂度和空间复杂度**\n\n[复杂度简介 - OI Wiki](https://oi-wiki.org/basic/complexity/)","categories":["NJUCS","数据结构"]},{"title":"栈的实现","url":"/posts/80ef1122dfce/","content":"\n## 顺序栈\n\n用顺序表实现栈（比如数组实现）\n\nSeqStack\n\n## 链表栈\n\n用链表实现栈，LinkedStack\n\n## 链表的应用\n\n### 后缀表达式计算\n\n\n\n### 中缀转后缀\n\n考虑一个中缀表达式： A + B*C -D，最终会变成：A B C *+D-\n\n我们发现：\n\n-   操作数的相对顺序不变\n-   在运算顺序的限定下，存在FILO的现象\n\n因此，可以这样操作：\n\n读到operand的时候，直接输出；读到opertor的时候，存入栈中；读到“（”直接skip，读到“）”的时候弹出栈一个operator\n\n((A+B)-(C*D))\n\nA B + C D * - \n\n---\n\n但是，这种解法需要我们先把括号给补齐，那么有没有一种算法，可以自由地处理各种形式的表达式呢？\n\n我们可以选取这样的方法，将中缀表达式直接转换为后缀表达式：\n\n1.  若为‘（’，入栈\n2.  若为‘）’，则依次将栈中的运算符加入后缀表达式，直到出现‘（’，并从栈中删除‘（’\n3.  若为‘+’，‘-’，‘*’，‘/’\n\n-   栈空，入栈\n-   栈顶元素为‘（’,入栈\n-   高于栈顶元素优先级，入栈\n-   否则，依次弹出栈顶运算符，直到一个优先级比它低的运算符或‘（’为止\n\n简单来说：\n\n-   如果是左括号，那么入栈，如果是右括号就一直出栈，直到左括号出栈\n-   如果是操作符：\n    -   如果当前的优先级比栈顶的优先级高，那么入栈\n    -   否则出栈，直到遇见优先级更低的运算符或或者”（“\n-\n\n## 栈和递归\n> 待补充\n\n## 卡特兰数\n> 待补充\n## 顺序栈\n> 待补充\n\n","categories":["NJUCS","数据结构"]},{"title":"数据结构 | 字符串","url":"/posts/e8c5ae902325/","content":"空串：只有一个串结束符“\\0”，不含其他任何字符。  \nstrlen(s) != sizeof(s) / sizeof(char)  \n比如 char* s = \"Hello\", 那么 strlen(s) = 5，但是存储还需要加上一个串结束符。  \n\n> [!NOTE] 注意事项  \n> 1. ```cpp  \n> Node& test1() {  \n>     return Node();  \n> }\n>//有错误，会出现 Dangling Reference，可能会在编译阶段就报错,正确做法应该是return一个对象，而非其引用\n\n\n\n## **KMP算法**\n在讨论问题之前，我们先定义一些符号：\n匹配的字符串P，目标串为T，维护的当前索引为currentIndex\n推荐阅读[[KMP 算法详解-labuladong的文章]]\n**状态机解法**\n把字符匹配看成是状态机的转移，\n\n**书本的解法**\n主要还是要关注书本的写法，因为书本上的解会是考试的重点！\n\n最差时间复杂度是2m次，先有m次不断往前走，然后m次回溯","tags":["DataStructure","数据结构","njucs"],"categories":["NJUCS","数据结构"]},{"title":"期末复习","url":"/posts/ee554c3c6e11/","content":"\n# 期末复习\n\n>   记录于最后一节课，补充于6月16日前后\n\n选择题10*2=20分（基本概念，简单计算）\n\n30 = 组合逻辑+时序逻辑（课堂讲得内容，给题干，设计电路、时序分析等，参考作业）\n\n50 = 一个大题，和指令系统、单周期、流水线CPU等（老师说和往年卷很像）\n\n---\n\n## 冯诺依曼结构\n\n此处知识点，请参考详细笔记[第一章-二进制表示](chapter1二进制表示.md)\n\n五大部件：运算器、存储器、控制器、IO设备\n\n**存储程序**的工作方式（程序和数据都存放在存储设备中，再取出执行）\n\n### 不同层次语言之间的等价转换\n\n`高级语言`-》编译得到`汇编语言`-》通过汇编程序得到`机器语言目标程序`-》指令译码器得到`控制信号`\n\n每条指令都和操作码和地址码组成\n\n高级语言可以编译成不同的汇编代码，汇编程序和机器指令是1对1的（和指令也是一对一的，由`ISA`决定）；\n\n任何语言都是要最终通过执行机器指令来实现功能\n\n## ISA指令集体系结构\n\nInstruction Set Architecture\n\nISA的核心是指令系统，包括指令格式、操作种类，寻址方式，寄存器大小，编址方式，大端小端等等。\n\n\n\n## 数据的编码\n\n数值数据三要素：进制。浮点、定点。编码\n\n**整数:**\n\n-   unsigned：原码\n-   signed：补码\n-   **整数的范围：编码方式和位数有关**\n\n**浮点数**：\n\n-   IEEE754\n-   符号位\n-   尾数：定点原码\n-   指数（阶码）：使用移码，有偏移常数\n-   **范围：和阶码位数和基的大小有关（尾数的影响很小）**\n-   **精度：和尾数的位数和是否规格化有关**\n\n**BCD码**\n\n-   用二进制表示0-9\n\n**格雷码**\n\n-   相邻两个只差一位\n\n## 数据的宽度和存储\n\n什么是数据的地址\n\n大端，小端?\n\n## 数字逻辑基础\n\n**逻辑门**：\n\n使用Cmos晶体管（含n-mos和p-mos，一对nmos和pmos称位cmos）\n\n与非或非需要2对cmos，非门1对cmos，与门和或门是3对。\n\n缓冲器、传输门、三态门\n\n**不会在考试中用布尔代数相关定理进行化简**\n\n真值表和逻辑表达式来描述逻辑变量\n\n（***即真值表到表达式要很熟悉！！***）\n\n**一定会考卡诺图化简**，不考代数法化简\n\n**等效逻辑符号、电路**->使用与非和或非来构建电路，因为效率更高；\n\n使用de-morgan将所有的逻辑表达式都化简为二级**与非**表达式\n\n## 组合逻辑电路\n\n数字逻辑电路有组合逻辑电路和时序逻辑电路\n\n**组合逻辑电路的输出仅仅依赖于当前的输入**\n\n组合逻辑电路可以是多级，两级电路的\n\n---\n\n重点：参考作业题目进行复习！\n\n1.   组合逻辑的设计： 功能分析-真值表-化简-画图-评价\n2.   无关项的处理很重要\n\n---\n\n三态门和高阻态非法值\n\n典型的组合逻辑部件：译码器等等\n\n延迟分析：\n\n-   传输延迟：关键路径上所有元器件的传输延迟\n\n## 时序逻辑电路\n\n不需要学会复现SR、D锁存器等等\n\n但是要熟悉其符号表示和功能，比如在试卷中出现图，需要认识，能够分析电路\n\n**SR锁存器**\n\n-   S为置位端、R是复位端\n\n这里省略其他锁存器，\n\n\n\n时序逻辑电路不仅仅依赖于当前的\n\n\n\nMealy型： ：输出=G(现态+输出)\n\nMoore型：输出=G(现态)\n\n时序电路的设计：功能分析-\n\n**状态的编码考试会给定！**\n\n未用状态分析(挂起、无法自启动) 是否无论从那个状态开始进入之后都可以进入正确的状态循环\n\n**定时分析！！**（clk-to-q，setup，hold最大延迟决定了时钟周期）\n\n典型时序逻辑电路部件（不会要求画图）\n\n### 存储器的结构和基本概念\n\n>   非重点，老师讲得很快\n\n完全不用知道实现原理\n\n寄存器用来存储少量数据，存储器整列存储大量数据\n\nROM、RAM\n\n## 运算部件的设计\n\n**ALU的实现**：\n\n-   加法器是基础（全加器，会计算标志位ZF,CF,OF等等知识点）\n-   并行进位（不需要画图）但是要知道概念\n\n**算数运算**：\n\n-   定点运算\n\n**明确不考：浮点数的运算部分**\n\n不考列竖式计算，考试不会考列竖式计算\n\n**乘法运算：关注思路、参考作业题**\n\nn*n得到2n位，如果只保留n位会溢出，如何判断移出？\n\n**除法运算：关注概念**\n\n扩充为2n%n位\n\n## 指令系统\n\n如何定义每一条指令\n\n指令含有操作码和地址码\n\n如何对操作数进行存储？ 寻址方式\n\n如何周而复始执行指令？ 1. 隐式地跳转到下一条 2. 显式地在指令中给出下一条指令 3. 条件测试后计算出转移地址\n\n寻址方式\n\nCISC和RISC的概念\n\n指令的格式\n\n**RISC-V**   有不同的指令，指令的设计\n\n**具体的指令和RTL功能**： 明确强调需要掌握一些指令的功能和RTL语言\n\n## CPU基础\n\n此处知识点，参考[第八章-CPU 说是]\n\nCPU的设计决定了时钟周期宽度和CPI（Cycle per Instruction)\n\ntime= CPI *T *numOfInstrction\n\nCPU： 数据通路+控制器\n\n1.   数据通路\n     -   包含有 存储元件和操作元件\n     -   存储元件是时序逻辑\n     -   状态元件是组合逻辑\n2.   控制器\n\n**单周期CPU**\n\n**数据通路的图需要很熟悉！！**\n\n**每一条指令对应的控制信号都要知道！！**\n\n**每一个指令的执行过程**\n\n每一个指令都在一个时钟周期内完成\n\n取指令，经过clk-to-Q, PC得到新值，经过access time得到单签指令，之后计算下指令，送入PC输入端，下一个时钟周期到来时，更新PC；同时执行对应指令\n\n**多周期**\n\n不需要数据通路和控制器等原理\n\n**只需要会对比即可！！**\n\n## 单周期和多周期的对比：\n\n-   单周期：T为load指令的花费时间；控制信号不变；\n-   多周期：不同指令的周期数不同，T是所有阶段中最长的为准；控制信号为变，使用有限状态机来描述指令执行的流程，用PLA或者微程序的方式...\n\n## 流水线CPU\n\n流水线数据通路也要很熟悉！！！\n\n指令的吞吐率：1s能够执行的指令数量；\n\n时钟周期为：流水段寄存器的读写时间+Mem阶段的时间；吞吐率=1/ T，T为周期； 每一条指令需要n*T时间进行执行 \n\n每一个流水段的时间都是一个时钟；\n\n每一条指令的执行时间都相同，都为阶段数* 时钟周期\n\n单条指令的时间变长，但是吞吐率变大。\n\n结构冒险\n\n数据冒险\n\n-   软件阻塞、硬件优化\n-   数据转发\n-   寄存器先读后写\n-   编译优化\n-   load-use：转发+nop（或者阻塞）解决\n\n控制冒险\n\n在正确的目标地址取出之前有几个出现的\n\n-   延迟分支。硬件阻塞\n-   分支预测（静态和动态）\n-   异常中断会引发控制冒险\n\n## CPU小结\n\nCPU的功能\n\n控制信号由控制信号生成，数据在数据通路中的流动由控制信号确定\n\n单周期、多周期、流水线CPU的对比\n\n\n\n---\n\n我的问题：\n\n1.   **涉及到画图的内容是 从头开始画吗？(比如画出数据通路)还是电路的某一部分，还是连线？**都会有 \n2.   **会不会涉及到 考察“为了使得datapath支持某一个指令，如何对其进行扩展”？ **会\n3.   会不会考察如何根据写出汇编代码？ 不会\n4.   **会不会考察如何对汇编程序进行 编译优化、分支调度等？** 会 \n\n# 小知识点总结\n\n>   笔者在复习的时候，发现有一些知识点容易遗忘，下面是笔者整理的一些知识点\n\n### 标志信号\n\n在加法器中我们生成了ZF、CF、OF、SF几个标志信号：\n\n1.   如何求？$OF=C_n \\oplus C_{n-1} =X_{n-1}Y_{n-1} \\overline C_{n-1}+ \\overline X_{n-1} \\overline Y_{n-1} C_{n-1}    \\\\ CF= Cin \\oplus Cout= Sub \\oplus Cout$ \n\n2.   Signed和unsigned分别有哪些符号？\n\n     Signed 对应有ZF、OF、SF ；Unsigned 对应有ZF、CF；\n\n3.   如何比较两数大小？\n\n     1.   如果是Singed，则$x<y  \\ \\ \\  iff \\ \\ \\ \\  SF \\oplus OF=1$\n     2.   如果是Unsigned，那么$x< y \\  \\ \\ iff \\ \\ \\ Cout=1$\n     3.   如果询问**大于等于、小于等于呢** 和ZF信号进行组合即可，~~添双筷子的事。~~\n\n### 指令复习\n\n问：jalr和jal的区别是什么？\n\njalr的功能是存储PC+4,并且跳转到imm+R[rs]的位置；而jal是跳转到PC+imm12的位置。\n\n问：beq为什么不能实现远距离调用函数？\n\n因为beq是条件条状指令，不是调用指令，无法返回地址\n\n问：返回指令是否需要指定放回地址？\n\n如果返回地址存放在栈中或特定的寄存器中，则返回指令中可以不需要地址码；如果返回地址存放在某个通用寄存器中，则返回指令中需要给出通用寄存器编号（地址码）\n\n>   比如我们知道使用jal指令可以实现函数调用，jal ra callsite，将PC+4存入ra寄存器（Register Adderess，在RISC架构下是寄存器x1）之后跳转到目的地址；\n>\n>   在目的函数结束之后，有一个返回指令，可以是jalr x0 0(ra)，即，将PC+4存入x0中，PC改为R[ra]+0，也就是之前保存的值；从而实现return。（写入X0是因为 x0的值不会被修改，**x0是硬编码0的！**）\n>\n>   说到X0硬编码为0还有另外一个小知识点：有的时候，我们需要在汇编代码中使用x0作为写入的对象和写出的值（读取这里面的0）； 我们在流水线CPU中知道，如果后一个指令依赖到了前一个指令所需要写入的寄存器，会通过数据转发，直接将前者的结果送入到后面指令的执行过程中（比如直接送到后者的ALU中）；但是如果这个“冲突”的寄存器是x0呢？前者写入x0为了舍弃掉这个输入，因为无意义；后者使用x0是为了用到这里的0，如果数据转发，会导致**后者得到的值变成了不确定的值**。 因此在数据转发的时候，还需要判断一下寄存器是否为0.\n\n---\n\n需要记忆的指令除了`牢九条`，还有`jalr`,`auipc`等\n\n`jalr rd rs1 1mm12`: jump and link resigter, 功能是R[rd]<-- PC+4; PC<-- R[rs]+SEXT(imm12<<1)\n\n`auipc rd imm20 `: add upper imm to PC, R[rd]<-- PC+imm20||000H  (这个表示拼接12个0上去，也可以用<<12,即左移12位)；\n\n>   突然想到一个**题目**：（在作业题和PPT中均涉及到相关问题）\n>\n>   如果想要将一个32位的数字赋值给一个寄存器，需要先将高32位使用`lui`指令存储到`t0`中，再把低12位用addi加进去即可；\n>\n>   但是，如果低12位的首位为1，那么会出现错误（addi指令会对imm12进行SEXT），所以，最好的办法是：\n>   $$\n>   lui \\ \\ t0 \\ \\ offset[31:12]+offset[11] \\\\ \n>   addi \\ \\ t0  \\ \\ offset[11:0]\n>   $$\n>   （大概是这个意思）\n>\n>   在lui中，额外加上一个offset[11]，也就是符号位；左移12位，和低12位的符号位扩展相加，这样就可以刚好**和扩展的符号位相互抵消**（进位了）\n>\n>   对题目的补充： 另外一个实现是，\n>   $$\n>   lui \\ \\ t0 \\ \\ Aupper20 \\\\\n>   xori \\ \\ t0 \\ \\ Alower12\\\\\n>   lw \\ \\ t1\\ \\  0(t0)\n>   $$\n>   即，直接将Apper20低位补0的数和Alower12位取异或 就可以实现将一个32位的数字存储到t1寄存器中。\n\n### 数据通路扩展\n\n下面这个是单周期CPU，支持`牢九条`指令，那么如何进行扩展使得其支持其他的指令呢？\n\n![image-20250616211109101](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250616211109101.png)\n\n如何扩展以下指令？\n\n1.   auipc？在ALUASrc选择PC作为输入即可\n2.   其他的b型指令？ 可能需要func3字段作为多路选择器的选择段，将ZERO信号换成多路选择器，按照不同的b型指令，来输出对应的值；(未经验证)\n3.   jalr指令（jalr rd rs imm12和jal区别在于，新的PC是在rs的基础上加了一个offset，比jal范围更大）？将PC+4送入busW；在下地值逻辑处，添加一个多路选择器，如果是jalr指令的话，Adder的左边就输入busA而非PC；\n\n控制器部分可能需要参考单周期CPIU实验部分内容，给相应的控制信号添加上相应的编码：\n\n比如我想要添加jalr信号，可能控制信号要多加一个`Jalr`,只有当指令为jalr的时候才为1，使Adder的左操作数为busA, 否则左操作数为PC（和正常的一样）\n\n\n\n---\n\n下面是流水线CPU的扩展数据通路\n\n>   没找到相关内容\n\n---\n\n### 性能分析\n\n>   注意：要把握住题目中的关键信息，比如，是否考虑流水段寄存器等等；\n\n**单周期和多周期对比：**\n\n成本比较：单周期下功能部件不能重复使用；而多周期下可重复使用，比单周期省单周期指令执行结果直接保存在PC、Regfile和Memory；而多周期下需加一些临时寄存器保存中间结果，比单周期费\n\n性能比较：单周期CPU的CPI为1，但时钟周期为最长的load指令执行时间多周期CPU的CPI是多少？时钟周期多长？  \n\n假定程序中22%为Load，11%为Store，49%为R-Type，16%为I-Type ，2%为Jump。每个状态需要一个时钟周期，CPI为多少？   \n\n若每种指令所需的时钟周期数为：   Load：4；Store：4；R-Type：4；I-Type：4；Jump：3     \n\n>   JUMP的CPI为3，其余的指令CPI均为4\n\n CPI = 0.22x4+0.11x4+0.49x4+0.16x4+0.02x3 = 3.98   \n\n假设单周期时钟宽度为1，且多周期时钟周期约为单周期的1/5，则多周期的总体时间约：3.98x1/5=0.796 ；而单周期总体时间为：1x1=1这种情况下：多周期比单周期效率高！\n\n>   源自课件\n\n**单周期和流水线对比**\n\n假设在单周期处理器中，各主要功能单元的操作时间为： \n\n存储单元（取指令、存取存储器里的数据）：200ps \n\nALU和加法器：100ps 寄存器、寄存器堆（读/写）：50ps\n\n假设MUX、控制单元、PC、扩展器和传输线路都没有延迟，不考虑任何特殊情况（延迟），则单周期和流水线的实现方式相比，哪个更快？吞吐率呢？\n\n![image-20250617085215143](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250617085215143.png)\n\n>   注： 1. 显然没考虑冒险 2. 吞吐率一般用 \n\n**单周期、多周期、流水线CPU比较**\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250617095210877.png\" alt=\"image-20250617095210877\" style=\"zoom:50%;\" />\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250617095239909.png\" alt=\"image-20250617095239909\" style=\"zoom:50%;\" />\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250617095316897.png\" alt=\"image-20250617095316897\" style=\"zoom:50%;\" />\n\n---\n\n### 冒险\n\n冒险的分类：\n\n-   控制冒险：后续指令在转移目标地址产生之前已经被取出\n-   结构冒险：同一部件被不同指令所使用\n-   数据冒险：后面的指令使用到了前面还没有生成的数据\n\n冒险的解决方案：\n\n-   数据冒险：\n\n    -   硬件阻塞、软件插入无关指令\n    -   同一周期先写后读（对于后面指令读了前面指令写的寄存器问题，只能将原先空三个指令改为空2个指令）\n    -   转发（无法解决load use冒险）\n    -   编译优化（解决一下load-use冒险）\n\n    >   1.   Load-use冒险没法通过转发技术解决，因为load一定要到M段才能把得到结果，而后面的一个指令此时一定处于Exec阶段，需要这个数据；矛盾无法调和。\n    >   2.   **数据冒险处理最佳方案：“转发” + “Load-use阻塞”**\n\n-   控制冒险\n\n    -   阻塞、空指令\n    -   减小延迟损失片\n\n    >    没有任何的优化（在M段才把PC进行更新）C=3\n    >\n    >   如果在Ex段就根据Zero信号和Target来更新PC，那么C=2\n    >\n    >   如果将target的计算和zero计算都前移到ID阶段，那么C=1\n    >\n    >   Reference：[(26 封私信 / 19 条消息) [读书笔记\\]CSAPP：13[B]处理器体系结构：流水线 - 知乎](https://zhuanlan.zhihu.com/p/107760564)\n\n    -   分支预测（静态、动态）\n\n        >   分支预测计算CPI的时候注意，只有B型指令可以预测，且B型指令的CPI为1+C*p，p为预测错误的概率\n\n    -   延迟分支（将前面的指令往后移）\n\n        >   类似之前解决load-use冒险的编译优化，也是调整指令的顺序；\n        >\n        >   把分支指令前面的与分支指令无关的指令调到分支指令后面执行，以填充延迟时间片（也称分支延迟槽Branch Delay slot），不够时用nop操作填充；\n\n### CPU中异常的处理\n\n>   不知道会不会考，但是我记得相关的知识点在几个章节里面都有\n\n外部异常、内部中断；\n\n\n\nCPU对异常的处理流程：\n\n1.   保存断点和程序状态\n2.   识别程序异常状态并且转到异常状态进行执行\n\n---\n\n多周期的异常处理：\n\n>   图中添加了两个状态对应异常处理的状态；新增的寄存器`Cause`,`EPC`分别存储异常原因和断点信息\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250617144747882.png\" alt=\"image-20250617144747882\" style=\"zoom:25%;\" />\n\n流水线的异常处理：\n\n异常和中断会引起`控制冒险`；\n\n处理方法：\n\n-   IF段前先检查是否有外部中断：如果有就执行中断逻辑。\n-   在每一个流水段中添加对应可能出现的内部异常检测逻辑，比如EX段添加OVERFLOW的检测；\n-   2021真题：\"该数据通路能否检测溢出异常？在溢出异常发生时，结果是否会写入目的寄存器\",可以，因为流水段中有Overflow信号。\n\n>   见课本270页；\n\n### The End\n\n>   本课程最后一页ppt\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250617140923745.png\" alt=\"image-20250617140923745\" style=\"zoom:33%;\" />\n\n\n\n# 考前提醒\n\n1.   地址范围不是指令范围\n2.   注意判断需要插入几个nop指令、阻塞几个周期时，需要考虑**是否有寄存器先写后读！否则需要分类讨论**\n\n\n\n","categories":["NJUCS","数字逻辑与计算机组成"]},{"title":"Homework4","url":"/posts/f529779ae614/","content":"\n>   这里的几个波形图由于是使用电脑画图软件做的，有的地方画的不是很整齐，见谅！\n\n## 4：做出输出波形： 图中最后六段是非法输出，最后三段是不确定的输出\n\n![image-20250402123602423](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250402123602423.png)\n\n\n\n## 5：做出输出波形：\n\n![image-20250330171135550](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250330171135550.png)\n\n**注：由于题目没有说明是上升沿触发还是下降沿触发，所以做了两个图，上面是 上升沿触发 下面是下降沿触发什**\n\n![image-20250330171309795](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250330171309795.png)\n\n\n\n\n\n---\n\n## 6：使用带使能端的T触发器，和组合逻辑电路构造D触发器\n\n因为D触发器的状态方程为`Q*=D`,T触发器的次态方程为$Q^*=En \\oplus Q$\n\n从而有$D = En \\oplus Q$\n\n因此有$En= D \\oplus Q$\n\n故，可以做下面的图：\n\n\n\n![image-20250402195635288](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250402195635288.png)\n\n## 9：使用尽可能少的D触发器实现检测110的电路\n\n-   状态编码，化简等步骤：\n\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/a7a2772358e415de580dfb2dd896b72.jpg\" alt=\"a7a2772358e415de580dfb2dd896b72\" style=\"zoom: 67%;\" />\n\n-   最终电路：\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250330223905701.png\" alt=\"image-20250330223905701\" style=\"zoom:25%;\" />\n\n如果D寄存器的个数没有限制，不妨用三位给状态进行编码，分别编码为100,010,001；\n\n类似地，再进行分析：\n\n![image-20250402130733048](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250402130733048.png)\n\n\n\n---\n\n## 11：求Clk的最大频率\n\n根据时序逻辑电路的分析可知：$T_{Clk}>T_{tp}+T_{setup}+T_{and}$\n\n从而得到：最大频率为$1 \\over (T_{tp}+T_{setup}+T_{and})$\n\n## 12：如图：\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/07277011e5a9f02dd0eb51f8686b195.jpg\" alt=\"07277011e5a9f02dd0eb51f8686b195\" style=\"zoom: 25%;\" />\n\n​\t特点： 1. 最后总能进入循环状态（如0000自循环和1101-0110-1011循环）2. 两个只有最后一位状态编码不同的状态，下一个clk进入同一个状态，即次态相同。 \n","categories":["NJUCS","数字逻辑与计算机组成"]},{"title":"数字逻辑与计算机组成实验","url":"/posts/7c206717b1e3/","content":"\n>   [ 电路元件库手册](https://www.baillifard.com/logisim/zh/html/libs/) This is a very good website designed for starters to learn logisim\n\n## 实验一\n\n## 学习logisim\n\n在使用logism之前需要学习相关内容，并配置相关环境。\n\n### 环境搭建\n\n最简单的汉化版本：[SecondCat/Logisim-Translation-Chinese: Based on Logisim 2.7.1, providing Chinese, integrated JRE.](https://github.com/SecondCat/Logisim-Translation-Chinese/releases/tag/v1)\n\n安装后，在导航栏->window->reference中更改。\n\n### 线的颜色\n\n在Logisim中，导线的颜色表示不同的状态和信号值。蓝色导线在布线和仿真过程中有不同的含义。\n\n布线时的蓝色导线\n\n在布线过程中，蓝色导线表示该点的值未知。这通常发生在布线尚未完成或某些连接未正确建立时。布线完成后，蓝色导线应消失，表示所有连接都已正确建立。\n\n仿真时的蓝色导线\n\n在仿真过程中，蓝色导线不应出现。如果在仿真过程中看到蓝色导线，可能意味着某些输入或输出未正确初始化或连接。此时，可以使用戳工具（Poke Tool）点击引脚（Pin）以改变其值，从而消除蓝色导线。\n\n其他颜色导线的含义\n\n除了蓝色导线，Logisim中还有其他颜色的导线，每种颜色表示不同的状态：\n\n-   **灰色导线**：表示未连接到任何东西。\n-   **浅绿色导线**：表示连接两端为高电平1的线[1](https://blog.csdn.net/a_vegetable/article/details/108920553)。\n-   **深绿色导线**：表示连接两端为低电平0的线[1](https://blog.csdn.net/a_vegetable/article/details/108920553)。\n-   **黑色导线**：表示多位线路传输，不管每路电平高低都为黑色[1](https://blog.csdn.net/a_vegetable/article/details/108920553)。\n-   **红色导线**：表示布线错误，产生冲突[1](https://blog.csdn.net/a_vegetable/article/details/108920553)。\n\n### 选择组件\n\n选择组件的时候，可以看看配置是否正确：\n\n![image-20250305084347837](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250305084347837.png)\n\n![image-20250305084410175](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250305084410175.png)\n\n如果不是自己想要的，一定要记得自己改掉！\n\n其中NMOS和PMOS的方向指的是**漏极的朝向**！\n\n>   NMOS的朝向向上，PMOS的朝向向上\n\n![image-20250305090935185](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250305090935185.png)\n\n（仔细看上面PMOS和CMOS的区别）\n\n\n\n### 思考题\n\n如何实现二进制和格雷码之间的转换？\n\n-   二进制转格雷码：\n\n​\t<img src=\"https://pic3.zhimg.com/v2-91a33445bf255814266d3ef3882b5058_1440w.jpg\" alt=\"img\" style=\"zoom: 33%;\" />\n\n-   格雷码转二进制：\n\n    <img src=\"https://pic4.zhimg.com/v2-686a9ef84945949b1f0ab8c17f45badf_1440w.jpg\" alt=\"img\" style=\"zoom: 33%;\" />\n\n\n\n\n\n## 实验二\n\n开始上强度了，需要注意的是，一定要小心**没注意到的线交叉**，建议开启电路仿真，往死里测试；\n\n### 加减法器\n\n~~没看题目，原来要作**加减法**器~~\n\n加法器做好了以后，减法器就是采用补码的方式，用加法得到减法的值\n$$\nA-B=A+(\\overline B+1)\n$$\n注意，那个**加一** 可以直接是由加法器的cin得到；\n\n### 汉明码校验\n\n原理：\n\n>   # Calculating the Hamming Code\n>\n>   The key to the Hamming Code is the use of extra parity bits to allow the identification of a single error. Create the code word as follows:\n>\n>   1.  Mark all bit positions that are powers of two as parity bits. (positions 1, 2, 4, 8, 16, 32, 64, etc.)\n>   2.  All other bit positions are for the data to be encoded. (positions 3, 5, 6, 7, 9, 10, 11, 12, 13, 14, 15, 17, etc.)\n>   3.  Each parity bit calculates the parity for some of the bits in the code word. The position of the parity bit determines the sequence of bits that it alternately checks and skips.\n>       Position 1: check 1 bit, skip 1 bit, check 1 bit, skip 1 bit, etc. (1,3,5,7,9,11,13,15,...)\n>       Position 2: check 2 bits, skip 2 bits, check 2 bits, skip 2 bits, etc. (2,3,6,7,10,11,14,15,...)\n>       Position 4: check 4 bits, skip 4 bits, check 4 bits, skip 4 bits, etc. (4,5,6,7,12,13,14,15,20,21,22,23,...)\n>       Position 8: check 8 bits, skip 8 bits, check 8 bits, skip 8 bits, etc. (8-15,24-31,40-47,...)\n>       Position 16: check 16 bits, skip 16 bits, check 16 bits, skip 16 bits, etc. (16-31,48-63,80-95,...)\n>       Position 32: check 32 bits, skip 32 bits, check 32 bits, skip 32 bits, etc. (32-63,96-127,160-191,...)\n>       etc.\n>   4.  Set a parity bit to 1 if the total number of ones in the positions it checks is odd. Set a parity bit to 0 if the total number of ones in the positions it checks is even.\n>\n>   Here is an example:\n>\n>   A byte of data: 10011010\n>   Create the data word, leaving spaces for the parity bits: _ _ 1 _ 0 0 1 _ 1 0 1 0\n>   Calculate the parity for each parity bit (a ? represents the bit position being set):\n>\n>   -   Position 1 checks bits 1,3,5,7,9,11:\n>\n>       **?** _ **1** _ **0** 0 **1** _ **1** 0 **1** 0. Even parity so set position 1 to a 0: **0** _ **1** _ **0** 0 **1** _ **1** 0 **1** 0\n>\n>   -   Position 2 checks bits 2,3,6,7,10,11:\n>       0 **? 1** _ 0 **0 1** _ 1 **0 1** 0. Odd parity so set position 2 to a 1: 0 **1 1** _ 0 **0 1** _ 1 **0 1** 0\n>\n>   -   Position 4 checks bits 4,5,6,7,12:\n>       0 1 1 **? 0 0 1** _ 1 0 1 **0**. Odd parity so set position 4 to a 1: 0 1 1 **1 0 0 1** _ 1 0 1 **0**\n>\n>   -   Position 8 checks bits 8,9,10,11,12:\n>       0 1 1 1 0 0 1 **? 1 0 1 0**. Even parity so set position 8 to a 0: 0 1 1 1 0 0 1 **0 1 0 1 0**\n>\n>   -   Code word: 011100101010.\n>\n>   \n>\n>   ## Finding and fixing a bad bit\n>\n>   The above example created a code word of 011100101010. Suppose the word that was received was 011100101110 instead. \n>\n>   Then the receiver could calculate which bit was wrong and correct it. The method is to verify each check bit. Write down all the incorrect parity bits. \n>\n>   Doing so, you will discover that parity bits 2 and 8 are incorrect. It is not an accident that 2 + 8 = 10, and that bit position 10 is the location of the bad bit. \n>\n>   In general, check each parity bit, and add the positions that are wrong, this will give you the location of the bad bit.\n>\n>   ## Try one yourself\n>\n>   Test if these code words are correct, assuming they were created using an even parity Hamming Code . If one is incorrect, indicate what the correct code word should have been. Also, indicate what the original data was.\n>\n>   -   010101100011\n>   -   111110001100\n>   -   000010001010\n\n简单来说，就是有一种特殊编码，叫做汉明编码，在原先数据的基础上，加上几位**校验码**，得到一种新的编码；\n\n将收到的汉明码重复计算一次校验码，和原先的校验码进行比较，得到**错误字**，错误字的数值代表了出错的位置。\n\n>   因为校验码的位置都是2的n次幂，所以当故障字中只有一位为1时，说明是校验位出错，否则就是数据位出错。\n\n### 四位奇偶校验电路\n\n![image-20250320221820983](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250320221820983.png)\n\n疯狂取异或就行。\n\n---\n\n## Lab3\n\n**算数左移，逻辑右移，循环左移？**\n\n1.   算数左移、右移： 普通的移位并且补0\n2.   逻辑左移：符号位不变，其他的地方正常移，末尾补零\n3.   逻辑右移：补符号位\n4.   循环左移、右移：都是将移出的位数放回\n\n\n\n\n\n","categories":["NJUCS","数字逻辑与计算机组成"]},{"title":"chapter6 | 运算方法和运算部件","url":"/posts/cb2d44dace68/","content":"\n[TOC]\n\n## 第一讲 | 基本运算部件 \n\n想要实现高级语言程序设计的各种运算，需要将表达式转换成指令。\n\n比如\n\n```cpp\nint a,b=5;\n```\n\n将数据以`补码`的形式存入寄存器中。指令->汇编->机器指令。\n\n软件（高级语言设计），指令（ISA），硬件设计，环环相扣。\n\n---\n\n所有的运算都可以通过ALU+逻辑部件实现。\n\n>   有关门延迟这一部分,建议阅读：[全加器以及行波进位加/减法器时延的计算 - 知乎](https://zhuanlan.zhihu.com/p/590151247)，因为ppt就是一坨。\n\n### 串行(行波)进位加法器:\n\n我们先回顾一下什么是全加器FA：\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250328110827793.png\" alt=\"image-20250328110827793\" style=\"zoom:33%;\" />\n\n在这个全加器里，Cout的延迟是2，F的延迟是3；\n\n>   这里是基于“异或门算3个门延迟的假设”\n\n由多个全加器相连接，前一个全加器的进位作为这一个加法器的cin。\n\n**效率慢**\n\n每一个FA（全加器）需要经过两级门延迟，n位的串行进位加法器就需要2n个门延迟得到Cn进位，2n+1个延迟得到Fn。\n\n>   生成最后一位的Cout在2n时生成，因此最后一位的F在2n+1位生成。\n\n### 并行(先行)进位加法器 CLA\n\n先行进位部件：（CLU)\n\n![image-20250328102746927](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250328102746927.png)\n\n一共需要6级延迟就能得到最终的和。\n\n其中xi和yi在第一个时间段生成gi和pi\n\n接着两个门延迟后，生成了Ci1\n\n最后三个门延迟生成和Fi。\n\n>   因此c4其实在第三个\n\n![image-20250328103202290](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250328103202290.png)\n\n---\n\n### **局部先行进位加法器** \n\n比如：使用4个4位先行进位加法器进行串行，实现一个16位的加法器。\n\n![image-20250328103710902](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250328103710902.png)\n\n（图中的数字代表的是时刻）\n\n**多级先行进位加法器**\n\n组内并行，组间仍然并行。\n\n### n位带标志加法器\n\n我们在加法器中加入一些标志输出，用于指示一些特殊状态（如：溢出）\n\n对于signed类型，有意义的是：\n\n1.   ZF：0标志位\n\n2.   OF：代表是否出现溢出。\n\n     >   判断是否出现Overflow的方法：\n     >\n     >   1.   看X+Y的和，如果$C_n$(符号位的进位)和$C_{n-1}$(即X和Y相加之后得到的符号位)的相同，则没有发生溢出。即$OF= C_n \\oplus C_{n-1}$ \n     >   2.   看X，Y，以及X+Y的符号位。如果$X_{n-1}=Y_{n-1} \\neq C_{n-1}$ 那么$OP=1$. \n\n3.   SF:符号位标志。\n\n对于unsigned类型，有意义的是：\n\n1.   ZF\n2.   CF借位进位标志 ($CF= cin \\oplus cout$)\n\n---\n\n1.   溢出标志$OF=C_n \\oplus C_{n-1}$\n2.   符号标志SF $SF=F_{n-1}$ (即，最高位)\n3.   零标志$ZF=1 \\space \\text{if F=0 else 0}$\n4.   进位借位标志$CF=Cout \\oplus Cin$\n\n### ALU：算数逻辑运算单元\n\n通过一个操作控制端（ALUop），来决定ALU进行什么样的运算\n\n>   通过多路选择器来决定输出哪一个信号。\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250328105550124.png\" alt=\"image-20250328105550124\" style=\"zoom: 33%;\" />\n\n\n\n核心是加减运算，输出结果和标志信息\n\n\n\n## 第二讲 | 定点数运算\n\n### 加减法\n\n$[x+y]_补 =2^n+x+y= 2^n+x+2^n+y= [x]_补+[y]_补 (mod 2n )$\n\n$[x-y]_补=2^n+x-y= 2^n+x+2^n-y= [x]_补+[-y]_补 (mod 2n )$\n\n补码的和就是和的补码，差的补码也是补码的和。\n\n因此补码可以实现加减法的统一.\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250328111952848.png\" alt=\"image-20250328111952848\" style=\"zoom:50%;\" />\n\n上面这个部件十分的神奇！Sub为1的时启动加法，sub还同时作为cin输入，相当于计算$A+\\overline B+1 (mod \\space 2^n)$ ； sub为0的时候，就正常计算就好。\n\n**有符号数singed整数加减法**：\n\n用上述加减法器件进行运算signed整数，例子如下：\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250328123830680.png\" alt=\"image-20250328123830680\" style=\"zoom:50%;\" />\n\n>   OF: overflow; SF: 符号标志位 ZF: 零标志位。\n\n如果用减法来判断两个数的大小，那么在这里我们要看是否有`OF=SF`，如果满足的话，说明前一个操作数大于后一个操作数。即$less= OF \\cdot SF$ (如果OF=SF，那么前一个数大于后一个数)\n\n**无符号数unsigned整数的加减法**：\n\n用这个部件对补码进行加减法显然是可以实现的：都是将输入的两个机器码输入，如果加法，则直接相加并取模；如果是减法，那么将第二个操作数取反再相加取模。\n\n这个部件实际上也可以实现无符号数的加减法。\n\n对于加法很好理解，无非是一位一位相加，求进位。\n\n如果比较两个数的大小，那么就看溢出位，$less=cin \\oplus cout$，即，如果有借位就说明前者比后者小。\n\n\n\n### 乘法运算\n\n\n\n#### 无符号数 unsigned乘法\n\n**Warning:在学习的过程中，我不慎将无符号位，原码补码两个概念搞混；因此笔记中可能含有错误的内容**\n\n无符号数：没有符号位。无符号数乘法默认是1位\n\n有符号： 原码或者补码表示，都带有符号！！！前者有1位或者2位，后者的算法称为布斯（Booth)算法！\n\n---\n\n\n\n无符号数乘法可以由加法和移位实现：\n$$\nX×Y= \\sum_{i=1}^{i=n}(X × yi×2^{-i})\n$$\n利用递归的方法，可以得到如下的算法：\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250331102900167.png\" alt=\"image-20250331102900167\" style=\"zoom:50%;\" />\n\n以32位原码的乘法为例，两个32位的原码相乘，至少需要64位存储积。\n\n>   注意在高级语言程序中，有溢出的可能，比如只要32位，那么只会从64位中取低32位。\n\n在实际的硬件实现中：1. C存储循环次数 2. 一个寄存器存储一个乘数 3. 一个存储器同时存储一个乘数和积。\n\n![image-20250331104724755](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250331104724755.png)\n\n即每一次都将高32位和原先的X相加，如果Y的最后一位是0，那么直接将高32位返回，如果是1，那么相加。循环32次。\n\n---\n\n#### 浮点数的乘法：\n\n1.   数值部分是原码，因此直接相乘。\n2.   阶码是移码，直接相加。\n3.   符号位取异或。\n\n#### 原码两位乘法\n\n前面介绍的都是一位乘法，即一位一位的运算，如果运算32位就需要32次循环，实际上，可以一次运算两位。\n\n类似的，我们一次性从乘数Y中取两位，如果Y=00，那么无需相加，直接右移；如果为01，则加上X并右移两位；10则加上2个X并右移；11的话按理是加上3个X并右移。但是实际上采取的是先减去一个X右移两位，**并通知下一位多加一个X**。\n\n![image-20250331110003790](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250331110003790.png)\n\n因此，考虑到前一位的标志，一共分成了8种情况。\n\n---\n\n原码2位乘法举例：\n\n（由于移位2位需要用到减法，因此采取补码实现加法）\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250331111755147.png\" alt=\"image-20250331111755147\" style=\"zoom: 80%;\" />\n\n采取模8补码，算术移位。\n\n（此处看ppt）\n\n---\n\n#### 补码的乘法运算\n\n**布斯算法 | Booth Algorithm**：\n\n推导过程（过个眼瘾就行）:\n$$\n\\space y= -y_{n-1}*2^{n-1}+\\sum_{i=0}^{i=n-2}y_i*2^i\n$$\nIf we define that $y_{-1}=0$, then we can get that \n$$\ny=\\sum_{i=0}^{i=1}(y_{i-1}-y_i)*2^i\n$$\n可以得到部分积公式：\n$$\nP_n=2^{-1}(P_{n-1}+(y_{i-1}-y_i)x)\n$$\n根据当前的位数和前一次的位数可以分成下面这四种可能：\n\n![image-20250331113749466](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250331113749466.png)\n\n一个运算的例子：\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250331114008479.png\" alt=\"image-20250331114008479\" style=\"zoom:50%;\" />\n\n<center>**注意：布斯算法右移的时候是补符号位！！！！**</center>\n\n-   那么什么时候会出现溢出呢？\n    -   **如果高四位都是符号位，那么结果不会溢出**\n\n-   如果[-x]的补码溢出了呢？\n    1.   方法1，增加符号位，（比如-8四位补码无法表示，但是我们可以加一位符号位）\n    2.   方法2，移位实现（因为我不清楚，所以略去）\n\n#### 补码两位乘法\n\n类似原码两位乘法，需要根据当前的位数去查表，确定在右移之前需要加多少X，or 多少个X的补码（自行看ppt）\n\n#### 补充：快速乘法\n\n1.   流水快速乘法器\n\n     -   n位运算需要n个ALU\n\n     -   完全采取组合逻辑电路，不需要clk的控制，速度快\n\n2.   CRA整列乘法器\n\n---\n\n#### 溢出判断\n\n两个n位的机器数通过无符号和有符号乘法算出的低n位其实是相同的，WHY？\n\n---\n\n-   硬件: 在硬件中\n\n如果结果只保留n位：\n\n-   无符号：高n位全为0。\n-   有符号：**高n位全是低n位的符号位**（比如1111 **1**001,or 0000 **0**011，容易验证均没有溢出）。\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250411101811389.png\" alt=\"image-20250411101811389\" style=\"zoom:50%;\" />\n\n**应该要能判断这个表中的溢出与否情况**！\n\n#### 乘法与指令\n\n机器指令包括：无符号成绩指令和有符号乘积指令\n\n-   在 RISC-V 中：\n\n    -   `mul` 指令执行普通的乘法，返回低 32 位乘积。\n\n    -   `mulh` 和 `mulhu` 分别处理带符号整数乘法和无符号整数乘法，返回高 32 位乘积。\n\n        这里的乘法运算其实只有一次，而不是两次，只是在ISA中用两条指令来分别取出高32位和低32位。\n\n两个n位的数相乘在硬件中会保留2n位的乘积，但是只会取n位。如果是无符号乘法，那么看高n位，不全位0，那么溢出；如果有符号位，那么看高n位是否全为低n位的符号位，如果不是，那么溢出。\n\n**溢出指的都是只保留低n位的情况**\n\n如何判断两个int类型的乘积是否溢出？\n\n```cpp\n1.   bool overflow(int a, int b){return (a*b)/b!=a;}\n\n2.   bool overflow(int a, int b){\n\t\tlong long mul=(long long)a*b;\n    \treturn mul!=(int)mul\n     }\n```\n\n\n\n---\n\n**The End: **\n\n注意：只有原码的一位乘法才是逻辑又移，其他的都是算术右移。因为原码的两位补码需要用到补码来表示负数。而补码乘法显然使用算术移码。\n\n## 除法运算\n\n### 定点数的除法运算\n\n**在除之前**：\n\n-   被除数=0，除数！=0，或者在定点除法中abs(dividend)<abs(divisor),结果均为0\n\n-   如果除数为0，那么除0错误\n\n    >   如果是浮点数，可以用阶码全为1，尾数全为0来表示infinite\n\n-   如果dividend and divisor both are 0, then the result is \"NAN\".\n\n    >   The NAN 在浮点数中用阶码全为1，尾数不全为0来表示\n\n**定点数除法的步骤：**\n\n1.   将被除数补位到2n位。\n\n     >   如果是定点小数，那么补低n位，；如果是定点整数，那么补高n位。\n\n2.   将这个2n位数和被除数相除。\n\n3.   进行恢复余数除法或者不恢复余数除法\n\n硬件实现：\n\n![image-20250407111551314](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250407111551314.png)\n\n-   除数寄存器Y：存放除数。\n\n-   余数寄存器R：初始时高位部分为高32位被除数；结束时是余数。\n-   余数/商寄存器Q：初始时为低32位被除数；结束时是32位商。\n-   循环次数计数器Cn：存放循环次数。初值是32（不包括第一次试商），每循环（移位）一次，Cn减1，当Cn=0时，除法运算结束。\n-   ALU：除法核心部件。在控制逻辑控制下，对于寄存器R和Y的内容进行“加/减”运算，在“写使能”控制下运算结果被送回寄存器R。 \n\n#### **一个例子（恢复余数法）：**\n\n因为除法需要用到减法，因此我们用补码来表示无符号数。\n\n>   X-Y=X+[Y]补; 别把补码和反码弄混了！\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250407113000347.png\" alt=\"image-20250407113000347\" style=\"zoom:33%;\" />\n\n-   如果中间余数够减： 整体左移并且上1\n-   如果中间余数不够减：先恢复余数，在左移，补0\n\n**最后得到的余数部分要右移一位，将绿色的0给移出。**\n\n#### **不恢复余数法（交替加减法）**\n\n根据恢复余数法(设D为除数，Ri=2Ri-1-D为第i次中间余数)，有：\n\nl若Ri<0,则商上“0”，做加法恢复余数，即：\n\n Ri+1=2(Ri+D)-D=2Ri + D     (“负，左移，上商0，加”)\n\nl若Ri>=0,则商上“1”，不需恢复余数，即：\n\n Ri+1=2Ri - D     (“正，左移，上商1，减”)\n\n省去了恢复余数的过程\n\n 注意：最后一次上商为“0”的话，需要“纠余”处理，即把试商时被减掉的除数加回去，恢复真正的余数。\n\n 不恢复余数法也称为加减交替法\n\n---\n\n### **带符号除法**\n\n#### 原码除法\n\n$Sign= Sign1 \\oplus Sign2$\n\n数字部分直接当成无符号数来除即可。\n\n#### 补码除法\n\n补码除法的被除数在进行位数扩展的时候，进行的是**符号扩展**\n\n补码的除法将符号位和数值位一起进行处理，采用的是不恢复余数法。\n\n补码最终在寄存器中得到的一位都不能丢，而在无符号的除法运算中，因为采用了补码来实现减法，因而最后得到的也是补码，需要舍弃掉符号位，剩下的是得到的商；\n\n---\n\n### 其他内容\n\n除以2^k的快速算法：\n\n-   无符号整数：逻辑右移，高位补0，低位丢弃。\n\n-   带符号整数：算术右移，高位补符，低位丢弃。\n\n---\n\n综合考虑了各类定点运算之后，发现所有的运算都可以通过`加`和`移位`来实现；\n\n可以通过ALU（or 加法器）结合寄存器，选择器等部件实现一个`运算数据通路`；\n\n\n\n## 浮点数运算\n\n>   **浮点数的运算老师说不考，但是考研408会考**\n\n先回顾之前的浮点数相关知识：\n\n-   非规格化数：阶码为0 （代表是-127），尾数不为0，没有前导1；\n-   0，阶码和尾数都为0；\n-   无穷：阶码全为1，尾数全为0；\n-   NAN：阶码全为1，尾数不全为0；\n-   其余的就都是规格化数，阶码的范围是1-254，尾数默认前导1；\n\n浮点数规格化数的范围（以SP的正半部分为例）：\n$$\n2^{-126}-2^{127}*(2-2^{-23})\n$$\n运算的方法：\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250411104022649.png\" alt=\"image-20250411104022649\" style=\"zoom:50%;\" />\n\n可能出现下面的情况：\n\n上述运算结果可能出现以下几种情况：\n\n-   阶码上溢：一个正指数超过了最大允许值 =〉+∞/-∞/溢出\n\n-   阶码下溢：一个负指数比最小允许值还小 =〉+0/-0\n\n-   尾数溢出：最高有效位有进位 =〉右规\n\n-   非规格化尾数：数值部分高位为0 =〉左规\n\n-   右规或对阶时，右段有效位丢失 =〉尾数舍入\n\n---\n\nIEEE754规定的几种异常情况：\n\n① 无效运算（无意义）\n\n-   运算时有一个数是非有限数，如：加 / 减∞、0 x ∞、 ∞/∞等\n\n-   结果无效，如：源操作数是NaN、0/0、x REM 0、 ∞ REM y 等\n\n② 除以0（即：无穷大）\n\n③ 数太大（阶码上溢）: 对于SP，阶码 E >1111 1110 (指数大于127)\n\n④ 数太小（阶码下溢）: 对于SP，阶码 E < 0000 0001(指数小于-126-23)\n\n⑤ 结果不精确（舍入时引起），例如1/3，1/10等不能精确表示成浮点数\n\n---\n\n### 浮点数加减运算\n\n1.   对阶\n\n     采取的都是小阶向大阶表示（都是右移），防止尾数溢出（溢出的几位可以用附加位进行暂时存储）。\n\n2.   尾数相加减\n\n3.   规格化\n\n     将尾数进行规格化，左移或右移，使得小数点前有一个隐含的前导1。\n\n4.   如果尾数比规定的数长需要舍入；（舍入有可能导致进位，最终需要右规）\n\n5.   如果尾数全为0（包含隐藏位在内的）那么应该要把阶码也赋值为0，因为这才是浮点数表示0的方法。\n\n附加位的作用：以保护对阶时右移的位或运算的中间结果。提高运算精度。\n\n（比如舍入的时候的精度）\n\n---\n\n![](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250411111702873.png)\n\n---\n\n### 浮点数的乘法\n\n浮点数乘 / 除法步骤\n\n（Xm、Ym分别是X和Y尾数原码， Xe和Ye 分别是X和Y阶移码 ）\n\n(1)求阶： Xe + Ye + 127 \n\n(2)尾数相乘除： Xm */Ym  （**两个形为1.xxx的数相乘/除**）注意有个**隐藏的1 **！！\n\n>   尾数相乘的时候最多要右规一次，尾数相除的时候左规的次数不定\n\n(3) 两数符号相同，结果为正；两数符号相异，结果为负；\n\n(4) 当尾数高位为0，需左规；当尾数最高位有进位，需右规。\n\n(5) 如果尾数比规定的长，则需考虑舍入。\n\n(6)若尾数是0，则需要将阶码也置0。\n\n(7) 阶码溢出判断\n\n\n\n---\n\n## 写在最后\n\n>   写于期末复习\n\n本章不是很重点的内容；\n\n学会如何判断溢出即可","categories":["NJUCS","数字逻辑与计算机组成"]},{"title":"第二章 | 数字逻辑基础","url":"/posts/a712c2e9f9c0/","content":"\n对应了实验123.\n\n##  逻辑门与数字抽象\n\n### 逻辑门：logic gate\n\n直接上图：\n\n<div style=\"display:flex;width: 33.3%\">\n<img src=\"./数字逻辑基础.assets/image-20250228105251394.png\"/>\n<img src=\"./数字逻辑基础.assets/image-20250228105333434.png\"/>\n<img src=\"./数字逻辑基础.assets/image-20250228105343896.png\"/>\n</div>\n上面的三种logic gate是基本逻辑门。\n\n![image-20250228110021775](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250228110021775.png)\n\n但是要记住这几种logic gate对应的运算符号。\n\n-   $A \\cdot B$, $\\overline{A}$, A+B\n-   $A \\oplus B$\n-   $A \\odot B$ \n\n### 数字抽象\n\n**数字抽象（逻辑采样）**：将某个物理量的实际值集映射为两个子集，对应于两个状态或两个逻辑值0和1。\n\n在数字系统中，将一定范围内的电压映射到两个状态：高态（high）和低态（low），并用0和1来表示。\n\n**正逻辑**将高电压映射为1，低电压映射为0；负逻辑则相反。\n\nL or H stands for 'Low' or 'High'\n\n-   VIHmin：确保能被识别为高态的最小输入电压值。\n-   VILmax：确保能被识别为低态的最大输入电压值。\n-   VOHmin：输出为高态时的最小输出电压值。\n\n>   VIHmin小于VOHmin,即**输入识别的电压范围比较大，输出电压的范围比较窄**\n\n-   VOLmax：输出为低态时的最大输出电压值。\n\n>   VILmax大于VOLmax，理由同上。\n\n>   ![image-20250228112500139](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250228112500139.png)\n>\n>   ​\t\t\t\t\t\t\t（图中表示输入输出的电压范围）\n\n### CMOS晶体管\n\nMOS是三极晶体管：\n\n-   gate栅极，通常是in的部分\n-   source源极\n-   drain漏极\n\n#### NMOS和PMOS\n\nMOS常见的是下面这两种：\n<img src=\"./数字逻辑基础.assets/image-20250228095605847.png\" width=50%/>\n\n左边是NMOS,上面是漏极，下面是源极；右边的PMOS相反。\n\n更重要的区别在与：\n\n-   对于NMOS，当Vgs<=0的时候，电阻大不导通；当Vgs>=0的时候导通\n-   PMOS是，当Vgs>=0的时候不导通，当Vgs<0的时候导通。\n\n**即栅极和源极在上面的那个电平大的时候导通**\n\n#### CMOS晶体管\n\n利用NMOS和PMOS构成CMOS,下面是非门(左），与非门（右）的实现方式：\n\n<div style=\"display:flex\">\n<img src=\"./数字逻辑基础.assets/image-20250228113834753.png\" width=50% />\n<img src=\"./数字逻辑基础.assets/image-20250228114607715.png\" width=50%/>\n</div>\n**K输入**：输入k个电压，通常小于4；因为会导致噪音增大。\n\n**级联**：将多个输入端较少的门电路级联，实现多数入。\n\n**缓冲器**：取两次非，将信号更加精准。\n\n>   由两个非门**级联**得到\n>\n\n#### 设计cmos电路\n\n这篇文章值得一看[COMS门电路的设计及其优化--以异或门为例 - The Pisces - 博客园](https://www.cnblogs.com/Atsea/p/3885879.html)\n\n这篇文章是和卡诺图有关讲得很好！  [逻辑函数的卡诺图化简 || 卡诺图 || 重点 || 数电 - 知乎](https://zhuanlan.zhihu.com/p/158535749)\n\n由真值表得到CMOS电路：\n\n1. 卡诺图化简\n2. 画图\n\n非门需要一对CMOS，与非门需要两对CMOS，与门需要三队CMOS。\n\n#### CMOS的电路特性\n\n-   转换时间：输入信号（或输出信号）从一种状态变成另外一种状态的所需的时间。\n-   传播延时：输入信号变化到输出信号变化的时间。\n\n![image-20250303102631853](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250303102631853.png)\n\n<center>(传播延时,tpHL是输出信号从high到low的时间，tpLH是输出信号从low到high需要的时间)</center>\n\n## 布尔代数\n\n### 一些定理\n\n**对偶定理**\n\n-   对偶式：将与和或互换，得到的新式子就是对偶式；（注意：运算的顺序不能改变，意味着，很多地方要加上括号）\n-   如果两个逻辑表达式相等，那么逻辑表达式的对偶式也相等。\n\n**乘积项**\n\n-   单独的几个变量相乘；\n\n**求和项**\n\n-   单独几个变量相加；\n\n**标准乘积项 | 最小项**\n\n-   出现所有变量的乘积项（出现一次）\n\n**标准求和项 | 最大项**\n\n-   出现所有变量的求和项（出现一次）\n\n>   n参数的逻辑函数，最大项/最小项数目为$2^n$个；\n>\n>   **所有最小项的和为恒为1，所有极大项的积恒为0**；\n\n**几个需要记忆的式子**\n\n-   $(X+Y) \\cdot (X+Z)=X+Y\\cdot Z$\n-   $(X+X \\cdot Y)=X$ \n-   $X \\cdot (X+Y)=X$\n-   $X \\cdot Y+\\overline X \\cdot Z+Y \\cdot Z= X \\cdot Y + \\overline X \\cdot Z$//有一项是多余的\n-   $(X+Y)\\cdot (\\overline X +Z)\\cdot (Y+Z)=(X+Y)\\cdot (\\overline X +Z)$\n\n### **异或 同或** 运算\n\n-   异或的性质：\n\n    1.   $A \\oplus A= 0$\n\n    2.   $(A \\oplus B) \\oplus C=A \\oplus (B \\oplus C)$\n\n    3.   $\\overline{A \\oplus B}=A \\oplus \\overline B=\\overline A \\oplus B=A \\odot B$\n\n- 同或的性质 \n\n    1.   $A \\odot A=1$\n    2.   同样满足交换律\n    3.   取反的性质和异或式一样的\n\n-  神奇的性质 \n    对于一系列逻辑变量 $A_n, n \\in N^+$，定义两种运算:\n\n\t-   \"连续同或运算\": (第一个省略号代表多个左半括号)\n\n    $$M_k = (\\ldots (A_1 \\odot A_2) \\odot A_3) \\odot \\ldots) \\odot A_k, k \\in N^+$$\n\n    -   \"连续异或运算\": (第一个省略号代表多个左半括号)\n\n    $$N_k = (\\ldots (A_1 \\oplus A_2) \\oplus A_3) \\oplus \\ldots) \\oplus A_k, k \\in N^+$$\n\n    **根据这两种运算得到的布尔变量 $M_k, N_k$ 根据 $k$ 的不同有以下关系:**\n\n    1. $M_k = N_k$, when $k$ is odd;\n    2. $M_k = \\overline{N_k}$, when $k$ is even.\n    \n    举个例子, 当 $k = 3$:\n\n    - $$M_3 = (A_1 \\odot A_2) \\odot A_3, \\quad N_3 = (A_1 \\oplus A_2) \\oplus A_3$$\n\n    - 结论为: $M_3 = N_3$\n\n**De Morgan's law和香农定理**\n\n![image-20250303105327608](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250303105327608.png)\n\n## 逻辑关系描述\n\n#### 逻辑函数\n\n**每一个输入组合都有一个确定的输出值**\n\n**每个逻辑函数都有一组确定的输出分别对应各种输入组合)**\n\n#### 真值表：truth table\n\n-   输入组合按照数值大小排序\n-   每一个真值表都对应了一个一个逻辑函数\n\n#### 波形图\n\n用来描述逻辑函数的输出对于输入变量的变化的响应。（忽略时间延迟）\n\n![image-20250303112030796](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250303112030796.png)\n\n#### 逻辑函数的标准表示形式\n\n-   乘积项\n-   求和项\n-   与或表达式：先与后或；sum of product\n-   或与表达式：先或后与：product of sum\n-   标准乘积项（极小项），只有一种情况下能够取1\n-   标准求和项（极大项） ，只有一个情况下能够取0；\n\n#### 根据真值表得到逻辑函数的表示\n\n将最小项取和或者将最大项取积；\n\n![image-20250303113829446](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250303113829446.png)\n\n#### 标准表示的好处：设计电路\n\n![image-20250303112546676](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250303112546676.png)\n\n电路只有**两级**。\n\n---\n\n**标准表示不是最简**，如何将标准的表达式化成最简呢?\n\n## 逻辑函数的化简和变化\n\n#### 1. 代数化简\n\n如果表达式的层级超过了两级，那么需要先转换成两级；\n\n如果有哦整体取反运算，则需要先转换为单变量取反运算；\n\n**技巧性较强**\n\n-   如果化简的对象比较复杂，可以先化简其对偶式，再将其取一次对偶即可；\n-   与或表达式取反得到或与表达式，两次取反可以得到**与非-与非表达式**或**或非-或非表达式**\n\n\n\n#### 2. 卡诺图化简 \n\n推荐阅读：[逻辑函数的卡诺图化简 || 卡诺图 || 重点 || 数电 - 知乎](https://zhuanlan.zhihu.com/p/158535749)\n\n将真值表图形化表示出来，相邻的几项是可以化简的。\n\n>   原理：$X \\cdot Y +X \\cdot \\overline Y=X$\n\n1.   卡诺图上找出所有的最小项（或者说真值表为1对应的所有赋值情况）\n2.   在卡诺图上将其按照相邻分块\n3.   取出所有没有相互覆盖的分块\n\n几种特殊情况：\n\n<div style=\"display: grid;grid-template-columns:repeat(2,50%)\">\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/20250307103204.png\"/>\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/20250307103322.png\"/>\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/20250307103322.png\"/>\n</div>\n\n>   1.   注意“相邻”的含义，指的是符合格雷码的规则，不是物理含义上的相邻\n>   2.   遵守“最大圈”和“完全覆盖的原则”；比如，为了覆盖011这个位置其实可以选择$\\overline X Y Z$，或者$YZ$,但是圈要最大，因此要选择YZ\n\n**蕴含项**\n\n-   最小项是蕴含项\n-   由蕴含项通过或表达式得到的乘积项也是蕴含项\n\n**质蕴含项**\n\n-   质蕴含项不能被其他的蕴含项 包含\n\n**实质蕴含项**\n\n-   **包含有至少一个最小项不为其他的蕴含项所包括**  | 人话：卡诺图里面，这个蕴含项有一个点位只有他包括进去了\n\n**最小覆盖**\n\n-   一组**蕴含项数量最少**的情况\n-   一定是要覆盖所有的点位\n\n>   实质蕴含项的定义就说明，它有别人所不能取代的原因：每一个最小覆盖一定**包含有所有的实质蕴含项**\n\n卡诺图的化简我觉得讲得最好的还是：[逻辑函数的卡诺图化简 || 卡诺图 || 重点 || 数电 - 知乎](https://zhuanlan.zhihu.com/p/158535749)\n\n#### 逻辑函数转换 \n\n可以通过对逻辑表达式进行**化简**，将逻辑表达式的形式改成更加适合电路设计；\n\n比如全部换成**与非和或非表达式**，实现的效果更快；\n\n比如对于下面这个逻辑函数\n$$\nF(X,Y,Z)=X \\cdot Y +X\\cdot Z +Y \\cdot Z\n$$\n可以两次使用德摩根率：\n$$\n\\overline {\\overline{ X \\cdot Y +X\\cdot Z +Y \\cdot Z}}=\\overline {\\overline{X \\cdot Y}\\cdot \\overline{X \\cdot Z} \\cdot \\overline{Y \\cdot Z}}\n$$\n\n\n\n---\n\n![image-20250307111246272](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250307111246272.png)\n\n<center><strong>图来自ppt</strong>\n</center>\n练习：注意**圈最大、圈最少**的原则\n\n![image-20250616111644289](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250616111644289.png)\n","categories":["NJUCS","数字逻辑与计算机组成"]},{"url":"/posts/a8221835b737/","content":"1.  **二进制编码**\n\n**作业：习题3、4、5、6、8、9、17**\n\n3.  实现下列各数的转换。\n\n&nbsp;\n\n1.  (25.8125)₁₀= (?)₂= (?) ₈= (?) ₁₆\n\n2.  (101101.011)₂ = (?)₁₀= (?) ₈= (?) ₁₆= (?) ₈₄₂₁\n\n3.  (0101 1001 0110.0011)₈₄₂₁ = (?)₁₀= (?) ₂= (?) ₁₆\n\n4.  (4E.C)₁₆ = (?)₁₀= (?) ₂\n\n**【分析解答】**\n\n1.  (25.8125) ₁₀= (1 1001.1101) ₂ = (31.64) ₈ = (19.D) ₁₆\n\n2.  (101101.011)₂ = (45.375)₁₀ = (55.3) ₈ = (2D.6) ₁₆ = (0100 0101.0011 0111 0101) ₈₄₂₁\n\n3.  (0101 1001 0110.0011)₈₄₂₁ = (596.3)₁₀ = (1001010100.010011…) ₂ = (254.4…) ₁₆\n\n4.  (4E.C)₁₆ = (78.75)₁₀ = (100 1110.11) ₂\n\n&nbsp;\n\n4.  假定机器数为8位（1位符号，7位数值），写出下列各二进制数的原码表示。\n\n+0.1001，–0.1001，+1.0，–1.0，+0.010100，–0.010100，+0，–0\n\n**【分析解答】**\n\n上述各二进制数的原码和补码（小数模为2，但一般表示整数）表示见下表。\n\n小数的原码和补码表示\n\n| 数值      | 原码      | 补码      |\n|-----------|-----------|-----------|\n| +0.1001   | 0.1001000 | 0.1001000 |\n| –0.1001   | 1.1001000 | 1.0111000 |\n| +1.0      | 溢出      | 溢出      |\n| –1.0      | 溢出      | 1.0000000 |\n| +0.010100 | 0.0101000 | 0.0101000 |\n| –0.010100 | 1.0101000 | 1.1011000 |\n| +0        | 0.0000000 | 0.0000000 |\n| –0        | 1.0000000 | 0.0000000 |\n\n5.  假定机器数为8位（1位符号，7位数值），写出下列各二进制数的补码和移码表示。\n\n+1001，–1001，+1，–1，+10100，–10100，+0，–0\n\n**【分析解答】**\n\n上述各二进制数的补码和移码表示见下表。\n\n整数的补码和移码表示\n\n| 数值   | 补码      | 移码（偏置常数=1 0000000） |\n|--------|-----------|----------------------------|\n| +1001  | 0 0001001 | 1 0001001                  |\n| –1001  | 1 1110111 | 0 1110111                  |\n| +1     | 0 0000001 | 1 0000001                  |\n| –1     | 1 1111111 | 0 1111111                  |\n| +10100 | 0 0010100 | 1 0010100                  |\n| –10100 | 1 1101100 | 0 1101100                  |\n| +0     | 0 0000000 | 1 0000000                  |\n| –0     | 0 0000000 | 1 0000000                  |\n\n6\\. 已知 \\[*x*\\]_(补)，求*x*\n\n（1）\\[*x*\\]_(补)=1110 0111 （2）\\[*x*\\]_(补)=1000 0000 （3）\\[*x*\\]_(补)=0101 0010 （4）\\[*x*\\]_(补)=1101 0011\n\n**【分析解答】**\n\n1.  x= –001 1001B= –25 （2）x= –1000 0000B= –128\n\n&nbsp;\n\n3.  x= +101 0010B=82 （4）x= –010 1101B = – 45\n\n8\\. 在32位计算机中运行一个C语言程序，在该程序中出现了以下变量的初值，请写出它们对应的机器数（用十六进制表示）。\n\n（1）int x=-32768 （2）short y=522 （3）unsigned z=65530\n\n（4）char c=’@’ （5）float a=-1.1 （6）double b=10.5\n\n**【分析解答】**\n\n（1）-2¹⁵=-1000 0000 0000 0000B，故机器数为1…1 1000 0000 0000 0000=FFFF8000H。\n\n（2）522=10 0000 1010B，故机器数为0000 0010 0000 1010=020AH。\n\n（3）65530=2¹⁶-1-5=1111 1111 1111 1010B，故机器数为0000FFFAH。\n\n（4）’@’的ASCII码是40H。\n\n> （5）-1.1=-1.00011 \\[0011\\]…B=-1.000 1100 1100 1100 1100 1100 **110**0…B，阶码为127+0=01111111，舍入的三位为110，因此舍入后尾数末位加1，故机器数为1 01111111 000 1100 1100 1100 1100 1101=BF8CCCCDH。\n>\n> （6）10.5=1010.1B=1.0101B×2³，阶码为1023+3=100 0000 0010，故机器数为0 100 0000 0010 0101 \\[0000\\]=40250000 00000000H。\n\n9.  在32位计算机中运行一个C语言程序，在该程序中出现了一些变量，已知这些变量在某一时刻的机器数（用十六进制表示）如下，请写出它们对应的真值。\n\n（1）int x：FFFF0006H （2）short y：DFFCH （3）unsigned z：FFFFFFFAH\n\n（4）char c：2AH 5）float a：C4480000H （6）double b：C024800000000000H\n\n**【分析解答】**\n\n（1）FFFF0006H=1…1 0000 0000 0000 0110B，故x= -1111 1111 1111 1010B= -(65535-5)=-65530。\n\n（2）DFFCH=1101 1111 1111 1100B=-010 0000 0000 0100B，故y=-(8192+4)=-8196。\n\n（3）FFFFFFFAH=1…1 1010B，故z=2³²-6。\n\n（4）2AH=0010 1010B，故c=42，若c表示字符，则c为字符’\\*’。\n\n> （5）C4480000H=1100 0100 0100 1000 0…0B，阶码为10001000，阶为136-127=9，尾数为-1.1001B，故a=-1.1001B×2⁹= -11 0010 0000B= -800。\n>\n> （6）C024800000000000H=1100 0000 0010 0100 1000 0 0…0B，阶码为100 0000 0010，阶为1026-1023=3，尾数为1.01001B，故b = -1.01001B×2³ = -1010.01B = -10.25。\n\n17. 假定在一个程序中定义了变量x、y和i，其中，x和y是float型变量，i是16位short型变量（用补码表示）。程序执行到某一时刻，x=–0.125、y=7.5、i=100，它们都被写到了主存（按字节编址），其地址分别是100，108和112。请分别画出在大端机器和小端机器上变量x、y和i中每个字节在主存的存放位置。\n\n**【分析解答】**\n\nx = –0.125 = –0.001B = –1.0B×2⁻³, 阶码e=127-3=0111 1111B -11B=0111 1100B, 所以，用IEEE 754单精度浮点数表示为：1 011 1110 0 000 0000 0000 0000 0000 0000 = BE00 0000H。\n\ny=7.5= 111.1B = +1.111B×2²，阶码e=127+2=128+1=1000 0001, 所以，用IEEE 754单精度浮点数表示为：0 100 0000 1 111 0000 0000 0000 0000 0000 = 40F0 0000H。\n\ni = 100 = 110 0100B，用16位补码表示为0064H。\n\n上述三个数据在大端机器和小端机器上的存放位置如下表所示。\n\n数据在大端和小端机器中的存放位置\n\n|               |          |          |\n|---------------|----------|----------|\n| 地址          | 大端机器 | 小端机器 |\n| &x（100）     | BEH      | 00H      |\n| &x + 1（101） | 00H      | 00H      |\n| &x + 2（102） | 00H      | 00H      |\n| &x + 3（103） | 00H      | BEH      |\n| &y（108）     | 40H      | 00H      |\n| &y + 1（109） | F0H      | 00H      |\n| &y + 2（110） | 00H      | F0H      |\n| &y + 3（111） | 00H      | 40H      |\n| &i（112）     | 00H      | 64H      |\n| &i + 1（113） | 64H      | 00H      |\n","categories":["NJUCS","数字逻辑与计算机组成"]},{"title":"chapter1 二进制表示","url":"/posts/f737840a5475/","content":"\n# 二进制表示\n\n## 计算机系统概述\n\n### 冯诺依曼结构\n\n采用 **存储程序** 的工作方式\n\n计算机由运算器，存储器，控制器，输入/输出设备（I/O 设备）构成。\n\n其中：\n\n-   存储器：存储指令和数据（指令和数据在计算机内部的表示方式一致，但是计算机由识别 他们的方法）\n-   运算器：内部有 **ALU**（arithmetic and logic unit）算数逻辑单元和通用寄存器组 **GPRs**（General Purposed Register Set），**是指令的执行单元**;\n-   控制器：**自动地取出指令**; 内有指令寄存器 **IR**(Instruction Register)和 **PC**(Program Count)程序计数器，前者存放从主存中取来的指令\n-   I/O 设备，输入和输出\n\n![image-20250217111409374](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250217111409374.png)\n\n>   CPU 中 除了‘控制部件’都是运算器；\n>\n>   注意缩写的含义!\n>\n>   ![image-20250217125953166](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250217125953166.png)\n>\n>   图中内容来自教材\n\n>   25/6/16 注： 指令的执行过程之后还会多次地提及\n\n### 程序的表示和执行（核心！！！）\n\n1.   程序在执行前：\n     -   将数据和指令存放在 **内存** 中\n     -   每一条指令和数据都有地址\n     -   指令有序存放  （但是不一定按序执行）\n     -   将程序的起始地址置入 PC（Program Count）（PC 其实是一个地址寄存器，用于寄存下一个指令的地址）\n\n>   程序执行前指的是“从点击鼠标”到执行第一条指令前的过程\n\n2.   程序执行的过程中：\n\n     -   根据 PC 取指令\n\n     -   翻译 PC 指令中的操作码\n\n     -   根据操作码：取操作数，执行操作，将结果写入目的地址中\n\n     -   **修改 PC 为下一条指令的地址**（这是指令依次执行的关键），再循环上述流程\n\n         >   指令中通常包括以下信息：操作码（加减等）源操作数 1 或/和 源操作数 2（的地址）  目的操作数地址  \n\n关于计算机读取指令的过程，还可以看下面 deepseek r1 生成的内容\n\n>   #### **1. 取指阶段（Fetch）**\n>\n>   -   **目标**：从内存中读取下一条指令。\n>   -   **步骤**：\n>       1.  **程序计数器（PC）**：控制器中的寄存器 PC 存储当前指令的内存地址。\n>       2.  **发送地址**：控制器将 PC 中的地址发送到内存。\n>       3.  **读取指令**：内存根据地址返回指令内容（二进制码）。\n>       4.  **存入指令寄存器（IR）**：指令被临时存入控制器的 **指令寄存器（IR）**。\n>       5.  **更新 PC**：PC 自动+1（或根据跳转指令修改），指向下一条指令地址。\n>\n>   ------\n>\n>   #### **2. 解码阶段（Decode）**\n>\n>   -   **目标**：解析指令内容，确定操作类型和操作数。\n>   -   **步骤**：\n>       1.  **拆分指令**：指令分为 **操作码（Opcode）\\**和\\** 操作数（Operand）**。\n>           -   **操作码**：指明操作类型（如加法、跳转）。\n>           -   **操作数**：指明数据来源（如寄存器、内存地址）。\n>       2.  **控制器生成控制信号**：根据操作码，向各部件发送控制信号（如激活 ALU、选择寄存器）。\n>\n>   ------\n>\n>   #### **3. 执行阶段（Execute）**\n>\n>   -   **目标**：完成指令规定的操作。\n>   -   **可能的操作类型**：\n>       -   **算术/逻辑运算**（由 ALU 执行）：\n>           -   例如：`ADD R1, R2`（将寄存器 R1 和 R2 的值相加）。\n>           -   控制器将 R1 和 R2 的数据送入 ALU，ALU 计算结果后存回指定寄存器。\n>       -   **数据移动**：\n>           -   例如：`LOAD R1, 0x100`（将内存地址 0x100 的数据加载到 R1）。\n>           -   控制器从内存读取地址 0x100 的数据，存入寄存器 R1。\n>       -   **控制流跳转**：\n>           -   例如：`JMP 0x200`（跳转到地址 0x200 执行）。\n>           -   直接修改 PC 的值，改变下一条指令地址。\n>\n>   ------\n>\n>   #### **4. 写回阶段（Write Back）**\n>\n>   -   **目标**：将执行结果写回寄存器或内存。\n>   -   **例如**：运算结果存入寄存器，或内存地址更新数据。\n\n---\n\n\n\n### 计算机系统的抽象层\n\n![image-20250217192637741](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250217192637741.png)\n\n **软硬件交互--ISA**\n\nISA 是硬件和软件之间的桥梁，规定了软件和硬件之间交互的接口；\n\nISA 是一种规约，规定了可执行的指令的集合，以及指令可以接受的操作数的类型。\n\n---\n\n### 机器级语言：机器语言，汇编语言 \n\n-   机器语言：0011.....\n\n-   汇编语言优点： 1. 可读性 2. 便于编写代码。\n\n汇编语言程序!= 汇编程序， **汇编语言程序** 是用汇编语言写的程序；**汇编程序** 是将汇编语言转换成 **机器级语言** 的程序。\n\n汇编符合某一个 ISA，只能在同一个 ISA 设计的 机器上运行。之所以我们写高级语言不用操心这一个，是因为有一层封装。\n\n**硬件只能执行机器语言程序**\n\n**编译与解释**：\n\n1.   编译：将高级语言源程序-> 机器级语言\n2.   解释：逐条翻译成\n\n机器代码还需要通过 **指令译码器** 翻译成控制信号\n\n![image-20250221103502221](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250221103502221.png)\n\n---\n\n### 一个例子\n\n**8 位** 模型机 M：8 位定长指令字，4 个 GPR，16 个主存单元；8 位指的是指令的长度，GPR 中大部分也为 8 位；\n\n>   目前市面上大部分的存储设备的主存单元都是 8 位\n\n详细见 ppt。\n\n---\n\n##  二进制编码\n\n机器只能执行二进制的机器代码，只能计算二进制的数据。\n\n-   真值：01 序列代表的现实中的值\n-   机器数：01 序列\n\n\n\n1. 数值型数据\n\n​\t不同的进制：二进制 B，八进制 O，十六进制 H(或 ox- prefix)\n\n2. 非数值型数据\n\n**不同进制之间的转换**\n\n1.   十进制和其他进制\n2.   二进制与十六进制，二进制与八进制。\n\n**定义数据的要素**：\n\n1.   进制:确定是几进制\n2.   定点/浮点: 因为小数点无法表示，需要有“定点”和”浮点“之分\n3.   编码：确定不同的编码方式\n\n---\n\n这一节的重点在于：熟悉进制的转换。\n\n\n\n##  数值型数据的表示\n\n原码：首位是符号位！\n\n原码和补码的范围由其**数值位**决定，浮点数主要由**阶码**决定。\n\n\n\n### 定点数\n\n定点数可以表示小数，也可以表示小数；小数的小数点默认在最左边，整数的小数点默认在最左边。\n\n>   定点整数：小数点固定在数值位最右，**无需显式表达** 定点小数：小数点固定在数值位最左，**无需显式表达**\n>\n>   补充：定点小数的小数点固定在数值位的最左边，**符号位的右边！**，比如1100 0000，表示的是-0.5，没有隐含的1！（不同于IEEE754规定的规格化浮点数尾数）\n\n补码：在模 n 的运算中，任何一个数的补码是它对 n 取模后的结果。\n\n如果用 n 位二进制来表示补码，则可以表示-2^(n--1) 到 2^(n-1)-1 的数字；\n\n给定任何一个这个范围中的数字，对 2^n 取模，将这个结果表示为二进制，即得到了这个数的补码。\n\n1.   显然，对于这个范围之间的正数，补码就是他的本身\n2.   对于负数，先加上 $2^n$，再表示为二进制。\n\n>   **给定一个 8 位的二进制，$2^8$-这个二进制 = 这个二进制按位取反+1；因为在这个二进制+这个二进制的取反 = $2^8$-1**\n\n因此，计算 -1101100 的补码，只需要计算 $2^n$-1101100 的二进制表示，即 1101100 按位取反再加一\n\n### 补码与源码之间的转换\n\n1.   原码转成补码：\n\n-   正数的原码就是它的补码。 \n-   负数的补码是它的相反数的补码（原码）按位取反再加 1。\n\n>   补充：负数求补码其实是求这个负数+$2^n$之后的二进制表示（原码或者说补码）而a+a按位取反+1=$2^n$ ,因此求-a的补码，即是要求 **a按位取反+1**\n\n2.   补码转源码：\n\n-   依然只用说负数的内容。要求负数的原码，只需要将这个补码的实际值对$2^n$取模，（将结果控制在-2^(n-1) ~2^(n-1)之间)即可得到-a的值，再把a的原码写出，加上符号位即可。\n\n>   也可以根据下面的内容，求出原码的值\n\n3.   补码转成真实值\n\n![image-20250223203429112](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250223203429112.png)\n\n>   因为补码对应的真值是 “补码对应的二进制数”-$2^{n}$ 将补码对应的二进制展开，即可得到上面的式子\n\n也可选择先转成源码，再转成真值。\n\n**变形补码**: 一般的补码在只能表示$-2^{n-1}$到 $2^{n-1}+1$的数据，变形补码引入了双符号位\n\n### 移码(excess notation)\n\n**给每一个数字加上一个偏移量**（bias or excess), 这个新的数字的二进制表示，就是原数字的偏移量。根据移码得到数字的方式->减去偏移量。\n\n如，四位二进制表示7，-3，如果偏移量为7，那么前者表示为1110，后者表示为0100;\n\n>   移码的出现主要是用于浮点数的阶码表示\n\n### Singed int and Unsigned int\n\n有符号数表示范围：$-2^{n-1}$ 到$ 2^{n-1}-1$;\n\n无符号数表示范围：0 到 $2^{n}$;;\n\n### 浮点数（IEEE 754）\n\n浮点数由符号位+阶码+尾数构成；\n\n阶码是由**移码**来表示的，bias是$2^{n-1}$; 而尾数是由**原码**来表示的。\n\n#### 将一个数字转成浮点数编码表示\n\n1.   11111=1.1111*$2^{4}$\n2.   符号位：0； 阶码：4+127=1000 0011； 尾数：1111 0000 0000 0000 0000 000（补全至32位）\n3.   最终结果：0 10000011 11110000000000000000000\n\n#### 浮点数的表示范围\n\n![image-20250224113901073](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250224113901073.png)\n\n1.   32位的浮点数 1+8+23   **(SP: single precision)**；\n\n-   **NAN**：阶码为FFH，尾数不为0； (Not A Num)\n\n>   NAN对于程序的调试有帮助\n\n-   **正无穷**：阶码为FFH，尾数全为0，符号位为0；**负无穷**：阶码为FFH，尾数全为0，符号位为1；\n-   0：阶吗和尾数全为零，根据符号位不同，可以有+0和-0的区别。\n-   **规格化数**的范围：$2^{127}*(2-2^{-23})$~$2^{-126}*1.0$\n-   **非规格化数**的特点是：\n    -   <span style=\"text-decoration:underline;\">阶码固定为 `-126`（实际指数 = 阶码值 - 127，但阶码为 `0` 时，实际指数固定为 `-126`）。</span>\n    -   **尾数没有隐含的前导 `1`**，即尾数的实际值为 `0.尾数位`。\n    -   非规格化数的表示范围是：$2^{-126}*2^{-23}-2^{-126}*(1-2^{-23})$\n\n-   <span style=\"text-decoration:underline;\"> **规格化数**的阶码部分范围为**1~254**</span>；阶码为0是非规格化数（阶码全零尾数非零的部分：范围是$2^{-126}-2^{127}*(2-2^{-23})$\n\n2.   64位的浮点数 1+11+52   **(DP: double precision)**：\n\n-   阶码偏移量为1023；\n-   规格化数的阶码范围为：1~2046(对应-1022 ~ 1023)\n-   规格化数的取值范围为：$2^{-1022}-2^{1023}*(2-2^{52})$\n-   非规格化数的取值范围是：$2^{-1022}*2^{-52}-2^{-1022}*(1-2^{-52})$\n\n#### 浮点数的规格化\n\n下面的回答来自deepseek\n\n**右规与左规**\n\n##### 右规（Right Normalization）\n\n>   **使用场景**：当尾数绝对值 ≥ `2.0` 时，需右规。\n>\n>   **操作**：\n>   \n>1. 尾数右移 1 位。\n>   2. 指数加 1。\n>\n>   **例子**：\n>   \n>$$\\text{Value} = 10.110 \\times 2^3\n>   $$\n>\n>   - 尾数 `10.110` = `2.75` ≥ `2.0`，需右规。\n>   - 右规后：\n>    $\n>     \\text{Value} = 1.0110 \\times 2^4\n>     $\n>   \n\n\n\n##### 左规（Left Normalization）\n\n>   **使用场景**：当尾数绝对值 < `1.0` 时，需左规。\n>\n>   **操作**：\n>   \n>1. 尾数左移 1 位。\n>   2. 指数减 1。\n>\n>   **例子**：\n>   $\n>\\text{Value} = 0.1101 \\times 2^3\n>   $\n>\n>   - 尾数 `0.1101` = `0.8125` < `1.0`，需左规。\n>   - 左规后：\n>    $\n>     \\text{Value} = 1.101 \\times 2^2\n>     $\n>   \n\n##### 总结\n\n>   - **右规**：尾数 ≥ `2.0` 时，尾数右移，指数加 1。\n>- **左规**：尾数 < `1.0` 时，尾数左移，指数减 1。\n>   - 规范化确保尾数范围在 `[1.0, 2.0)`。\n\n### 不同数据类型之间的强制类型转换\n\n#### 整数有符号和无符号\n\n-   signed int装成unsigned int，会按照二进制的值来表示\n-   由unsigned int 转signed int，会发生`undefined behavior`\n-   signed int和unsigned int一起运算的时候，会发生`强制类型提升`，int变成unsigned\n\n由short转成int or unsigned int的时候要补位，如果是singed就补符号位，如果是unsigned就补0\n\n\n\n#### float,int,double之间的转换\n\n(a). float和int之间的转换：\n\n-   一方面，float的移码最高表示到2的126次方，远大于int的2147483647；\n-   但是float的尾数只有23位，算上隐含的1最多能表示24位的二进制表示，如果位数太多，会发生**精度缺失**。\n\n(b). double和int之间的转换:\n\n-   double的尾数有52位，可以一次性表示53位二进制数（不发生精度缺失）\n-   因此d==(int)(double)d为真（其中d是一个int型整数）\n\n#### float和double之间的强制类型转换\n\n-   由double转float可能数值溢出或者精度缺失\n\n-   double和float的加减法需要**对阶**\n\n    >   比如以$1.0*2^{53}+1.0$(前者为double，后者为int)，因为尾数只有52位（最多表示53位有效数字），所以至少要大小为$2^{53}/2^{52}$这么大的数字才有效\n    >\n    >   因此，你可以看到：\n    >\n    >   ```cpp\n    >   #include<bits/stdc++.h>\n    >   using namespace std;\n    >   int main(){\n    >   \n    >       int a=0;\n    >       double d=1;\n    >       for(int i=0;i<52;i++){\n    >           d*=2;\n    >       }\n    >       cout<<((d+1)-d)<<endl;//output: 1\n    >       d*=2;\n    >       cout<<((d+1)-d)<<endl;//output: 0\n    >       cout<<(d+2)-d<<endl;//output: 2\n    >       return 0;\n    >   }\n    >   ```\n    >\n    >   \n\n## 字符的表示\n\n### 汉字编码形式：\n\n有以下几种汉字代码：\n\n-   输入码：对汉字用键盘按键进行编码表示，用于输入\n-   内码：用于在系统中进行存储、查找、传送等处理\n-   字模点阵码或轮廓描述: 描述汉字字模的点阵或轮廓，用于输出\n\n### 数据的基本宽度\n\n-   现代存储器通常按字节编址：即按位编址\n\n>   此时，字节是最小可寻址单位 (addressable unit ) \n\n-   字 (word) 也经常用来作为数据的长度单位\n\n-   字长：64位计算机，32位计算机。\n\n>    字长是定点运算的数据通路的宽度，即**ALU**是64位或者32位。\n\n同样的数据类型，如果机器的字长不同，分配的字节数不一定相同。\n\n### 数据（机器数）的排列位置\n\n**数据的地址**：指数据在内存中的起始地址，即数据所占内存单元中地址最低的字节的地址。\n\n- **按字节存储**：现代计算机通常以字节（8位）为单位存储数据。\n\n**小端模式（Little-Endian）**：数据的低位字节（LSB）存放在低地址处，高位字节存放在高地址处。\n\n**大端模式（Big-Endian）**：数据的高位字节（MSB）存放在低地址处，低位字节存放在高地址处。\n\n>   大端小端模式是重点知识之一，尽管内容不多。\n\n**例如**：对于16位数据0x1234，存储在地址0x100和0x101：\n\n- **小端模式**：地址0x100存放0x34（低位字节），地址0x101存放0x12（高位字节）。\n- **大端模式**：地址0x100存放0x12（高位字节），地址0x101存放0x34（低位字节）。\n\n**要能区分大端模式和小端模式**\n","categories":["NJUCS","数字逻辑与计算机组成"]},{"title":"DLCO-2025-Spring-Final","url":"/posts/3f9169848111/","content":"\n本文为南京大学计算机科学与技术专业 2025年春 数字逻辑与计算机组成往年卷，全文约2000字，阅读时间10min。\n\n## 选择题\n\n1.   下面哪些是加权码？ A 余三码 B NBCD码 C 格雷码 D 独热码\n2.   其他貌似都是常规题，第一题嘛，**读到这里的你真的知道`余三码`是什么码?如果你在考试，你会选择什么？**\n3.   判断下面哪个数最小？ 给了一些反码、补码、原码\n4.   下面哪一个需要3个CMOS们才能表示？选A，二输入与门\n5.   下面有关Booth算法的描述，错误的是？ 选择那个说 由“最后一位来决定每一次计算”的那个选项，这个题目说实话，已经在考试试卷上出现几次了。读者可以找一下以前的往年卷。什么你不知道哪里有往年卷？抱歉我也不提供\n\n## 组合逻辑\n\n组合逻辑考得是写真值表、逻辑表达式，并且用**布尔代数**化简，最后再转化为**二级与非表达式**\n\n常规题\n\n## 时序逻辑\n\n时序逻辑给了一个情境：投币购物，可以投1元硬币和2元硬币，商品价格为3元，不设找零，多出的钱只能下一次使用。当钱>=3时，Y输出为1。\n\n第一问给了4个状态：\n\n| S0       | S1       | S2      | S3       |\n| -------- | -------- | ------- | -------- |\n| 初始状态 | 投了一元 | 投了2元 | 投了三元 |\n\n这题的一个特殊点在于，有两个输入：A，B。分别代表投入的钱是1元或者2元。**不会出现AB同时为1的情况**\n\n>   貌似作业题和课本上都没有涉及过2输入的时序逻辑设计，不过理解原理之后其实也大差不差\n\n*第一问* \t写出相关的状态转移表\n\n*第二问* \t先问了**哪些状态可以合并**，也就解决了考生的疑问“吃饱没事干，干嘛要给S3单独一个编码？”同时，给出了S0-S3的编码用Q1Q0表示，之后要求填入真值表，实际上真值表上面S3对应的内容已经填好了（全是无关项），和上面状态合并相对应；值得注意的是需要按照**合并之后的状态转移情况，填入真值表**\n\n*第三问*\t写出状态转移方程、生成函数、激励函数\n\n*第四问*\t连线题。书卷上给出了Logisim画出的部分图，考生需要将剩余部分补齐。由于试卷上已经很明显地告诉了考生，D0* 和 D1*都是三个与门用或门连接好了\n\n![image-20250618140555700](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250618140555700.png)\n\n读到这里你可能会疑惑？为什么没有未用状态分析？ 确实没有。\n\n*第五问*\t画出D0、D1、Y随着CLK、A、B的变化的波形图\n\n*第六问*\t时序逻辑分析。记住Tclk>setup+clk2q+longest-delay即可\n\n## 指令&CPU综合 \n\n这个板块占比为**50分**，考试题型是：先给出一个指令体系结构，之后几个大题都是围绕这个指令体系结构给出不同的数据通路（单周期、多周期、流水线），结合不同的知识点来考察。\n\n*第一部分*\t指令体系结构\n\n题干给出了一种RISC-V风格的指令体系结构，给出了8条指令的编码（不包括sub，为后续埋下伏笔）\n\n这一部分貌似出了这些题目：\n\n1.   请你写出add x7 x7 x6的机械码（16进制）（具体是什么我忘了）\n2.   请问最多有多少个通用寄存器？ 显然32个，因为给出的指令体系结构中，寄存器的编码位数为5\n3.   请问图中a b c d e 的值代表多少？其实就是考察每一个地方的位数\n\n![image-20250618142040568](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250618142040568.png)\n\n***单周期***\t这一部分给出了单周期的数据通路，并结合单周期的数据通路考察了一些问题：\n\n问：如何修改数据通路以同时支持add和sub指令？\n\n***多周期***\t不记得单独考了什么了。好像就没有单独考察数据通路的内容，和老师上课时强调的一致。\n\n\n\n***流水线***\t出现了以下问题：如何使得其支持检测溢出并防止错误结果写入，如何修改数据通路使得其支持bne指令？\n\n***汇编程序分析题***\n\n这一部分是本张试卷的难点之一，综合考察了对于汇编指令的理解、CPU性能的比较和冒险分析\n\n包括但不限于：\n\n给了一段汇编代码（包含lw、sw、slti、add等等指令），需要判断出代码的执行情况，能够分析出这段代码在不同CPU上的执行情况。\n\n汇编代码模拟版本（感谢starwink的提供）\n\n```\n描述：内存0x0-0x4存储的真值分别为-2，-1,0,1,2；执行一下汇编代码：\nadd x5 x0 x0\t\t\t#1\nlw x6 2(x5)\t\t\t\t#2\nloop: bne x5 x6 finish \t#3\n\taddi x5 x5 1\t\t#4\n\tlw x6 0(x5)\t\t\t#5\n\tslti x7 x6 1\t\t#6\n\tsub x6 x6 x7\t\t#7\n\tsw x6 0(x5)\t\t\t#8\n \tjal x0 loop\t\t\t#9\nfinish\n```\n\n\n\n以下是回忆版试题：\n\n1.   第一次执行到#7这条指令（一条sub指令）的时候，xx的值是多少。写出此时的OF、ZF、SF、CF信号。如何“有OF、ZF、SF、CF”如何表示无符号和有符号的小于。\n\n2.   有哪些部分出现了数据冒险？使用转发能够解决哪一些？（8分还是10分，可以说占比相当大了）\n\n3.   在程序结束的时候，内存0x0-0x4的值分别是什么，用10进制表示真值。\n\n4.   分析这段汇编代码在前面设计的单周期和流水线CPU中执行的周期数。\n\n     >   这个地方需要能够准确地判断出汇编代码的执行情况，这一部分许多题目都需要分析出这一点才能接着分析\n     >\n     >   并且，流水线中还需要考虑load-use冒险和分支预测，并且，分支预测采取的还是**一位动态预测**，最开始时预测为**跳转**，但是实际上不跳转，所以预测错误一次，最后离开周期的时候还会有一次预测错误；jal指令和bne指令的延迟损失片需要根据数据通路来判断；\n\n5.   告诉你每一个指令在多周期数据通路中需要多少个周期，问你上面那个汇编程序需要执行多少个周期\n\n6.   询问如何优化流水线数据通路，使得其能够减少汇编程序周期执行数\n\n     >   已经采取了数据转发，只能优化的地方是延迟损失片；前面计算流水线的时候已经出现过延迟损失片了，因此我们只需要 将相关的更新PC的逻辑往前移，即可。\n\n---\n\n## 写在最后：\n\n期末考试情况：\n\n90分及以上 14人；80-89,18人；70-79,16人；60-69,16人；50-59,9人；40-49,4人；39及以下,2人；\n\n**也就是说80分以上的比例高达约40%**\n\n\n\n>   **试卷内容不保真，仅做为参考**\n>\n>   制作本回忆版试卷的初衷是为了让学弟学妹们有针对性地进行复习，能够少走一些弯路，用更少的时间学会更重要的内容。\n>\n>   回顾整张试卷，你会发现试卷结构井井有条：最开始的20分基础题，涵盖了本书中许多基础知识点，之后是组合逻辑和时序逻辑电路，为后续CPU的设计打下了基础；最后在情境中给出指令体系结构，并且针对性地设计了数据通路，还考察了在这个数据通路中、在 这个指令体系结构下，汇编代码的执行。\n>\n>   试卷难度看个人能力而定，建议复习侧重重点；结合老师最后画的重点进行针对性的复习；核心考点是最后两章+时序逻辑，理论上，这张试卷如果你完全不复习其他内容，而选择ALL in 这两章的话，可以取得不错的成绩。\n>\n>   写到这里，到了Yama的午睡时间了，~~一觉醒来全世界的DLCO水平下降一万倍~~，醒来之后还有物理复习☝️🤓\n>\n\n**转载请标注来源 **\n\n*2025-6-18   author: [yama-lei](https://github.com/yama-lei)* \n\n","categories":["NJUCS","数字逻辑与计算机组成"]},{"url":"/posts/370c251f0155/","categories":["NJUCS","学术阅读和写作"]},{"url":"/posts/5f821feb6d89/","content":"\n**作业交学习通！！！！！**\n\n## 作业1\n\nSome people take their family when they work abroad for a period of time. Does this have more advantages than disadvantages forindividuals and their family?\nPara 1. Introduction: Background + Thesis statement\n\n**Para 2. ldea 1: Topic sentence 1 + Supporting evidences**\n\nPara 3. ldea 2: Topic sentence 2 + Supporting evidences\n\nPara 4. Conclusion: Summary + lmplication\n\n---\n\npara2：\n\n```\n\tTaking family members abroad might caues them uncomfotable with the new environment. Living abroad means departing with the familar hometown, leaving all the friends and other relatives, giving up former jobs  and starting a toally unpredictable new life. So it's easy for other family members to feel disconnected and uneasy to go with you to live in a new country without a solid social network.\n```\n\n---\n\n![198453c35304a50a46b64959b6330b5](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/198453c35304a50a46b64959b6330b5.jpg)\n\n\n\n\n\n\n\n---\n\n**Introduction:**\n\n\t1. Hook-> Background->Thesis statement\n\t1. Consise but effective! \n\n例子：\n```case1\n\tAs humans celebrate the new year, most areunaware that nearly all polar bears will vanish by2050 due to global warming (Bernish,2015). \n\tWith polar ice melting at alarmingrates, bears are starving and drowningas scientists search for ways toprevent their extinction. \n\tIn order for polarbears to survive,humans must reduceglobal warming byconservingenergy and reducinggreenhouse gases.. \n```\n\nCase 2 : \n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/5167edc8eec80d325d1958ee80a3498.jpg\" alt=\"5167edc8eec80d325d1958ee80a3498\" style=\"zoom: 25%;\" />\n\n\n\n​\t\n\n\n\n\n\nBoby paragraph：\n\n​\tTopic sentence-> Evidence-> Analysis->Transition  (`Transition is needed but its position is flexible` )\n\n>    U should also think about the rebutal \n\n![203da71d7115e66ba8c40806ea24ef5](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/203da71d7115e66ba8c40806ea24ef5.jpg)\n\n---\n\n**Paraphase:**\n\n使用一些高级的词，比如用paramount merit代替biggest advantages\n","categories":["NJUCS","Others"]},{"title":"English(Monday)","url":"/posts/ce7a2a220fbb/","content":"\n慕课链接：[高级英语视听_南京大学_中国大学MOOC(慕课)](https://www.icourse163.org/course/NJU-1464262167)\n\n## 慕课Mooc Answer\n\n>   Warning: I use ``A ``stands for `Yes` and `B`  for `No` in the judgement questions for simplying the asnwers! \n\n1.1 ACCBD\n\n1.2 BABBB\n\n1.3 ABBAB（不计分）\n\n2.1 ABABB BABDB\n\n\n\n## Individual Talk\n\n**Requirements for Individual Talk Show**\n\n**Topic**:\n\nIntroduction to a Local Intangible Cultural Heritage or Custom\n\n**Content**: \n\nChoose one intangible cultural heritage or local custom that you are familiar with and passionate about. It could be **a traditional craft, a folk art, a festival, a unique custom**, or any other cultural element that represents your hometown. Explain its **origin, significance,** and **how it is practiced today.**\n\n**Presentation Style**: You are encouraged to present in a creative and engaging way. You may use a PPT to include pictures, videos, or any other visual aids to make your presentation more interesting and informative. \n\n**Duration:** Your presentation should be around 3 minutes long. If you include a video, please ensure that its length is appropriate and does not exceed half minute. \n\n**Note:**\n\n​            1.     请脱稿演讲。PPT上不可写完整的句子，可写关键词或者短语。\n\n​            2.     PPT请提前两天发到教学立方，并QQ告知我。\n\n​            3.     交PPT的同时请大家附上文字稿或者主要内容的清楚信息，以供**quiz小测选用**。\n\n---\n\n\n\n\n\n## Listening Part:\n\n## Unit1\n\n### Advice on learning English\n\nDo you really want to learn English? Celestino Santee, an English language teacher, gives students important advice. Please give some advice to those who come to the United States to learn English. I'd like to give some suggestions and some advice based on my experience to students learning English. First of all, don't be afraid to speak to Americans. Americans seem to enjoy meeting people from other countries and they like to share the information that they have. So if you're afraid to speak to an American, that means that you're passing up an opportunity for communication, which is really what it's all about. It's not about reading books or learning grammar in some abstract way. It's more about speaking, communicating, learning how real people talk and what they have to say. \nA good way to do this is to go out into the community. Another piece of advice I'd like to give to people is try to learn as much about our culture as you can. And I think in that way you'll feel more confident and you'll also be able to appreciate our culture a little bit better. Learning about some of the differences but also some of the similarities. What is the best age to learn English? As a teacher and a tutor I've taught all different ages from really people in their 60s and 70s all the way down to the lowest elementary school children. And I found some real differences. Of course, the adults have a more traditional form of education that they base their form of learning on. Also, in many cases, they're more hesitant to speak, they're a little bit more embarrassed, and they want to make sure that they have the structure of the grammar. \nHowever, the young children are like sponges. They really just want to soak up every piece of information. They're not afraid of making mistakes, as are the older people. It is so much easier to learn a language when you're a child, but, you know, it can be done at any age, and I think it just takes a little bit more of an effort and also the willingness to take risks, to appear a little bit foolish, perhaps, But in so doing, if you can laugh at yourself a little bit and your own mistakes, then other people feel more comfortable around you. And this makes everybody more comfortable. And of course, communication is what it's all about. What is the best way to teach English? There are so many different ways of teaching English. It varies school to school. It varies teacher to teacher. It also varies as to whether you're taking private lessons with a tutor \nor if you're in a large classroom situation. In some ways, it's great to have a tutor individually because you can have somebody work with you one-on-one. However, there is also an advantage to be able to take a class with students from not just your country, but other countries as well. So therefore, you can communicate with other people, which is again what it's all about. You can learn about other cultures in addition to the American culture. You can learn about other cultures. I've had students who complain about being a class with other English as a second language students, but overall I have found that the communication outweighs any disadvantages. So students really enjoy meeting each other and being forced to speak in English. \n\n### The queen's speech\n\n(转录由TurboScribe.ai完成。升级到无限以移除此消息。)\n\nHistory links monarchs and parliament, a connecting thread from one period to the next. So in an era when the regular worthy rhythm of life is less eye-catching than doing something extraordinary, I'm reassured that I am merely the second sovereign to celebrate a diamond jubilee. As today, it was my privilege to address you during my silver and golden jubilees.\n\nMany of you were present ten years ago, and some of you will recall the occasion in 1977. Since my accession, I have been a regular visitor to the Palace of Westminster, and at the last count have had the pleasurable duty of treating with twelve prime ministers. Over such a period, one can observe that the experience of venerable old age can be a mighty guide, but not a prerequisite for success in public office.\n\nI am therefore very pleased to be addressing many younger parliamentarians, and also those bringing such a wide range of background and experience to your vital national work. During these years as your Queen, the support of my family has, across the generations, been beyond measure. Prince Philip is, I believe, well known for declining compliments of any kind.\n\nBut throughout he has been a constant strength and guide. He and I are very proud and grateful that the Prince of Wales and other members of our family are travelling on my behalf in this diamond jubilee year to visit all the Commonwealth realms and a number of other Commonwealth countries. These overseas tours are a reminder of our close affinity with the Commonwealth.\n\nEncompassing about one third of the world's population. My own association with the Commonwealth has taught me that the most important contact between nations is usually contact between its peoples. An organisation dedicated to certain values, the Commonwealth has flourished and grown by successfully promoting and protecting that contact.\n\nAt home, Prince Philip and I will be visiting towns and cities up and down the land. It is my sincere hope that the diamond jubilee will be an opportunity for people to come together in a spirit of neighbourliness and celebration of their own communities. We also hope to celebrate the professional and voluntary service given by millions of people across the country who are working for the public good.\n\nThey are a source of vital support for the welfare and wellbeing of others, often unseen or overlooked. And as we reflect upon public service, let us again be mindful of the remarkable sacrifice and courage of our armed forces. Much may indeed have changed these past 60 years, but the valour of those who risk their lives for the defence and freedom of us all remains undimmed.\n\n(转录由TurboScribe.ai完成。升级到无限以移除此消息。)\n\n## Unit 2\n\n### Unit 2 Chores for child\n\nDid you know it could make them more successful in life? Mona Moore from The Mom Zone is here with more. All right, it's springtime. You know, moms have the whole spring cleaning thing down. How are we going to get kids to help? Should we expect them to? Absolutely expect them to. And I know moms with little kids are thinking, oh, my gosh, it's going to take me four times as long to get anything done if the kids actually help me, right? And moms with older kids, they don't want to hear all the whining about they don't want to and this and that. Well, doing chores is actually really important. to make kids feel a part of the family. And as a matter of fact, there was a study done at the University of Minnesota that showed that young adults that did chores when they were three or four years old actually were more successful as adults than people that didn't. And you know, if you really think about it, it makes sense. Family chores provide kids with a sense of being needed. You know, they feel some kind of purpose and pride. They feel confidence. Mom thinks I can do this, so maybe I really can. \nAnd starting young, I'm sure, helps too. Absolutely. The question that I have though is what can a little toddler do? Yeah, you would be surprised. Kids as young as one can start helping you. They can actually put clothes in the hamper. You know, kids love to move things from one little box to another little box. They can water plants, help you with laundry, move from the washer to the dryer. You know, put books and magazines away. They can help set the table. You know, older kids can do different things as well, and as they start getting older, and there you go, five to seven years, as they start getting older, you give them more responsibility. You know, you allow them to make their bed. They're not gonna do it like you do it, but you know what, it's okay. \nPolish the furniture. Help clean the car. I've got a six-year-old and he makes a mess in the car. He should help clean that up, right? Yeah, get one of those dust busters. They love to use that anyway. Exactly. Rake the leaves. They can help, you know, pick weeds. Sweep and wash the patio. They're out there playing, you know. Let them help sweep up the patio. And is that kind of how it goes on? You kind of keep looking at the different responsibilities and what they can do. This is 11 to 13-year-old. Yep. and they can do things more supervised, too. Absolutely. And their skill sets are greater, you know, so you can give them more responsibility. I mean, mowing the lawn, How would you like for your husband to give that up, you know? I bet your husband would like it. Exactly, yeah, yeah, exactly. You know, they can, and they should be responsible for cleaning their room at that age. You know, help clean the closets. They can check the oil in the cars. I'm telling you, start now, and it will help you later. And also, I heard, too, like, don't criticize. You know, if you give them a task, don't criticize everything that they do. That's absolutely true. And what you actually want to do is praise. \npraise the kids for what they're doing, because that will encourage them to keep trying and to keep helping, which is what you want. You want them to do it again and again. Absolutely. All right, now what tips can you give moms as they assign these chores? Right, there's actually three tips you want to keep in mind. First and foremost, you want to make sure you give age-appropriate chores. So you don't want to give, you know, a two-year-old the chore of cleaning their bed, because they're not going to have any idea how to do that. So you want to make sure that the chores are age-appropriate. Second, you want to make sure that... your expectations are reasonable. Like I said, a five-year-old is not going to clean his or her bed like you would do it, but it's okay, because as they get older and they get more practice, they're going to learn, and that's exactly what you're wanting. It's going to get better and better. And the final tip is provide lots of praise and appreciation. You know, you want to make sure that they understand that this is a very valuable part of being a part of the family, \nAnd as you provide that confidence in them, they're going to want to keep trying, and they'll learn those great life skills. Sounds good. So give them the swifter right here or the broom, and they can just go ahead and tackle it. Get them going. Exactly. And use the antibacterial stuff later. All right. For more information, just go to momzone.org, or you can call the number on your screen. Thanks so much for being here. Thank you. All \n\n### Unit 2 Kitchien Talk（Couple）\n\nHey there, what's for dinner?\nFried rice again?\nYou have no idea, do you?\nHow much time and creativity it takes to plan a decent dinner?\nFirst, you have to get an idea for something that's balanced, taste good,\nand isn't the same old thing.\nYeah, and then you have to figure out what ingredients you already have,\nand what you need to buy.\nThen you have to go get the stuff, bring it home, cook it.\nI have to do this every single day.\nOkay, I get your point, but what can I do?\nYou know what an awful cook I am.\nWell, if you really want to help,\nyou could look through these cookbooks and cooking magazines\nto get an idea for dinner tomorrow.\nThen you could go to the store.\n\n### Changing life style\n\nWelcome to Changing Lifestyles. Today we'll take a look at the changing role of fathers. In the 1950s and the 1960s, most fathers went to work every day, and most mothers stayed at home to take care of the children. However, since the late 60s and the early 70s, family life has been changing dramatically. Instead of accepting the rigid roles imposed by society, many couples have been deciding to change their work-life balance. More mothers have been pursuing careers, while at the same time fathers have been devoting more time to caring for children and doing household chores. This is David Noll. David is 33 years old. husband, and father of two girls. David is a modern father. He and his wife both pursue careers in sharing raising the children and doing housework. Okay, well then you're going to go to the playground? Right. Okay. I love you. Can you say bye-bye? Bye-bye. Bye-bye. Bye-bye. David's father, Bob Knoll, was also a loving father. But David's role as a father was different. \nDuring the early part of his career, Bob went to work every day while his wife Shirley stayed home. Bob worked for 38 years at Westinghouse as an electrical engineer. Bob worked on some of the first computers ever produced. Bob had always been an involved father. But in 1970, Shirley decided to go back to work. That was when Bob's role as a father changed. When Shirley went back to work, I had to change my role and started doing more cooking, driving the children here and there. When our children were growing up, I took a lot of interest in what they were doing. I think in many ways, I was probably better prepared for the changing roles that I've had to take on by my father. \nWe did many things together and I tried to get them involved in other areas that they seemed to show interest in, such as theater and magic. He did a great deal more than I think many fathers. I can think of childhood friends whose fathers were running businesses who participated almost not at all in their development. And I think I had a role model. I remember David was interested in, he got very interested in magic and juggling, and he was an avid reader. As a young man, David loved magic, but he pursued a career as a biochemist. Before having children, David spent 40 hours per week studying cellular DNA in a research lab. And his wife, Diane... spent 40 hours a week working as a lawyer in Washington, DC. After the girls were born, David and Diane both cut back on their hours in order to take care of their daughters. As a research scientist, David's schedule was more flexible, so he took on more responsibilities for the children's day-to-day care. \nWell, I have been able to adjust my schedule so that I can be home at 5 o'clock for the kids, and if the children are sick, being able to come home and take them to the doctors. We go for a walk, we take the dogs up the street, go to the park, hang out at the park, and then head back to the house and begin preparing dinner. Since Bob retired 10 years ago, he has been enjoying his role as a grandfather. He's been traveling with his wife, Shirley, and he's been playing tennis. Meanwhile, David is just beginning his journey as a father in a new era. It can be difficult, especially when you're taking on new roles for the first time, and it can be disconcerting, and it can be more comfortable to take on those traditional roles. I think I have many more responsibilities than even most fathers do today, and certainly more than I think when my father was raising his children. \nBut the difference is not the sort of classic role reversal. I'm not a stay-at-home dad. We have an excellent babysitter who has allowed us, allowed both my wife and I, the opportunities to continue pursuing our career. While there are many differences in how David and Bob have raised their children, there are many important similarities. \n\n### Man and woman\n\n(转录由TurboScribe.ai完成。升级到无限以移除此消息。)\n\nSo for any of us in this room today, let's start out by admitting we're lucky. We don't live in the world our mothers lived in, our grandmothers lived in, we're career choices for women, we're so limited. And if you're in this room today, most of us grew up in a world where we have basic civil rights and amazingly, we still live in a world where some women don't have them.\n\nBut all that aside, we still have a problem and it's a real problem. And the problem is this. Women are not making it to the top of any profession, anywhere in the world.\n\nThe numbers tell the story quite clearly. 190 heads of state, nine are women. Of all the people in Parliament's in the world, 13% are women.\n\nIn the corporate sector, women at the top, sea level jobs, board seats, tops out at 15, 16%. The numbers have not moved since 2002 and are going in the wrong direction. Even in the nonprofit world, a world we sometimes think of as being led by more women, women at the top, 20%.\n\nWe also have another problem, which is that women face harder choices between professional success and personal fulfillment. A recent study in the U.S. showed that of senior managers, of married senior managers, two-thirds of the married men had children and only one-third of the married women had children. A couple of years ago, I was in New York and I was pitching a deal and I was in one of those fancy New York private equity offices you can picture.\n\nAnd I'm in the meeting, it's about a three-hour meeting, and two hours in, there kind of needs to be that bio break and everyone stands up. And the partner running the meeting starts looking really embarrassed. And I realize he doesn't know where the women's room is in his office.\n\nSo I start looking around for moving boxes, figuring they just moved in, but I don't see any. And so I said, so did you just move into this office? And he said, no, we've been here about a year. And I said, are you telling me that I'm the only woman to have pitched a deal in this office in a year? And he looked at me and he said, yeah, or maybe you're the only one who had to go to the bathroom.\n\nSo the question is, how are we going to fix this? How do we change these numbers at the top? How do we make this different? I want to start out by saying I talk about this, about keeping women in the workforce, because I really think that's the answer. In the high income part of our workforce, in the people who end up at the top Fortune 500 CEO jobs or the equivalent in other industries, the problem I am convinced is that women are dropping out. Now, people talk about this a lot and they talk about things like flex time and mentoring and programs companies should have to train women.\n\nI want to talk about none of that today, even though that's all really important. Today, I want to focus on what we can do as individuals. What are the messages we need to tell ourselves? What are the messages we tell the women that work with and for us? What are the messages we tell our daughters? Now, at the outset, I want to be very clear that the speech comes with no judgments.\n\nI don't have the right answer. I don't even have it for myself. I left San Francisco where I live on Monday and I was getting on the plane for this conference.\n\nAnd my daughter, who's three, when I dropped her off at preschool, did that whole hugging the leg crying, mom, you don't get on the plane thing. This is hard. I feel guilty sometimes.\n\nI know no women, whether they're at home or whether they're in the workforce, that don't feel that sometimes. So I'm not saying that staying in the workforce is the right thing for everyone. My talk today is about what the messages are if you do want to stay in the workforce.\n\nAnd I think there are three. One, sit at the table. Two, make your partner a real partner.\n\nAnd three, look at that, don't leave before you leave. Number one, sit at the table. Just a couple of weeks ago at Facebook, we hosted a very senior government official and he came in to meet with senior execs from around Silicon Valley.\n\nAnd everyone kind of sat at the table. And then he had these two women who were traveling with him who were pretty senior in his department. And I kind of said to them, sit at the table, come on, sit at the table.\n\nAnd they sat on the side of the room. When I was in college, my senior year, I took a course called European Intellectual History. Don't you love that kind of thing from college? Wish I could do that now.\n\nAnd I took it with my roommate, Carrie, who was then a brilliant literary student and went on to be a brilliant literary scholar. And my brother, smart guy, but a water polo playing pre-med who was a sophomore. The three of us take this class together.\n\nAnd then Carrie reads all the books in the original Greek and Latin, goes to all the lectures. I read all the books in English and go to most of the lectures. My brother is kind of busy.\n\nHe reads one book of twelve and goes to a couple of lectures, marches himself up to our room a couple of days before the exam to get himself tutored. The three of us go to the exam together and we sit down and we sit there for three hours in our little blue notebooks. Yes, I'm that old.\n\nAnd we walk out and we look at each other and we say, how'd you do? And Carrie says, boy, I feel like I didn't really draw out the main point on the Hegelian dialectic. And I say, God, I really wish I had really connected John Locke's theory of property, the philosophers that follow. And my brother says, I got the top grade in the class.\n\nYou got the top grade in the class? You don't know anything. The saddest thing about all of this is that it's really hard to remember this. And I'm about to tell a story which is truly embarrassing for me, but I think important.\n\nI gave this talk at Facebook not so long ago to about a hundred employees. And a couple hours later, there was a young woman who works there sitting kind of outside my little desk and she wanted to talk to me. And I said, okay.\n\nAnd she sat down and we talked and she said, I learned something today. I learned that I need to keep my hand up. I said, what do you mean? She said, well, you're giving this talk.\n\nAnd then you said, you're going to take two more questions. And I had my hand up with lots of other people. And then you took two more questions and I put my hand down and I noticed all the women put their hand down.\n\nAnd then you took more questions only from the men. And I thought to myself, wow, if it's me who cares about this, obviously giving this talk during this talk, I can't even notice that the men's hands are still raised and the women's hands are still raised. How good are we as managers of our companies and our organizations at seeing that the men are reaching for opportunities more than women? We've got to get women to sit at the table.\n\nMessage number two, make your partner a real partner.\n\n(转录由TurboScribe.ai完成。升级到无限以移除此消息。)\n\n## Unit 3\n\n### warm up\n\n(转录由TurboScribe.ai完成。升级到无限以移除此消息。)\n\nThis, this is the 150th anniversary of the Civil War. How many have seen those Ken Burns documentaries on the Civil War? Have you seen them? Fantastic! Well, you should watch them. They're just fantastic. \n\nAnd thank God for people like Ken Burns, who research every historical fact. Because I've learned from doing these jay walks where we talk to people on the street. You don't want to rely on the average American for a history lesson.\n\nSo to prove my point, we took answers from jay walks we've gotten over the years. And we made our own documentary. But it's based on what these people say actually happened in American history.\n\nWhat is July 4th famous for? The celebration of independence. Independence from whom? Mexico. Mexico.\n\nIn 1775, Generales George Washington led 13 colonies to war against their mother country Mexico to gain independence. The uprising had its roots in one significant act of defiance, the Boston Taco Party. Fearing the newly formed United States to try to expand their country, Mexico built a wall along the border to keep Americans out.\n\nWho is this? Armick? Jefferson? What's his first name? George? In 1776, the Declaration of Independence was written by a sitcom character named George Jefferson, a businessman who left the Harlem ghetto to open a chain of dry cleaners. He and his wife Wheezy later met with John Adams and Benjamin Franklin to finish the document in a deluxe apartment in the sky. There he penned these immortal words.\n\nWe hold these truths to be self-evident that all men include stupid, fat-headed, hungry crackers of creative equals. Who warned the British are coming, the British are coming? The British? In what proved to be a tactical era, the British sent horseback riders through the streets announcing they were to launch surprise attacks on American military bases. This version of events has been put into question by this political scholar, as she described Paul Revere's ride.\n\nHe warned the British that they weren't going to be taking away our arms by reading those bills and making sure that he's riding his horse through town. Sarah Palin, June 3rd, 2011 Who were Lewis and Klein? Superman and... In the early 1800s, Superman and his girlfriend Lois began an expedition across America to explore the uncharted west. No obstacle proved too great or a threat too dangerous, with Superman along for the dream.\n\nWhat made the Alamo take place? 18-something. 18-something? About when? 37. Close, 36. \n\nVery good. Who fought there? John Wayne. In 1836, Jim Bowie, Davey Crockett, and Academy Award-winning actor John Wayne fought valiantly against Santa Ana and his army at the Alamo.\n\nHis experience helped him later when he returned to Hollywood to play Davey Crockett in the 1960 film The Alamo. John Wayne recalled. The producer almost fired me when I refused to do things in the script that weren't accurate.\n\nI told him, I was there, pilgrim, so you can kiss my ass. During what war was the battle of Gettysburg fought? World War II. World War II. \n\nWhat was the Gettysburg address? It was made by Washington. At the remarkable age of 207, George Washington gave Abraham Lincoln's famous Gettysburg speech to Allied troops in World War II. Said Army Private Baylor Hunt Rhodes that day.\n\nIt was inspiring to see a president I thought was dead give a speech from the Civil War. Although we often begged us to shoot him and put him out of his misery. May 8, 1944.\n\nImmediately after the speech, Washington had his wooden teeth replaced with dentures. Who fought in the Civil War? The North and the South. Who won that one? Unfortunately, the South.\n\nBy the beginning of 1865, when it became clear the South was going to win the war, every single African-American said screw this and fled the rebel states. Thus bringing the North many important cultural milestones. When was Pearl Harbor? A long time ago.\n\nBut what was it? What happened? It was bombed by the Hawaiians. It was bombed by the Hawaiians? Without warning, on December 7, 1941, Hawaii conducted a surprise attack on itself. The assault on Pearl Harbor was so devastating, the U.S. declared war on Hawaii.\n\nOk, so finally in 1945, George Washington, the man who liberated us from Mexico, who was guided by the great words of Wheezy and George Jefferson, and inspired by his idol, John Wayne, sent Superman to free Hawaii from Hawaii, thus ending World War II.\n\n(转录由TurboScribe.ai完成。升级到无限以移除此消息。)\n\n### Unit3 Story of us\n\nShiploads of businessmen and true believers are crossing the Atlantic Ocean to create a new world. May 1610, 120 years after Columbus, it's still a perilous journey. One ship, the Deliverance, carries a cargo that will change America forever. On board is John Rolfe. A 24-year-old English farmer. Ambitious, self-reliant, visionary, a born entrepreneur. What takes us six hours today by plane was then a voyage of more than two months. Seven of the early adventurers out of every ten will be dead within a year. But the risks are worth it. North America is the ultimate land of opportunity. A continent of vast, untapped wealth, starting with the most valuable resource of all, land. What will be home to more than 300 million people lies under a blanket of forest covering nearly half the land, more than 50 billion trees. \nFurther west, 9 million square miles of vast American wilderness. 60 million bison roam the plains. And underground, there are rumors of gems. Silver. and the largest seams of gold in the world. The settlers expect nothing less than El Dorado. But what Ralph finds at the English settlement of Jamestown is hell on earth. More than 500 settlers made the journey before Rolf. Hello? Hello? Barely 60 remain. It's called The Starving Time. \n\n---\n\n### Unit3 part2 text2\n\n**The Mayflower vayoge**\n\nThe Atlantic Ocean separates Europe and the new continent. Almost 400 years ago, a British ship sailed for two months and crossed this ocean and lowered its anchor in this Plymouth area. This is the Mayflower. It was a commercial ship mainly carrying wine between England and France. It has been said that the arrival of the Mayflower was the beginning of America. Approximately 100 feet in length and only 25 feet wide, Aboard this small ship were 102 passengers and 26 crew members. It consisted mainly of Puritans, a group of people who sought a strict and aesthetic faith. Most of them were farmers from the suburbs of London. Having been persecuted in England, where the Anglican Church, linked closely to the royal family, was the mainstream, \nThey headed for the new continent for freedom of faith. But of the 102 immigrants, only 41, which was less than half, were Puritans. The rest had various motives, many scheming to strike gold in the new land. But before they even make it to shore, they encounter their first crisis. The non-Puritans sought to take separate ways. So, the leaders of the Puritans drew up a pledge and suggested that they all sign it. This pledge was for all the immigrants to have law, a constitution for all to abide by, in order to create a new society. This document was later referred to as the Mayflower Compact. it is said that this document originated the spirit of American foundation. The document was signed by all 41 men, not including children. Some were people of lower class who came with their masters. This Mayflower compact acted as a bond between \npeople of different faiths and social status. \n\n### part2  text3\n\nAbout 27 miles northwest of Plymouth is Boston. The settlement began 10 years after the Mayflower arrived at Plymouth. Since then, this city historically developed as the core of New England. Boston also staged a major historical event, the American Revolutionary War. Walking through the back streets, the appearance of this serene ancient city can still be found. Every year in April, the Boston Marathon is run. Since its opening, in 1897, it is the longest running marathon event in the world. The marathon originated when a messenger ran a long distance back in ancient Greece. It is said that the Boston Marathon was also taken after a great messenger that ran through this land. was Paul Revere. He is the one Revolutionary War hero that everyone in America knows. In the mid-18th century, Boston had grown to become the largest city among the American colonies. It also became the center of the Revolutionary War. It has left its mark all over the city until this day. \nthe British colonial government was established here at that time. In 1770 an incident occurred in front of this building that sparked the American Revolutionary War. It was the Boston Massacre. British troops fired at a mob of people rebelling against British control and killing five civilians. This is the famous engraving that spread the news all over the colonies and turned public opinion towards independence. The man who created this engraving was Paul Revere. Three years after the Boston Massacre, the famous Boston Tea Party occurred. Citizens who opposed the taxation of tea, disguised as Native American Indians, boarded the ship and dumped all the tea into the sea to protest. Paul Revere was part of a rebel squad that consisted of 60 men involved in that mission. Revere was also a messenger, racing on horseback between Philadelphia, New York, and Boston, playing a huge role in influencing the Patriots' movements. \n\n---\n\nNorth End. The serene city streets are preserved as a historical district. \nPaul Revere's house still remains in this area. It is the oldest wooden house in Boston. Born in the North End District, Revere, at the age of 37, bought this house and made it his home. Paul Revere was a silversmith. It was a family business that his father, an immigrant from France, began. This silver tableware was made by Revere. His craftsmanship was said to be of the highest quality. The copper engraving of the Boston Massacre was a reflection of his fine craftsmanship as a silversmith. Soon, Revere became a representative craftsman, taking part in America's independence movement. But after all, he was just a silversmith. The reason why he is considered a hero of the War of Independence is because he contributed to the Revolutionary War \ncarrying vital information from Boston on horseback in the middle of the night. This event was expressed in a poem written by the great American poet Henry Longfellow which led to Revere's fame. The now famous The Midnight Ride of Paul Revere is well known nationwide. \n\n\n\n(转录由TurboScribe.ai完成。升级到无限以移除此消息。)\n\nIn the heart of the city is Boston Common. This is the first park ever to open in America. At that time, over 3,000 British troops were stationed here.\n\nThey were actively preparing to take control of the Patriots. And, on the night of April 18, 1775, the British troops began their stealthy mission. They were headed for Concord, approximately 16 miles to the northwest.\n\nThey attempted to seize the Patriots' weaponry there. Revere and his comrades sensed their scheme at once. This is the Old North Church that was used by Revere to signal the Patriots.\n\nThe church tower at the time was the tallest establishment in Boston. Revere attempted to notify his comrades in the Boston suburbs that were closest to Concord. Directed by Revere, the comrades sent a signal by lantern to notify the beginning of the British stealth mission.\n\nBut there was no way of making sure that the message had been received. At that point, Revere decides to head for Concord himself. But the river along the road to Concord was betrothed and blocked by British battleships that night.\n\nRevere somehow managed to slip by the British patrol and rose to the opposite shore. And with muffled oar, silently rode to the Charleston shore. Just as the moon rose over the bay, where swinging wide at her moorings lay, the Somerset, British Man of War, a phantom ship with each mast and spar across the moon like a prison bar.\n\nOnce Revere made it to the opposite shore, he mounted the horse that his comrades prepared and rode 16 miles to the Patriots' strong point in the middle of the nights. A hurry of hooks in a village street, a shape in the moonlight, a bulk in the dark. The fate of a nation was riding that night.\n\nAlong the way, Revere shouted the urgent message. This midnight call allowed the Patriots to prepare for a counterattack and to prevent the British troops from seizing their weapons.\n\n(转录由TurboScribe.ai完成。升级到无限以移除此消息。)\n\n\n\n### Columbus\n\nChristopher Columbus, the man who found America. Tierra! Tierra! Land! Land! The call, loud and clear, sang out from Rodrigo de Triana. Look out on the Caravel Pinta, sailing half a mile ahead of Santa Maria, flagship of Master Mariner and adventurer Christopher Columbus.\n\nA stern was the smaller boat, Niña. It was 2am, October 12, 1492. Over four weeks since Columbus and his small fleet of three boats had left the last landfall of Tenerife behind them and sailed into the unknown of the deep Atlantic.\n\nOver there, far to the west believed Columbus was a route to the Indies, India and Cathay, as China was known. Lands of great riches and spices and opportunities. The first man to discover the sea route, safer and quicker than the slow and dangerous land route to the east, would make fortune and fame for himself and for his country.\n\nIt was this dream that had possessed Columbus for ten long years. Though born in the Italian town of Genoa, he had travelled first to Portugal and then to Spain to find a sponsor for his idea. Finally, his enthusiasm and personality had convinced Isabella, the Queen of Spain, to back him and provide him with enough funds to create a small fleet to sail west, west and further west until he hit land.\n\nThe nerves of his sailors had proved as big an obstacle as the strange seas and the unpredictable weather. Shortly before land was sighted, the sailors had been on the point of mutiny, wanting to force Columbus to return. After all, Columbus had told them that he expected landfall in less than two weeks.\n\nAfter three weeks, the sailors began to grumble. After four weeks, without sight of land, they wanted to return. On October the 9th, Columbus promised his captains that if land was not sighted in three days, he would order the ships to turn and head back east.\n\nBut he had seen flocks of birds fly overhead. Then he saw branches with green leaves and flowers in the water. The anticipation grew as the three ships ploughed through the strong swell, and the history of mankind was changed by that excited call of Tierra, Tierra, in the sharp moonlight.\n\nWhen Admiral Columbus landed on the beach of the San Salvador, as he called the island, he thought he had arrived at the Indies, and called the first native people he met Indians. In fact, he had made landfall on a small island of the Bahamas off the coast of South America. He was entranced with the islanders, whose simplicity and honesty made him call them children of nature.\n\nThey were largely naked, but had little pendants of pure gold hanging from their noses. It was very different to the bustling advanced culture of the east Columbus had expected to find, but he was not disappointed. If he just sailed a bit to the south or to the west, he thought he would perhaps find Japan or China.\n\nBack in his flagship, Santa Maria, he started to explore the Bahamas. He needed to find hordes of gold and spices to please his royal Spanish sponsors. He landed in Cuba, saw people with a firebrand in their hand and breathing in the smoke, the first sight of cigars, but no gold.\n\nHe continued sailing and landed on Hispaniola, the present-day Haiti and the Dominican Republic, and here, fortunately, he found more evidence of gold worn by the Tenos, a largely gentle people. Christmas Day, 1492, found the fleet in a small harbour, but the Santa Maria had gone aground on a reef. All attempts to refloat it the following day were doomed and the flagship was lost.\n\nBut Columbus took it as a sign and decided to found a colony at that spot. Navidad, Christmas Town, was the first attempt at a settlement on the other side of the Atlantic by the Spanish explorers. With the town fortified in a few days, Columbus set off back to Spain in the Niña, convinced that he had found a source of gold and spices, and as a devout believer in the Catholic Church, great potential for converts.\n\nOn board, he carried 11 islanders from Hispaniola, as extra proof of the lands he had discovered. By brilliant navigation, despite only having very primitive instruments to check speed and position on the open sea, Columbus made it back to Europe, first arriving in Portugal, having survived a storm. He finally sailed around Capes and Vincent and arrived in Spain 224 days after he left.\n\nOf this voyage, I observe that the will of God hath miraculously been set forth, he wrote at the end of his journal, which he presented to the king and queen of Spain. He pointed out that he had succeeded despite the opposition he had faced in court as he tried to persuade Ferdinand and Isabella to invest in his idea, and his reward was a letter addressed to himself as Don Cristobal Colon, Admiral of the Ocean Sea, Viceroy and Governor of the Islands that he had discovered in the Indies, and funds for a second voyage. It was the happiest moment of his life.\n\n(转录由TurboScribe.ai完成。升级到无限以移除此消息。)\n\n---\n\n## News\n\n### Locusst Invasion\n\nacross the globe. Can mighty ducks help gobble up a problem with locusts? That is a question being asked in Southern Asia. Like the region of East Africa, the nation of Pakistan is trying to keep swarms of locusts from eating the country's crops. But while the insect invasion in Africa has been blamed on weather, experts say the one in Pakistan is a side effect of a civil war in the Middle Eastern country of Yemen. Because of that war, officials haven't been able to do enough pest control to keep Yemen's locust population from growing. So, the insects apparently multiplied and made their way northeast, eventually descending on Pakistan. Locusts don't directly attack people. They threaten us by eating our crops. And so many of these insects in such large numbers can destroy regional food supplies. That's why Pakistan declared a state of emergency early this month \nsaying it was dealing with the highest number of locusts in more than 20 years. So, what can be done about it? Some experts say pesticides are needed to kill masses of these insects. But there's another idea being considered in China. It may send ducks to Pakistan, as many as 100,000 of them, to fight the locusts by eating them. An expert interviewed by the Bloomberg Media Company says one duck can eat more than 200 locusts per day. and China has reportedly used ducks to successfully gobble up a locust problem in the past. But not everyone is on board with this. A member of China's delegation to Pakistan says there's not enough water in Pakistan's hot, dry climate to keep the ducks going. Whatever methods are used to control locusts in Asia, the situation in Africa is getting more desperate by the day. For three months now, swarms of desert locusts have been eating their way through East Africa. \nPeople bang utensils to try and ward off an increasing menace to their livelihoods. All to no avail. The locusts keep coming. A voracious appetite means these locusts eat the equivalent of their own body weight in a single day. And they move with speed on the changing winds. As far as 150 kilometers, almost 100 miles a day. Beans, maize, pasture for animals. Nothing stands a chance. Raising fears over food security as the farmlands are decimated. And they keep breeding, laying their eggs in the earth in pastoral and agricultural lands. Across East Africa, locust swarms of biblical proportions have been threatening life and grazing land and eating all the people's crops. Here you can see these hoppers are the new generation that will pose a bigger threat to agriculture in Kenya. The war against the locust is now in full swing. If the swarms aren't stopped, \nThe UN says they can multiply as much as 500 times by June. So the Kenyan government and UN agencies are fighting back with pesticides. In Isiolo, northeastern Kenya, villagers tell us they're seeing billions of newly hatched locusts. How did this happen? After years of drought, two cyclones hit East Africa in as many years. But the heavy rains made the wet earth ideal breeding ground for locusts. \n","categories":["NJUCS","Others"]},{"title":"BeingMortalBookReading","url":"/posts/7c4a027872e1/","content":"\n# Being Mortal 最好的告别：关于衰老与死亡，你必须知道的常识\n\n《Being Mortal》\n\n[阿图·葛文德](https://zhida.zhihu.com/search?content_id=170038812&content_type=Article&match_order=1&q=阿图·葛文德&zhida_source=entity)\n\n最近读到一本书，关于衰老与死亡的现实讨论。未读之前，从未想过延长生命的长度与增加生命的温度这类沉重的话题。读过之后，也不禁思考：如果要在生命的长度与生命的质量之间做选择，我的选择又会是怎样的呢？\n\n不得不说，当在生命临近终点时，具有清晰的意识可以进行自主选择也算是幸运的吧。大多数人可能还没有来得及思考或者说从未思考过，生命的选择权已经落在了他人的手中，面临死亡的人，需要做出选择的人，无疑都是痛苦的，挣扎的。\n\n很喜欢文章的一句话：“**接受个人的必死性，清楚了解医学的局限性和可能性，这是一个过程，而不是一种顿悟**。”虽然这仍是我不想面对的话题，但是现在的我想要更加善待我的人生，我的父母，我身边珍贵的人……在有限的时光中书写一个完整的故事。\n\n## **自序：一介凡夫**\n\n生的愉悦和死的坦然都将成为生命圆满的标志。但是任何一个人在死亡降临的时候，都是无法舍弃求生的欲望的。就像书中所讲，我们大多数人在面临死亡时，只是将命运交由医学、技术和陌生人来掌控。应该如何优雅地跨过生命的终点？在我看来，这本就是一个没有答案的问题，每个人仅有一次生命体验，也仅有一次选择的机会，至于最后是否是优雅的归属，只有当事人心里最清楚吧。\n\n## **1.独立：活到100岁的代价**\n\n现代的社会老龄结构已经改变了，作为儿女，大多数人已经无法像以前的祖辈那样，整个家族生活在一起，老人作为家中的权威受到子女的尊崇，可以按照自己的意愿生活，并得到家人充分的照顾。现状就是越来越多的老年人独居或者住进了养老院，当无法维持独立生活的状态，子女又没有时间精力进行照料，好像养老院是一个普遍的选择。\n\n## **2.崩溃：接受变老这件事**\n\n这章我最喜欢的一节是：脚才是老年人真正的危险。作者举到一个病人简·嘉福丽尔斯的例子，一个85岁的老奶奶，一个人独自生活，手指甲修剪的整整齐齐。在询问之后，老年病学家却花大量时间检查她的脚。看起来衣冠楚楚的老年人，但是由于身体原因，其实是无法弯腰够到脚的。这位老年人面临的问题不是身体的疼痛，而是跌倒。导致跌倒的危险因素：平衡能力差，服用超过4种处方药和[肌肉乏力](https://zhida.zhihu.com/search?content_id=170038812&content_type=Article&match_order=1&q=肌肉乏力&zhida_source=entity)。这些容易忽略的小细节，也许就是危险的紧急信号提示。总觉得看到这章的时候，脑海里想到最多的就是父母十年二十年后，我应该如何和他们一起接受他们变老这件事。\n\n## **3.依赖：我们为老做好准备了么**\n\n“老年是一系列连续不断的丧失”。在这之前，我从未想到对于老年人来说，丧失听力、记忆力，不得不放弃固有的生活方式是一件多么痛苦的事情。也许是因为无法感同身受，也许是巨大的年龄差异，我也曾陷入文中提到的误区，认为安全对于老年人来说才是最重要的。当他们不再有能力保护自己的时候，也许他们更加渴望可以找到其他的生活价值，而不仅仅是安全。\n\n## **4.帮助：适应从家到老人院生活的转变**\n\n[威尔逊](https://zhida.zhihu.com/search?content_id=170038812&content_type=Article&match_order=1&q=威尔逊&zhida_source=entity)的母亲的渴求是一扇能上锁的门，这扇可以上锁的门代表着她还拥有自己的生活和做自己的权利，但是在大多数养老院，老人们都是双人间，他们不得不要和陌生人住在一起，就像寄宿制的学生，期待可以回家，但是他们知道他们已经没有能力回家照顾自己了，只能依赖他人的帮助有质量的生活。\n\n我们如何使用时间取决于我们觉得自己还有多少时间。生命的脆弱性和面临衰老是一样的，重要的是观念，而不是年龄，当我们面临死亡威胁时，我们的生活目标和动机都会发生改变的，我们会重新对自己的欲望进行排序。生命的脆弱性就像天气一样，可以预测却无法预料。\n\n## **5.更好的生活：抗击疗养院的三大瘟疫**\n\n厌倦感、孤独感和无助感，这何尝不是大多数老年人面临的困境，想一想，许多留守老年人、留守儿童、身在异乡的人们都会经历这些感受吧~我们的[生命属性](https://zhida.zhihu.com/search?content_id=170038812&content_type=Article&match_order=1&q=生命属性&zhida_source=entity)天生就是互相依赖的。\n\n“当人们意识到生命有限，他们就不再要求太多。他们不再寻求更多的财富，不再寻求更多的权利。他们只要求，在可能的情况下，被允许保留塑造自己在这个世界的生命故事的权利。”\n\n## **6.放手：什么时候努力医治，什么时候放弃治疗**\n\n善终服务。标准医疗和善终护理的区别在于优先顺序不同，善终服务的目的是为了让患者在当下享有可能的最充分的生活，在作者给出的案例中，善终服务不仅提高了患者的生而为人的生活质量，部分患者还延长了生命的长度，而不仅仅是通过手术和[化疗](https://zhida.zhihu.com/search?content_id=170038812&content_type=Article&match_order=1&q=化疗&zhida_source=entity)的方式延长生命。至少有一点值得我思考的是，当人们在接受化疗等手术方案时，希望的是可以延长10年或者更长时间的寿命，有时为了有机会获得未来的时间而不得不牺牲掉现在生活的治疗。比如化疗的副作用等，但是善终服务更加关注患者当下的感受，他们会停止在医院的战斗，返回家中，[善终服务](https://zhida.zhihu.com/search?content_id=170038812&content_type=Article&match_order=5&q=善终服务&zhida_source=entity)的团队会了解患者当下的需求，也会有专门的医务人员定时上门提供[医疗服务](https://zhida.zhihu.com/search?content_id=170038812&content_type=Article&match_order=1&q=医疗服务&zhida_source=entity)。作者也指出，是否参加善终服务本质上并没有应该癌症患者的存活时间，甚至有些病人似乎还延长了存活时间。[姑息治疗](https://zhida.zhihu.com/search?content_id=170038812&content_type=Article&match_order=1&q=姑息治疗&zhida_source=entity)也体现出更多人性的温暖。只有不去努力获得更长，才能够获得更长。这一充满禅意的结论，我还真的是无法理解到这个境界。\n\n## **7.艰难的谈话：为迎接生命的终点谋求共识**\n\n作者的父亲都是医生，但是在面临父亲身体出现巨大变故时，他们和普通人一样，也会不知所措，在众多选择中权衡利弊，很显然，治疗的方案时何其的多，他们可以进行各种医疗的尝试。但是作者的父亲很幸运遇到了一位解释型的医生，[爱德华](https://zhida.zhihu.com/search?content_id=170038812&content_type=Article&match_order=1&q=爱德华&zhida_source=entity)·本泽尔，他能够给予患者及时的共情，并在患者的角度上给出治疗方案。肿瘤是必须要切除的，但是考虑到手术的风险，他建议等到症状威胁到其正常生活时再进行，得益于这位医生，他的父亲又度过了几年有价值的生活，而不是躺在床上靠药品度日。这就像一个[黑匣子](https://zhida.zhihu.com/search?content_id=170038812&content_type=Article&match_order=1&q=黑匣子&zhida_source=entity)，同一个患者，没有办法进行科学的对照，我们无法知道哪一种方案时最合适的，但毫无疑问的是，患者感到舒适的应该是最佳的方案吧。\n\n## **8.勇气：最好的告别**\n\n**善终不是好死而是好好活到终点。**\n\n![img](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/v2-4d541067a0958d7c991355da75b0dfc5_1440w.jpg)\n\n\n\n老年人和年轻人有什么区别呢？除了身体机能的衰老，他们也同样渴望追求有价值的生活。第一次读关于死亡的书，书中很多真实的例子和观点值得我去思考，作为健康、充满活力的年轻人，我应该要如何去善待生命。当父母垂老之时，我希望那时的我可以更多的尊重他们的意愿，帮助他们生活的更有快乐。\n\n生命这个大轮回，我来时，你守我；你老时，我护你。\n\n本文源自知乎：[Being Mortal 最好的告别：关于衰老与死亡，你必须知道的常识 - 知乎](https://zhuanlan.zhihu.com/p/368592240)\n\n---\n\n# Story sample\n\n1.   约瑟夫 p4  儿子最后放弃治疗\n2.   我的爷爷斯塔拉姆·葛文德（印度）在前现代社会，能够按照自己的意愿生活（而非送到养老院）“他得以按照自己的意愿生活，一直到死，家人都陪在他身边。”\n3.   爱丽丝晚年： 步履不稳，健忘，失能。搬到老年社区，但是不喜欢。（主要内容在第三章）最后要强地死去（没有惊动别人，安静地死去）\n4.   简-嘉福里尔斯 p35 晚年要强，被威胁了但是也没有告诉别人\n5.   布鲁道（医生）说，医生的工作是未付病人的生命质量p38\n6.   菲力克斯（研究老年病学，也已经年老）自己经历几次手术，妻子也身体不好（失明了）。退休不再行医，搬到高端退休社区。还能开车。身体状况不错。妻子贝拉圣体每况愈下，最后被迫去了疗养院，但是菲利克斯不满意。\n7.   路-桑德斯，晚年住到了女儿的家中，但是给家中带来了很多麻烦（80页前）\n8.   威尔逊 提出辅助生活机构（由于母亲的经历）。\n9.   卡斯特洛（87页，第四章）\n\n\n\n# Some logics\n\n## 第一章\n\n现代社会的转型使得年轻人和老年人的关系发生改变\n\n1. **传统家庭养老模式**  \n   - 历史上老年人主要由多代同堂的家庭（尤其是子女）照顾，通常由特定子女（如小女儿）承担赡养责任。  \n   - 家庭内部自然形成养老支持系统，无需依赖外部机构（如疗养院）。  \n\n2. **现代社会的转变**  \n   - 家庭结构核心化（小家庭取代大家庭）削弱了传统养老支持。  \n   - 老龄化和医疗进步使老年人口比例增加，但老年人的社会地位下降（从权威角色变为需依赖医疗/机构的群体）。  \n\n3. **转变原因**  \n   - **人口结构变化**：长寿者增多，老年人不再稀缺，传统权威性减弱。  \n   - **文化价值观变迁**：从\"尊老\"转向独立个体化，养老责任转移至社会机构。  \n\n**关键对比**：  \n传统模式（如葛文德、狄金森家庭）→ 家庭内部自然赡养；  \n现代模式（如霍布森）→ 依赖个人或外部机构，家庭纽带弱化。\n\n## 第二章\n\n1.   变老是不争的事实\n\n2.   医生不喜欢老人\n\n3.   **老年病学医生严重短缺**  \n\n     - 全球范围内（尤其是美国），老年病学医生、护士、社工等专业人员数量不足。  \n     - 每年培养的老年病学医生（<300人）远低于需求，无法应对老龄化加剧的未来。  \n\n     1. **替代策略：培训初级医疗人员**  \n        - 老年病学专家（如博尔特）提议**培训初级护理医生、护士等**，使其掌握老年照护技能，而非仅依赖专科医生。  \n        - **挑战**：  \n          - 医学生对老年病学兴趣低（仅3%选修相关课程）。  \n          - 需政府资助，让老年病学专家转向教学而非直接诊疗。  \n\n     **关键结论**：  \n\n     - **“太晚”培养足够专科医生，但可通过系统性培训缓解危机**。  \n     - 需政策干预，将老年照护纳入基础医疗教育，以应对老龄化社会需求。\n\n\n\n## 第三章\n\n1.   有钱人、发达国家的养老社区：菲利克斯的妻子贝拉由于身体状态，被迫去了疗养院。“菲利克斯和贝拉还是觉得他们的存在令人气恼。有的护士把贝拉当成病人，而不是人。比如，贝拉有她喜欢的梳理头发的方式，但是没人问起，也没人明白。菲利克斯想出了使她容易吞咽的分切食物的最佳办法、她觉得舒服的安置办法、她喜欢的穿衣办法。但是，无论他怎么费力地跟护理人员解释，他们就是不明白要点。”\n\n     “我们（菲利克斯，贝拉和医护人员）相互妨碍”\n\n2.   养老社区太商业化了。\n\n3.   发展中国家的穷人、传统的救济院：传统救济院是缺乏家庭或财富支撑的老年人的最后选择，但环境恶劣且充满道德歧视。\n\n     ```\n     除非家人能够收容这样的人，否则，他们只得去通常所谓的救济院(poorhouse)或者济贫院(almshouse)。这类机构几百年前在欧洲和美国就有了。如果年事已高、需要帮助，但是又没有子女或者独立的财富可资依靠，那么,救济院就是唯一的庇护所。救济院是冷酷、可憎、地狱般的地方—一这是当时的人的用词。这里住着各种类型的穷人——老乞丐、背运的移民、年轻的酒鬼、精神病人，其功能是令这些“犯人”改正他们被假定的酗酒放纵行为以及道德败坏。监管人员在布置工作的时候对老年乞丐一般比较宽大，但是，他们仍然像其他人一样被视为犯人。这些地方通常又脏又破。在这里，丈夫和妻子被分开，缺乏基本的身体保健。\n     ```\n\n4.   在爱丽丝的生命历程中，工业化世界的老年人得以脱离这种命运的威\n\n胁。经济繁荣使得即便穷人也能够指望入住提供一日三餐、专业健康服务、\n\n理疗和宾戈游戏的疗养院，它们使几百万人缓解了衰弱和老年之苦。适当的\n\n照顾和安全成为范式，其程度是救济院的“犯人”无法想象的。然而，大多\n\n数人仍然觉得，作为度过生命最后一程的地方，老人院是恐怖的、孤寂的、\n\n可憎的。我们需要、我们想要的更多。**核心逻辑概括：**  \n\n爱丽丝被迫离开熟悉的家，搬入养老机构（朗沃德）以换取安全和照护，但机构的规则和监控剥夺了她的自主性，使她感到被管制而非被支持。尽管子女和护工出于好意试图延缓她进一步失去独立性的可能（如雇佣私人助理），但这些干预仍不断侵蚀她对生活的掌控，凸显老年照护中**安全与自由的根本矛盾**。  \n\n（用一句话总结：**机构养老以安全为名剥夺了老年人的自主权，尽管子女努力缓解，仍难平衡照护与尊严。**）\n\n5、之后爱丽丝在社区家里跌倒，最后移到疗养院\n\n```\n她丧失了所有的隐私和控制力。大多数时候她穿着病号服。他们叫醒她她就起床，安排她洗澡她就洗澡，让她穿衣服她就穿衣服，叫她吃饭她就吃饭。她和院方安排的人住在一起。她有过好几个同屋，但是她们入住的时候院方都没有征求过她的意见。这些人都有认知障碍，有的很安静，也有的很闹腾，有一个人甚至吵得她整晚睡不着觉。她觉得像个犯人，仅仅因为老了就被投进了监狱。\n```\n\n爱丽丝所在疗养院内：老年人以“不合作”对抗机构规则以捍卫自主权，却被系统贴上“顽固分子”的标签——这种矛盾揭示了机构照护中**“服从效率”与“个体尊严”的根本冲突**。\n\n\n\n## 第四章\n\n1.   生活辅助机构：不是病人，而是房客。\n\n     ```cpp\n     核心观点：\n     \"辅助生活\"模式通过赋予老人对居住环境、日常规则及风险的自主权，从根本上颠覆传统养老机构的权力结构，使其在获得必要照护的同时，仍能保持\"在家\"的尊严与掌控感——即使面对健康衰退，个人选择（或代理人意志）仍优先于机构效率。\n     （一句话总结：\"辅助生活\"以住户自主性为核心，让老人在接受护理时仍做家的主人，而非被体制化的病人。）\n     ```\n\n2.   老了以后，是什么使得生活值得活下去？p87页左右。老年人和那些正处于死亡边缘（或者处于死亡的恐惧中）有相同的地方：\n\n     ```\n     托尔斯泰看出了那些与生命的脆弱性相抗争的人与不抗争的人之间的观念鸿沟，他也把握到了只能独自承受这个认识所带来的特定痛苦。但是，他还看到了别的：即便死亡的威胁使我们重新对欲望加以排序，但这些欲望也并非不可以满足。虽然伊万·伊里奇的家人、朋友和医生不理解他的需求，他的仆人盖拉西姆却能懂得。盖拉西姆觉得伊万·伊里奇是一个痛苦、畏惧、孤独的人，并对他满怀同情。他也意识到有一天自己也会遭遇主人同样的命运。其他人躲着伊万·伊里奇，盖拉西姆却同他闲聊。当伊万·伊里奇发觉只有把衰弱的腿放到盖拉西姆的肩头才可以缓解疼痛的时候，盖拉西姆为了让他舒服，整个晚上坐在那儿。他不介意他的角色，即便他不得不把伊里奇从便桶上抱上抱下，在他便溺完后给他擦屁股。他在提供照顾的时候不带任何算计和欺骗，也不强加任何超出伊万·伊里奇愿望的目标。这对于伊万·伊里奇渐趋衰弱的生命关系重大：\n     \n     ```\n\n     \n\n\n\n\n\n\n\n\n\n---\n\n## 🗣 Team Presentation: *Being Mortal*\n\n### My Section – End-of-Life Care (2–3 Minutes)\n\n​\tHello everyone, I’ll be sharing with you one key theme from *Being Mortal*: **end-of-life care** — how we approach the final stage of life.\n\n​\tAtul Gawande, being both a doctor and a son, realized that medicine often fails when people reach the end. \n\n​\tInstead of helping them live well in their final days, the system keeps focusing on **treating and extending life**, even when it's no longer helpful.\n\n---\n\nOne powerful story in the book is about **Sara Monopoli**, a young woman diagnosed with terminal cancer while pregnant. Although it was clear her illness was incurable, doctors kept offering aggressive treatments. She said, *“I don’t want to die in the hospital”*, but sadly, that’s where she died — connected to machines, in pain. This shows the cost of avoiding honest conversations.\n\n---\n\nIn contrast, Gawande shares a more hopeful story — about his **own father**, who had a spinal tumor. Instead of rushing into dangerous surgery, his father focused on what mattered: staying independent, avoiding paralysis, and spending time meaningfully. Later, he chose hospice care, and his final months were calm and dignified.\n\n---\n\nWhat Gawande learned is that good end-of-life care isn’t about giving up. It’s about **understanding what people really want** when time is short. Some want more time, but many want comfort, family, or simply to stay at home.\n\n>   As Gawande writes: *“Our ultimate goal is not a good death, but a good life — all the way to the very end.”*\n\nStudies he cites also show that patients who have early end-of-life discussions suffer less, make better choices, and often live longer. Their families also cope better after they pass away.\n\nSo in this part of the book, Gawande challenges doctors, patients, and families to **rethink what matters most at the end of life**. Not just survival, but dignity, meaning, and choice.\n\nThank you — and I’ll now pass it over to my teammate, who will explore...","categories":["NJUCS","Others"]},{"title":"Part1，chapter2 数据的机器级表示和处理","url":"/posts/d32785e30064/","content":"\n## 定点编码方式\n\n**原码、补码、反码、移码**\n\n-   2的31次方=2147438648；\n-   2的7次方为128\n\n2147438647用signed int来表示的时候是7FFF FFFF； 用unsigned int来表示也是7FFF FFFF。\n\n但是-2147483647用signed int来表示为8000 0001，如果强转为signed int那么结果为2147483649\n\n并且-2147483648强转为unsigned之后还是2147483647\n\n\n\n## 浮点编码方式\n\n**IEEE754标准**\n\n32位浮点数：1+8+23       \n\n64位浮点数：1+11+52\n\n阶码为移码，偏置常数为127；尾数是原码，默认前导1；符号为1位，0代表正数，1代表负数；\n\n>   127刚好是0111 1111！！\n\n**规格化数**：\n\n规格化的方法： 将尾数部分进行左规或者右规，直到\n\n对于32位的浮点数，**绝对值最小的非规格化数**为$2^{-149}$ 次方！因为非规格化数的阶码为0（即$2^{-127}$）且不含默认的前导1\n\n能够精确地表示 阶码*（1+n个$2^{-23}$)\n\nfloat能够表示的有效位数约为7位，而double为15位\n\n\n\n## 数据宽度和存储\n\n**字长和字**\n\n字用于度量数据类型的宽度，比如XX数据类型宽度是双字/是单字\n\n字长是数据通路的宽度\n\n\n\n\n\n**大端和小端模式**\n\n对于某个数据（以int型为例），其可能占用多个字节，其地址位是 LSB还是MSB决定了其是BigEndian还是LittleEndian。\n\n大端BIgEndian，先读取最高位有效字节（因为大端低地址放的是最高有效字节）\n\n小端LittleEndian，先读取最低位有效字节（因为小段地址存放的是最低有效字节）\n\n比如说，0x12345678，占四个字节，如果小端机器的话，从低字节从高字节读取出来是78->56->34->12\n\n>   因此，如果是小端机器要读取一个立即数，都要注意正确读法！\n\n如果是大端机器，那么读取出来是12 34 56 78（因为12是MSB，大端机器从12开始）\n\n\n\n\n\n**浮点数相加减**\n\n先对阶，小阶对大阶，如果阶差大于25，则出现**大阶吃小阶**的情况\n\n两个移码的加减法得到的不是两个数加减法之后的移码！！！\n\n那为什么阶码不使用补码，而是使用补码？一个好处是，可以通过直接比较阶码的机器数来判断大小\n\nIEEE754规定，浮点数运算的中间结果必须要有两位附加位（分别称作“保护位gaurd”和“舍入位round”）\n\n在IEEE754中规定：**01舍，11入，10结果为偶数**\n\n1.1101**10**-> 1.1110（为了让结果为偶数）\n\n\n\n>   浮点数只能表示有限个数字，比如float在754标准下，在[1,2)之间可以表示$2^{23}$次方个数，每一个数字的间隔是$2^{-23}$.\n>\n>   float可以表示的数字最大到$2^{127}*(2-2^{23})$，而int最多才$2^{31}-1$ 到$-2^{31}$ ，把int转换成float会出现一些精度的舍入（因为只有23位的尾数，但是int有32位，但是转成double的话是可以的）\n\n浮点数的运算满足交换律：a+b=b+a，但是不满足结合律，比如a+b-c!=a-c+b，因为存在**大数吃小数**的情况\n\n\n\n**Kahan累加算法**：大量浮点数累加算法\n\n不能直接用float来进行大规模的浮点数累加，避免大数吃小数的现象。\n\n在对阶的时候，如果一个数字非常的大，两外一个数字非常地小，常常由于精度问题，导致较小的一个数字出现低位被省略的情况。\n\n**可能出现a+b-a!=b**\n\nKahan算法的核心思想，用一个数字来记录误差值，详细见[Kahan 求和 - OI Wiki](https://oi-wiki.org/misc/kahan-summation/)","categories":["NJUCS","ICS计算系统基础"]},{"title":"计算机系统基础：第一课","url":"/posts/e28a9744cd3e/","content":"\n授课老师：唐杰、刘杰\n\n计算机系统基础：清楚理解计算机是如何生成和运行可执行文件的！\n\n考试：高级代码+汇编代码\n\nPa（30%）+期末（50%）+Lab实验和习题、小测试（各10%）\n\n---\n\n三个主题：\n\n-   Representation:\n    -   不同数据类型在寄存器和存储器之间如何表示和存储\n    -   指令如何表示和白拿\n    -   存储地址如何表示，如何生成复杂数据结构中的数据元素的地址\n-   Translation&Link\n    -   高级语言程序对应的机器级代码是怎样的，如何合并成可执行文件\n-   Control Flow\n    -   计算机所能理解的程序是如何组织和控制的\n    -   如何在计算机中组织多个程序的并发执行？\n    -   逻辑控制流中的异常时间及其处理\n\n平台：IA-32+linux+gcc\n","categories":["NJUCS","ICS计算系统基础"]},{"url":"/posts/4ebd3f4126c8/","content":"\n## 遇见的问题\n\n**ssh连接失败**\n\n貌似是梯子的问题，clash开了tun模式，之后关闭梯子即可正常使用。\n\n\n\n\n\n## 必做题\n\n### **状态机**\n\n```\n// PC: instruction    | // label: statement\n0: mov  r1, 0         |  pc0: r1 = 0;\n1: mov  r2, 0         |  pc1: r2 = 0;\n2: addi r2, r2, 1     |  pc2: r2 = r2 + 1;\n3: add  r1, r1, r2    |  pc3: r1 = r1 + r2;\n4: blt  r2, 100, 2    |  pc4: if (r2 < 100) goto pc2;   // branch if less than\n5: jmp 5              |  pc5: goto pc5;\n```\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250901210018927.png\" alt=\"image-20250901210018927\" style=\"zoom:50%;\" />\n\n```text\n回答：(0,x,x)->(1,0,x)->(2,0,0)->(3,0,1)->(4,1,1)->(2,1,1)->(3,1,2)->(4,3,2)->......->(2,4851,98)->(3,4851,99)->(4,4950,99)->(2,4950,99)->(3,4950,100)->(4,5050,100)->(5,5050,100)->...# 不断循环这个\n```\n\n### **宏Macro**\n\n>   kconfig生成的宏与条件编译\n>\n>   我们已经在上文提到过, kconfig会根据配置选项的结果在 `nemu/include/generated/autoconf.h`中定义一些形如`CONFIG_xxx`的宏, 我们可以在C代码中通过条件编译的功能对这些宏进行测试, 来判断是否编译某些代码. 例如, 当`CONFIG_DEVICE`这个宏没有定义时, 设备相关的代码就无需进行编译.\n>\n>   为了编写更紧凑的代码, 我们在`nemu/include/macro.h`中定义了一些专门用来对宏进行测试的宏. 例如`IFDEF(CONFIG_DEVICE, init_device());`表示, 如果定义了`CONFIG_DEVICE`, 才会调用`init_device()`函数; 而`MUXDEF(CONFIG_TRACE, \"ON\", \"OFF\")`则表示, 如果定义了`CONFIG_TRACE`, 则预处理结果为`\"ON\"`(`\"OFF\"`在预处理后会消失), 否则预处理结果为`\"OFF\"`.\n>\n>   **这些宏的功能非常神奇, 你知道这些宏是如何工作的吗?**\n\n**回答：**\n\n在macro.h的文件中，对`IFDEF`和`MUXDEF`的定义为：\n\n```c\n// simplification for conditional compilation\n#define __IGNORE(...)\n#define __KEEP(...) __VA_ARGS__\n// keep the code if a boolean macro is defined\n#define IFDEF(macro, ...) MUXDEF(macro, __KEEP, __IGNORE)(__VA_ARGS__)\n// keep the code if a boolean macro is undefined\n#define IFNDEF(macro, ...) MUXNDEF(macro, __KEEP, __IGNORE)(__VA_ARGS__)\n// keep the code if a boolean macro is defined to 1\n#define IFONE(macro, ...) MUXONE(macro, __KEEP, __IGNORE)(__VA_ARGS__)\n// keep the code if a boolean macro is defined to 0\n#define IFZERO(macro, ...) MUXZERO(macro, __KEEP, __IGNORE)(__VA_ARGS__)\n```\n\n可以看到__IGNORE和      _ KEEP宏分别就是将传入的参数全部去掉或者全部保留。\n\n而IFDEF则通过调用由boolean macro来决定是保留还是舍去。\n\n而这里的MUXDEF的实现**更加巧妙**：\n\n```c\n#define CHOOSE2nd(a, b, ...) b\n#define MUX_WITH_COMMA(contain_comma, a, b) CHOOSE2nd(contain_comma a, b)\n#define MUX_MACRO_PROPERTY(p, macro, a, b) MUX_WITH_COMMA(concat(p, macro), a, b)\n#define __P_DEF_0  X,\n#define __P_DEF_1  X,\n#define MUXDEF(macro, X, Y) MUX_MACRO_PROPERTY(__P_DEF_, macro, X, Y)\n```\n\n因为参数macro是一个boolean macro，因此结果一定是0或者1，而不论是0，还是1，经过concat之后，前面都会加上“__ P__DEF _”的前缀，最终变成`__P_DEF_0 `或者`__P_DEF_1`，但是这两个都变成了`X,`，那么被CHOOSE2nd选中的就将会是a。\n\n如果macro压根就没有被定义，那么macro对应的就是空值，因此concat之后的结果也是没有定义的（因为`__P_DEF_`没定义），因此也就不会哟“X,”的展开，那么b就是the second。\n\n也就实现了IFDEF和MUXDEF的效果：\n\n-   MUXDEF： 如果传入的macro被定义了，那么就选择a，否则就选择b\n-   IFDEF：如果macro被定义了，那就keep the code， otherwise ingnore the code\n\n>   Thanks to [nju-pa摸鱼记3-NEMU中宏的源码阅读 - Miao's Blog](https://miaohao-oops.github.io/2022/02/05/nju-pa摸鱼记3-nemu中宏的源码阅读/) . By the way, the author is not  a nju student.\n\n### **init_monitor函数**\n\n阅读`init_monitor()`函数的代码, 你会发现里面全部都是函数调用. 按道理, 把相应的函数体在`init_monitor()`中展开也不影响代码的正确性. 相比之下, 在这里使用函数有什么好处呢?\n\n使用函数可以使得代码更加清晰，模块分离，便于实现模块化设计。\n\n### parse_args()的参数解析，以及参数从哪里来\n\n```cpp\nstatic int parse_args(int argc, char *argv[]) \n```\n\n这里的argc是argument count，argv是argument vector；函数接受参数之后调用了getopt_long函数进行参数解析，按照传入的不同参数进行不同的解释。\n\n那么参数是哪里来的呢？通过`grep -nr 'init_monitor'`在ics2025/nemu下进行查找，发现调用`init_monitor`的地方为`src/nemu-main.c`\n\n在该文件的main函数接受了参数argc 和argv，并且原封不动地将这些参数传递到了init_monitor()中；而main函数接受的这些参数又来自运行可执行文件时的命令行参数。\n\nFor example, `./a.out arg1 arg2 arg3 `\n\n这里一共有4个参数，其中argv[0]是程序名(\"./a.out\")。 \n\n```cpp\n 16 #include <common.h>\n 17\n 18 void init_monitor(int, char *[]);\n 19 void am_init_monitor();\n 20 void engine_start();\n 21 int is_exit_status_bad();\n 22\n 23 int main(int argc, char *argv[]) {\n 24   /* Initialize the monitor. */\n 25 #ifdef CONFIG_TARGET_AM\n 26   am_init_monitor();\n 27 #else\n 28   init_monitor(argc, argv);\n 29 #endif\n 30\n 31   /* Start engine. */\n 32   engine_start();\n 33\n 34   return is_exit_status_bad();\n 35 }\n```\n\n###  究竟要执行多久?\n\n在`cmd_c()`函数中, 调用`cpu_exec()`的时候传入了参数`-1`, 你知道这是什么意思吗?\n\n**解答**\n\n调用cpu_exec(-1)的时候因为n的类型为uint64_t，因此将-1进行强制类型转换为2^64-1,之后传给execte()，在这里会run n遍execute_once()。\n\n在execute中通过添加调试打印，可以发现，在加载内置程序的时候只执行了4步，就执行了内置的Hit Good TRAP。\n\n>   添加  printf(\"Exectute Once, current pc is %u\\n\",s.pc);\n\n![image-20250912222331896](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250912222331896.png)\n\n###   优美地退出\n\n为了测试大家是否已经理解框架代码, 我们给大家设置一个练习: 如果在运行NEMU之后直接键入`q`退出, 你会发现终端输出了一些错误信息. 请分析这个错误信息是什么原因造成的, 然后尝试在NEMU中修复它.\n\n**解答**：\n\n目前程序在make run之后会出现:\n\n```bash\nWelcome to riscv32-NEMU!\nFor help, type \"help\"\n(nemu) q\nmake: *** [/home/yama/ics2024/nemu/scripts/native.mk:38: run] Error 1\n```\n\n说明程序以“1”退出了，回到`nemu-main`这个文件中，发现return的结果是：`is_exit_status_bad()`，而这个函数的的定义为：\n\n```c\nint is_exit_status_bad() {\n  int good = (nemu_state.state == NEMU_END && nemu_state.halt_ret == 0) ||\n    (nemu_state.state == NEMU_QUIT);\n  return !good;\n}\n```\n\n尝试打印中间变量发现，neum_state.state=1，对应的是enum { NEMU_RUNNING, NEMU_STOP, NEMU_END, NEMU_ABORT, NEMU_QUIT };中的NEMU_STOP，因此，错误**在于没有将nemu_state.state进行更改**或者是错误地将其赋值为了NUME_STOP\n\n使用grep查找：\n\n![image-20250912212040608](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250912212040608.png)\n\n发现在state.c中有这样一段逻辑：\n\n```c\nNEMUState nemu_state = { .state = NEMU_STOP };\nint is_exit_status_bad() {\n  printf(\"%d\",nemu_state.state);\n  int good = (nemu_state.state == NEMU_END && nemu_state.halt_ret == 0) ||\n    (nemu_state.state == NEMU_QUIT);\n  return !good;\n}\n```\n\n对nume_state进行了初始化，而此后通过grep指令搜索发现：\n\n```cpp\n~/ics2024/nemu pa1 !1 ?1 ❯ grep -nr 'nemu_state' | grep NEMU_STOP\ngrep: build/obj-riscv32-nemu-interpreter/src/isa/riscv32/inst.o: binary file matches\nsrc/cpu/cpu-exec.c:117:    case NEMU_RUNNING: nemu_state.state = NEMU_STOP; break;\nsrc/utils/state.c:18:NEMUState nemu_state = { .state = NEMU_STOP };\n```\n\n只有在初始化以及cpu-exec的代码中才会涉及到将nemu_state设置为NEMU_STOP的情况，~~但是我还没看懂其中逻辑~~。\n\n最后检查发现，在输入q的时候应该将state设置为quit：\n\n```c\nstatic int cmd_q(char *args) {\n  nemu_state.state=NEMU_QUIT;\n  return -1;\n}\n```\n\n成功实现**优雅地退出**\n\n![image-20250912214558229](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250912214558229.png)\n\n\n### 实现算术表达式的词法分析\n\n你需要完成以下的内容:\n\n- 为算术表达式中的各种token类型添加规则, 你需要注意C语言字符串中转义字符的存在和正则表达式中元字符的功能.\n- 在成功识别出token后, 将token的信息依次记录到`tokens`数组中.\n> [!NOTE] regex库快速了解\n\n## 补充：C语言拾遗\n\n**Spiral Rule** 螺旋法则\n\n[Clockwise/Spiral Rule](https://c-faq.com/decl/spiral.anderson.html)\n```c\n                      +-----------------------------+\n                      |                  +---+      |\n                      |  +---+           |+-+|      |\n                      |  ^   |           |^ ||      |\n                void (*signal(int, void (*fp)(int)))(int);\n                 ^    ^      |      ^    ^  ||      |\n                 |    +------+      |    +--+|      |\n                 |                  +--------+      |\n                 +----------------------------------+\n```\nsignal是一个函数：\n- 参数为：\n\t1. int\n\t2. 一个函数指针fp，fp指向的函数接受一个int作为参数，return为空\n- 返回值为：一个函数指针，接受参数为int，返回为空\n**建议**：使用 `typedef`，比如`typedef void (*sighandle_t)(int)`之后，再定义为`sighandle_t signal(int, void (*fp)(int));`\n\n","categories":["NJUCS","ICS计算系统基础"]},{"url":"/posts/73d05296abda/","content":"\n\n\n# PA0  Report\n\n## 实验进度\n\n我完成了所有的任务，包括：\n\n1.   前置学习：\n     -   vim\n     -   makefile\n     -   git\n2.   按照手册要求编译项目\n\n## 遇见的问题\n\n**zsh错误**\n\n我使用的shell是zsh而非bash，而代码中是默认只会给`~/.bashrc`的末尾加上环境变量\n\n```bash\nexport NEMU_HOME=/home/yama/ics2024/nemu\nexport AM_HOME=/home/yama/ics2024/abstract-machine\n```\n\n所以需要手动使用vim修改`~/.zshrc`\n\n**make出错**\n\n```bash\n~/ics2024/nemu pa0 ?1 ❯ make                                           22:02:40\nmake -C tools/capstone\nmake[1]: Entering directory '/home/yama/ics2024/nemu/tools/capstone'\nCloning into 'repo'...\nConnection closed by 198.18.0.63 port 22\nfatal: Could not read from remote repository.\n\nPlease make sure you have the correct access rights\nand the repository exists.\ncd repo && CAPSTONE_ARCHS=\"x86|mips|riscv|loongarch\" bash make.sh\n/bin/sh: 1: cd: can't cd to repo\nmake[1]: *** [Makefile:23: repo/libcapstone.so.5] Error 2\nmake[1]: Leaving directory '/home/yama/ics2024/nemu/tools/capstone'\nmake: *** [src/utils/filelist.mk:23: tools/capstone/repo/libcapstone.so.5] Error 2\n~/ics2024/nemu pa0 ?1 ❯                                                22:03:35 \n```\n\n出现了`Connection closed by 198.18.0.63 port 22`的错误\n\n发现198.18.0.63正是github的服务器ip，而port22是ssh连接所需要的端口，所以这波是使用ssh在连接clone code的时候出现了问题\n\n```bash\n~/ics2024/nemu pa0 ?1 ❯ ssh -T git@github.com                    ✘ HUP 22:09:06\nConnection closed by 198.18.0.63 port 22\n```\n\n问题就出现在这里\n\n我记得我明明早就做好了这一步？\n\n但是我重新将秘钥导入到之后，还是没用。\n\n![image-20250826222527425](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250826222527425.png)\n\n但是当我过了一段时间之后发现又可以了。猜测可能是网络环境的问题（比如代理等等）\n\n**git配置**\n\n项目要求使用自己的学号和名字作为git身份，但是我同时又想要使用 自己github的信息，所以只在ics2024仓库下配置了学号和名字，global的git身份仍然是和github信息一致。\n\n\n\n## 必答题\n\n**学习gdb**：\n\n```cpp\n~/tmp ❯ cat test.c                                                                                          5s 22:09:03\nint actual_calc(int a, int b){\n  int c;\n  c=a/b;\n  return 0;\n}\n\nint calc(){\n  int a;\n  int b;\n  a=13;\n  b=0;\n  actual_calc(a, b);\n  return 0;\n}\n\nint main(){\n  calc();\n  return 0;\n}\n~/tmp ❯ ls                                                                                                     22:09:07\ntest.c\n~/tmp ❯ gcc -ggdb test.c -o test.out                                                                           22:13:57\n~/tmp ❯ ./test.out                                                                                             22:14:21\n[1]    90785 floating point exception (core dumped)  ./test.out\n~/tmp ❯     \n```\n\n\n\n-   su认证失败是怎么回事?\n\n    >   开始我认为可能是密码输错了？\n    >\n    >   ```bash\n    >   ~ ❯ su                                                              5s 11:18:27\n    >   Password:\n    >   su: Authentication failure\n    >   ```\n    >\n    >   然后搜索发现：\"现在很多的Linux的桌面系统出于安全考虑，在默认安装后，root用户默认是被锁定了的，不允许登录，也不允许 su 到 root ，对于桌面用户来说这个可能是为了增强安全性，但是服务器版上确实有一大问题。\"\n    >\n    >   然后按照教程，成功解决问题：\n    >\n    >   ```bash\n    >   ~ ❯ sudo passwd                                                     7s 11:18:41\n    >   [sudo] password for yama:\n    >   New password:\n    >   Retype new password:\n    >   passwd: password updated successfully\n    >   ~ ❯ su                                                              8s 11:20:00\n    >   Password:\n    >   root@LAPTOP-24A7CVC0:/home/yama#\n    >   ```\n\n    \n\n-   grep提示no such file or directory是什么意思?\n\n    >   当然是没有想要找的那个文件\n\n-   请问怎么卸载Ubuntu?\n\n    >   如果是使用wsl的话，在cmd中运行：\n    >\n    >   ```bash\n    >   wsl --list\n    >   wsl --unregister Ubuntu-XXX # 换成要删除的系统\n    >   ```\n    >\n    >   如果是使用虚拟机的话，可以删除虚拟机\n    >\n    >   如果是装了系统的话，重新刷一个别的系统就行了\n\n-   C语言的xxx语法是什么意思?\n\n    >   我怎么知道xxx语法是什么意思？\n\n-   ignoring return vaule of 'scanf'是什么意思?\n\n-   出现curl: not found该怎么办?\n\n-   为什么strtok返回NULL?\n\n-   为什么会有Segmentation fault这个错误?\n\n-   什么是busybox?\n\n**写到一半突然发现原来不是叫我回答问题......这体现了RTFM的重要性！** 原来作业是写**读后感**\n\n​\t结合`提问的智慧`和Stop-Ask-Questions-The-Stupid-Ways之后，我对于提问的艺术有了更加深刻的把握。\n\n​\t在`提问的智慧`这一篇文章中作者讲到要在提问之前先写serach the fucking website看看是否可以从已经有的互联网上搜索到自己问题的解决方案，这是很好解决问题的思路。 但是现在ai时代，我认为还需要加上一句Ask the fucking model， 问大模型往往也是一个很不错的解决方案，学会合理的使用ai也是每个人必不可少的技能。从这个角度看，手册和这两篇文章具有一定的滞后性，考虑到都是n年前写的，倒也是挺合理的。\n\n​\t好的提问，应该要能够将自己所做过的尝试、项目的环境等等背景信息都清楚地给到，让回答者能够充分地理解问题。一个好的问题，就像一个精心准备的舞台，所有必要的道具和背景都已就位，就等主角登场。 你不能指望别人在你只给了一个模糊的舞台灯光下，就猜出你演的是哪出戏。你得告诉他，你用了什么语言，什么框架，遇到了什么报错信息，甚至最好能贴上你认为是核心问题的代码片段。这不是为了让别人帮你调试，而是为了让对方能快速定位到问题的本质。\n\n下面这个就是群里一个同学发的**好的提问**， 给出了清晰的说明和解释，帮助助教和老师定位问题\n\n![image-20250914203343422](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250914203343422.png)\n\n​\t提问的艺术，归根结底是一种沟通的艺术。 它要求你站在对方的角度去思考：我怎么才能让对方以最高效的方式理解我的困境？只给一个错误码，就像是我去食堂买放一样，我问阿姨有没有肉包，她说没有肉包，我指了指那个包子问她这个是什么，她说这个是鸡肉包。然后我说也许，接着阿姨就给我装了一个鸡肉包，但是我需要的打包好的肉包，于是还需要再次和阿姨讲清楚，实际上我们之间就存在着这样的不对称信息（~~没有对齐颗粒度~~），所有我们互相都误解了对方。。。\n\n​\t我很多时候在组织问题的过程中，就自己已经找到了答案。这种自问自答的过程，其实就是将一个混沌的思绪，通过逻辑的梳理，变得条理清晰。当你把自己的尝试、遇到的问题思考的过程都写下来时，你会发现，你对这个问题的理解已经上了一个台阶。就算最终还是要求助，你的问题也会变得更有质量，更值得被认真回答。因为你不仅是在寻求帮助，更是在展示你的思考能力和解决问题的态度。简单粗暴的问题，通常只能得到简单粗暴的答案s甚至得不到任何答案。\n\n​\t在做PA0的时候，我阅读了很多的文档（主要是PA的官方文档，和一些linux手册说明），来理解linux的一些基本指令、基本操作等等，在不断地阅读文档的过程中，，我渐渐地理解了阅读文档的重要性，通过阅读文档，按照文档的步骤和规范来进行操作，能够让我们更加深入地理解项目的细节，更加顺利地完成项目。\n\n​\t但是RTFM还远远不够解决所有的问题，很多东西都需要搜索引擎和ai大模型的辅助。\n\n​\t比如在按照文档的要求，执行某一个脚本的时候（好像是init.sh还是啥来着），默认的行为是在~/.bashrc中添加环境变量，但是我使用的shell不是bash，而是zsh,所以需要把这里环境变量添加到  ~/.zshrc中，才能够正常地使用。\n\n​\t","categories":["NJUCS","ICS计算系统基础"]},{"url":"/posts/45a328abf07c/","content":"物理实验安排\n\n![image.png](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/20250922100513.png)\n![image.png](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/20250922100527.png)\n![image.png](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/20250922100538.png)\n\n我在第五组\n\n---\n","categories":["NJUCS"]},{"url":"/posts/33c5823f2de2/","content":"Rewrite the text provided in {}. The goal is to make it more fluent without grammer mistakes(to achieve this, you can modify the structure of the passage). The tone should be less AI-style and consistent with the style of {activeNote}. Do not invent emotions or details.","categories":["copilot-custom-prompts"]},{"url":"/posts/f136ebfe29bd/","content":"Translate {} into Chinese:\n    1. Preserve the meaning and tone\n    2. Maintain appropriate cultural context\n    3. Keep formatting and structure\n    Return only the translated text.","categories":["copilot-custom-prompts"]},{"url":"/posts/da65a697bd26/","content":"Create a bullet-point summary of {}. Each bullet point should capture a key point. Return only the bullet-point summary.","categories":["copilot-custom-prompts"]},{"url":"/posts/b26a2710205c/","content":"Simplify {} to a 6th-grade reading level (ages 11-12). Use simple sentences, common words, and clear explanations. Maintain the original key concepts. Return only the simplified text.","categories":["copilot-custom-prompts"]},{"url":"/posts/6dfc912adcf4/","content":"Rewrite {} as a single tweet with these requirements:\n    1. Maximum 280 characters\n    2. Use concise, impactful language\n    3. Maintain the core message\n    Return only the tweet text.","categories":["copilot-custom-prompts"]},{"url":"/posts/00662486e10f/","content":"Convert {} into a Twitter thread following these rules:\n    1. Each tweet must be under 240 characters\n    2. Start with \"THREAD START\" on its own line\n    3. Separate tweets with \"\n\n---\n\n\"\n    4. End with \"THREAD END\" on its own line\n    5. Make content engaging and clear\n    Return only the formatted thread.","categories":["copilot-custom-prompts"]},{"url":"/posts/ca4b2f2d29de/","content":"Remove all URLs from {}. Preserve all other content and formatting. URLs may be in various formats (http, https, www). Return only the text with URLs removed.","categories":["copilot-custom-prompts"]},{"url":"/posts/77dfc45300dd/","content":"Reduce {} to half its length while preserving these elements:\n    1. Main ideas and key points\n    2. Essential details\n    3. Original tone and style\n    Return only the shortened text.","categories":["copilot-custom-prompts"]},{"url":"/posts/675c443cb9d2/","content":"Expand {} to twice its length by:\n    1. Adding relevant details and examples\n    2. Elaborating on key points\n    3. Maintaining the original tone and style\n    Return only the expanded text.","categories":["copilot-custom-prompts"]},{"url":"/posts/ea80c08b9054/","content":"Generate a hierarchical table of contents for {}. Use appropriate heading levels (H1, H2, H3, etc.). Include page numbers if present. Return only the table of contents.","categories":["copilot-custom-prompts"]},{"url":"/posts/02ff4b568a0f/","content":"Create a glossary of important terms, concepts, and phrases from {}. Format each entry as \"Term: Definition\". Sort entries alphabetically. Return only the glossary.","categories":["copilot-custom-prompts"]},{"url":"/posts/6312ffc41211/","content":"Fix grammar, spelling, typos, and formatting errors in the following text: {}. Preserve all original line breaks, spacing, and special characters exactly as they appear.\n\nBold: **text** is valid; ** text ** (with spaces) is not bold—fix only if bolding was intended.\nInline code: Use `code` with no spaces inside backticks.\nCode blocks: Use triple backticks for multi-line code.\nLaTeX math:\nInline: $...$ with no spaces (e.g., $a$, not $ a $,!!!, use $(a,b,c)$ not           $ (a,b,c) $).\nDo not add, remove, or restructure any content. Return only the corrected text—no explanations or extra content.","categories":["copilot-custom-prompts"]},{"url":"/posts/ecef3e783fdb/","content":"Fix the grammar ,spelling and other mistakes of {}. Preserve all formatting, line breaks, and special characters. Do not add or remove any content. Return only the corrected text.","categories":["copilot-custom-prompts"]},{"url":"/posts/40d1a17fdcc3/","content":"Explain {} in simple terms that a 5-year-old would understand:\n    1. Use basic vocabulary\n    2. Include simple analogies\n    3. Break down complex concepts\n    Return only the simplified explanation.","categories":["copilot-custom-prompts"]},{"url":"/posts/bd9f41d2313f/","content":"Add relevant emojis to enhance {}. Follow these rules:\n    1. Insert emojis at natural breaks in the text\n    2. Never place two emojis next to each other\n    3. Keep all original text unchanged\n    4. Choose emojis that match the context and tone\n    Return only the emojified text.","categories":["copilot-custom-prompts"]},{"title":"第三章：程序的转换以及机器数表示","url":"/posts/99b290041c5c/","content":"\n# 程序的转换以及机器数表示\n\n**RTL表示**\n\nRTL：Register Transfer Language。在本书中规定为：R[r]寄存器r里面存储的内容，M[addr]地址addr里面存储的内容，PC程序计数器\n\n目的寄存器在左，源操作数在\n\n>   重点掌握32位的知识，这个是考试的核心的内容，但是64位是现在用的比较多的。。\n>\n>   考试形式：给高级语言和汇编语言，分析程序执行过程中的各种内容的分析\n\n**汇编语言格式**\n\n>   以mov指令为例，这里选取了一个基址+变址*倍数 +偏移量的方式\n\nIntel格式： mov [bx+di-6], cl \n\nAT&T格式：\n\n>   课程采取AT&T的格式\n\n我们需要学习的是，如何写RTL语言\n\n\n\n**一条指令必须包含的信息**\n\n操作码：指定操作类型\n\n操作数：一个或多个源操作数所在的地址\n\n**x86_64和IA32的区别**\n\nx86_64添加了8个64位的通用寄存器，所有的GPRs都由原先的32位扩充到64位。字长变为64位，过程调用的时候通常用通用寄存器而不是栈来传递参数\n\n## 3.2 IA-32\n\n### 寻址方式\n\n\n> 寄存器的顺序是： **eax ecx edx ebx** 分别代表了0 1 2 3 > 然后是esp，ebp，esi和edi分别是5678\n\n\n\n## IA32指令格式\n\n机器指令由指令前缀+指令本身构成\n指令前缀：\n指令的结构为：\nOP+ModR/M+ SIB+位移+ 立即数\n\n\n\nb  w l q(分别代表1个，2个，4个和8个字节)\n\nw要加66，q要加一个48（不一定是48，二进制的低三位不一定全为0）\n\n### 常见的汇编指令\n**操作码的后缀**\n因为数据宽度的不同（比如有8位寄存器，16位寄存器和32位寄存器等等），同一个指令后面加上数据宽度的后缀就能够表示对不同宽度寄存器的操作\n- `movl %eax %ecx `将32位（4个字节）的eax内的数据传递到ecx里面\n- `pushq %ebx` 从栈中弹出64位的（8个字节）数据，保存到ebx里面\n其中，一般用b w l q 代表1,2,4,8个字节（一个字节是8位）\n\nMOV: \nMOVS: 符号扩展传递，如movsbw将byte的移动到一个w长度的寄存器\nMOVZ:\n> 不存在从单独的截断指令，直接使用mov指令传送即可，按照位数低的来进行传送，默认会选取低XX位进行传送。\n> `movl %edi %eax`把\n\n**PUSH、POP**：入栈出栈，如pushq为推入一个4字节的指令\n注意：在执行pop和push的时候，一定会改变esp的值，比如：\n```ass\npushl %eax\npopl %ecx\n```\n在这里中\n\n**LEA指令** (Load Effective Adderess)有效地址传输\n比如 leal 6(%eax), %edx 用于将eax寄存器+6的地址存在edx中（如果eax的值是x，那么edx里面存储的是x+6)\nlea的花哨用法：用于加减乘法，\n比如 leal 0x10(%eax, %eax, 3) %eax 的效果为：$x= 4* x+10$\n**输入输出指令**\nin将端口内容送累加器，out将累加器送I/O端口\n**标志传送指令**\npushf将标志寄存器的内容压栈；popf将栈顶的内容存入标志寄存器中\n**加减指令**\nADD和SUB都是将结果存入目的地，并且加减的结果标志送入标志寄存器`FLAGS/EFLAGS`中\n**INC/DEC**\n对指定的位串进行+1（INC，increment）或者-1（DEC，decrement）操作，标志信息存标志寄存器中\n**NEG指令**\n取负指令，或者为取补指令，对指定的位串进行按位取反再加一。\n如果是0，那么NEG后仍为0，但是CF置为0（其他的情况，CF一直都是0）\n如果是首位为1，其他位都是0（也就是最大的负数），NEG之后，值不变，且将OF设置为1，即溢出。\n**乘除指令**\n> 比较复杂，建议看书，P106\n\n\n> [!NOTE]+ Note\n> 老师说：\n> 1. 考试可能会考类似，“执行了XX乘法指令之后，哪些寄存器发生了改变”\n> 2. 乘法指令要考就考只有一个操作数的，除法的话，如果是8位除8位，那么一定要把被除数扩展到16位。被除数放到eax里面，扩展到edx里面\n> 3. 凡是\n\n\n例题：\n\n\n\n布斯算法的思想：乘以其真值而非机器数的值，只要我乘的是其真值\n判断溢出，无符号，高X位不全位0，有符号，高X位不全为符号位。\n\n\n数据类型：考虑宽度，以及带不带符号\n64位是r开头，比如rax （64位是q）\n32位都是e开头的（eax）（32位是l）\n16位没有e，比如ax（16位是w，word）\n（8位是b，byte）\n\n作long型除法时，被除数被扩展，原来的在rax里面，拓展的部分在rdx里面。（ppt里面有一个例子，说的是想要把RDI里面的x除以XX里面的y，指定要把除数和XX放到XX寄存器，问可以怎么写汇编指令，可以看一下这个题目，挺好的，因为作除法的时候会占用edx，所以需要一开始就把edx的值先存放到其他的寄存器中）\n\n\n**位移指令**\n见ppt吧\n\n**控制转移指令**\n1. 无条件跳转\n\t- JUP DST 无条件跳转到DST处\n2. 有条件跳转\n\t - 先cmp b a\n3. 条件设置和条件传输\n4. 调用和放回指令\n\t- CALL DST: 放回地址ra入栈，转到DST继续执行\n\t- RET:  从栈中拿回返回地址RA，转到RA继续执行\n5. 陷阱指令\n\t- 和函数的区别，陷阱指令\n\n\n0x8048000是XX 制度文件去的开始地址是","categories":["NJUCS","ICS计算系统基础"]},{"url":"/posts/1254bdaf8180/","content":"\n\n## 一个困扰许多人的问题\n\n一个很常见的场景：你在 GitHub 上看到一个很有趣的 Python 项目，决定把它拿到 Windows 本地试试。你熟练地敲：\n\n```\ngit clone git@github.com:yama-lei/demo.git\ncd demo\n```\n\n发现仓库里有 `requirements.txt`，部署过多个python应用的你熟练地敲下：\n\n```\npython -m venv .venv\n.venv/Scripts/activate\npip install -r requirements.txt\n```\n\n然而命令刚跑没多久，就红了一大片错误：`error: XXX is required. Please XXXXX\".`某个依赖是 C 扩展，pip 没找到合适的 wheel，要从源码编译。\n\n你去问了 AI，AI回复了一大串，给了几条建议——安装 XXX、装上 XXX。你按照建议去做，装了几个XXX的构建工具，回到项目目录再跑一遍。终于，pip 的输出不再一直报错，慢慢地安装完了。\n\n![](https://cdn.nlark.com/yuque/0/2025/png/46999547/1758245115259-b1f6d12a-0e51-4e9b-b9af-dcbc69e63b4d.png \"寻求Qwen3 解决环境问题时的小插曲\")\n\n**Install Success!**\n\n激动的心，颤抖的手，你高兴地敲下：`python app.py` 结果却是一堆 traceback：应用在导入 NumPy 的某个扩展模块时崩了，控制台报的是：`ImportError: numpy.core.multiarray failed to import`。你又查了下 `requirements.txt`，发现项目作者在文件里明确写了 `numpy==1.19.0`，但你之前因为随手更新过包，机器上现在装的是最新的 `numpy`。你试着把本地的 numpy 卸载，pip install 指定回 `1.19.0`，这次安装又失败了——因为你当前的 Python 版本和某些老 wheel 不兼容，pip 又试图从源码编译，编译又需要 XXX 等系统库。\n\n来回折腾了好几次，你改过 `requirements.txt` 的版本组合、也尝试把Python 版本降低到和作者一致，问题一会儿是这里“缺系统库”，那里的版本不兼容。\n\n时间就这样一点点耗掉。几个小时、甚至一天过去了，你最终还是放弃了部署这个项目，心里很不甘——到底是哪一环出错了？为什么在我机器上配置环境竟然这么难？\n\n到这个时候，你的心里只剩下一个F开头K结尾的单词。\n\n![](https://cdn.nlark.com/yuque/0/2025/png/46999547/1758096021392-2fde6ada-a3a5-407a-b23e-2ce7c3954b40.png)\n\n不只是在部署别人的应用的时候才会发生这个问题：你在 Windows 上开发好的东西，一搬到 Linux 服务器上可能也又出一串新错误——系统包名不一样、编译器版本不一样......\n\n环境配置是部署应用最大的麻烦事之一。怎么确保自己的应用能在服务器上跑起来？怎么把别人写好的东西拉到我这台电脑上就能跑？核心问题一句话——**开发环境和部署环境里各种库、系统依赖、编译工具、甚至系统包的版本不一致**，只要哪儿不对，软件就可能跑不起来。\n\n## Docker : build once run anywhere\n\n于是很多人会想：**如果能把运行时环境一并打包，把系统依赖、Python 包、配置文件都做成一个“镜像”，别人拿到就能完全一样地运行，不就省事了吗？**\n\n这里知识拿python举一个例子，docker可以部署绝大部分的程序运行环境；\n\n这就是 Docker 要解决的问题。\n\n**Docker容器是一个在宿主机内核上运行的、被隔离的进程，但它拥有自己独立的文件系统环境**。\n\ndocker 有 Dockerfile 有镜像，有容器。镜像是打包好的环境，容器是镜像跑起来之后的实例，Dockerfile 是造镜像的配方。理解了这三个东西，基本上就能明白 Docker 在做什么。\n\n![](https://cdn.nlark.com/yuque/0/2025/png/46999547/1758247324828-acd5142b-21f0-4cde-a075-58151f008b80.png \"null\")\n\n|   |   |   |   |\n|---|---|---|---|\n|概念|定义|作用|类比|\n|Dockerfile|一份文本文件，写明如何构建镜像的步骤|配置依赖、安装包、复制代码、设置启动命令|建房子的“施工图纸”|\n|Image|根据 Dockerfile 构建出来的只读模板|打包好应用和环境，别人拿到就能复用|建好的“房子模型”|\n|Container|基于镜像运行起来的实例（动态进程）|真正执行应用的地方，可以随开随关|住进去的“房子”|\n\nDocker把应用和它的运行环境统一封装成一个“镜像”，别人不需要再重新配置，直接用镜像启动一个“容器”即可，\"Build once, run anywhere\"。\n\n![](https://cdn.nlark.com/yuque/__mermaid_v3/ba99695fc423a3dede86a778300777db.svg)\n\nDockerfile 就好比一张建造说明书，里面有如何构建镜像的步骤。镜像是构建好的一个静态环境，而当你真正运行它的时候，这个集装箱才会变成一个容器，里面的应用进程、网络、文件系统都在那一刻活了过来。**镜像是静态的，容器是动态的；镜像可以复用，容器可以随开随关。**\n\n## Docker如何使用\n\n### Docker环境配置\n\n对于windows和macos：下载docker desktop；[https://www.docker.com/products/docker-desktop/](https://www.docker.com/products/docker-desktop/)\n\n对于linux，直接通过命令行安装\n\n需要sudo权限\n\n### 用 Docker 来部署一些好玩的东西\n\n现在 Github 上有很多应用都提供了 Docker 部署的选择，其中不少复杂的应用甚至把 **Docker 部署作为最推荐的方案。**拿一个机器人平台 **AstrBot**为例。官方文档里面在部署方面只有三行指令：\n\n```\ngit clone https://github.com/AstrBotDevs/AstrBot\ncd AstrBot\nsudo docker compose up -d\n```\n\n考虑任何环境配置和兼容性问题。![](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250917164133911.png \"null\")\n\n那它背后到底发生了什么呢？  \n当我们第一次 `docker compose up` 或者 `docker run` 某个容器时，Docker 会先在本地看看是否存在对应的 **镜像（image）**。\n\n- 如果已经有了，就直接用这个镜像创建一个新的 **容器（container）** 实例。\n- 如果没有，docker 会自动去DockerHub上拉取。\n\n第一次拉取镜像速度可能比较慢（可能需要配置科学上网或者配置docker镜像站点，国内访问速度比较慢），但以后只要敲一句 `docker start`，几乎立刻就能起来。\n\n而且 Docker 还有一个好处：容器和宿主机是隔离的。容器里安装的各种包、各种配置，对于电脑本身不会有任何的影响。就算哪天这个容器崩了，你只需要一句 `docker rm` 把它删掉，再重新跑一次 `docker run`，环境就是干干净净的。\n\n---\n\n### Docker 基本指令\n\n- `docker build . -t name`：自己写 Dockerfile，然后构建一个镜像。\n- `docker run image-name`：基于镜像启动一个容器\n- `docker stop container-name`：停止一个正在运行的容器（但**容器内**数据还在）。\n- `docker rm container-name`：删除容器实例。\n- `docker rmi image-name`：删除镜像。\n\n## 那 Docker 到底是怎么工作的？\n\n#### 1. 操作系统层面的虚拟化\n\nDocker 的实现依赖几个关键机制。我们希望容器之间能够完全隔离，互不干扰，每一个容器都像是一个小小的 Linux“系统”。\n\n注：这里称其为linux系统不太合适，实际上所有的docker容器都是在宿主机内核上运行的。\n\n要实现这种“像系统一样”的效果，就需要几个核心机制。\n\n第一个机制是 **命名空间（Namespaces）**。它负责隔离，让容器**误以为**自己独占了一套系统资源。  \n比如：\n\n- 网络命名空间会为容器分配独立的 IP 和端口；\n- 文件系统命名空间则让容器只能看到自己的目录树，而看不到宿主机的完整文件系统。  \n    正是这种隔离，让不同容器之间互不干扰。![](https://cdn.nlark.com/yuque/0/2025/png/46999547/1758117943828-5e2e0f71-ecc9-4399-9ba1-b79001cc16b3.png)\n\n第二个机制是 **控制组**。它用来管理和限制容器的资源，比如 CPU、内存等。通过控制组，宿主机可以控制每个容器最多能用多少资源，避免某个容器无限制地占用，影响其他容器的运行。\n\n除了隔离和限制，Docker 容器还有一个重要的特性：**无状态（Stateless）**。  \n所谓“状态”，是指程序运行过程中产生的中间数据。无状态容器的意思是：容器在运行时不会把这些数据留在容器内部，而是统一存储在容器外部。如果容器被 remove，之前容器内的数据自然就消失了。\n\n注：这里指的是容器内部的数据会消失，如果需要持久化，可以通过挂载把数据保存到宿主机上\n\n要支撑这种无状态，Docker 依赖 **分层存储**。镜像并不是一个庞大的单一文件，而是由一层层文件系统叠加起来的。底层可能是只读的基础镜像，在它之上叠加一些包或配置。而当你运行容器时，Docker 只是在最上面加一个可写层，你的改动都会记录在这一层，底下的只读层保持不变。\n\n总结起来就三个关键词：**进程隔离、资源限制、存储分层**。\n\n#### 2.网络：容器怎么和外界、和其他容器通信？\n\n- **默认 bridge 网络**：  \n    Docker 启动的时候会自动建一个 `docker0` 网桥。每个容器都会连到这个网桥上，有自己的虚拟网卡和 IP。容器之间可以通过这个ip互相访问。但如果想让外界访问容器，就得 **做端口映射**，在运行的时候加上-p参数 比如`-p 8080:80`，这样访问 `localhost:8080` 就能进容器的 80 端口。\n\n回顾前面的docker容器运行指令 docker run demo，如果需要将容器demo的8080端口服务映射到host的8080，那就需要用 docker run -p 8080:8080 demo\n\n- **host 模式**：  \n    有些场景需要直接把容器“接入”宿主机网络。这样容器没有独立 IP，直接用宿主机的网络栈。缺点是容易端口冲突。\n- **容器间通信** ：  \n    先用`docker network create` 创建网络，再通过 `--network` 让容器加入进去相互之间用名字来访问对方，比如说：\n\n```\ndocker network create mynet\ndocker run --network mynet --name service-a ...\ndocker run --network mynet --name service-b ...\n```\n\n然后在service-a里面就可以通过[http://service-a:](http://service-a:8888)端口 来进行访问\n\n1. DockerDesktop（win和mac上的）也可以通过docker.internal.host获取到主机的host进行通信\n\n#### 3. 存储\n\nDocker官网：docker适合做stateless的服务，而不适合做数据库等有状态的任务\n\n默认情况下，容器里的数据就存在容器本身。容器一旦删掉，数据可能也跟着没了。\n\n所以正确的做法是使用 -v 参数进行路径的映射\n\n用 `-v ./data:/app/data` 把宿主机的目录挂载到容器里，这样数据都放在宿主机硬盘上，容器删了也不会丢。\n\n参数为：-v 宿主机的路径:容器内部的路径，其中宿主机的路径既可以使用像“./data”,\"/docker/data\"之类的路径，也可以通过docker crteate volume 来创建一个卷，直接用卷来替代宿主机的路径，比如\n\n```\ndocker create volume1\ndocker run -v volume1:/app/data demo\n```\n\n意思是 先创建一个叫 `volume1` 的卷，再运行一个 demo 容器，把这个卷挂载到容器的 `/app/data` 目录\n\n**容器是一次性的，数据要放在宿主机或者卷里，才能持久化。**\n\n## 再更高阶一点？\n\n### 怎么构建自己的镜像\n\n用别人的镜像固然爽，自己搓一个镜像到处都可以用才是真的爽。\n\n如果你想把自己的应用交给别人使用，那就需要自己构建镜像。做法很简单：写一个叫 **Dockerfile** 的文件，把环境怎么准备、代码怎么放进去、最后程序怎么启动都写好。这样别人拿到这个目录，只需要在终端里执行：\n\n```\ndocker build -t demo .\ndocker run demo\n```\n\n就能跑起来，不用再纠结环境配置。\n\n下面是一个简化版本的dockerfile\n\n```\nFROM node:22.18.0-alpine\n\nWORKDIR /app\nCOPY . . \nRUN npm ci --only=production\nRUN mkdir -p /app/data /app/logs && chown -R node:node /app/data /app/logs\n\nVOLUME [\"/app/data\", \"/app/logs\"]\nEXPOSE 8080 8081\nCMD [\"npm\", \"run\", \"start\"]\n```\n\n### 为什么需要 docker-compose\n\n如果你的项目只有一个容器，比如一个简单的 web 服务，直接 `docker run` 就足够了。但要是像 AstrBot 这样，需要两个容器一起跑（一个是 napcat，一个是 astrbot），每次都要手动敲一长串命令，就显得又累又难维护。\n\n这时候 **docker-compose** 就很有用了。你可以写一个 `yaml` 文件，把所有容器的配置放在一起。然后一条命令就能把整个应用拉起来，还能帮你处理容器之间的网络、卷、环境变量等等。\n\n我简化了一下 AstrBot 的 `compose.yml`，核心内容大概是这样：\n\n```\nservices:\n  napcat:\n    image: mlikiowa/napcat-docker:latest\n    container_name: napcat\n    ports:\n      - \"6099:6099\"\n    volumes:\n      - ./data:/AstrBot/data\n    networks:\n      - astrbot_network\n    restart: always\n\n  astrbot:\n    image: soulter/astrbot:latest\n    container_name: astrbot\n    ports:\n      - \"6185:6185\"\n    volumes:\n      - ./data:/AstrBot/data\n    networks:\n      - astrbot_network\n    restart: always\n\nnetworks:\n  astrbot_network:\n    driver: bridge\n```\n\n简单说就是：定义了两个服务 napcat 和 astrbot，它们共享同一个网络，可以互相通信；各自有端口和卷的配置；掉线还能自动重启。  \n然后运行：\n\n```\ndocker compose -f ./compose/astrbot.yml up -d\n```\n\n整个系统就能跑起来。\n\n用一张图来理解 napcat 和 astrbot 的关系：\n\n![](https://cdn.nlark.com/yuque/__mermaid_v3/6995c8c7a3c05d071ab4cf849b85ef6d.svg)\n\n两个容器都接入了同一个网络 `astrbot_network`，所以它们能直接互相通信。外部访问时则通过端口映射进入。\n\n## 回顾：Docker究竟是个啥\n\n**Docker容器是一个在宿主机内核上运行，拥有自己独立的文件系统环境，被隔离的进程**。\n\n从**使用者**的角度讲： 直接用docker可以一键部署自己需要的应用，可以隔离各个应用，不至于相互干扰。可以使用简单的命令来实现对应用的管理。\n\n从**开发者**的角度讲：通过docker来轻松实现软件的交付，不需要操心客户环境配置问题；可以通过docker compose来实现多个应用的协作。\n\n从**我**的角度讲：借助docker可以完成一场近20min的分享，并畅享苏州一日游\n\ndocker可以实现什么？\n\n- 项目交付和部署\n- 解决环境依赖问题\n- 版本迭代和发布\n\ndocker不适合做什么？\n\n- 小型脚本 （增加复杂度）\n- 持久化服务、有状态的服务\n\n---\n\n日志：\n\n9/17 午 完成一个困扰许多人的问题\n\n9/17晚 完成docker如何使用，完善docker如何工作\n\n写起来好费时间，但是也算倒逼自己去了解原理\n\n9月17日晚23.13，我宣布，第一版结束！\n\n9月18日，修改部分内容\n\n9月19日，cac在讲PBL，和我想象中的PBL不一样","tags":["tech","docker","nova"],"categories":["NOVA"]},{"url":"/posts/e3305c79a66b/","content":"## Optimizer: 优化器\n### SGD（Stochastic gradient descent）\n(Chinese Name: 随机梯度下降法)\nThe main idea of SGD can be explained by the following formula:\n$$\nW \\leftarrow W - \\eta \\frac{\\partial L}{\\partial W}\n$$\nwhere $\\eta$ stands for learning rate, which is ussally set to be predefined values like 0.001 or 0.01. \n\n```python\nclass SGD:\n\tdef __init__(self, lr=0.01):\n\t\tself.lr=lr\n\t\n\tdef update(self, params, grads):\n\t\tfor key in params.keys():\n\t\t\tparams[key]+=lr* grads[key]\n```\n\nSGD is easy to complement, but sucks at its efficiency. In an example of function $f(x,y)= \\frac{1}{20}x^2+ y^2$\n![image.png](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/20250922223004.png) the gradient of the function is nearly parallel to the y axis, which means it can be hard to find the \"best position\" of the function\n\n","categories":["科研启蒙","CVLearning"]},{"title":"例会汇报 | 第十次&第11次","url":"/posts/5cd6193a7b44/","content":"\n之前在服务器上面尝试跑过两个模型，均已存档，分别保存在model-6-28和model-7-2\n\n模型的结构是\n\n![a80e79c486cdd4b0d4eb34fc28090d51](https://malanhuakai.oss-cn-nanjing.aliyuncs.com/malanhuakai/a80e79c486cdd4b0d4eb34fc28090d51.png)\n\n## Baseline \n\nbaseline模型在vqa-v2 validation上的指标为：\n\n```text\nEvaluating epoch 10\nUse vqa_v2_image_id_path_map.json\nAccuracy: 0.5273659460518582\nEvaluating epoch 20\nUse vqa_v2_image_id_path_map.json\nAccuracy: 0.6017429112589455\nEvaluating epoch 30\nUse vqa_v2_image_id_path_map.json\nAccuracy: 0.651301118710171\nEvaluating epoch 40\nUse vqa_v2_image_id_path_map.json\nAccuracy: 0.6644895826529946\nEvaluating epoch 50\nUse vqa_v2_image_id_path_map.json\nAccuracy: 0.6895276038702334\nEvaluating epoch 60\nUse vqa_v2_image_id_path_map.json\nAccuracy: 0.6949858645045113\nEvaluating epoch 70\nUse vqa_v2_image_id_path_map.json\nAccuracy: 0.6958582531699898\nEvaluating epoch 80\nUse vqa_v2_image_id_path_map.json\nAccuracy: 0.6959888782108101\nEvaluating epoch 90\nUse vqa_v2_image_id_path_map.json\nAccuracy: 0.696348097073066\nEvaluating epoch 100\nUse vqa_v2_image_id_path_map.json\nAccuracy: 0.6969685660169626\n```\n\n\n\n模型结构：\n\n```cpp\nclass VQA_Model(nn.Module):\n    def __init__(self,vocab_size,answer_size,hidden_size=512):\n        super(VQA_Model,self).__init__()\n        # 1. 图像编码器 (img_encoder)\n        resnet = models.resnet18(pretrained=True)\n        self.img_encoder = nn.Sequential(*list(resnet.children())[:-1])\n        # 冻结图像编码器的参数\n        for p in self.img_encoder.parameters():\n            p.requires_grad = False\n        # 2. 问题编码器 (question_encoder)\n        self.embed=nn.Embedding(vocab_size,hidden_size)\n        self.classifier=nn.Sequential(\n            nn.Linear(512+hidden_size,1024),\n            nn.ReLU(),\n            nn.Linear(1024,answer_size)\n        )\n    def forward(self,image,question):\n        image_features = self.img_encoder(image)\n        image_features = image_features.view(image.size(0), -1) \n        question_features=self.embed(question).mean(dim=1)\n        combined_features=torch.cat([image_features,question_features],dim=1)\n        output=self.classifier(combined_features)\n        return output\n```\n\n\n\n---\n\n## A Failed Attempt Using LSTM\n\n```python\nclass VQA_Model(nn.Module):\n    def __init__(self,vocab_size,answer_size,hidden_size=512):\n        super(VQA_Model,self).__init__()\n        # 1. 图像编码器 (img_encoder)\n        resnet = models.resnet18(pretrained=True)\n        self.img_encoder = nn.Sequential(*list(resnet.children())[:-1])\n        # 冻结图像编码器的参数\n        for p in self.img_encoder.parameters():\n            p.requires_grad = False\n\n        # 2. 问题编码器 (question_encoder)\n        self.q_lstm = nn.LSTM(\n            input_size=512,\n            hidden_size=512,\n            num_layers=1,\n            batch_first=True\n        )\n        self.spatial_attention = nn.Sequential(nn.Conv2d(512,1,kernel_size=1),nn.Sigmoid())\n        self.embed = nn.Embedding(vocab_size,hidden_size)\n        self.classifier=nn.Sequential(\n            nn.Linear(512+hidden_size,1024),\n            nn.ReLU(),\n            nn.Linear(1024,answer_size)\n        )\n    def forward(self,image,question):\n        image_features = self.img_encoder(image)\n        #image_features = image_features.view(image.size(0), -1) \n\t#6月30日改成了注意力机制\n        attention_map= self.spatial_attention(image_features)\n        attended_image_features=image_features*attention_map\n        attended_image_features=attended_image_features.view(image.size(0),-1)\n        question_features=self.embed(question)\n        question_features, _ = self.q_lstm(question_features)\n        question_features = question_features[:, -1, :]\n        combined_features=torch.cat([attended_image_features,question_features],dim=1)\n        output=self.classifier(combined_features)\n        return output\n```\n\n## Solution on that\n\n\n\nFailed:\n\n```cpp\nclass VQA_Model(nn.Module):\n    def __init__(self,vocab_size,answer_size,hidden_size=512):\n        super(VQA_Model,self).__init__()\n        # 1. 图像编码器 (img_encoder)\n        resnet = models.resnet18(pretrained=True)\n        self.img_encoder = nn.Sequential(*list(resnet.children())[:-1])\n        # 冻结图像编码器的参数\n        for p in self.img_encoder.parameters():\n            p.requires_grad = False\n\n        # 2. 问题编码器 (question_encoder)\n        self.q_lstm = nn.LSTM(\n            input_size=512,\n            hidden_size=512,\n            num_layers=1,\n            batch_first=True\n        )\n        self.question_attention_linear = nn.Linear(hidden_size, 1)\n        self.spatial_attention = nn.Sequential(nn.Conv2d(512,1,kernel_size=1),nn.Sigmoid())\n        self.embed = nn.Embedding(vocab_size,hidden_size)\n        self.classifier=nn.Sequential(\n            nn.Linear(512+hidden_size,1024),\n            nn.ReLU(),\n            nn.Linear(1024,answer_size)\n        )\n    def forward(self,image,question):\n        image_features = self.img_encoder(image)\n        attention_map = self.spatial_attention(image_features)\n        attended_image_features=image_features*attention_map\n        attended_image_features=attended_image_features.view(image.size(0),-1)\n        question_features = self.embed(question)\n        # LSTM 输出 question_features 的形状是 (batch_size, seq_len, hidden_size)\n        question_features, _ = self.q_lstm(question_features)\n        # ====== 修改：应用注意力机制来聚合 LSTM 输出 ======\n        attention_scores = self.question_attention_linear(question_features)\n        attention_weights = torch.softmax(attention_scores, dim=1)\n        question_features = torch.sum(question_features * attention_weights, dim=1)\n        # ====== 结束修改 ======\n        combined_features=torch.cat([attended_image_features,question_features],dim=1)\n        output=self.classifier(combined_features)\n        return output\n```\n\n---\n\n重新训练了model-6-29,只使用了vqa-v2数据集，并且将上面三种结构的模型进行一个横向对比：\n\n**模型一**\n\n>   question_features = self.embed(question).mean(dim=1)\n\n```\nUse MSCOCO_image_id_path_map.json\nUsing Device:  cuda\nEpoch10\n100%|██████████| 419/419 [04:09<00:00,  1.68it/s]\nAccuracy: 0.4185\nLoss: 2.2599\nEpoch20\n100%|██████████| 419/419 [05:21<00:00,  1.30it/s]\nAccuracy: 0.4080\nLoss: 2.7145\nEpoch30\n100%|██████████| 419/419 [05:10<00:00,  1.35it/s]\nAccuracy: 0.4057\nLoss: 3.2608\nEpoch40\n100%|██████████| 419/419 [06:16<00:00,  1.11it/s]\nAccuracy: 0.4019\nLoss: 3.8281\nEpoch50\n100%|██████████| 419/419 [06:14<00:00,  1.12it/s]\nAccuracy: 0.4016\nLoss: 4.4108\n```\n\n**模型二**：\n\n>   ```py\n>   self.q_lstm = nn.LSTM(\n>           input_size=512,\n>           hidden_size=512,\n>           num_layers=1,\n>           batch_first=True)\n>   question_features=self.embed(question)\n>   question_features, _ = self.q_lstm(question_features)\n>   question_features = question_features[:, -1, :]\n>   ```\n\n>   由于模型不慎被覆盖，没有计算相关数据\n\n**模型三：**\n\n>   ```py\n>         # 2. 问题编码器 (question_encoder)\n>           self.q_lstm = nn.LSTM(\n>               input_size=512,\n>               hidden_size=512,\n>               num_layers=1,\n>               batch_first=True\n>           )\n>           self.question_attention_linear = nn.Linear(hidden_size, 1)\n>   question_features = self.embed(question)\n>       # LSTM 输出 question_features 的形状是 (batch_size, seq_len, hidden_size)\n>       question_features, _ = self.q_lstm(question_features)\n>       # ====== 修改：应用注意力机制来聚合 LSTM 输出 ======\n>       attention_scores = self.question_attention_linear(question_features)\n>       attention_weights = torch.softmax(attention_scores, dim=1)\n>       question_features = torch.sum(question_features * attention_weights, dim=1)\n>       # ====== 结束修改 ======\n>   ```\n\n```\nUse MSCOCO_image_id_path_map.json\nUsing Device:  cuda:1\nEpoch10\n100%|██████████| 419/419 [05:18<00:00,  1.32it/s]\nAccuracy: 0.4402\nLoss: 2.4808\nEpoch20\n100%|██████████| 419/419 [04:57<00:00,  1.41it/s]\nAccuracy: 0.4218\nLoss: 3.9324\nEpoch30\n100%|██████████| 419/419 [06:06<00:00,  1.14it/s]\nAccuracy: 0.4190\nLoss: 5.2839\nEpoch40\n100%|██████████| 419/419 [06:12<00:00,  1.13it/s]\nAccuracy: 0.4133\nLoss: 6.3854\nEpoch50\n100%|██████████| 419/419 [04:44<00:00,  1.47it/s]\nAccuracy: 0.4149\nLoss: 7.3706\nEpoch60\n100%|██████████| 419/419 [04:14<00:00,  1.64it/s]\nAccuracy: 0.4134\nLoss: 8.1589\nEpoch70\n```\n\n---\n\n**模型四**：（model-7-14）\n\n```py\nclass VQA_Model(nn.Module):\n    def __init__(self,vocab_size,answer_size,hidden_size=512):\n        super(VQA_Model, self).__init__()\n        resnet = models.resnet18(pretrained=True)\n        modules = list(resnet.children())[:-2]\n        self.cnn = nn.Sequential(*modules)\n        for p in self.cnn.parameters():\n            p.requires_grad = False\n        self.image_feature_dim = 512 \n        self.embed=nn.Embedding(vocab_size,hidden_size)\n        self.classifier=nn.Sequential(\n            nn.Linear(hidden_size,1024),\n            nn.ReLU(),\n            nn.Linear(1024,answer_size)\n        )\n        self.softmax=nn.Softmax(dim=1)\n        self.k= 128 # 这个参数是vQ和u生成p_A过程中的一个维度\n        self.fc1=nn.Linear(self.image_feature_dim,self.k)\n        self.fc2=nn.Linear(hidden_size,self.k)\n        self.b_A = nn.Parameter(torch.randn(self.k))\n        self.fc3=nn.Linear(self.k,1)\n    def forward(self,image,question):\n        image_features_map = self.cnn(image) # 形状: (batch_size, D_cnn, H_out, W_out) e.g., (batch_size, 512, 14, 14)\n        batch_size = image_features_map.shape[0]\n        d_cnn = image_features_map.shape[1] \n        h_out = image_features_map.shape[2]  \n        w_out = image_features_map.shape[3]  \n        m = h_out * w_out # 196 (区域数量)\n        # 7月14日更正： 每一次都计算一次具体的数值，便于之后切换模型\n        v_I = image_features_map.view(batch_size, d_cnn, m).transpose(1, 2)\n        v_Q=self.embed(question).mean(dim=1)\n        h_A=self.fc1(v_I)+(self.fc2(v_Q)+self.b_A).unsqueeze(1)\n        p_I= self.softmax(self.fc3(h_A).squeeze(2)) \n        v_I_a = (p_I.unsqueeze(2) * v_I).sum(dim=1)\n        u_1= v_I_a+ v_Q\n        return self.classifier(u_1)\n```\n\n\n\n鉴于acc在10个epoch之后一直下降，并且训练的数目越多，准确率越降低，于是我猜测最好的模型应该在5-10个epoch之间，于是，我将model-6-28和model-7-2-refined两个模型重新进行训练：\n\n数据集：vqa-v2\n\n训练次数：15个epoch\n\n训练时间：model-6-28用时100min，model-7-2-refined用时150min\n\n训练结果：\n\n\n\n详细的训练数据：\n\nMode 1\n\n```text\nUse MSCOCO_image_id_path_map.json\nUse MSCOCO_image_id_path_map.json\nLoading vocabulary from vocab...\nVocabulary loaded successfully.\nEpoch 1/15: 100%|██████████| 867/867 [07:11<00:00,  2.01it/s]\nEpoch 1/15, Average Loss: 3.0484\nValidating: 100%|██████████| 419/419 [03:23<00:00,  2.06it/s]\nAccuracy: 0.3773\nLoss: 2.4807\nEpoch 2/15: 100%|██████████| 867/867 [07:19<00:00,  1.97it/s]\nEpoch 2/15, Average Loss: 2.2613\nValidating: 100%|██████████| 419/419 [03:25<00:00,  2.04it/s]\nAccuracy: 0.3955\nLoss: 2.2361\nEpoch 3/15: 100%|██████████| 867/867 [07:21<00:00,  1.97it/s]\nEpoch 3/15, Average Loss: 2.0160\nValidating: 100%|██████████| 419/419 [03:25<00:00,  2.04it/s]\nAccuracy: 0.3992\nLoss: 2.1677\nEpoch 4/15: 100%|██████████| 867/867 [07:20<00:00,  1.97it/s]\nEpoch 4/15, Average Loss: 1.8614\nValidating: 100%|██████████| 419/419 [03:26<00:00,  2.03it/s]\nAccuracy: 0.4101\nLoss: 2.1314\nEpoch 5/15: 100%|██████████| 867/867 [07:21<00:00,  1.97it/s]\nEpoch 5/15, Average Loss: 1.7432\nValidating: 100%|██████████| 419/419 [03:29<00:00,  2.00it/s]\nAccuracy: 0.4140\nLoss: 2.1298\nEpoch 6/15: 100%|██████████| 867/867 [07:23<00:00,  1.96it/s]\nEpoch 6/15, Average Loss: 1.6449\nValidating: 100%|██████████| 419/419 [03:24<00:00,  2.05it/s]\nAccuracy: 0.4078\nLoss: 2.1534\nEpoch 7/15: 100%|██████████| 867/867 [07:19<00:00,  1.97it/s]\nEpoch 7/15, Average Loss: 1.5597\nValidating: 100%|██████████| 419/419 [03:25<00:00,  2.04it/s]\nAccuracy: 0.4131\nLoss: 2.1661\nEpoch 8/15: 100%|██████████| 867/867 [07:21<00:00,  1.96it/s]\nEpoch 8/15, Average Loss: 1.4839\nValidating: 100%|██████████| 419/419 [03:25<00:00,  2.04it/s]\nAccuracy: 0.4161\nLoss: 2.2032\nEpoch 9/15: 100%|██████████| 867/867 [07:17<00:00,  1.98it/s]\nEpoch 9/15, Average Loss: 1.4187\nValidating: 100%|██████████| 419/419 [04:45<00:00,  1.47it/s]\nAccuracy: 0.4107\nLoss: 2.2466\nEpoch 10/15: 100%|██████████| 867/867 [10:16<00:00,  1.41it/s]\nEpoch 10/15, Average Loss: 1.3614\nValidating: 100%|██████████| 419/419 [04:58<00:00,  1.41it/s]\nAccuracy: 0.4171\nLoss: 2.2912\nEpoch 11/15: 100%|██████████| 867/867 [10:12<00:00,  1.41it/s]\nEpoch 11/15, Average Loss: 1.3103\nValidating: 100%|██████████| 419/419 [05:01<00:00,  1.39it/s]\nAccuracy: 0.4116\nLoss: 2.3398\nEpoch 12/15: 100%|██████████| 867/867 [10:17<00:00,  1.40it/s]\nEpoch 12/15, Average Loss: 1.2628\nValidating: 100%|██████████| 419/419 [04:58<00:00,  1.40it/s]\nAccuracy: 0.4153\nLoss: 2.3894\nEpoch 13/15: 100%|██████████| 867/867 [10:10<00:00,  1.42it/s]\nEpoch 13/15, Average Loss: 1.2222\nValidating: 100%|██████████| 419/419 [04:59<00:00,  1.40it/s]\nAccuracy: 0.4170\nLoss: 2.4406\nEpoch 14/15: 100%|██████████| 867/867 [10:15<00:00,  1.41it/s]\nEpoch 14/15, Average Loss: 1.1849\nValidating: 100%|██████████| 419/419 [05:00<00:00,  1.39it/s]\nAccuracy: 0.4150\nLoss: 2.4621\nEpoch 15/15: 100%|██████████| 867/867 [10:11<00:00,  1.42it/s]\nEpoch 15/15, Average Loss: 1.1505\nValidating: 100%|██████████| 419/419 [05:01<00:00,  1.39it/s]\nAccuracy: 0.4124\nLoss: 2.5393\n```\n\n实际上第5个epoch就基本没有提升了\n\n\n\nModel2:\n\n```\nEpoch 1/15: 100%|██████████| 867/867 [10:15<00:00,  1.41it/s]\nEpoch 1/15, Average Loss: 2.6244\nValidating: 100%|██████████| 419/419 [04:58<00:00,  1.40it/s]\nAccuracy: 0.4008\nLoss: 2.1095\nEpoch 2/15: 100%|██████████| 867/867 [10:15<00:00,  1.41it/s]\nEpoch 2/15, Average Loss: 1.9068\nValidating: 100%|██████████| 419/419 [04:58<00:00,  1.40it/s]\nAccuracy: 0.4340\nLoss: 1.9462\nEpoch 3/15: 100%|██████████| 867/867 [10:13<00:00,  1.41it/s]\nEpoch 3/15, Average Loss: 1.6859\nValidating: 100%|██████████| 419/419 [04:58<00:00,  1.40it/s]\nAccuracy: 0.4398\nLoss: 1.9197\nEpoch 4/15: 100%|██████████| 867/867 [10:19<00:00,  1.40it/s]\nEpoch 4/15, Average Loss: 1.5274\nValidating: 100%|██████████| 419/419 [04:59<00:00,  1.40it/s]\nAccuracy: 0.4458\nLoss: 1.9412\nEpoch 5/15: 100%|██████████| 867/867 [10:17<00:00,  1.40it/s]\nEpoch 5/15, Average Loss: 1.3875\nValidating: 100%|██████████| 419/419 [05:00<00:00,  1.39it/s]\nAccuracy: 0.4441\nLoss: 1.9828\nEpoch 6/15: 100%|██████████| 867/867 [10:18<00:00,  1.40it/s]\nEpoch 6/15, Average Loss: 1.2566\nValidating: 100%|██████████| 419/419 [04:57<00:00,  1.41it/s]\nAccuracy: 0.4465\nLoss: 2.0777\n--- Saving model and evaluating after Epoch 7 ---\n2025-07-14 23:25:11,734 - INFO - Model saved to model-2/model_epoch_7.pth\n2025-07-14 23:25:11,735 - INFO - Running evaluation on validation set...\n2025-07-14 23:28:42,473 - INFO - Accuracy: 0.4419\n2025-07-14 23:28:42,474 - INFO - Loss: 2.1604\n2025-07-14 23:28:42,478 - INFO - Validation Accuracy: 0.4419, Validation Loss: 2.1604\n2025-07-14 23:28:42,479 - INFO - --------------------------------\n2025-07-14 23:36:26,647 - INFO - Epoch 8/15, Average Loss: 1.0292\n2025-07-14 23:36:26,647 - INFO - ---\n2025-07-14 23:36:26,647 - INFO - \n--- Saving model and evaluating after Epoch 8 ---\n2025-07-14 23:36:26,834 - INFO - Model saved to model-2/model_epoch_8.pth\n2025-07-14 23:36:26,834 - INFO - Running evaluation on validation set...\n2025-07-14 23:40:03,044 - INFO - Accuracy: 0.4446\n2025-07-14 23:40:03,044 - INFO - Loss: 2.2963\n2025-07-14 23:40:03,045 - INFO - Validation Accuracy: 0.4446, Validation Loss: 2.2963\n2025-07-14 23:40:03,045 - INFO - --------------------------------\n2025-07-14 23:47:58,770 - INFO - Epoch 9/15, Average Loss: 0.9360\n2025-07-14 23:47:58,770 - INFO - ---\n2025-07-14 23:47:58,771 - INFO - \n--- Saving model and evaluating after Epoch 9 ---\n2025-07-14 23:47:58,983 - INFO - Model saved to model-2/model_epoch_9.pth\n2025-07-14 23:47:58,983 - INFO - Running evaluation on validation set...\n2025-07-14 23:52:29,471 - INFO - Accuracy: 0.4446\n2025-07-14 23:52:29,473 - INFO - Loss: 2.3849\n2025-07-14 23:52:29,473 - INFO - Validation Accuracy: 0.4446, Validation Loss: 2.3849\n2025-07-14 23:52:29,474 - INFO - --------------------------------\n2025-07-15 00:02:34,321 - INFO - Epoch 10/15, Average Loss: 0.8512\n2025-07-15 00:02:34,322 - INFO - ---\n2025-07-15 00:02:34,322 - INFO - \n--- Saving model and evaluating after Epoch 10 ---\n2025-07-15 00:02:34,557 - INFO - Model saved to model-2/model_epoch_10.pth\n2025-07-15 00:02:34,557 - INFO - Running evaluation on validation set...\n2025-07-15 00:07:32,042 - INFO - Accuracy: 0.4381\n2025-07-15 00:07:32,042 - INFO - Loss: 2.5163\n2025-07-15 00:07:32,044 - INFO - Validation Accuracy: 0.4381, Validation Loss: 2.5163\n2025-07-15 00:07:32,044 - INFO - --------------------------------\n2025-07-15 00:17:49,403 - INFO - Epoch 11/15, Average Loss: 0.7788\n2025-07-15 00:17:49,403 - INFO - ---\n2025-07-15 00:17:49,404 - INFO - \n--- Saving model and evaluating after Epoch 11 ---\n2025-07-15 00:17:49,630 - INFO - Model saved to model-2/model_epoch_11.pth\n2025-07-15 00:17:49,630 - INFO - Running evaluation on validation set...\n2025-07-15 00:22:47,713 - INFO - Accuracy: 0.4388\n2025-07-15 00:22:47,714 - INFO - Loss: 2.6451\n2025-07-15 00:22:47,714 - INFO - Validation Accuracy: 0.4388, Validation Loss: 2.6451\n2025-07-15 00:22:47,714 - INFO - --------------------------------\n2025-07-15 00:33:01,897 - INFO - Epoch 12/15, Average Loss: 0.7123\n2025-07-15 00:33:01,898 - INFO - ---\n2025-07-15 00:33:01,899 - INFO - \n--- Saving model and evaluating after Epoch 12 ---\n2025-07-15 00:33:02,118 - INFO - Model saved to model-2/model_epoch_12.pth\n2025-07-15 00:33:02,119 - INFO - Running evaluation on validation set...\n2025-07-15 00:37:59,538 - INFO - Accuracy: 0.4352\n2025-07-15 00:37:59,538 - INFO - Loss: 2.7984\n2025-07-15 00:37:59,540 - INFO - Validation Accuracy: 0.4352, Validation Loss: 2.7984\n2025-07-15 00:37:59,540 - INFO - --------------------------------\n2025-07-15 00:48:16,068 - INFO - Epoch 13/15, Average Loss: 0.6526\n2025-07-15 00:48:16,070 - INFO - ---\n2025-07-15 00:48:16,070 - INFO - \n--- Saving model and evaluating after Epoch 13 ---\n2025-07-15 00:48:16,298 - INFO - Model saved to model-2/model_epoch_13.pth\n2025-07-15 00:48:16,298 - INFO - Running evaluation on validation set...\n2025-07-15 00:53:13,832 - INFO - Accuracy: 0.4336\n2025-07-15 00:53:13,832 - INFO - Loss: 2.9345\n2025-07-15 00:53:13,834 - INFO - Validation Accuracy: 0.4336, Validation Loss: 2.9345\n2025-07-15 00:53:13,834 - INFO - --------------------------------\n2025-07-15 01:03:28,461 - INFO - Epoch 14/15, Average Loss: 0.6000\n2025-07-15 01:03:28,461 - INFO - ---\n2025-07-15 01:03:28,461 - INFO - \n--- Saving model and evaluating after Epoch 14 ---\n2025-07-15 01:03:28,694 - INFO - Model saved to model-2/model_epoch_14.pth\n2025-07-15 01:03:28,695 - INFO - Running evaluation on validation set...\n2025-07-15 01:08:25,722 - INFO - Accuracy: 0.4358\n2025-07-15 01:08:25,723 - INFO - Loss: 3.1118\n2025-07-15 01:08:25,724 - INFO - Validation Accuracy: 0.4358, Validation Loss: 3.1118\n2025-07-15 01:08:25,724 - INFO - --------------------------------\n2025-07-15 01:18:39,512 - INFO - Epoch 15/15, Average Loss: 0.5510\n2025-07-15 01:18:39,512 - INFO - ---\n2025-07-15 01:18:39,512 - INFO - \n--- Saving model and evaluating after Epoch 15 ---\n2025-07-15 01:18:39,729 - INFO - Model saved to model-2/model_epoch_15.pth\n2025-07-15 01:18:39,729 - INFO - Running evaluation on validation set...\n2025-07-15 01:23:38,861 - INFO - Accuracy: 0.4307\n2025-07-15 01:23:38,861 - INFO - Loss: 3.1711\n2025-07-15 01:23:38,863 - INFO - Validation Accuracy: 0.4307, Validation Loss: 3.1711\n2025-07-15 01:23:38,864 - INFO - --------------------------------\n\n```\n\n\n\nModel 3：\n\n```cpp\n2025-07-14 23:52:33,153 - INFO - 模型二训练 model-7-14\n2025-07-14 23:52:33,153 - INFO - Start A New Training, log_dir: model-3\n2025-07-14 23:52:57,599 - INFO - Save every epochs: 1\n2025-07-15 00:03:10,815 - INFO - Epoch 1/15, Average Loss: 3.2105\n2025-07-15 00:03:10,816 - INFO - ---\n2025-07-15 00:03:10,817 - INFO - \n--- Saving model and evaluating after Epoch 1 ---\n2025-07-15 00:03:11,041 - INFO - Model saved to model-3/model_epoch_1.pth\n2025-07-15 00:03:11,042 - INFO - Running evaluation on validation set...\n2025-07-15 00:08:10,308 - INFO - Accuracy: 0.3529\n2025-07-15 00:08:10,314 - INFO - Loss: 2.6552\n2025-07-15 00:08:10,314 - INFO - Validation Accuracy: 0.3529, Validation Loss: 2.6552\n2025-07-15 00:08:10,314 - INFO - --------------------------------\n2025-07-15 00:18:23,356 - INFO - Epoch 2/15, Average Loss: 2.4078\n2025-07-15 00:18:23,356 - INFO - ---\n2025-07-15 00:18:23,357 - INFO - \n--- Saving model and evaluating after Epoch 2 ---\n2025-07-15 00:18:23,562 - INFO - Model saved to model-3/model_epoch_2.pth\n2025-07-15 00:18:23,562 - INFO - Running evaluation on validation set...\n2025-07-15 00:23:22,221 - INFO - Accuracy: 0.3763\n2025-07-15 00:23:22,221 - INFO - Loss: 2.3913\n2025-07-15 00:23:22,221 - INFO - Validation Accuracy: 0.3763, Validation Loss: 2.3913\n2025-07-15 00:23:22,224 - INFO - --------------------------------\n2025-07-15 00:33:37,415 - INFO - Epoch 3/15, Average Loss: 2.1219\n2025-07-15 00:33:37,415 - INFO - ---\n2025-07-15 00:33:37,415 - INFO - \n--- Saving model and evaluating after Epoch 3 ---\n2025-07-15 00:33:37,664 - INFO - Model saved to model-3/model_epoch_3.pth\n2025-07-15 00:33:37,665 - INFO - Running evaluation on validation set...\n2025-07-15 00:38:36,318 - INFO - Accuracy: 0.3876\n2025-07-15 00:38:36,319 - INFO - Loss: 2.2888\n2025-07-15 00:38:36,320 - INFO - Validation Accuracy: 0.3876, Validation Loss: 2.2888\n2025-07-15 00:38:36,321 - INFO - --------------------------------\n2025-07-15 00:48:53,172 - INFO - Epoch 4/15, Average Loss: 1.9319\n2025-07-15 00:48:53,173 - INFO - ---\n2025-07-15 00:48:53,173 - INFO - \n--- Saving model and evaluating after Epoch 4 ---\n2025-07-15 00:48:53,396 - INFO - Model saved to model-3/model_epoch_4.pth\n2025-07-15 00:48:53,397 - INFO - Running evaluation on validation set...\n2025-07-15 00:53:56,342 - INFO - Accuracy: 0.3947\n2025-07-15 00:53:56,343 - INFO - Loss: 2.2570\n2025-07-15 00:53:56,344 - INFO - Validation Accuracy: 0.3947, Validation Loss: 2.2570\n2025-07-15 00:53:56,344 - INFO - --------------------------------\n2025-07-15 01:04:07,519 - INFO - Epoch 5/15, Average Loss: 1.7839\n2025-07-15 01:04:07,520 - INFO - ---\n2025-07-15 01:04:07,520 - INFO - \n--- Saving model and evaluating after Epoch 5 ---\n2025-07-15 01:04:07,734 - INFO - Model saved to model-3/model_epoch_5.pth\n2025-07-15 01:04:07,734 - INFO - Running evaluation on validation set...\n2025-07-15 01:09:06,658 - INFO - Accuracy: 0.3999\n2025-07-15 01:09:06,659 - INFO - Loss: 2.2633\n2025-07-15 01:09:06,660 - INFO - Validation Accuracy: 0.3999, Validation Loss: 2.2633\n2025-07-15 01:09:06,660 - INFO - --------------------------------\n2025-07-15 01:19:22,122 - INFO - Epoch 6/15, Average Loss: 1.6581\n2025-07-15 01:19:22,122 - INFO - ---\n2025-07-15 01:19:22,122 - INFO - \n--- Saving model and evaluating after Epoch 6 ---\n2025-07-15 01:19:22,337 - INFO - Model saved to model-3/model_epoch_6.pth\n2025-07-15 01:19:22,337 - INFO - Running evaluation on validation set...\n2025-07-15 01:24:12,056 - INFO - Accuracy: 0.3990\n2025-07-15 01:24:12,057 - INFO - Loss: 2.2910\n2025-07-15 01:24:12,057 - INFO - Validation Accuracy: 0.3990, Validation Loss: 2.2910\n2025-07-15 01:24:12,057 - INFO - --------------------------------\n2025-07-15 01:31:47,245 - INFO - Epoch 7/15, Average Loss: 1.5501\n2025-07-15 01:31:47,245 - INFO - ---\n2025-07-15 01:31:47,245 - INFO - \n--- Saving model and evaluating after Epoch 7 ---\n2025-07-15 01:31:47,413 - INFO - Model saved to model-3/model_epoch_7.pth\n2025-07-15 01:31:47,413 - INFO - Running evaluation on validation set...\n2025-07-15 01:35:17,817 - INFO - Accuracy: 0.4009\n2025-07-15 01:35:17,817 - INFO - Loss: 2.3232\n2025-07-15 01:35:17,818 - INFO - Validation Accuracy: 0.4009, Validation Loss: 2.3232\n2025-07-15 01:35:17,819 - INFO - --------------------------------\n2025-07-15 01:42:55,178 - INFO - Epoch 8/15, Average Loss: 1.4566\n2025-07-15 01:42:55,178 - INFO - ---\n2025-07-15 01:42:55,178 - INFO - \n--- Saving model and evaluating after Epoch 8 ---\n2025-07-15 01:42:55,335 - INFO - Model saved to model-3/model_epoch_8.pth\n2025-07-15 01:42:55,335 - INFO - Running evaluation on validation set...\n2025-07-15 01:46:26,033 - INFO - Accuracy: 0.4028\n2025-07-15 01:46:26,033 - INFO - Loss: 2.3793\n2025-07-15 01:46:26,034 - INFO - Validation Accuracy: 0.4028, Validation Loss: 2.3793\n2025-07-15 01:46:26,035 - INFO - --------------------------------\n2025-07-15 01:54:04,536 - INFO - Epoch 9/15, Average Loss: 1.3754\n2025-07-15 01:54:04,536 - INFO - ---\n2025-07-15 01:54:04,537 - INFO - \n--- Saving model and evaluating after Epoch 9 ---\n2025-07-15 01:54:04,702 - INFO - Model saved to model-3/model_epoch_9.pth\n2025-07-15 01:54:04,703 - INFO - Running evaluation on validation set...\n2025-07-15 01:57:37,852 - INFO - Accuracy: 0.4021\n2025-07-15 01:57:37,853 - INFO - Loss: 2.4269\n2025-07-15 01:57:37,853 - INFO - Validation Accuracy: 0.4021, Validation Loss: 2.4269\n2025-07-15 01:57:37,853 - INFO - --------------------------------\n2025-07-15 02:05:15,181 - INFO - Epoch 10/15, Average Loss: 1.3039\n2025-07-15 02:05:15,181 - INFO - ---\n2025-07-15 02:05:15,183 - INFO - \n--- Saving model and evaluating after Epoch 10 ---\n2025-07-15 02:05:15,379 - INFO - Model saved to model-3/model_epoch_10.pth\n2025-07-15 02:05:15,379 - INFO - Running evaluation on validation set...\n2025-07-15 02:08:47,073 - INFO - Accuracy: 0.4028\n2025-07-15 02:08:47,073 - INFO - Loss: 2.4854\n2025-07-15 02:08:47,074 - INFO - Validation Accuracy: 0.4028, Validation Loss: 2.4854\n2025-07-15 02:08:47,074 - INFO - --------------------------------\n2025-07-15 02:16:25,832 - INFO - Epoch 11/15, Average Loss: 1.2426\n2025-07-15 02:16:25,833 - INFO - ---\n2025-07-15 02:16:25,833 - INFO - \n--- Saving model and evaluating after Epoch 11 ---\n2025-07-15 02:16:25,999 - INFO - Model saved to model-3/model_epoch_11.pth\n2025-07-15 02:16:25,999 - INFO - Running evaluation on validation set...\n2025-07-15 02:19:59,859 - INFO - Accuracy: 0.4013\n2025-07-15 02:19:59,859 - INFO - Loss: 2.5545\n2025-07-15 02:19:59,860 - INFO - Validation Accuracy: 0.4013, Validation Loss: 2.5545\n2025-07-15 02:19:59,860 - INFO - --------------------------------\n2025-07-15 02:27:32,272 - INFO - Epoch 12/15, Average Loss: 1.1865\n2025-07-15 02:27:32,273 - INFO - ---\n2025-07-15 02:27:32,274 - INFO - \n--- Saving model and evaluating after Epoch 12 ---\n2025-07-15 02:27:32,438 - INFO - Model saved to model-3/model_epoch_12.pth\n2025-07-15 02:27:32,439 - INFO - Running evaluation on validation set...\n2025-07-15 02:31:04,379 - INFO - Accuracy: 0.3989\n2025-07-15 02:31:04,380 - INFO - Loss: 2.6122\n2025-07-15 02:31:04,380 - INFO - Validation Accuracy: 0.3989, Validation Loss: 2.6122\n2025-07-15 02:31:04,380 - INFO - --------------------------------\n2025-07-15 02:38:40,199 - INFO - Epoch 13/15, Average Loss: 1.1350\n2025-07-15 02:38:40,200 - INFO - ---\n2025-07-15 02:38:40,200 - INFO - \n--- Saving model and evaluating after Epoch 13 ---\n2025-07-15 02:38:40,380 - INFO - Model saved to model-3/model_epoch_13.pth\n2025-07-15 02:38:40,380 - INFO - Running evaluation on validation set...\n2025-07-15 02:42:11,942 - INFO - Accuracy: 0.3984\n2025-07-15 02:42:11,942 - INFO - Loss: 2.6879\n2025-07-15 02:42:11,942 - INFO - Validation Accuracy: 0.3984, Validation Loss: 2.6879\n2025-07-15 02:42:11,943 - INFO - --------------------------------\n2025-07-15 02:49:52,821 - INFO - Epoch 14/15, Average Loss: 1.0911\n2025-07-15 02:49:52,822 - INFO - ---\n2025-07-15 02:49:52,822 - INFO - \n--- Saving model and evaluating after Epoch 14 ---\n2025-07-15 02:49:52,989 - INFO - Model saved to model-3/model_epoch_14.pth\n2025-07-15 02:49:52,989 - INFO - Running evaluation on validation set...\n2025-07-15 02:53:25,289 - INFO - Accuracy: 0.3954\n2025-07-15 02:53:25,290 - INFO - Loss: 2.7446\n2025-07-15 02:53:25,290 - INFO - Validation Accuracy: 0.3954, Validation Loss: 2.7446\n2025-07-15 02:53:25,290 - INFO - --------------------------------\n2025-07-15 03:00:59,078 - INFO - Epoch 15/15, Average Loss: 1.0485\n2025-07-15 03:00:59,079 - INFO - ---\n2025-07-15 03:00:59,079 - INFO - \n--- Saving model and evaluating after Epoch 15 ---\n2025-07-15 03:00:59,242 - INFO - Model saved to model-3/model_epoch_15.pth\n2025-07-15 03:00:59,242 - INFO - Running evaluation on validation set...\n2025-07-15 03:04:31,190 - INFO - Accuracy: 0.3991\n2025-07-15 03:04:31,191 - INFO - Loss: 2.8151\n2025-07-15 03:04:31,191 - INFO - Validation Accuracy: 0.3991, Validation Loss: 2.8151\n2025-07-15 03:04:31,191 - INFO - --------------------------------\n```\n\n我把模型全部重新跑了一遍，相关细节：\n- 训练数据集：vqa-v2 train\n- 评估数据集： vqa-v2 val\n- 训练轮次：15 epochs\n- 单卡（batch_size= 512, num_workers=16) 训练时长从2-3h，每一个模型训练实际占用显存约5GB\n结果如下：\n![loss_comparison](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/loss_comparison.png)\n\n![accuracy_comparison](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/accuracy_comparison.png)","categories":["科研启蒙","Reports"]},{"title":"例会汇报 | 第八次","url":"/posts/c37b764ffd13/","content":"\n<div style=\"\n  padding: 8px 15px;\n  border-left: 5px solid #e91e63;\n  display: inline-block;\n\">\n  省流版:这两天我又双叒叕想复现一个模型，又双叒叕失败了；但是也积累了一些<del>经验</del>教训\n</div>\n\n因为环境迁移很麻烦，然后就想着要实现一个\n\n实验室环境：\n\npython3.6.8（2018年），对应支持的包版本也就比较旧，比如numpy只支持到1.19.5；\n\ncentOS7，也是很老了\n\n我们没有管理员权限\n\n---\n\n**尝试远程开发**\n\n这样就不用使用ftp传文件了，也不用切来切去了\n\n[LinuxPrereqs]: 远程主机可能不符合 glibc 和 libstdc++ VS Code 服务器的先决条件 (远程主机不满足运行VS Code服务器的先决条件)\n\n>   glibc 和 libstdc++版本太老了！！更新不了\n\n---\n\n<div style=\"\n  padding: 8px 15px;\n  border-left: 5px solid #e91e63;\n  display: inline-block;\n\">\n  下一步的计划\n</div>\n\n我计划下一步先实现一个最小的，能够有效的跑起来的模型，成功之后再慢慢提升复杂度😂\n\n参考的三个模型的代码和结构：\n\n**层次化注意力**\n\n[Hierarchical Question-Image Co-Attention for Visual Question Answering](https://proceedings.neurips.cc/paper_files/paper/2016/file/9dcb88e0137649590b755372b040afad-Paper.pdf)\n\npytorch复现代码仓库https://github.com/karunraju/VQA/tree/master\n\n>   注：原代码是用lua写的，这个是第三方复现代码；\n>\n>   在注意力融合阶段做的比较复杂，说实话不是很明白\n\n---\n\n**VQA: Visual Question Answering**\n\n[VQA: Visual Question Answering](https://arxiv.org/pdf/1505.00468)\n\n复现代码https://github.com/tbmoon/basic_vqa，结构：\n\n![model](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/basic_model.png)\n\n** **\n\n**Simple Baseline for Visual Question Answering**\n\n[Simple Baseline for Visual Question Answering](https://arxiv.org/pdf/1512.02167)\n\n结构如图，代码仓库：[zhoubolei/VQAbaseline: Simple Baseline for Visual Question Answering](https://github.com/zhoubolei/VQAbaseline)\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250624232422917.png\" alt=\"image-20250624232422917\"  />\n\n---\n\n","categories":["科研启蒙","Reports"]},{"title":"例会汇报 | 第九次","url":"/posts/4c1b551cb3ec/","content":"\n## 数据集\n\n### The composition of dataset\n\n-   Images\n-   Annotations\n-   Questions\n\n### How to use dataset?\n\n以vqa-v1数据集和vqa-v2数据集为例\n\n## 词表\n\n------\n\n你理解得非常准确！简单来说，你概括得很好。\n\n是的，这段代码的核心目的就是构建一个**“语言到数字的翻译”系统**。\n\n-   **`word2idx`：** 没错，它是在构建将**问题中的每个词语“翻译”成唯一数字 ID 的字典**。当用户输入一个问题时，比如“图片里有什么？”，这段代码首先将问题分词为 `['图片', '里', '有', '什么']`，然后利用 `word2idx` 把它们逐个转换成对应的数字序列，例如 `[10, 25, 8, 30]`。这个数字序列才是模型能够理解和处理的输入。\n-   **`answer2idx`：** 这部分你的理解稍微有点偏差，但只是一点点。`answer2idx` 实际上是**将最常见的“答案文本”也翻译成唯一的数字 ID**（例如，把“Yes”翻译成 `0`，把“No”翻译成 `1`，把“Red”翻译成 `2` 等）。\n    -   **在训练阶段**：模型会学习如何将图片和问题（都已经数字化了）映射到对应的答案数字 ID。\n    -   **在预测阶段**：模型会根据输入的图片和问题，**输出一个数字**（比如 `0`）。然后，我们会需要一个**逆向的翻译表**（通常称为 `idx2answer`，它是 `answer2idx` 的反向映射，通过 `idx2answer = {v: k for k, v in answer2idx.items()}` 就能得到），用它把模型输出的这个数字 `0` 再“翻译”回人类能理解的答案文本，也就是“Yes”。\n\n所以，整个流程可以概括为：\n\n1.  **用户输入问题 (文本) → `tokenize` + `word2idx` → 问题数字序列 (模型输入)**\n2.  **模型处理图片特征和问题数字序列 → 模型输出一个答案数字 ID**\n3.  **模型输出的答案数字 ID → `idx2answer` (根据 `answer2idx` 反向构建) → 最终答案 (文本)**\n\n理解了这一点，你就抓住了 VQA 模型中文本处理和数字映射的关键原理了！\n\n------\n\n## 尝试写了一个mini-vqa模型\n\n结构很简单，图像使用resnet18提取出512维特征，问题也是得到512维特征，之后两个相拼接（特征融合），并且从得到答案\n\n![a80e79c486cdd4b0d4eb34fc28090d51](https://malanhuakai.oss-cn-nanjing.aliyuncs.com/malanhuakai/a80e79c486cdd4b0d4eb34fc28090d51.png)\n\n![image-20250626172722596](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250626172722596.png)\n\n![image-20250626172734930](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250626172734930.png)\n\n![image-20250626172748879](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250626172748879.png)\n\n使用val数据集（Question为）进行计算正确率：\n\n| 训练轮数 | Accuracy            |\n| -------- | ------------------- |\n| 5        | 0.43181743366910263 |\n| 10       | 0.42779313977220357 |\n| 15       | 0.4269207979458819  |\n| 20       | 0.4191026400684706  |\n\n---\n\n\n\n## 和官方的进行对比\n\n官方的评估脚本https://github.com/GT-Vision-Lab/VQA\n\n官方的测试baselinehttps://github.com/hengyuan-hu/bottom-up-attention-vqa","categories":["科研启蒙","Reports"]},{"title":"高程复习","url":"/posts/a7a0c9086189/","content":"\n## 老师最后一节课画的重点\n\n1. 面相对象： 代码、背后的逻辑（在编程题和程序分析题）\n2. 操作符重载：不会单独考，会和oop一起考（和编程题中加入，手写代码）\n3. 面向对象IO（输入流输出流不作为重点，）不是重点，可能在编程里需要处理输入输出\n4. Exception 不会多于5分，考程序分析题\n5. 不会考时间驱动的\n6. 泛型不会单独出题\n7. 并行程序设计 10分左右，OJ、课后作业、课上例子的难度 \n8. 内存安全程序设计： 程序分析题等，会和面向程序等知识结合\n9. 函数式和程序\n10. **只有程序分析题和编程题**（全是代码，不需要注意ppt里面有哪些概念，而是把编程熟悉）\n11. STL 不考，如果考的话，会告诉所有api，甚至可以在考试的时候问。\n12. 智能指针会考，因为属于内存安全问题（时间和空间，unique_ptr,shared_ptr,weak_ptr）\n13. 题量比较大，可能是2h刚好写完，题量大\n14. IO和事件驱动不用看 \n\n## 核心必考内容\n\n### 1. 面向对象编程\n\n#### 1.1 对象的创建方式（必考）\n- 直接创建：`A a;` 内存在stack区，作用域结束后内存自动释放\n- 间接方式创建动态变量：`A* p=new A;` 需要手动释放内存 `delete p;`\n- 在创建对象的可以传参（具体根据`constructor`来决定，但是`A* alist= new A[100]`;只能调用默认构造函数；\n\n#### 1.2 对象作为函数参数和返回值（必考）\n```cpp\nvoid fun(A a){} // 传入对象，创建临时对象\nvoid g(A& a){} // 传入原对象的引用\nDate f1(A& a){ return a; } // 创建临时变量并返回\nDate& f1(A& a){ return a; } // 返回原对象的引用\n```\n\n比如，下面这个例子中，当对象作为值进行传递的时候，会调用拷贝构造函数**两次（传入一次，return一次）**\n\n```cpp\nString returnByValue(String getByValue){\n        return getByValue;\n    }\n```\n\n而下面这个例子只会出现一次：\n\n```cpp\n    String& returnByValue(String getByValue){\n        return getByValue;\n    }\n```\n\n都使用reference的话，不会出现拷贝构造：\n\n```cpp\n    String& returnByValue(String& getByValue){\n        return getByValue;\n    }\n```\n\n\n\n#### 1.3 析构函数（200%必考）\n\n什么时候必须要析构函数：\n```cpp\nclass String {\n    int len;\n    char *str;\npublic:\n    String(char *s) { \n        len = strlen(s); \n        str = new char[len+1]; \n        strcpy(str,s); \n    }\n    ~String() { \n        delete []str; \n        len=0; \n        str=nullptr; // 为了更加安全\n    }\n};\n```\n\n#### 1.4 拷贝构造函数（必考）\n浅拷贝与深拷贝问题：\n\n>   关注什么时候需要自定义拷贝构造函数！！\n\n```cpp\nclass String {\n    int len;\n    char *str;\npublic:\n    String(char *s) { \n        len = strlen(s); \n        str = new char[len+1]; \n        strcpy(str,s); \n    }\n    // 深拷贝构造函数\n    String(String& s) {\n        len = s.len;\n        str = new char[len+1];\n        strcpy(str, s.str);\n    }\n    ~String() { delete []str; len=0; str=nullptr; }\n};\n```\n\n当涉及到多个类的时候，情况更加复杂，如果A是B的一个成员变量（composition），B使用拷贝构造函数的时候，如果没有明确指出调用A的拷贝构造函数，那么就会调用A的默认构造函数:\n\n```cpp\n注意：自定义的拷贝构造函数默认调用的是成员对象类的默认构造函数来对成员对象初始化！\nclass A\n{  int x,y;\n public:\n  A() { x = y = 0; }\n  void inc() { x++; y++; }\n};\nclass B\n{    int z;\n   A a;\n   public:\n   B() { z = 0; }\n   B(const B& b)            { z = b.z; }\n   void inc() { z++; a.inc(); }\n};\n...\nB b1;  /b1.z、b1.a.x和b1.a.y均为0\nb1.inc();  //b1.z、b1.a.x和b1.a.y均变成了1\nB b2(b1); //b2.z为1，b2.a.x和b2.a.y均为0\n如何能让b2与b1一致呢？\n在B类的拷贝构造函数的成员初始化表中显式指出！\n下面对b2.a进行赋值初始化与拷贝构造的区别是什么？\nclass A { ...... };\nclass B\n{ int z;\n   A a;\n  public:\n   B() { ...... }\n   B(const B& b)\n   { z = b.z;\n      a = b.a;\n   }\n   ......\n};\nB b1;\nB b2(b1);\n```\n\n\n\n#### 1.5 派生类的成员对外访问情况（100%必考）\n\n- public继承：基类public成员→派生类public成员；基类protected成员→派生类protected成员\n- protected继承：基类public和protected成员→派生类protected成员\n- private继承：基类public和protected成员→派生类private成员\n- 不需要考虑积累的private成员变成派生类的什么成员，因为private成员无论那种继承都是不可见的\n\n>   A man and woman are in a computer programming lecture. The man touches the woman's breasts.\n>\n>   \"Hey!\" she says. \"Those are private!\"\n>\n>   The man says, \"But we're in the same class!\"\n\n---\n\n>   NOTE：此处略去`常成员函数`和`继承`的内容，因为我tm时间来不及了，只能抓紧搞重点了；\n>\n>   有关继承注意一点： 可以将derived class的成员变量（或者pointer）赋值给base class，反之不行。并且先调用base的构造函数，再派生类；析构时恰好相反。\n\n例子：\n\n```cpp\nclass A\n{\tpublic:\n\t\tvoid f();\n\tprotected:\n\t\tvoid g();\n\tprivate:\n\t\tvoid h();\n};\nclass B: protected A\n{ //f为protected\n   //g为protected\n   //h为不可直接访问\n   public:\n\t\tvoid q() \n\t\t{ f(); //?\n\t\t   g(); //?\n\t\t   h(); //?\n\t\t}\n};\nclass C: public B\n{\tpublic:\n\t\tvoid r()\n\t\t{\tf();  //OK\n\t\t\tg();  //OK\n\t\t\th();  //Error\n\t\t     q();  //?\n     }\n};\nvoid func()\n{ B b;\n   b.f();  //Error\n   b.g(); //Error\n   b.h(); //Error\n   b.q(); //?\n}\n```\n\n\n\n### 2. 虚函数和消息的动态绑定（200%必考）\n\n#### 2.1 静态绑定与动态绑定\n\n静态绑定：\n\n```cpp\nvoid main(){\n\tA a;\n\tfunc1(a);\n\tfunc2(&a);\n\tB b;\n\tfunc1(b);\n\tfunc2(&b);\n}\n//无论传入的是A还是B，都是调用A的f，因为这里的形参已经确定\nvoid func1(A& x)\n{\t......\n\tx.f(); //调用A::f还是B::f ？\n\t......\n}\nvoid func2(A *p)\n{\t......\n\tp->f(); //调用A::f还是B::f ？\n\t......\n}\n```\n\n动态绑定：\n\n```cpp\nclass A {\npublic:\n    virtual void f();\n};\nclass B: public A {\npublic:\n    void f(); \n    void g();\n};\nvoid func1(A& x) {\n    x.f(); // 动态绑定，根据对象类型调用A::f或B::f\n}\nvoid func2(A *p) {\n    p->f(); // 动态绑定，根据对象类型调用A::f或B::f\n}\nA a;\nfunc1(a); // 调用A::f\nB b;\nfunc1(b); // 调用B::f\n```\n\n**重要提示**：\n- 只有通过指针或引用调用虚函数才能实现动态绑定\n- 构造函数不能是虚函数，析构函数往往是虚函数\n- 在构造函数和析构函数中调用虚函数不会进行动态绑定\n\n### 3. 操作符重载\n\n#### 3.1 前置++和后置++的操作符重载（必考）\n```cpp\nclass Counter {\n    int value;\npublic:\n    Counter() { value = 0; }\n    // 前置++\n    Counter& operator++() {\n        value++;\n        return *this;\n    }\n    // 后置++\n    const Counter operator++(int) {\n        Counter temp = *this; // 保存原对象\n        value++; // 或 ++(*this);\n        return temp; // 返回原对象\n    }\n};\n```\n\n#### 3.2 赋值操作符重载（必考）\n```cpp\nclass String {\n    int len;\n    char *str;\npublic:\n    String& operator=(const String& s) {\n        if (&s == this) return *this;  // 防止自身赋值\n        delete []str; // 释放原有内存\n        str = new char[s.len+1];\n        strcpy(str, s.str);\n        len = s.len; \n        return *this;\n    }\n};\n```\n\n### 4. 异常处理（必考，10分左右）\n\n```cpp\nvoid f() {\n    try {\n        throw 1;\n    } catch(int a) {\n        cout << \"Catch \" << a << endl;\n        throw 2;\n    }\n}\n\ntry {\n    f();\n    g();\n} catch(int) {\n    // 处理异常\n} catch(char*) {\n    // 处理异常\n}\n```\n\n异常处理机制：\n- 每个函数有一个catch表\n- 执行throw时检查当前catch表是否能捕获\n- 如果不能捕获，退栈回到上一个函数\n- 如果能被catch，从捕获点继续执行\n- 如果最终未被捕获，调用terminate()终止程序\n\n### 5. 内存安全程序设计\n\n#### 5.1 RAII和智能指针（100%必考）\n```cpp\ntemplate<typename T> \nclass Toy_ptr {\n    T* ptr;\npublic:\n    Toy_ptr(T* p = nullptr) : ptr(p) {}\n    ~Toy_ptr() { delete ptr; }\n    T& operator*() { return *ptr; }\n    T* operator->() { return ptr; }\n};\n```\n\n#### 5.2 智能指针（必考）\n\n##### unique_ptr\n```cpp\n#include <memory>\n\nstd::unique_ptr<int> p1(new int(10));\nauto p2 = std::make_unique<int>(10);\nauto p3 = std::move(p2); // p2变为nullptr\n\nint* raw_ptr = p1.release(); // p1变为nullptr，返回原始指针\np3.reset(new int(20)); // 释放原指针，设置新指针\n```\n\n##### shared_ptr\n```cpp\nstd::shared_ptr<int> p1(new int(10));\nauto p2 = p1; // 引用计数+1\nauto p3 = std::make_shared<int>(20);\n\nstd::cout << p1.use_count(); // 输出引用计数\np2.reset(); // 减少引用计数\n```\n\n##### weak_ptr（解决循环引用问题）\n```cpp\nstruct Node {\n    std::shared_ptr<Node> next;\n    std::weak_ptr<Node> prev; // 使用weak_ptr避免循环引用\n};\n```\n\n### 6. 并行程序设计（10分左右）\n\n多线程基础：\n```cpp\n#include <thread>\n\nvoid func(int& n) {\n    n++;\n}\n\nint main() {\n    int n = 0;\n    std::thread t1(func, std::ref(n));\n    std::thread t2(func, std::ref(n));\n    t1.join();\n    t2.join();\n    return 0;\n}\n```\n\n## 注意事项\n\n1. 代码题中注意检查：\n   - 析构函数是否正确释放内存\n   - 拷贝构造函数是否实现深拷贝\n   - 赋值操作符是否检查自赋值\n   - 智能指针的正确使用\n\n2. 程序分析题中注意：\n   - 虚函数的动态绑定规则\n   - 派生类成员访问权限\n   - 异常处理的执行流程\n   - 智能指针的引用计数变化\n\n3. 重点关注老师上课提到的例子，特别是标注为\"必考\"、\"200%必考\"的内容\n\n## 模拟题\n\n### 程序分析题\n\n#### 题目1：分析虚函数与静态/动态绑定（15分）\n找出以下代码中的错误并解释原因，同时分析每个函数调用时执行的是哪个类的函数。\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nclass Base {\nprotected:\n    int data;\npublic:\n    Base(int d = 0) : data(d) { cout << \"Base constructor\" << endl; }\n    virtual ~Base() { cout << \"Base destructor\" << endl; }\n    virtual void show() { cout << \"Base::show: \" << data << endl; }\n    void display() { cout << \"Base::display\" << endl; show(); }\n};\n\nclass Derived : public Base {\n    int* ptr;\npublic:\n    Derived(int d = 0, int p = 0) : Base(d) {\n        ptr = new int(p);\n        cout << \"Derived constructor\" << endl;\n        show();  \n    }\n    ~Derived() {\n        cout << \"Derived destructor\" << endl;\n        delete ptr;\n    }\n    void show() override {\n        cout << \"Derived::show: \" << data << \", \" << *ptr << endl;\n    }\n};\n\nint main() {\n    Base* bp = new Derived(5, 10);\n    bp->show();\n    bp->display();\n    \n    Derived d1(1, 2);\n    Base b1 = d1;  \n    b1.show();\n    \n    Derived d2(3, 4);\n    Derived d3 = d2;     \n    delete bp;\n    return 0;\n}\n```\n\n我的解答：\n\n>   ```cpp\n>   int main() {\n>       Base* bp = new Derived(5, 10);\n>       //调用: Base::Base() Derived::Derived() Derived::show()\n>       bp->show();\n>       //Derived::show()\n>       bp->display();\n>       //Base::display()\n>       Derived d1(1, 2);\n>       //调用: Base::Base() Derived::Derived() Derived::show()\n>       \n>       Base b1 = d1;  //会缺失derived class的一些东西\n>       b1.show();\t//Base::shwo()\n>       \n>       Derived d2(3, 4);\n>       //调用: Base::Base() Derived::Derived() Derived::show()\n>       \n>       Derived d3 = d2;     \n>       //shallow copy\n>       delete bp;\n>       return 0;\n>   }\n>   ```\n>\n>   \n\n#### 题目2：内存安全与智能指针（20分）\n\n以下代码存在几个内存安全问题，请找出并修正它们。\n\n```cpp\n#include <iostream>\n#include <memory>\nusing namespace std;\n\nclass Resource {\n    int id;\npublic:\n    Resource(int i) : id(i) { cout << \"Resource \" << id << \" created\" << endl; }\n    ~Resource() { cout << \"Resource \" << id << \" destroyed\" << endl; }\n    void use() { cout << \"Using resource \" << id << endl; }\n};\n\nstruct Node {\n    shared_ptr<Resource> res;\n    shared_ptr<Node> next;\n    shared_ptr<Node> prev;\n    \n    Node(int id) : res(new Resource(id)) {}\n};\n\nvoid problematicFunction() {\n    Resource* raw = new Resource(1);\n    unique_ptr<Resource> u1(raw);\n    unique_ptr<Resource> u2(raw);  \n    shared_ptr<Resource> s1(new Resource(2));\n    Resource* r2 = s1.get();\n    delete r2; \n    \n   auto node1 = make_shared<Node>(3);\n    auto node2 = make_shared<Node>(4);\n    node1->next = node2;\n    node2->prev = node1; \n}\n\nint main() {\n    problematicFunction();\n    cout << \"Function finished\" << endl;\n    return 0;\n}\n```\n\n>   My solution:\n>\n>   ```cpp\n>   void problematicFunction() {\n>       Resource* raw = new Resource(1);\n>       unique_ptr<Resource> u1(raw);\n>       unique_ptr<Resource> u2(raw);  //用同一个裸指针\n>       shared_ptr<Resource> s1(new Resource(2));\n>       Resource* r2 = s1.get();\n>       delete r2;  //不能这样， 会出现重复释放问题    \n>      auto node1 = make_shared<Node>(3);\n>       auto node2 = make_shared<Node>(4);\n>       node1->next = node2;\n>       node2->prev = node1; //循环引用\n>   }\n>   ```\n>\n>   \n\n#### 题目3：异常处理（10分）\n\n分析以下代码的执行过程，说明每个catch块是否会执行，以及最终的输出结果。\n\n```cpp\n#include <iostream>\nusing namespace std;\n\nvoid f3() {\n    cout << \"f3 starts\" << endl;\n    throw 42;\n    cout << \"f3 ends\" << endl;\n}\n\nvoid f2() {\n    cout << \"f2 starts\" << endl;\n    try {\n        f3();\n    } catch (char* msg) {\n        cout << \"f2 caught char*: \" << msg << endl;\n    }\n    cout << \"f2 ends\" << endl;\n}\n\nvoid f1() {\n    cout << \"f1 starts\" << endl;\n    try {\n        f2();\n    } catch (int e) {\n        cout << \"f1 caught int: \" << e << endl;\n        throw \"Exception from f1\";\n    }\n    cout << \"f1 ends\" << endl;\n}\n\nint main() {\n    cout << \"main starts\" << endl;\n    try {\n        f1();\n    } catch (const char* msg) {\n        cout << \"main caught char*: \" << msg << endl;\n    } catch (...) {\n        cout << \"main caught unknown exception\" << endl;\n    }\n    cout << \"main ends\" << endl;\n    return 0;\n}\n```\n\n>   My solution:\n>\n>   ```cpp\n>   #include <iostream>\n>   using namespace std;\n>   \n>   void f3() {\n>       cout << \"f3 starts\" << endl;\n>       throw 42;\n>       cout << \"f3 ends\" << endl;\n>   }\n>   \n>   void f2() {\n>       cout << \"f2 starts\" << endl;\n>       try {\n>           f3();\n>       } catch (char* msg) {\n>           cout << \"f2 caught char*: \" << msg << endl;\n>       }\n>       cout << \"f2 ends\" << endl;\n>   }\n>   \n>   void f1() {\n>       cout << \"f1 starts\" << endl;\n>       try {\n>           f2();\n>       } catch (int e) {\n>           //42被捕获\n>           cout << \"f1 caught int: \" << e << endl;\n>           throw \"Exception from f1\";\n>       }\n>       cout << \"f1 ends\" << endl;\n>   }\n>   \n>   int main() {\n>       cout << \"main starts\" << endl;\n>       try {\n>           f1();\n>       } catch (const char* msg) {\n>           //Exception from f1被捕获\n>           cout << \"main caught char*: \" << msg << endl;\n>       } catch (...) {\n>           cout << \"main caught unknown exception\" << endl;\n>       }\n>       cout << \"main ends\" << endl;\n>       return 0;\n>   }\n>   ```\n>\n>   \n\n### 编程题\n\n#### 题目4：实现一个内存池分配器（25分）\n实现一个简单的内存池，使用operator new和operator delete来管理固定大小的对象。要求：\n\n1. 每次申请内存时，如果池中有可用内存块，则从池中分配\n2. 如果池为空，则一次性申请多个内存块（如32个）\n3. 当对象被删除时，将内存归还到池中而不是直接释放\n4. 程序结束时释放所有申请的内存\n\n```cpp\nclass MemoryPool {\n    // 实现代码\n};\n\nclass MyClass {\n    int data;\npublic:\n    MyClass(int d = 0) : data(d) {}\n    static void* operator new(size_t size);\n    static void operator delete(void* p);\n};\n```\n\n>   My solution：\n>\n>   ```cpp\n>   class MemoryPool {\n>       // 实现代码\n>   };\n>   \n>   class MyClass {\n>       int data;\n>   public:\n>       MyClass(int d = 0) : data(d) {}\n>       static void* operator new(size_t size);\n>       static void operator delete(void* p);\n>   };\n>   ```\n>\n>   \n\n#### 题目5：设计一个线程安全的单例模式（15分）\n\n实现一个线程安全的单例类，满足：\n\n1. 懒汉式初始化（第一次使用时才创建实例）\n2. 线程安全\n3. 防止内存泄漏\n4. 禁止拷贝和赋值\n\n#### 题目6：实现一个安全的字符串类（15分）\n设计一个安全的字符串类SafeString，正确处理内存管理、拷贝构造和赋值操作。要求：\n\n1. 实现深拷贝的拷贝构造函数和赋值操作符\n2. 正确处理自赋值情况\n3. 实现移动构造函数和移动赋值操作符\n4. 提供字符串连接运算符+和+=\n5. 实现比较运算符==、!=、<、>等\n\n```cpp\nclass SafeString {\nprivate:\n    char* data;\n    size_t length;\n    \npublic:\n    // 构造函数和析构函数\n    SafeString(const char* str = nullptr);\n    SafeString(const SafeString& other);\n    SafeString(SafeString&& other) noexcept;\n    ~SafeString();\n    \n    // 赋值操作符\n    SafeString& operator=(const SafeString& other);\n    SafeString& operator=(SafeString&& other) noexcept;\n    \n    // 其他操作符重载\n    // ...\n    \n    // 实用方法\n    size_t size() const;\n    const char* c_str() const;\n};\n```\n比较考验细节的地方是：\n```cpp\n SafeString operator+(const SafeString& other) const {\n        size_t newLen = length + other.length;\n        char* newData = new char[newLen + 1];\n        std::strcpy(newData, data);\n        std::strcat(newData, other.data);\n        SafeString result(newData);\n        delete[] newData;\n        return result;//这里要先delete之前的数据\n    }\n```\n#### 题目7：并行计算数组元素和（10分）\n编写一个函数，使用多线程计算一个大数组的元素和。要求：\n\n1. 将数组分成多个部分，每个线程计算一部分\n2. 正确汇总各线程的计算结果\n3. 处理线程同步问题\n4. 考虑性能和线程数量的优化\n\n","tags":["class-notes","njucs","复习"],"categories":["NJUCS","高级程序设计"]},{"title":"马原复习（陈建老师班）","url":"/posts/51226466442b/","content":"\n\n\n## 题型分布\n\n1.   名词解释\n\n     >   从以下10个里面选5个进行考察：\n     >\n     \n2.   简答题\n\n3.   论述题（要点+分析）\n\n## 名词解释\n\n>   [马克思主义哲学原理名词解释 - 知乎](https://zhuanlan.zhihu.com/p/27747613)\n\n### 物质  \n物质是标志客观实在的哲学范畴，是运动的承担者和存在方式。马克思主义认为，物质具有客观实在性，不依赖于人的意识而存在，并能为人的意识所反映。物质世界是统一的，其统一性在于其客观实在性（世界物质统一性原理）。物质的存在形式包括时间（一维性）和空间（三维性），其运动是绝对的、无条件的，而静止是相对的、有条件的。\n\n---\n\n### 静止  \n静止是**物质运动**在一定条件下表现出来的**相对稳定状态**，包括位置未变或性质未变两种情形。静止是相对的、有条件的，是运动的一种特殊状态。运动与静止相互依存、相互渗透，即“动中有静，静中有动”。承认相对静止的意义在于：只有通过静止状态，才能区分事物并研究其变化过程。\n\n---\n\n### 真理  \n**真理是人们对客观事物及其规律的正确反映**，具有客观性、绝对性和相对性。马克思主义强调实践是检验真理的唯一标准，真理在实践中不断发展，表现为绝对真理与相对真理的辩证统一。真理的绝对性指其内容的客观性和发展的无限性，相对性则指其在特定历史条件下的局限性。\n\n---\n\n### 矛盾特殊性  \n**矛盾特殊性指不同事物的矛盾及矛盾的不同方面各有其特点。**这是矛盾普遍性（矛盾存在于一切事物中）的具体表现，要求具体问题具体分析。例如，同一矛盾在不同发展阶段的表现不同，需采取不同解决方法（如唯物辩证法中“特殊性”对实践的指导意义）。\n\n---\n\n### 矛盾斗争性  \n**矛盾斗争性指矛盾双方相互排斥、相互对立的属性**，体现为对立面之间的冲突和转化。它是矛盾的基本属性之一（另一为同一性），推动事物的运动、变化和发展。例如，阶级斗争是社会基本矛盾在特定历史阶段的斗争性表现。\n\n---\n\n### 上层建筑  \n**上层建筑是建立在一定经济基础之上的意识形态、制度和设施的总和，包括政治法律制度（如国家政权）、意识形态（如宗教、哲学）等。**上层建筑反作用于经济基础，其性质由经济基础决定，并服务于统治阶级的利益需求。\n\n---\n\n### 理性认识  \n理性认识是认识的高级阶段，通过抽象思维把握事物的本质和规律，以概念、判断、推理等形式反映客观现实。它依赖于感性认识，但比感性认识更深刻，如通过理论分析揭示社会发展的客观规律。\n\n---\n\n### 社会存在  \n**社会存在指社会的物质生活条件，是社会生活的物质方面**，包括地理环境、人口因素和生产方式（核心）。它是社会意识的根源，决定社会意识的内容和变化，如生产力与生产关系的矛盾运动推动社会形态的更替。\n\n---\n\n### 社会意识  \n**社会意识是社会存在的反映，是社会生活的精神方面**。包括政治、法律、道德、宗教、哲学等意识形态，以及风俗习惯等。社会意识具有相对独立性，能反作用于社会存在，如先进的社会意识推动社会发展，落后的则阻碍。\n\n---\n\n### 改革  \n**改革是社会主义制度的自我完善和发展，是解决社会基本矛盾（生产力与生产关系、经济基础与上层建筑的矛盾）的根本途径**。通过调整不适应生产力的生产关系和上层建筑，改革推动经济社会发展，实现人民对美好生活的追求。  \n\n\n\n---\n\n## 重点内容\n\n### 1. 马克思主义的内涵\n\n详细见p2 第二段\n\n-   [x] 完成\n\n### 2. 马克思主义的基本特征\n\np13\n\n>   会考简答题或者论述题，建议将下面\n\n1.   科学性：马克思主义是对自然、社会、人类思维发展规律的正确反映\n2.   人民性:  人民至上是马克思主义的政治立场\n3.   实践性：马克思主义是从实践中来，到实践中去，在实践中不断发展的学科。\n4.   发展性：马克思主义是不断发展的学科，具有**与时俱进**的特点。\n\n>   如果是**简答题**: 你搭出来的**科学的理论，人民的理论、实践的理论、发展的理论。**\n>\n>   但是如果这个题是**论述题**，那么你必须要阐述你为什么说它是科学的理论，为什么说它是人民的理论，为什么实践理论发展的理论\n>\n>   **考的题型可能不一样**\n\n### 3. 马克思主义的当代价值\n\np16\n\n>   要考也是考简答题\n\n1.   观察世界变化的认识工具\n2.   指引当代中国发展的行动指南\n3.   引领人类社会进步的科学真理\n\n#### 4. 物质和意识的辩证关系 \n\np33\n\n1.   物质决定意识\n2.   意识对物质具有反作用\n3.   正确地认识物质与意识的辩证关系还需要把处理好主观能动性和客观规律之间的关系\n\n### 5. 矛盾的同一性和斗争性\n\np44\n\n**矛盾的同一性：**矛盾的对立面相互依存、相互贯通的性质和趋势。\n\n（相互依存：互为存在，处于同一个统一体中；相互贯通：在一定条件下可以转化）\n\n**矛盾的斗争性：**对立面相互排斥、相互分离的趋势\n\n### 6. 矛盾的普遍性和特殊性\n\np46\n\n**普遍性**：指矛盾存在于一切事物中，存在于一切事物发展过程的始终 —— 事事有矛盾，时时有矛盾。 **[方法论]**：坚持矛盾分析法\n\n**特殊性**：指各个具体事物的矛盾、每一个矛盾的各个方面在发展的不同阶段上各有其特点。矛盾的特殊性决定了事物的不同性质。 **[方法论]**：具体问题具体分析\n\n### 7. 如何理解实践对认识的决定作用\n\np79\n\n1.   实践是认识的来源\n2.   实践是认识的发展动力\n3.   实践是认识的目的\n4.   实践是检验认识真理性的唯一标准\n\n### 8. 从感性认识到理性认识\n\np85\n\n**感性认识：**在实践的基础上，由感觉器官直接感受到的事物的现象、事物的外部联系、事物的各个方面的认识（感觉器官对事物的直接认识）包括**感觉，知觉，表象**等。\n\n**理性认识：**借助抽象思维，概括整理大量感性材料基础上，达到的对事物本质、全体、内部联系和事物自身规律性的认识\n\n**需要哪些条件**\n\n1.    投身实践深入调查，获取感性材料（基础）\n2.    经过思考，运用理论思维对感性材料进行加工，形成概念理论系统。\n\n### 9. 为什么说实践是检验真理的唯一标准\n\n>   南大杰出校友【胡福明】是《实践是检验真理的唯一标准》的作者。\n\np101\n\n1.   从真理的本性看：真理是人们对客观事物及其发展规律的正确反映，**其本性在于主观和客观相符合。**\n2.   从实践的特点看：**实践具有`直接现实`性**。实践的直接现实性是其客观实在性的具体表现。\n\n### 10. 价值的基本特性\n\np104\n\n1.   主体性：价值直接与主体相联系，始终以主体为中心。\n2.   客观性：客体对于主体的意义不依赖于主体的主观意识而存在。\n3.   多维性：每个主体的价值关系具有多样性，同一客体对于主体的不同需求会产生不同的价值。\n4.   社会历史性：主体和客体的不断变化决定了价值的社会历史性。\n\n### 11. 生产力和生产关系的矛盾运动及其规律\n\np134\n\n1.   生产力决定生产关系：  \n     -   生产力状况决定生产关系的性质；（有什么样的生产力就有什么样的生产关系） \n     -   生产力的发展决定生产关系的变化；  （生产力变化->生产关系变化）\n2.   生产关系反作用于生产力 \n     -   .当生产关系适应生产力状况时，对生产力的发展起促进作用；\n     -   当生产关系不适应生产力状况时，它对生产力的发展起阻碍作用。\n\n>   经济基础和上层建筑不要求掌握\n\n### 12.社会基本矛盾是历史发展的根本动力\n\np154\n\n什么是社会基本矛盾？ 贯穿社会发展始终，规定社会发展过程中的基本性质和基本趋势，对社会发展起根本推动作用的矛盾。包括`生产力和生产关系之间的矛盾` `经济基础和上层建筑之间的矛盾` \n\n社会基本矛盾在历史发展中的作用主要表现在：\n\n1.   生产力是社会基本矛盾中最基本的动力因素\n2.   生产力是社会进步的根本内容\n3.   社会基本矛盾决定着社会中其他矛盾的存在和发展\n\n### 13. 科学技术在社会发展中的作用\n\np165\n\n>   这些内容也可能分开来考你，也可能综合起来就是说生产力、生产关系，包括科学技术，这些东西都是综合起来讲，因为本身科学技术就是生产力当中一个重要的一个元素。\n\n科学技术是先进生产力的重要标志，是推动社会文明进步的重要力量\n\n1.   对生产方式产生重大影响\n2.   对生活方式产生巨大影响\n3.   促进了思维方式的变革\n\n### 14. 劳动价值论（三句话）\n\n1.   劳动的**二重性——具体劳动和抽象劳动**  决定商品的**二因素——使用价值和价值**\n     -   价值是凝结在商品中的无差别的一般人类劳动；\n     -   使用价值是商品能够满足人的某种需求的有用性\n     -   商品的价值由抽象劳动决定\n2.   商品价值量由社会必要劳动时间决定；\n3.   价值规律：价值决定价格；价格受供求关系影响，围绕价值上下波动。\n\n商品的二因素、生产劳动的二重性、商品的价值量\n\n### 16. 剩余价值学说\n\n>   关于剩余价值和再生产的题目有可能会考计算题\n\n>   图源：JacyCui的笔记\n\n![image-20250608091650691](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250608091650691.png)\n\n计算剩余价值。公式和答案都要对\n\n### 17. 垄断条件下竞争\n\n定义：垄断是在自由竞争中产生的，是作为自由竞争的对立面产生的。\n\n特点：**规模大时间长手段残程度激烈**\n\n1.   目的上，是为了获取高额垄断利润，巩固地位\n2.   手段上，除了采取经济手段还会采取非经济手段\n3.   范围上，国际市场竞争激烈；经济领域之外也有竞争。\n\n### 18. 帝国主义论\n\n>   还有一个非常重要的内容，就是帝国主义论，这个已经反复明确讲了，帝国主义论是必须要掌握的内容，就是列宁对方成立丰富发展的最重要的，这样对代表性的理论，中国主义论那个课件上已经讲的很清楚了。就是讲的五大特征，对吧？三大矛盾，也是垂死的腐朽的，并且他可能有几种录像\n\n[列宁的《帝国主义是资本主义的最高阶段》总结 - 知乎](https://zhuanlan.zhihu.com/p/29078918963)\n\n帝国主义的实质：垄断资本凭借着垄断地位获取高额垄断利润\n\n**五大特征**（p254）\n\n1.   垄断组织在经济生活中起决定性作用\n2.   在金融资本的基础上形成资本寡头的控制\n3.   资本输出有重要的意义\n4.   形成瓜分世界的国际垄断同盟\n5.   最大资本主义大国已经把世界上的领土瓜分完毕\n\n**三大矛盾**\n\n>   1.   无产阶级与资产阶级的矛盾；\n>   2.   帝国主义国家之间的矛盾；\n>   3.   殖民地半殖民地人民与帝国主义的矛盾。\n\n### 19. 资本主义被社会主义替代的历史必然性\n\np278\n\n资本主义为社会主义替代的历史必然性\n\n1.   资本主义基本矛盾蕴含着冲突的萌芽\n2.   资本积累会计划资本主义基本矛盾并最终否定资本主义\n3.   国家垄断资本主义是资本社会化的更高阶段，是成为社会主义的前奏\n4.   资本主义存在资产阶级和无产阶级两大阶级之间的矛盾和斗争\n\n### 20. 科学社会基本主义的10大原则\n\n>   第六章只有一个知识点，就是第二节科学.当然了，最后考的时候我可能不要求你全记住，但是也要求记住一半以上\n\n1.   资本主义必然灭亡、社会主义必然胜利\n2.   无产阶级是最先进、最革命的阶级，担负着推翻资本主义旧世界、建立社会主义国家的责任\n3.   无产阶级革命是无产阶级进行斗争的最高形式，目的是建立无产阶级专政\n4.   生产资料公有制\n5.   对社会生产进行计划，按劳分配\n6.   合乎自然规律地改造和利用自然 核心共生\n7.   坚持科学的理论指导，大力发展社会主义先进文化\n8.   无产阶级政党是无产阶级的先锋队，社会主义事业必须坚持无产阶级政党的领导\n9.   大力发展生产力，消灭剥削，实现共同富裕\n10.   实现共产主义是共产党人最高理想\n\nReference：\n\n[马原（2023版）知识点整合 - 知乎](https://zhuanlan.zhihu.com/p/703536812)\n\n[njucs/Politics/《马克思主义原理》期末复习（家才）.pdf at main · JacyCui/njucs](https://github.com/JacyCui/njucs/blob/main/Politics/《马克思主义原理》期末复习（家才）.pdf)","categories":["NJUCS","Others"]},{"title":"例会汇报 | 第六次","url":"/posts/1d4617ee687a/","content":"\n两周之前，我分享了近期读的论文[1511.02274](https://arxiv.org/pdf/1511.02274) Stacked Attendtion of Image Question Answering. 论文讲的是SAN（堆叠注意力）的应用。\n\n最近（其实就是昨天😂）我尝试在服务器上复现这个模型：\n\n## **First Attempt：**\n\n不慎找了个19年的tensotflow的实现，但是\n\n```\nPython 3.6–3.9\n若要支持 Python 3.9，需要使用 TensorFlow 2.5 或更高版本。\n若要支持 Python 3.8，需要使用 TensorFlow 2.2 或更高版本。\n本地用的python3.12，pip下载不了tensorflow\n需要先安装python旧版本再创建`venv`环境，\n而且windosw和liunx的venv又不是互通的，需要先导出requirements.txt再到服务器上重新配置\n......\n用conda的话实验室没有配置，而且我也不熟😂\n```\n\n---\n\n花了几个小时之后，我放弃了这个决定\n\n---\n\n## 几个小发现\n\n### 南大的gitlab服务\n\n在想办法配置环境，迁移数据的时候，我无意间发现了南大的git服务，没错是nju.edu.cn！这意味着\n\n**✅终于能够解决很多的数据迁移问题了！**\n\n网址：[南大GitLab服务](https://git.nju.edu.cn/) ！！！\n\n但是界面和github有些区别，需要时间适应，但是起码服务器上可以用了！\n\n![image-20250524223725938](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250524223725938.png)\n\n比直接用ftp(适合大文件）传递的速度要快一些，目测大于10MB/s \n\n>   而且到时候团队协作写代码肯定也是需要用到git🤓☝️直接用南大的git服务能直接解决很多麻烦\n\n但是如果在服务器上想要提交代码，需要先登录账号：\n\n![image-20250525090402915](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250525090402915.png)\n\n---\n\n\n\n\n\n---\n\n### 使用jupyter+ssh隧道穿透\n\n>   省流版本：在服务器安装好jupyter之后使用ssh隧道和自己的电脑建立联系，十分方便地进行跑代码、改代码，再也不用用vim或者在本地改完又提交了\n\n在尝试运行上述项目的过程中，我配置了jupyter环境来运行ipynb文件，\n\nssh隧道穿透解决链接问题：\n\n![image-20250524224956589](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250524224956589.png)\n\n老师还提供两个访问liunx服务器的方法：\n\n1.   使用VNC用本地电脑操纵远程电脑，可以使用gedit进行编辑等等。只要不在桌面管理器里面logout就能一直访问\n2.   putty or mabaxterm\n\n\n\n\n\n---\n\n### 训练过程\n\n1.   配置环境\n\n     \n\n2.   准备数据，之前已经在`project/vqa/resources`目录下放置了vqa v2和vqa v1数据集\n\n​\t\n\n1.   准备pretrained-model\n\n     先在外网下号预训练模型，之后将模型移动到/home/vqa/.cache/torch/hub/checkpoints 目录下，可以使用cp命令\n\n     `cp *.pth /home/vqa/.cache/torch/hub/checkpoints/vgg19-dcbb9e9d.pth`\n\n### Reflection and Takeaways\n\n1.   寻找复现代码的时候需要考量：\n     1.   代码复现使用的框架、语言\n     2.   环境配置难度\n     3.   项目的复杂程度\n2.   使用gitlab服务能够高效地实现在校园网环境下的团队协作、版本管理、代码更改与与提交\n3.   使用pip下载包的时候如果在build wheel卡住，可能是缺少相应的编译环境，如：\n\n>    前面我遇见的问题：“代码用了`import cv2`,需要先`pip install opencv`，但是卡住很久没有反应，查询发现缺少cmake环境，于是直接下载预编译好的二进制文件，在末尾加入`-prefer-binary` 参数”\n\n---\n\n\n\n\n\n\n\n---\n\n路线一：VliT、BliP等融合+下游任务处理\n\n路线二：传统的vqa方法训练一个简单的模型\n\n我要负责做传统的vqa方法，比如NIPS-2016-hierarchical-question-image-co-attention-for-visual-question-answering-Paper.pdf、SANs等几年前的模型\n\n---\n\n","categories":["科研启蒙","Reports"]},{"title":"例会汇报 | 第六次","url":"/posts/eebfe12c97be/","content":"\n上一次在[[1704.03162\\] Show, Ask, Attend, and Answer: A Strong Baseline For Visual Question Answering](https://arxiv.org/abs/1704.03162)\n\n这篇论文中，**Stacked Attention**的具体实现不是很懂，这篇论文给出了更加详细地实现[1511.02274](https://arxiv.org/pdf/1511.02274)\n\n**Reference**\n\n[【论文笔记】Stacked Attention Networks for Image Question Answering | Blog of YQ](https://junzx.github.io/2019/11/22/paper-QAnswering/)\n\n[show ask attend and answer](https://chatgpt.com/s/dr_681cbe52e6048191b18bbed8a36370cc)\n\n---\n\n## 什么是Stacked Attention?\n\n**Stacked Attention Network（SAN）** 是一种**多步推理的注意力机制**，它在回答问题时，不是一次性决定关注图像的哪个区域，而是**分多步迭代地逐步缩小注意区域**，从而提升推理能力。\n\n-   在每一步，网络都会根据问题与当前图像表示**生成一个注意力分布**（相当于给图像的每一块都加上了注意力权重）\n-   然后使用这个注意力加权图像区域，**更新问题表示**（称为 refined query vector） \n-   将这个 refined 表示继续作为下一轮 attention 的 query，形成“堆叠”的结构\n\n![image-20250510191315747](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250510191315747.png)\n\n## SANs的构成\n\nThe SAN consists of three major components:\n\n (1)图像建模:\t` the image model,` which uses 1a CNN to extract high level image representations, e.g. one vector for each region of the image; \n\n(2) 问题建模:\t`the question model`, which uses a CNN or a LSTM to extract a semantic vector of the question and .\n\n(3) 堆叠注意力:\t`the stacked attention model`, which locates, via multi-step reasoning, the image regions that are relevant to the question for answer prediction. \n\nThe following image illustrates how do these components work together.\n\n![image-20250509182945001](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250509182945001.png)\n\n\n\n## Image Model\n\n1.   对图像的处理：使用CNN来处理图像，并且取池化层`pooling`的最后一层（因为具有图像内容的高级特征）\n\n     >   | CNN 层级               | 特征层次 | 表达能力                 |\n     >   | ---------------------- | -------- | ------------------------ |\n     >   | 前几层（Conv1、Conv2） | 低级特征 | 边缘、颜色、纹理等       |\n     >   | 中间层（Conv3、Conv4） | 中级特征 | 局部结构、轮廓           |\n     >   | 后几层（Conv5、FC）    | 高级特征 | 对象类别、语义、区域含义 |\n\n     \n\n2.   具体过程：\n\n     1.   将图像变形为448*448px\n\n     2.   经过CNN处理，提取出一个512* 14* 14的向量（即，图像被一个向量表示了出来，这个图像被划分成了14*14个区域，每一个区域有512维的特征,在论文中，这个向量用$f_I$来表示，$f_I$的第i列用$f_i$ 来表示，$i\\in [0,14^2-1]$ ）\n\n     3.   与question向量进行对齐。 通过一层`single layer preception单层感知机`（即全连接层加上激活函数） \n          $$\n          v_I = tanh(W_If_I +b_I)\n          $$\n          这里的$v_I$就是我们处理过后，对齐的图像特征\n\n          >   因为图像特征和文本特征的融合需要进行融合;\n          >\n          >   $W_I$是d*512的一个矩阵，将f_i (512维) 映射成为d维。\n\n\n\n## Question Model\n\n>   这里我对于问题特征的提取不是特别了解\n\n### `LSTM` based question model\n\n将问题作为一个词序列输入\n\n用 LSTM（长短期记忆网络）对每个词编码，最终使用最后一个隐藏状态作为问题向量 $v_Q$\n\n![image-20250511092514446](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250511092514446.png)\n\n### `CNN` based question model\n\n将问题作为一个词向量序列（如 GloVe）输入\n\n使用一维卷积提取局部 n-gram 特征，然后 max pooling 得到全局语义表示\n\n更适合短句或问题结构比较固定的情况\n\n![image-20250511092535914](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250511092535914.png)\n\n## Stacked Attendtion Network\n\n前面我们已经得到了图像特征($v_I$)和文本特征($v_Q$)的表示，并且已经将他们统一到了同一维度(维度均为d). \n\n>   注意$v_I$和$v_Q$的形状不一样，\n\n下面是如何通过多次注意力机制来实现`stacked attendtion` \n\n1.   将图像特征和文本特征进行融合\n2.   得到每一个区域的权重分布（反应了图像和问题的相关程度）\n\n$$\n\\begin{align} h^A &= \\tanh(W_I^A v_I + (W_Q^A v_Q + b_A)) \\tag{15} \\\\ p^I &= \\text{softmax}(W_P h^A + b_P) \\tag{16} \\end{align}\n$$\n\n>   这些公式里面的W都代表是参数矩阵，b都代表是参数向量；上面表了一个A代表是Attendtion，I代表Image，Q代表Question\n\n更详细地：\n\n$h^A$是将原本的$v_I$和$v_Q$的特征向量都映射成了k维（即$v_I$原本是d*m维的，m是图像的patch数，d是每一个patch的特征维数，但是在这个公式中左乘了一个 k * d维的向量，将其映射成了k * m维的向量。vQ同理，原本是m维向量，变成了k维向量）\n\n得到的$h^A$ （一个k* m 维向量）再左乘一个1*k维的参数矩阵变成1 *m维，之后进入一层softmax，得到最后一个权重向量，$P_I$ 。\n\n$P_I\\in R^m$,长得类似(0.1, 0.2,0.7),代表了每一个patch的注意力权重。 \n\n我们用这个权重对原先的Image vector进行加权，得到：\n$$\nv_I^`= v_IP^I\n$$\n(想想一下，$v_I$是一个d*m维的向量，$P^I$是一个m *1 的向量,相乘得到一个d * 1的向量)\n\n新的图像特征和和文本特征相加得到一个`refined query vector`。可以理解为是更加精准的融合特征表示\n$$\nu= v_I^`+ v_Q\n$$\n此时我们已经完成了一次注意力，实际上上述过程可以进行重复操作。\n\n使用这个注意力加权图像区域u，**更新问题表示**（称为 refined query vector）\n\n将这个 refined 表示继续作为下一轮 attention 的 query，形成“堆叠”的结构\n\n即： 将u替代最初的v_Q进行迭代，多次迭代实现堆叠注意力。\n\n\n\n![image-20250510191315747](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250510191315747.png)\n\n---\n\n>   query vector 好像是一个attention机制里面的专有名词， 我没有弄明白，故在这里不解释.下面是ai的解释\n>\n>   ### 什么是 Query Vector？\n>\n>   在注意力机制中：\n>\n>   -   **Query vector** 是“发起注意力请求的向量”\n>   -   在 VQA 中，问题的向量 $v_Q$ 就是一个 query，它“在问图像：你哪里能回答我？”\n\n![image-20250510184754070](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250510184754070.png)\n\n最后一步就是拿着得到的query vector生成答案概率：\n$$\np_{ans} =softmax(W_uu^K + b_u)\n$$\n","categories":["科研启蒙","Reports"]},{"title":"内存安全程序设计","url":"/posts/9a8511f5a25d/","content":"\n## Background\n\n**Pointer**\n\nA pointer is a varaible that contains the memory address of a portion of memory, that is , **pointer holds address**\n\n-   Dereferencing operator: *p refers to the object pointed to by the pointer.\n-   Address operator: get the address of an object.\n-   The size of pointer is fixed, it depends on your computer. (64位的机器的指针有8个字节)\n\n---\n\n**Dynamic and local pointer**\n\n注意用new申请的内存要用delete删除，用new申请的内存在heap上；\n\n```cpp\nint *p1,*p2, n;\n//p1 p2 n are variables in the stack\np1= new int;\n// allocate memory in the heap\n*p1= 10;\np2= p1;\n//p1 and p2 points to the same memory\n```\n\n**Memory-safety Problems**\n\n1.   Use after free \n\n     指针释放之后继续使用，导致异常\n\n2.   Buffer overflow\n\n     访问非法的空间\n\n3.   Doule free\n\n     重复释放指针\n\n---\n\n记得： 在delete之后将指针赋值为null，在new一个新的pointer之前确定原先的指针指向的内容已经被删除或者还有其他指针占用。new后一定要delete！\n\n---\n\n## Memory-safety Programming\n\n### Tempora Memory Problems \n\n时间类的内存问题，use after free， memory leak, double free\n\nDanglnig Pointer比如：\n\n```cpp\nint main(){\n    int* ptr;   \n    {\n        //create an inner block;\n        int a=1;\n        ptr=&a;\n    }\n    cout<<*ptr; // Dangling pointer;\n}\n```\n\nIn this case, a is a temporary varible in the block; \n\n---\n\nThen,  how to exscape such problems ???\n\n**什么是RAII**\n\n如果文件打开但是忘记close可能会带来一些问题，我们可以用过RAII的思想，来封装一个类来解决这个问题。\n\n**R**esource **A**cquisition **I**s **I**nitialisation  (**Constructor Aquires , Destructor Releases**)\n\n```cpp\nclass FileObj{\n    public:\n    File* ptr;\n    Fileobj(char* name){\n        //打开文件\n    }\n\t~Fileobj(){\n        //close the file when deconstructings\n    }\n}\n\nvoid printFile(const char* name){\n    Fileobj file(name);\n    //这个是local地创建，创建在stack上，而非在heap上创建，确保会自动回收；\n    \n}\n\nint main(){\n    FileObj file1(\"file1\");\n    //local地创建file而非用new创建，保证会自动地调用deconstructor\n}\n```\n\n\n\n基于RAII的思想（Resources accusition is initialized )我们可以设计smart pointer；\n\nsmartPointer核心背后的逻辑;\n\n```cpp\n```\n\n","categories":["NJUCS","高级程序设计"]},{"title":"《孙吧老哥爱上小红书仙女》","url":"/posts/298d0f5f96cc/","content":"\n\n\n\n\n作者：知乎用户NAh5fc\n链接：https://www.zhihu.com/question/53943602/answer/3499174416\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n《孙吧老哥爱上小红书仙女》\n\n1V1，高甜，双向奔赴（感谢1.6万赞！4.8已更新两章）\n\n<!--more-->\n\n## 一.相遇\n\n这是孙啸川第一次看见季莓。\n\n他脑子里面嘭嘭的，心好像随着融化了的脑浆热热腾腾地往下冲，到了底又涌上小头，“轰”的一下，眼花耳热，头昏脑涨。\n\n于是他连夜敲响了村里虎屠户的门，约定了三后送肉上门。正宗大肥猪肉，三百斤。\n\n\n\n## 二.孙坝\n\n孙啸川住在的孙坝村以前有一条姬家人修的大坝，坝上刻满了春秋战国的大家浮雕。后来上游的红薯村在一个雨夜开了闸，一时间洪水滔滔，孔子被冲毁了，庄子被卷走了，老子没了，姬坝没了，只剩下了孙子。\n\n从此姬坝改名孙坝。\n\n\n\n## 三.觉醒\n\n多年以后，面对红薯村，季莓将会回想起，自己从产道滑出来后宣布与生理父母划清界限的那个下午。\n\n那些长久以来无故承担这两个庸俗称谓带来压力的陌生男性女性围着沾满血污的产床，热泪盈眶，为季莓鼓起代表觉醒的掌声。\n\n不过季莓的反抗并没有因敌方一时的妥协而停止，在无限欲望和有限资源之间不可调和的矛盾被自然规律终结之前，她对老登爆金币的战争不死不休。\n\n物质觉醒是精神觉醒的第一步。\n\n\n\n## 四.石块\n\n孙啸川遇上季莓的契机，是季莓生理意义上的母亲。\n\n那时人们正在将代表幼女的泥人搅碎、与血水肉块混合了细细地涂抹在耕地上以期风调雨顺，却遭到那位母亲惊慌的指责。\n\n孙啸川潜入她的家中，破案了，她真有一个女儿。\n\n在长着季莓模样的碎块被送出后，那个老女人安静了。\n\n\n\n## 五.同甘苦\n\n但毕竟是有什么东西变了。\n\n是的，孙啸川爱上了季莓，只因尾随时的惊鸿一瞥。\n\n但他并没有意识到这一点，即使到了两人深陷同一个大坑的时候，他依然第一时间选择向家人求助——孙坝的家人正在坑外安静的、有条不紊地轮流举着写满字的横幅给他看。\n\n孙啸川抬头，看见刺眼的太阳底下四个大字：给我半扇。\n\n他忽然听到一声巨响，回头，原来是季莓踩着红薯村人丢的一堆全球限量的篓子想要爬出去，摔了。\n\n他同样看到同一个太阳底下的四个大字：女性力量。\n\n孙啸川捡起季莓掉落的大码外套，递给她。\n\n烟尘弥漫，同一个坑，坑外人群涌动，坑内两人沉默不语。\n\n\n\n## 六.驱逐\n\n两人还是得到了独处的机会。\n\n孙坝村的人发现孙啸川居然关心季莓，当即开会表决除名，将其驱逐至龟南镇沸羊羊村。\n\n红薯村的人发现坑里竟然还有一个男性孙啸川，立即建议他自刎谢罪。实现不了又发现季莓接过了外套，立即决定同样将其驱逐至娇七村。\n\n月明星稀，懂得瑟瑟发抖的两人面面相觑。\n\n季莓忽然叹气。\n\n季莓：唉，真是让人叹息，看看现在社会上对女性审美观念的绑架，仿佛国内的女生都逃脱不了被那套‘pua’式美学标准影响的命运。这种现象让人深感忧虑，它不仅仅限制了女性对于自我认知的多元化探索，还无形中给无数女性套上了沉重的精神枷锁。\n\n孙啸川：嗯。\n\n 季莓：sign...我们真的需要再次强调，美，从来就不是单一模具刻出来的复制品。它是春天里百花齐放的盛景，每一朵花都有它独特的风采，不正是这样的多样性和差异性构成了世界的绚烂多彩吗？美的定义，应当如彩虹般包罗万象，既包括了传统认知中的‘白幼瘦’，也同样拥抱那些饱满丰盈的体态、光泽健康的黑皮肤，以及岁月沉淀下成熟韵味的女性之美。\n\n孙啸川：嗯。\n\n季莓：这些年来，越来越多的声音在呼吁，让我们打破那些狭隘的美学框架，学会欣赏不同形态、不同年龄阶段的女性魅力。因为，真正的美，是从内心焕发出来的自信与光彩，是那份不可复制的独特气质，是拥抱并展现自己最真实模样的勇气。所以，不论是纤细柔美，还是健壮丰满，不论是雪肤明眸，还是黝黑健康，亦或是历经时光雕琢后的成熟风韵，每一种状态下的女性，都是这世界上最独一无二、值得赞美与尊重的风景线。\n\n孙啸川：嗯。\n\n季莓：所以你的意见是？\n\n孙啸川：看看B。\n\n\n\n## 七.■■\n\n季莓忽然翻身，似鲇鱼打滚，盯着身旁熟睡的人，眼露凶光。\n\n性别是一种原罪，所有男性的出生都沾着女性的鲜血，而他应该为了他错误的降生付出代价。\n\n她举起尖刀——等等——\n\n**你怎么能这么轻率地定义她？*\n\n唔，好吧，让我们换个措辞。\n\n这位小姐举起尖刀——\n\n**你怎么能用有歧义的词来定义她？*\n\n好吧，为了尊重，我们再换一次。\n\n这位美丽优雅的女士举起尖刀——\n\n**你怎么能用如此刀这么残忍的东西定义她？*\n\n没问题！我们再修改！\n\n……\n\n一位像一块奶油蛋糕一样可爱并智慧与美丽兼存但仍然有普通女孩缺点不过这并不影响她散发魅力的小女孩在命运无情的驱使下含着热泪被迫举起了一把可能有些危害但她完全不知情的小木棍——\n\n**你怎么能用男人创造的词来定义她？*\n\n*……*\n\n请将本文划入克苏鲁神话，因为这里出现了*无法被定义*的古神。\n\n\n\n## 八.三棺\n\n在确认关系前，孙啸川就知道季莓爱他。\n\n没有理由。\n\n这是季莓命中注定。\n\n男人需要女人，就像泰迪需要对着空气日天日地；而女人就没有不渴望男人的，她们的存在就是向男人索要财物和欲望——太多男的女的装得道貌岸然，却不真实。\n\n真实的孙坝边上埋着一座古墓，东西很少，只有三座棺材。棺材里外空空荡荡，既没有仁义，也没有道德，不知春秋，不着四六——但是它们毕竟很板正。\n\n孙坝主打的一个三棺正。\n\n\n\n## 九.猪油\n\n在确认关系前，季莓就知道她会爱上孙啸川。\n\n没有理由。\n\n这是季莓命中注定。\n\n季莓的前半生是不断心动的半生。村小读书，她爱上了来支教的一口标准普通话的男老师；进厂打工，她爱上了门口羞涩爱吃小熊饼干的保安；下田排水，她在一场骂战中爱上了邻居二柱。\n\n爱是平等，是自由，是每一个动心的午后黄鸟的啼鸣——红薯村她们只是在欣赏美罢了，只是平等地把爱倾注给每个有姿色的异性。\n\n季莓隔着尘土飞扬的空气注视着对面那个肥头大耳胡子拉碴头发蔫吧萎靡不振的男性，胸口忽然抽了一下，一瞬间好像也看到了一大块猪油。\n\n肥美的。\n\n她动心了。\n\n\n\n## 十.争吵\n\n确定关系的那个清晨，睡饱了的季莓捂着肚子翻了个身，睁眼看见了愣神的孙啸川，于是自然地遵循着生理本能理直气壮地对他说：我饿。\n\n孙啸川哦了一声，表示知道了。\n\n季莓脸色骤变，你还是不是个男人？和女孩子在一起都不知道主动表示？花呢？洋馒头呢？红薯呢？\n\n孙啸川冷笑，我嫖了你的吗？我欠你的吗？中年妇女自称女孩恶不恶心？ 就你们这群东西我见多了，老子舔不了一点，要么饿着，要么和我一起饿着！\n\n季莓大骂，你昨天晚上还说你在村里当干部，家里有两头牛！到现在什么人都没来，什么吃的都没有！\n\n孙啸川说是啊，干部只要我竞选就能当，牛只要当了干部就有了。我当了干部什么女人没有？再说我有钱和你什么关系，我的钱是给你看的，不是给你花的。\n\n季莓说那你还说爱我？\n\n孙啸川说，我爱啊，当然爱啊，我打胶时只有想着你的脸才能出来。\n\n季莓继续问，那我长啥样？\n\n孙啸川毫不犹豫地回答：猪样。\n\n哈哈，破防了。孙啸川指着嚎啕大哭的季莓像个鹌鹑似的狂笑。\n\n\n\n## 十一.520番外\n\n吊桥效应失效了，季莓提出了分手。\n\n但是她不退还恋爱期间男方赠与物资。\n\n好在，孙啸川也没打算送。\n\n其次，季莓认为，既然分手了，孙啸川就得重新追求她。比如当孙啸川握着两个苹果朝季莓走来的时候，她眼里盯着，嘴上却撅着嘟哝说不要，现在不想谈恋爱。\n\n孙啸川本来就因为分手心情不好，看到季莓怎么样更加莫名其妙。他绕过季莓，径直走向坑底的一个水塘——对了，此时两人还困在大坑里没出来——胡乱擦两下咔吧咔吧把苹果咬去了一半。\n\n季莓急眼了 。我是女孩子！\n\n喔，所以呢？孙啸川又咔吧咔吧两下，一个苹果没了。\n\n——我是女的，你凭什么不让我！\n\n——因为我聪明捏，不像那些龟男一哄就去舔小仙女力。\n\n——你做我男朋友也不付出任何东西！\n\n——蜀黍我啊是个烂人，我都承认我烂了，你还想怎么样？\n\n——那你为什么要谈恋爱！\n\n——因为我爱你啊。\n\n——你根本不爱我！\n\n——我只想上你，其他人我不想上，这怎么不叫爱？\n\n——你谈恋爱就是为了上我？\n\n——不然你以为我会奔着什么去？死猪。\n\n——那就分。\n\n——不行。\n\n——为什么？\n\n——我爱你。\n\n——我不爱你了。\n\n——你不可能不爱我。\n\n——那你为什么什么都不做？\n\n——因为蜀黍是个烂人诶，烂人就是这样的，你还想怎么样？\n\n……\n\n\n\n## 十二.红薯村规则怪谈\n\n**红薯村管理委员会公告**\n\n《关于红薯村特殊习俗与行为规范的正式通知》\n\n亲爱的游客，欢迎你们来到本市最大的新时代优秀生态示范新模式新业态村庄红薯村。为保障村庄和谐、安全及传统文化的传承，红薯村管理委员会特此发布以下正式规定，望来访人员严格遵守：\n\n一、总则\n\n1.  红薯村是一座充盈着爱、自由、关怀、平等的美丽村庄。任何登记的村民在红薯村都是平等的。\n2.  有的村民比其他村民更平等，因此有的红薯比其他红薯更平等。尊重红薯村特有的社会现象，请游客不要对此进行质疑或评论。\n\n二、地理特征\n\n1.  红薯村坐落于益邑市五遗镇东南部，距离镇中心51公里，其独特的地理位置造就了红薯村的自然风光。如游客周围任何景观被破坏，无论是否为第一责任人，一律由游客承担修复费用。\n2.  红薯村有一条西北东南走向的母亲河穿村而过，是红薯村的重要水源。游客必须记住母亲河的存在，但不得在交流中提到任何形式的母亲河或其他河流。\n3.  红薯村没有水库和大坝。若游客在游览过程中发现周围存在大坝，请立即遵循第一条规则，抱头蹲下并尽力以“短——长——短”的频率呼救。这是红薯村特有的求救信号，我们的救援人员会迅速前来提供帮助。\n\n三、特色产业与购买规则\n\n1.  红薯村以红种植为特色产业，请前来观光的游客填写五代关系网并提交政审材料，预先准备好相关购买凭证和资金，在村门口领取游客身份牌并缴纳保证金。如因缺少身份牌造成游客意外伤亡，红薯村村委会概不负责。\n2.  红薯村的红薯不仅产量高，而且富含多种营养成分，深受市场欢迎。即使是最小最不起眼的红薯也不可随意丢弃，每一个红薯都是平等且独一无二的，请游览和购买时务必端正态度。\n\n四、邻里关系与社区规范\n\n1.  红薯村是邻里关系优秀示范五星级村庄，我们强调平等、和谐与互助。在红薯村，每个人都平等地耕种属于自己的土地，不存在任何形式的斗争、抢夺、攻击、陷害、诅咒、孤立、污蔑。\n2.  若游客在红薯村发现存在上述不良行为，请立即意识到您可能已不在真正的红薯村中。请按照第一条规则向我们发出求救信号，我们将尽快赶来帮助您。\n3.  红薯村村民凭借世代传承的种植技术和对土地的深厚感情，培育出了品质优良、口感独特的红薯。请不要质疑村民对土地的感情，这是他们生活的重要组成部分。\n4.  如在交谈中发现村民并不热爱土地，请立即前往村门口，村委会会帮助您解决■，并确保您能够继续享受红薯村的和谐氛围。\n5.  红薯村会让每一个不顺从的游客付出■■■。\n\n五、其他\n\n1.  红薯村还依托其独特的自然景观和丰富的农业资源，开发了农家乐、农耕体验等乡村旅游项目，为游客提供了丰富的旅游体验。请确保您携带的■■足以让所有工作人员感到■■，再自行选择想要体验的项目，违者后果自负。\n2.  红薯村把游客当人看。爱你，游客。■■■。\n\n红薯村管理委员会\n\n[注] 本公告自发布之日起生效，解释权归红薯村管理委员会所有。\n\n\n\n## 十三.圣物\n\n孙坝村村委会会议室墙上挂着两样东西，左边是一瓶空了的[西地那非片](https://zhida.zhihu.com/search?content_id=666285999&content_type=Answer&match_order=1&q=西地那非片&zhida_source=entity)，右边是一把没有弹匣的枪。\n\n这套被瞻仰的圣物曾经为一位苦于学业的艺术生夺得优秀毕设的荣誉，学术界的先辈为其赐名《真实的欲望》。\n\n另：左边那个瓶子在评审时是满的。\n\n\n\n## 十四.一切都是红薯干的\n\n村民怀着敬畏和谦卑列队从圣物下经过。发酵数月的汗臭和风格迥异的体味有如实质侵占着本还算宽敞的空间，人人脸庞发红而目光明亮，望向颁奖台的眼神炽热。\n\n孙坝村村长是一位标准的男性。他蓄须而不留长，身材不壮且并不纤细，说话粗犷并直击人心，是从心理到性取向都真正顺从生理性别的代表——村长遗憾地宣读了驱逐孙啸川的通告，在骚动汹涌之前话锋一转，提到了每月向孙坝村交换物资的车辆。\n\n有关红薯的制品越来越多了。\n\n这是红薯村控制全国经济的铁证。\n\n村长一口气写下了一长串数字，告诉大家这是孙坝村每年消费的金额，随后勾画几笔，这是红薯村的消费金额。\n\n“我们有权力要求交易点本该全心全意为我们服务——而他们却提供红薯制品。权力机关早在很久以前就被红薯侵蚀透了。”\n\n这一切都是一个有关经济、文化、宗教、阶级、政治的阴谋。\n\n量大的红薯象征着垄断，好吃的红薯是对于底线的试探，难吃的红薯是明目张胆的挑衅，而一切的结局是迟早有一天她们会端上坏的红薯，那时候孙坝村却因丧失话语权而无力反抗，只得被迫屈服于淫威而不自知。\n\n孙啸川就是最好的例子，驱逐他的并不是孙坝村，是他的懦弱造成了他的自取灭亡——\n\n村长的声音慈爱而悲怆。\n\n“孩子们，我们的敌人不在邻里，不在远处，就在上游。”\n\n孙坝村的人们站起来！为了自由！为了话语权！为了拨乱反正！为了千百年被压迫的兄弟们！为了将这群占领市场的红薯赶回泥地！\n\n后来，人们以这样的口号为这场轰轰烈烈的运动揭幕——\n\n有薯不玩。\n\n\n\n## 十五.脱难\n\n有一个路人前来买瓜。\n\n路人经过大坑，瞥见里面七横八竖地躺着两个不知生死的人，抬手报了个警。警车到，消防车到，梯子放下来，二人被麻利地捞上救护车，距离路人骑着摩托车出门刚好三十四分钟。\n\n季莓睁开眼睛第一个反应是问路人哪个村的，如果是红薯村一切好说，如果不是，那就得追究一下救援时肢体接触的责任了。\n\n孙啸川清醒了则是第一时间为自己的家乡而自豪。毫无疑问，这一定是孙坝村出来的人物。他左右手在胸口交替各锤三下，以此呼应“三棺正”的村训。父亲那双让他既怕又爱的深邃的眼睛又出现在了脑海里，父亲的眼晴是他这辈子最恐惧的东西，父亲的称赞是他这辈子最渴望得到的表扬，他这辈子最渴望的荣誉，不是扬名立万，而是父亲的认可；父与子，是君臣，是仇人，是情敌，是兄弟，是朋友，是舍友，只有躺在病床上那一刻才是父子；父子如君臣，君臣相伴会长久，君要臣死臣不得不死。\n\n孙啸川热泪盈眶，因为他想起了他的父亲。\n\n季莓同样热泪盈眶，因为她觉得自己的清白被玷污了。\n\n至于路人究竟是哪个村的——既然二位都认为是孙坝村的，那就是吧。\n\n\n\n## 十六.争吵x2\n\n救护车猛地一个拐弯，很快载上了第三人——一个腹部插着一把刀的水果贩子。\n\n再一问，是那路人捅的。\n\n二人愣了半秒，随即孙啸川冷笑一声：这下他不问就知道路人来自哪个村了。\n\n季莓怒斥他凭什么侮辱红薯村。\n\n孙啸川哈哈大笑，典，你怎么知道我指的是红薯村？\n\n季莓说因为你们孙坝村就是喜欢扣屎盆子，吃不上精米白面又看不起麸皮杂粮，要不到饭就嚷嚷，丢脸丢到县里头了。\n\n孙啸川嘻嘻一笑，绷，你们红薯村截了上游的水道还不让人去要饭？不就指着我们全村人跪着舔你们吗？\n\n季莓先喊了一声乐，然后双手一摊，那你去讨口子吧。\n\n孙啸川指着她，孝死了，乖儿子在你爸爸面前充老子，每年烂在地里的红薯有多少，不都得求着孙坝村的人要？\n\n季莓一跺脚，边上好好躺着的水果贩子震了三震。我种红薯还白菜干你什么事？\n\n孙啸川一踢墙，刚刚起来的水果贩子又倒了回去。你种地不就是出来卖的吗！\n\n那你有钱你就买啊——季莓又是一脚，水果贩子吐出一口血。\n\n不干净的蔬菜水果我凭什么买——孙啸川接上一拳，水果贩子心率跳上了二百一。\n\n上下游浇的一条河的水，你说不干净你自己就干净？——水果贩子腹部伤口渗出了血。\n\n我不干净我自己待在家不出来，你凭什么把红薯拿出来卖？——水果贩子腹部的刀震飞出来了。\n\n乐了，你们孙坝村的不出门不就是往路上泼屎然后讹人吗？——水果贩子嗓子里嗬嗬作响。\n\n所以呢，不还是出来卖的嘛？——水果贩子嘴唇翕动，竟是悠悠转醒。\n\n不花钱你就拿东西换，什么都没有你去要饭——季莓被一个突兀坐起的人影止住了话头，大喊一声“鬼啊”抱住了一旁的孙啸川。\n\n水果贩子猛地坐起，颤颤巍巍地举起了手指，对着面露惊恐抱作一团的二人憋了半天，咬着牙一字一顿地挤出几个字，“一群傻宝”。\n\n然后重重跌回了担架。\n\n随车的医生一拍板——你，还有你，你们两个人都给我滚下去！警察呢？谁来管管这群颠货？\n\n\n\n## 十七.圆满\n\n季莓和孙啸川并排走在没有路灯的路上，沉默溶于月色，月光如水。目力所及，星火无半点，耳闻之音，狼嚎三两声。\n\n被救护车抛下后他们已经在荒郊野外游荡了许久，此时俱是饥寒交迫。集体赋予个体以特性，规范其行为，铸造其意识，却忘了给他们上一道独自行走的保险——离开了村庄，他们是谁，行于何处，去往何处？\n\n季莓侧头，孙啸川崎岖的脸颊被夜色所笼罩着，呈现出一种莹润的白色，抿住的双唇为他添了几分儒雅随和，看上去很是乖巧。\n\n孙啸川用余光往边上瞟去，季莓肉嘟嘟的小嘴宛若沾了蜜水般闪烁着晶莹的光泽，让他想到了一种肉质丰满的软体动物。\n\n季莓并没有捕捉到窥视的视线。她在思考，在思考爱情对于她的意义。\n\n我们所看到的实体月亮不过是存在于神圣领域中真实、完美、永恒月亮理念的影子。这是一个关于人类状况的隐喻，我们的肉体存在不过是我们真实、精神自我的反映。\n\n……孙啸川试探者勾住了她的手指，季莓没有反抗。\n\n而爱情，哦，爱情，这是一个多么深奥的概念。它就像伊曼努尔·康德的范畴命令，一个无条件的道德命令，我们应该以一种我们的行为准则能够成为普遍法则的方式行事。\n\n……孙啸川握住她的手，在手臂上按出浅浅的肉坑。\n\n在爱情中，我们应该把别人当作自身的目的，而不仅仅是达到我们自己目的的手段。这是关于相互尊重、理解和一种超越肉体、进入灵魂领域的深刻内在联系。\n\n……孙啸川的手还在游走。\n\n她是不是对孙啸川要求太高了？其实即使不是干部，家里没有牛羊，但也是一个健壮的劳力，无论帮衬家里还是另做他用都是极好的。\n\n孙啸川终于抵达了终点。他呼吸急促，脸涨得像一块癌变的猪肝，手里还紧紧抓着季莓的内衣扣子，“快……我这辈子……这辈子还没有女人愿意碰我……”\n\n“我听到狼嚎了……就算要死在这里，也让我做完再死吧……”孙啸川手忙脚乱地解裤子，半个雪白的屁股横斜逸出，“你……满足我……就在这里，快，让我……”\n\n孙啸川声音越来越小。他看见一片庞大魁梧的阴影铺天盖天地向他逼近，在彻底压上并包裹他的一刹那，他顿悟了宇宙的意义——宇宙黑洞深邃莫测宛如夜空中吞噬一切的巨兽之眼其内部隐藏着无尽的黑暗吞噬光线与物质形成无法窥视的深渊它的深邃不仅在于其强大的引力更在于其未知的秘密让人敬畏又着迷星系黑洞暗物质恒星行星彗星太阳系星云宇宙射线宇宙微波背景辐射虫洞4242424242424242424242424242424242424242424242424242……\n\n\n\n## 十八.不吃\n\n季莓在挑选出租屋必备的东西。\n\n买东西是有讲究的。\n\n色、涩、瑟、冲、充、受、收、扒、浇、拔、射、涉、摄、灌、顶、抽、插、撞、勃、录、卤、鲁、鹿、管、馆、丁、坤、谷、何、洞、液、浆、乳、奶、印、银、花、草、艹、艸、槽、漕、黑、白、雪、日、夜、进入、注入、挺进、输出、打桩、冲刺、吞吐、软硬、粗细、深浅、大小、用力、有劲、飞机……\n\n这些词不能出现在一个包装上，一个平面也不行。\n\n不然孙啸川看一眼就会吐着舌头翻着白眼抖成筛糠晕过去，然后病情加重。\n\n还有一些菜是孙啸川吃不了的，买都不能买。\n\n例如奶油、酸奶、牛奶、泡芙、馒头、饺子、木耳、黄瓜、烧鸡、整鸡、烧鸭、兔子、鲍鱼、杏鲍菇、胡萝卜、乳酸菌、爆浆蛋糕、流心月饼。\n\n放以前不过昏迷几天的事，不过自从那次夜里孙啸川被季莓一屁股坐成关节粉碎性骨折加多处软组织挫伤之后，他恢复能力便大不如前了。\n\n……作为女朋友，季莓觉得自己有义务为孙啸川的健康保驾护航。\n\n那就先从隔绝阻碍孙啸川恢复的东西做起吧。\n\n\n\n## 十九.你是一只JK白丝猫娘（慎入）（千赞番外）\n\n在这个樱花瓣偶尔飘落的春日午后，你，孙啸川，坐在了那张见证过无数故事的木质长椅上。\n\n周围弥漫着淡淡的花香与新绿的气息。\n\n你的形象，仿佛是从某个日常漫画中走出的角色——头发油腻杂乱，如同长时间未被打理的野草，胡须也是未经修剪，沾染了几分春日的慵懒，带着几分典型的“おっさん”气质。\n\n啊，还有青春——青春没有赠与你什么美好的回忆，但在你的脸上烙下了一生难忘的痕迹。\n\n你身着的是精心挑选的日系女高中生制服，绀青与纯白的配色如同放学后渐染的夜色，洋溢着青春的清新与活力。\n\n但你局促不安地将手压在两腿之间。\n\n每当你试图调整坐姿时，都会牵动那本该轻盈飘逸的裙摆，不可避免地露出大腿根部。你有些羞涩，老二时不时掀起的凉意提醒着你在后面玩的小把戏。你握住那条长长的电动猫尾——在你头上还有一对同款的猫耳，几乎不敢多动。\n\n要是被人知道来自孙坝村又黑又肥的你在大庭广众之下穿着Jk和白丝扮演猫娘……你怕自己明天就得垫上纸尿裤。\n\n但是确实性感。你呼之欲出的赘肉被紧绷的制服死死地箍住，在腹部勾勒出圆润的弧线，从发丝间成股流下的汗液滋润着你的粗壮的毛孔，在胸前和腋下晕染开一片灰褐色的印迹。\n\n雪白的丝袜边缘绣着镂空蕾丝花边，紧紧勒着你并粗壮黝黑的大腿，每一步轻微的移动，都能看到丝袜下的雄壮的汗毛汹涌。\n\n你的脸上带着一丝羞涩却又坚定的笑意。当她，你心中最重要的人，季莓，看到这一幕时，是否会从最初的惊讶转为理解与感动？\n\n你想象着季莓把你的制服从两边撕碎。\n\n“杂鱼……像你这样的油腻大叔扮成猫娘也一点不可爱呢。”\n\n季莓扣住你的渗油的下巴。\n\n季莓握着你的手腕将你压得喘不过气。\n\n“就算戴上尾巴也不会有人喜欢你哦……求饶吧猥琐大叔……快承认你就是没用的～杂鱼～呀～”\n\n你的短裙被褪到一边，露出摇摆的猫尾。\n\n季莓无视了你的口臭，吻上你坑坑洼洼的脸颊。\n\n“唔……是臭烘烘的大叔味道呢～变成这样真是可怜～就算这样……”\n\n然后她温柔地含住你的下唇。\n\n一夜鱼龙舞。\n\n你愿意为她跨越所有界限。\n\n周围的樱花树轻轻摇曳，你静静地坐着，憧憬着那一瞬间，你们之间的情感能在这春日绽放出最美丽的花朵。\n\n\n\n## 二十.屎循环（两千赞番外）\n\n前几年益邑市体会了些指示，对齐了一下颗粒度，聚焦在了垂直领域，到了五遗镇这儿就有了个任务——全称“创建新时代优秀生态示范新模式新业态村庄”，简称创村。\n\n那几个月红薯村与孙坝村的村委俱是一片愁云惨淡，文化墙刷了，企业投资少但也有联动了，刷实践分的大学生俯拾即是，村长也开上大奔了，那创新在哪？新模式在哪？\n\n……直到孙啸川抱着一本名叫《者也》的杂志冲进村委办公室。\n\n这[者也杂志社](https://zhida.zhihu.com/search?content_id=666285999&content_type=Answer&match_order=1&q=者也杂志社&zhida_source=entity)原先是县里一个向来以插科打诨为业的末流文学阵地，阳春白雪不顶饿，近些年就弄了个“群众之友”的锦旗，和诸位村长打好了交道，卖八卦小报就算是师出有名。\n\n他们拿出来个啥方案呢？屎类大循环。\n\n李时珍曾在他那本书里写过，鸡之遗矢富含多种氨基酸和矿物质维生素，古时候西洋人靠着鸡屎提取的黄金镭元素乃至核武原料完成了工业革命。鸡屎虽人不能食但对于动物是入口顺滑滋味丰富，那些猪一旦尝到此等美味便如孩童嗜糖体重与日俱增，猪粪回哺于鸡，形成一个闭合的生态系统，此即“[鸡猪循环论](https://zhida.zhihu.com/search?content_id=666285999&content_type=Answer&match_order=1&q=鸡猪循环论&zhida_source=entity)”。\n\n屎有了，环保有了，乡村振兴有了，产业集群有了，谁来搬屎？\n\n“者也”杂志社站出来了。\n\n勤劳的编辑和签约作者走到孙坝村，按照屎的浓度、色泽、气味、颗粒度进行评级，有时还要尝尝咸淡，增稠或者稀释，再转手给其他村子。\n\n如何评价孙坝村的鸡屎？\n\n如何评价红薯村的猪屎？\n\n如何评价某某村的狗屎？\n\n只有我一个人觉得孙坝村的屎不臭吗？\n\n为什么会有人觉得红薯村的屎臭？\n\n是什么让你选择了孙坝村的屎？\n\n混合型鸡猪屎上市了，你有什么期待？\n\n……\n\n“者也”杂志社在奋笔疾书。\n\n那一阵子，整个五遗镇此起彼伏的是这样的咆哮：\n\n“我靠，屎！”\n\n“妈的红薯村这依托答辩  ”\n\n“姐妹们，孙坝村又拉了一坨大的！”\n\n“味太冲了家人们，受不了了！”\n\n……\n\n粮食有限怎么办？村里干活积极性不高怎么办？没关系，加入屎循环，一切都会好起来的。\n\n产够了屎，就去评鉴其他村的屎，评鉴够了就再让牲畜吃了，主打一个环保节能，工作娱乐两不误。\n\n往以前，人们评价《者也》，说它内容之混乱，犹如盛宴之上山珍海味与粗茶淡饭并陈，既无学术之严谨又乏通俗之乐趣，高不成低不就；文章之选，或为道听途说或为臆测之辞，偶有哲理之思，却如蜻蜓点水浅尝辄止，反倒是沦为谈资笑料；编者多为江湖散人，笔耕之余还需为稻粱谋，其精力分散，难有深研之功，故而《者也》之名鲜为人知销量之薄，可想而知。\n\n而现在，益邑市五遗镇上的人提到《者也》刊载的作品都会骄傲的地竖起拇指：我是品诗家，这就是诗吧。\n\n\n\n## 二十一.忧郁\n\n孙啸川认识的女人有两种。一种是打扮的好看的鸡，他只屑于发泄；另一种是让他提不起兴趣的雌性动物，除了完成繁衍任务他花的每一分钱都是耻辱柱上的刻痕，是村头的狗，是烂根的稻，是拉倒一半又憋回去的便意，他每每想到被杀死的金钱和精力就仿佛听到了生命在呻吟——她们不值得。\n\n多可笑，只有付钱才能嫖，甚至付钱了也嫖不到。\n\n孙啸川很早就知道这个世界烂透了。\n\n真实的世界是这样的。人们只要衣冠楚楚装点礼义廉耻就够了，而孙坝村忙着捍卫人世间最后的一点真诚就很辛苦了。\n\n在孙啸川四十岁的人生中，从来没有女孩子亲口对他说过，“我喜欢你”。他是下水道的鼠鼠，是可循环使用的菜汤，是家族的耻辱国家的米虫。本来会这样日复一日地过下去，但是季莓带着强劲的风和重力坐碎了他从未有过关怀的心。\n\n在季莓身上，他有生以来第一次感受到了作为男性的价值。从此以后，日月星辰尽可以各司其职，他则既不知有白昼也不知有黑夜。他周围的世界全然消失了。\n\n“妈妈，”孙啸川说，“我恋爱了。”\n\n\n\n## 二十二.未来日记（三千赞番外）\n\n202X年X月X日\n\n易孕体质，被亲亲男友的小银针扎鼓包哩，皮薄陷大美孕妈妈，小孕妇每天都用宝宝碗，男友说儿子生下来就领证嘻嘻他好爱我，男友给我买进口避孕药还把小吊带藏起来了，可是我穿得性感你把我带出去不是更有面子吗，不小心氪金从男友手机上走了他说下次用开房抵就好了嘻嘻。\n\n202X年6月2日\n\n接男宝。\n\n202X年6月3日\n\n接男宝。\n\n202X年6月4日\n\n接男宝。\n\n202X年6月5日\n\n接男宝。\n\n……\n\n202X年6月15日\n\n好奇肚子里的小家伙性别是什么，真的仅仅是好奇哦，本身也不太注重性别，想要女宝，觉得贴心乖巧，可转头呢又想要个男宝，男宝好养，不用那么娇贵，长大后还可以保护妈妈，小夹克帅而且有面子，长辈也希望嗯，你懂的，于是就开启了福尔摩斯式探究，通过孕期症状，肚子形态，做梦细节获取性别信息的蛛丝马迹，明天托人去香港查的报告就出来了，这里接一个白白净净健健康康的男宝。\n\n……\n\n202X年6月18日\n\n接b超不准。\n\n202X年6月19日\n\n接翻盘。\n\n202X年6月20日\n\n接翻盘。\n\n……\n\n202X年3月XX日\n\n卸货了，跟我一点不像，本以为生了个小棉袄却发现我就是个送货的，给老公生了个小情人，以后亲亲老公的爱要被分走了。\n\n……\n\n202X年6月XX日\n\n宝宝撅屁股是代表二胎要来了吗？宝宝四肢撑地代表要生二胎了吗？我闺女今天突然做这个动作，然后还指着我肚子叫弟弟，不是重男轻女，单纯只是想凑一个好。\n\n……\n\n202X年7月XX日\n\n恶评太多。不想解释。祝你们一撇腿一个女儿。\n\n\n\n## 二十三.绿帽\n\n孙啸川坐在廉租房天台的边缘，周围的一切都跟往常一样，风啊，烟啊，还有夕阳。只有那么一句“请先生赴死”在空气中悬着，像是一句不怀好意的玩笑。\n\n孙啸川抬头望着天，好像在数云彩。但是呢，刀已经磨亮了，遗书也写好了，等解决奸夫淫妇他就准备赴死。不，解决的过程就是赴死，季莓可以一屁股把他坐成粉碎性骨折，他现在一个半残废提着刀也斗不过他们半个屁股。\n\n赴死，好，赴死。太他妈悲壮了，这他妈简直就是一场行为艺术，把生和死玩得跟猫捉老鼠似的，就应该这样这么搞，这他妈是奔赴战场的武士，是英雄。\n\n季莓出轨了。\n\n孙啸川打着石膏的腿在颤抖。\n\n他从来没想过能独立坐起来后往窗外看到的第一眼是季莓和一个男的说话，有说有笑的。\n\n他们俩还转了钱。\n\n从昨天起他就没主动蹦出一句话。季莓回来告诉他后天房东联系人修水管，孙啸川反问她去干什么了。季莓说刚刚电子厂下白班赚钱啊不然你妈天天吃西北风，孙啸川一哂，他知道这个母人不会说真话。\n\n又白又深的水管也引不了他的兴趣了。\n\n他其实特别想拽着季莓的头发把她砸在桌角，以不容置喙的语气对这个女人说：你绿了我。\n\n你肯定绿了我是不是？\n\n你只是嘴上不说，其实早就和那个男人，不，那些男人，那群男人，已经做过了吧？\n\n你一个女的怎么赚钱养我？你有什么钱来租房？\n\n是哪个黑人吧。你一个女人又看不懂篮球，看到科比却有反应。\n\n求求你告诉我，你是绿了我对吧？\n\n你为什么不绿我？\n\n你不绿我就是看不起我。\n\n我这么烂你凭什么不绿我？快告诉我吧，你就是看不起我又胖又矮又穷，看不起我的板寸络腮胡，看不起我家里有老母要养，看不起我找盗版种子，看不起我攒钱找小姐，看不起我不虚荣。\n\n你他妈就是看不起人！装死你得了，谁他妈不是这样？\n\n原来都是对的。孙啸川想家了，他想念孙坝村了，“见义勇为如果碰到红薯村的一律见死不救，碰到孙坝村的尽力帮忙”，“凡是红薯村反对的无条件支持，凡是红薯村支持的无条件反对”，原来都是对的。\n\n他又想起父亲那如水般含着泪的眸子了。\n\n\n\n## 二十四.就喜欢绿帽\n\n房东说我来看下水管，季莓连忙拦他说别别别我男人在休息。\n\n房东以看神经病的眼神撇她一眼。我去看房能碍着他伸腿瞪眼了不？\n\n季莓陪笑，我保证，我保证，我不要您修了，我自己找人修 ，诶，还有房租，我一起交，下个月的也一起交。\n\n房东嘴角东南西北方向都抽了个遍也没憋出一句话。好像是骂了句是什么？总之打发走了。\n\n……这是昨天的事了。\n\n季莓其实从昨天就察觉到了不对。\n\n他怀疑她。\n\n喔。\n\n他怀疑她。\n\n真是太酷了。\n\n季莓在电子厂的厕所，一手翻知名短视频APP，一手拼命删改。\n\n“妾身在此，轻启朱唇，细诉心声。妾身的退步，便是此生的长路。妾身的罪过，始于与君的邂逅，继而是相知，继而是相交。妾身的心中，有喜悦，有思念，有牵挂，有守护。每一份罪过，都是对君的深情，每一份罪过，都是对君的承诺。\n\n“妾身的罪过，一罪，是那不经意间的相遇；二罪，是那心有灵犀的相知；三罪，是那情投意合的相交；四罪，是那心头荡漾的悦君；五罪，是那夜深人静的思君；六罪，是那无时无刻的顾君；七罪，是那不离不弃的守君；八罪，是那风雨无阻的护君；九罪，是那魂牵梦萦的恋君；十罪，是那刻骨铭心的爱你。\n\n“妾身这一退，便是一生的承诺。在这漫漫人生路上，妾身愿以这十罪，换君一笑，换君一生平安喜乐。妾身的罪过，是爱，是情，是此生不渝的誓言。”\n\n眼里的泪大把大把的砸下来，一砸一个坑。\n\n他，是掌舵商业帝国的精英，却因自负凉薄，将挚爱推至情感的悬崖。她，以一腔孤勇爱过，最终选择在人海中消失。\n\n城市的霓虹映不亮他内心的荒芜，他开始在每一个失眠的夜晚，咀嚼失去的苦涩。他曾是那捕获无数的猎豹，却偏偏弄丢了心中最温柔的鹿。他像一个迷失的灵魂，疯狂寻找她的踪迹，企图弥补裂痕却发现她已筑起铜墙铁壁，将过去彻底封锁。\n\n他，曾是傲视苍穹的龙翔九天，却因一念之差，错失了生命中最温润的月光。她，一抹轻盈游走于烟火人间的清风，带着无尽的柔情与聪慧，最终却只能化作遥不可及的梦影。\n\n“我以江山为聘，换你笑靥如花。”他曾以为，这世间万物皆可掌控，直到她的背影渐行渐远，融入那片他再也无法触及的云烟。她走后，万籁俱寂，只余下内心无尽的空洞与悔恨。\n\n她只留下一句话：“后来我死了，他们疯了一样的找我。可是，我已经不要他们了。”\n\n快告诉我吧，你会因为我的自残自害自毁而痛不欲生，你会用你的余生忏悔你现在的过错，你的后半生会被我巨大的背影填满，你看到信的时候会想起我，吃到泡芙会想起我，吃到奶油会想起我，但我已经不在了呀，唉。我不在了你该怎么办呢。\n\n季莓有点想家了。如果在红薯村，一定有很多家人支持她。可惜这不是，她只能在诀别书落款上写一句苍白无力的“爱你”。\n\n情感不及孙啸川他爹三分。\n\n\n\n## 二十五.彩礼（四千赞番外）\n\n某天季莓和昔日同学桂弥重聚吃饭，期间桂弥提到她前些天办了订婚宴，季莓好奇地问男方彩礼出多少，答：十八万八。\n\n季莓得令，转头要求孙啸川付彩礼不少于二十万，理由是不能输给老同学。给不出？耽搁了女孩子七八年青春你拿什么赔？\n\n这边孙啸川和领导喝酒喝上了。领导告诉他当初儿子葛孟结婚时女方没要一分钱彩礼，还倒贴三套房两台车。同时痛斥一切提出要彩礼的就是捞女，不接受任何反驳，反驳你也是捞女。\n\n孙啸川听得眼睛亮堂堂的。\n\n季莓找他商量彩礼，他说好女孩都不要彩礼。你是好女孩，我出钱就是向你父母买女儿，这是对你的侮辱，所以我不会出。\n\n季莓气得刷抖音刷到凌晨四点，睡不着了，给桂弥发消息哭着说男朋友不想为自己出一分钱。到第二天八九点桂弥姗姗回复了一句话：现在不付出是其次，你将来生孩子的一切支出也要一个人扛吗？\n\n对啊。如果孙啸川不出一分钱，结婚了我岂不是白给他生个孩子？说出去还是老孙家的种，和我季莓有什么关系？而且生完孩子身体还垮了！\n\n季莓打了个冷战。\n\n她给孙啸川发消息，二十八万，付了才领证，一分钱不能少，少了这婚也别结了。\n\n孙啸川把手机往邻座一甩。\n\n葛孟慢条斯理地放下勺子，擦嘴，问他发生了什么。\n\n孙啸川看看对面座的人，想想葛孟他爸，恒河水在嘴里拐了十八个弯出口成了冰露。他淡淡地说，没什么，看到个新闻，一小……女的打着彩礼的名头骗了男的二十八万，分手了法院还不追回。\n\n葛孟愤愤不平，这简直没天理了！\n\n是啊，山东不让女人上桌是有祖宗的智慧的，打出来的媳妇揉到的面，不打几顿这群母人都不知道自己的地位！\n\n——这句话孙啸川没说出来。因为他想起了葛孟已经结婚了，这群文化人就喜欢装清高，少不得转述给他爸。\n\n领导面前还是要留个好印象。\n\n兄弟，听说你是酒吧舞的高材生，人又一表人才，自主创业都要上市了，那彩礼一定给的很多了？\n\n葛孟淡然一笑，答，时代变了。\n\n孙啸川心下了然。他给季莓发消息，简明扼要一个字：滚。\n\n付了彩礼要有性生活还要征得季莓同意。\n\n付了彩礼要生孩子还得征得季莓同意。\n\n付了彩礼季莓也不一定做家务。\n\n付了彩礼季莓也不一定不出轨。\n\n甚至付了彩礼季莓也可以合法携款分手。\n\n所以彩礼存在的意义是什么？\n\n彩礼是战争赔款，是合法诈骗。\n\n我，孙啸川，不给彩礼。\n\n结了婚强奸也是合法的。\n\n结了婚被打到挂尿袋也离不了。\n\n结了婚生的孩子都是孙啸川的，身体的亏损是我自己的。\n\n结了婚不伺候好孙啸川一家就是我的失职。\n\n不收彩礼孙啸川会觉得我廉价，倒贴。\n\n没有物质补偿我，我拿什么来保证我的未来不会是生了孩子人老珠黄又被抛弃？\n\n我，季莓，一定要彩礼。\n\n某日，季莓又提起了彩礼。\n\n孙啸川先拖。季莓说再拖分手，这婚别结了。\n\n孙啸川于是啪一声跪在了季莓脚边。\n\n“我打工三十年一共攒了五万块，我和我爸一起给你跪下了，你要少点成不成？”\n\n季莓也跪下了，眼底含泪。\n\n“我跟了你七年了，这七年的感情连二十八万都不配吗？”\n\n孙啸川笑道你一个被我玩了七年的破鞋离开了我还能有谁要你。\n\n他举例——“我领导的儿子！我的好哥们！跳舞的研究生！身价几千万！一分彩礼没出！”\n\n人家高材生以身作则不收彩礼，他孙啸川作为普通牛马也要向他看齐。\n\n季莓看他的眼神就像是看傻逼。她让孙啸川撒泡尿照照自己长什么样，再想想领导儿子又长什么样，你提的是葛孟吧，你不是瞧不起他做某委的上门女婿吗？\n\n孙啸川不说话了。\n\n季莓也举例——“我大学的同学！我的好闺蜜！男方给了十八万八！房产证还写女方名字！”\n\n孙啸川冷笑一声，你肯定没问陪嫁多少，这边浙江的规矩就是女方给双倍，我给彩礼可以，也不用双方抵扣了，你直接给我二十万就行了，你给的起吗？\n\n话音落下两人一同沉默了。\n\n为什么找个过日子的人会变成找个诈骗犯？\n\n为什么总有人不付出又想得到一切？\n\n为什么有的人的彩礼不会被女方带走，不会交给哥哥弟弟娶媳妇，而是成为小家庭的启动资金？\n\n为什么有人不付彩礼也不愁找不到对象？\n\n为什么有的人结婚不需要出一分钱，父母就能打点好一切？\n\n寄吧，为什么只有他们总因为钱而发愁？\n\n又为什么，只有他们执着着想要结婚？\n\n## 二十六.第4869次演讲纪实（五千赞番外）\n\n同志们，兄弟们，所有拒绝接触红薯的联合者们：\n\n你们知道，为什么有重男轻女吗？\n\n每当一个红薯村的女性结婚，孙坝村的一个家庭就会倾家荡产。为了支付她们难填的欲壑，孙坝村不得不拿走亲姐妹的彩礼，带走父母的养老金，顺走祖父母的棺材本，一整个家庭，从祖父祖母到姐姐妹妹，十几口人，百来年的积蓄，全被这一个独生子的婚姻掏空了！\n\n孙坝村的敢给女儿分家产吗？不敢。分了，就供不起儿媳妇的彩礼了，没有儿媳妇就没有孙子，没有孙子这个家就绝后了！\n\n明白吗？\n\n谁来谁来干工地，谁来守边疆，谁来支持社会运转，谁来延续文明？就靠红薯村的这群捞女吗？为什么吃十元盒饭的都是我们孙坝村，而红薯村在喝二十五元的奶茶？她们的钱是哪来的？市场上为什么会有金钱流动？是我们，是伟大的孙坝，一切都是我们供的。\n\n你们知道吗，红薯村其实已经崩溃了。哪来的钱？她们没有钱。经济好看都是自己编的。红薯村宁可一个字一个字的篡改数据来骗政府拨款，也不愿真的去赚一分钱。\n\n多可笑，就这样，孙坝村还在买她们的红薯！\n\n试问，从古至今，红薯村有做过什么贡献吗？理工科没天赋，文科就一定有天赋——可笑，哪些政客是红薯村出来的？\n\n红薯村样样不如孙坝村。\n\n孙坝，拯救人类。\n\n请大家安静。是，我承认，或许是有那么几个女的做出了贡献，比如屠**，比如吴**。但他们是脱离了低级趣味的人，我们尊称一声先生，因为他们的成就与性别无关。我们还是来看海量个例——\n\n一个家庭堆出来的独生子在相亲市场上就像行走的香饽饽，没有女的不馋的，所有的红薯都会找到属于它的孙坝男。\n\n红薯村会怎么做呢？\n\n她们会以恋爱的名义要挟你把钱给她，如果没钱就不给肏，当你忍气吞声咬牙切齿地把钱交出去，她们就会故作清高提出要结婚要彩礼，当你被搜刮一滴都不剩的时候，她们就会和你提分手。\n\n而你付出的钱，因为是自愿赠与，一分都要不回来。\n\n你以为掏光家底就能换来家庭和平吗？现在女的良心早坏了，她们好吃懒做又贪财，既不尊重你的家人，也不尊重你，和你结婚的目的就是拿着你辛辛苦苦赚的钱去寻欢作乐，专门生下不是你的孩子来羞辱你！\n\n这就是红薯，这，就是红薯村。\n\n其实男性很脆弱，但这个世界将太多压力强压在了我们身上。请不要伤害我们——但没有人听见。\n\n我们无法从法律中获取力量。是的，现在的政府不过是一只大号的红薯。\n\n没了，一切都结束了，红薯已经打上来了。如果她们把你迷晕了进行人工取精，在法律判决下你甚至还要为素不相识的人送钱，即使你什么都不知道。\n\n但，兄弟们，请伸出你的手，告诉我，那是什么？\n\n是拳头，是力量，是文明的源头，是儒家文化的延续，我们已经又到了危急存亡的关头了，不要被文明道德所迷惑，你所拥有的肉体力量才是你自信的根本。\n\n对她们使用炎拳吧！\n\n美国女人不要彩礼，乌克兰女人胸大屁股翘还特别喜欢东亚，俄罗斯女人会赚钱养你，韩国女人不要，日本女人贤惠的可以留下其他的突突了，印度女人不要彩礼还送钱——即使是礼崩乐坏的中国，只要恢复清朝的制度，回到三妻四妾的社会，一切会好起来的，所有人都会有老婆的。\n\n我们是全家的骄傲和希望啊，我们曾经那么优秀啊，怎么可以被女人毁了呢？\n\n若没有人与我们并肩，我们就是那昂首挺立的唯一一个。\n\n我要这天，再遮不住我眼， 要这地，再埋不了我心——团结起来吧，兄弟们！\n\n只有男人，才能拯救男人！\n\n谢谢大家！\n\n## 二十七.辩论\n\n中国有句古话，叫做：\n\n带上你的千军万马，虽然最终不免孤身奋战。\n\n在首质阶段二人在判准上达成统一：在当代社会，究竟是男性压迫女性还是女性压迫男性，如果是前者，则季莓得证，后者则孙啸川得证。\n\n立论时，双方已经各自抛出三个论点六个例子，例如季莓举出的百香果女孩和小花梅，孙啸川举出的张薇和胖猫。\n\n孙啸川在驳论环节指出，拐卖女性并用铁链囚禁小花梅的董某其实是男性对于无理女性的反击，应被尊称为圣，所以作为季莓方的论点并不成立，同时感谢对方辩友证明我方观点。\n\n而季莓就胖猫事件提出了自己的质疑：你不觉得这件事有很大的漏洞吗？胖猫跳江的时候仲尼为什么不救他？明明也在水里。\n\n在申论部分二人分歧进一步扩大。季莓首次提出“我接受≠我同意”，孙啸川则根据立论中“凡是女性支持的一切反对，凡是女性反对的一切支持”的两个凡是原则进一步完善，指出“反对不完全就是完全不反对”，为结辩时升价值打下了良好的基础。\n\n到质询环节双方交锋已经非常明显。归根结底还是个例打个例，基于不同事件或同一事件的不同解读出论，然后谁也攻击不到谁。\n\n今天她多收了彩礼，明天他讹走了嫁妆；今天他说法律维护家暴的女性，明天她被殴打到挂尿袋也离不了婚；今天她杀丈夫，明天他杀妻子；今天他摔女婴，明天她摔男婴；今天二十岁女性打不过四岁男童，明天十四岁男童奸杀十岁女性；今天她结婚就是奔着分财产，明天她喝杯奶茶都是捞女；今天他相亲了就想开房，明天女朋友隐瞒婚育他还接盘；今天他奸杀女童，明天她奸杀男……哦，这个好像没有。\n\n事例数据呢？占比呢？大部分是什么样子呢？\n\n没有。\n\n数据呢？\n\n有，但你统计方不够权威/数据不够新/曲解了原意。\n\n数据呢？\n\n有，但政府背书就是正确的吗？肯定是出于利益关系遮掩了什么。你们都是一伙的，这该死的女权/男权社会。\n\n……\n\n不管怎么说，激动人心的自由辩环节到了。\n\n季莓冷冷一笑。她要拿出她的杀手锏了。\n\n先念一段数据：性别比……二胎性别比……女性出生……农村宅基地……就业歧视……\n\n然后开始打感情牌：如果我们生了一个女儿……社会是复杂的，但你对你将来的女儿……谢谢。\n\n孙啸川，啸川面对这个女人，他面对的是全世界孙坝男的目光和期待。季莓曾经在益邑市最，他深知这一点，他还能够微笑着面对他面前的这个人吗？十秒钟以后，他会是怎样的表情？\n\n孙啸川张口了！\n\n他说！\n\n“闭嘴，你和你的女儿都是我的**套子，生下来就是给我用的，张着你那嘴干什么？给我*吗？不就是想要我的**嘛，我就喜欢母子*，陪你玩够了，让我*两把不行？还是说你喜欢黑哥哥的大*？真是**，你女儿和你一样将来是个**，我要在你**的时候就把她**，*到你*。”\n\n季莓崩溃了。错过了最后的结辩。\n\n唉，季莓也许会后悔的，孙啸川在下半场多打一个观点的情况，她打得太保守，太沉稳了，她失去了自己的勇气，面对孙坝村悠久的三棺，她没有拿出猛冲猛打的作风，她终于自食其果。她该回家了，她不用回遥远的红薯村，她们大多数都在益邑市生活。\n\n好了，让我们恭喜胜者的诞生吧。\n\n季莓破防了，比赛结束了，孙坝村获得了胜利，淘汰了红薯村。他们没有再一次倒在季莓的面前，伟大的孙坝村，伟大的三棺，孙啸川生日快乐，孙坝村万岁！\n\n## 二十八.和好\n\n房子里有灯。\n\n灯下站着两个人。\n\n一个是男人，一个是女人。\n\n男人提刀静坐，仿佛和昏黄的灯光融为一片。他只看到了女人。\n\n他的刀很快。\n\n她的棍很慢。\n\n他有把握接下她的棍吗？\n\n她确信他接不住。\n\n她能抵住他的刀吗？\n\n他有必中的准头。\n\n动了吗？\n\n不。\n\n现在？\n\n也不。\n\n窗牖洞开，他听见树叶窸窣，但是不是风动。\n\n他想到了无声的夜晚，缠绵的黏腻的胶状空气像被面前的女人捏起又甩掉。\n\n她用一根棍子刺破了他的兵荒马乱，她还是那么丰满，又形销骨立。扎得他生疼。\n\n他真疼啊。\n\n女人像是没有心。\n\n男人听见体内浪潮奔涌，不仅仅是眼泪。他知道他已经败了。他永远无法放弃一个与自己相似的肉体与灵魂，他爱她就像爱自己，就像爱他的络腮胡和寸头，爱他不洗的内裤，爱这具名为孙啸川躯体上的一切，包括和他那么相似的女人。\n\n怎么办呢。\n\n再硬男人，直肠依然是柔软温暖的。\n\n孙啸川抬头，季莓同样看着他，仍然握着棍棒，泪光闪烁。\n\n“我们和好吧。”\n\n多余的话被吻走。孙啸川几乎喘不上气，眼泪一并被舔走，他像一滩融化了的甜美的奶油，从喉间不断挤出惬意的沙哑的气泡。\n\n季莓打开电视，正好落在CCTV9。这是一档科普节目。\n\n涨潮是地球引力和月球引力的相互作用所导致的自然现象。当地球、月球和太阳处于一条直线上时，月球和太阳的引力会相互增强，这会造成海洋表面水位的升高，即涨潮。\n\n沙滩是岩石的风化，在崩裂破碎之前并无遇水的经验，全然干燥。\n\n山有小口，仿佛若有光。\n\n干涩的沙滩时而被海浪温柔地抚摸，时而被有力地冲刷，细软的沙粒在海浪的推动下，时而堆砌成小山丘，时而又被抚平，在湿润的沙滩上留下一道道蜿蜒的水痕。\n\n初极狭，才通人。\n\n退潮会带走沙滩上的沙砾和贝类。沙滩祈求这片翻涌的海浪能给他带来更多。随着潮水逐渐涌上，海浪变得愈发有力，它们以排山倒海之势向岸边涌来，每一次触碰沙滩都激起层层白色的绵密泡沫，如同无数颗细小的珍珠在阳光下闪烁。\n\n复行数十步，豁然开朗。\n\n随着涨潮的深入，海浪的力量愈发强大，它们不再仅仅是简单的轻抚，而是开始奋力地向前推进，将一片片沙滩覆盖，形成一片片临时的水域，又退走，一步步刷新沙滩的高地。有些贝壳海藻或是小石子被海浪携带着，深深嵌入了沙滩的内部。\n\n直到漆黑的大海被刺刀一样的白光扎破。\n\n潮水冲向了沙滩的最深处。\n\n天将破晓。\n\n彻底被淹没。\n\n季莓喟叹一声，提上裤子，扔出一团餐巾纸。\n\n“我会永远爱你。”\n\n孙啸川低头擦拭。\n\n“嗯。”\n\n恰似一朵水莲花不胜凉风的娇羞。\n\n## 二十九.性焦虑\n\n孙啸川曾遭遇三度背叛。其一为女性，他的母亲，他未曾谋面的爱人。性焦虑刻在男性的基因中，而只有女性才有交配权，两者导致国男在两性关系中处于被动——他无法主导一个女人同意和他睡觉，这是给他行使权力带来了极大的困难，无疑是疑背叛了他的基因和天性。\n\n其二为男性，他的同伴，无限包容女性的懦夫。这个世界和家庭都是男人撑起来的，男人解决了资金、房子、工作、家庭、社会价值、情绪价值、虚拟价值、真实价值、存在价值、使用价值、过渡性价值、个体性生产价值、社会性生产价值，才能勉强舔到一个女人。男人本不需要付出，多一个男人在舔，就是多一份背叛。\n\n其三为国家，他的父亲，他的神佛。祂爱孙啸川，祂理应爱孙啸川，但是，祂老了。不止是从小的性压抑教育和社会性压抑氛围，还有对性交易的严格打压，桩桩件件都让他痛彻心扉。他的怒火，不会停歇。\n\n天哪，请重塑男性底层自信价值观吧！请拯救还没有觉醒的同胞们吧！\n\n请让女性爱我，尊重我吧！\n\n## 三十.数据\n\n最近季莓找孙啸川碰面的时候都要带一个硬盘，以备翻旧账。\n\n开始是手机备忘录，后来发现她甩案例的时候孙啸川会放视频，两个喇叭比她一个嗓门大，于是季莓连夜从京西买了个U盘下载了网络可查的近十年的法院判决书，在下一次杀了孙啸川一个措手不及。\n\n自从京西找个了某女代言人孙啸川就发誓要卸载京西给卑鄙的资本主义市场一些颜色看看，因此他的U盘还要过些日子才到。\n\n双方战得满头大汗力竭的时候U盘容量也在告罄。也就某一天，季莓忽然意识到不止找案例对对碰，她还可以检验数据，就真实性和权威性上狠狠地打压孙啸川！\n\n于是季莓先发现了新国辩知名大学辩论队使用伪证。\n\n很不巧，造假的是她使用过多次的数据。\n\n季莓熬了一夜整理材料梳理逻辑，半夜摸黑把文档贴在红薯村的宣传栏上，回去时扭头一看材料被撕了。\n\n季莓熬了两夜写了篇情深意切的小作文，大意是喔宝宝你是一个香香软软脑袋一时糊涂涂的宝宝但是这个问题要改正哦宝宝好吗好的，凌晨摸到红薯村发现宣传栏底下站着一红一蓝俩护法，手里各一柄渔叉，等着解决提出问题的人。\n\n熬了三夜，季莓找到了败方大学宣传部。\n\n那日，彩旗飘飘，日光炫目。记者甲捻着采访本角，忽地开口道：“辩士女士，您当真懂得查证数据么？”\n\n辩手便昂起下颌，水晶灯在冠军奖杯上折射出炫目光斑。众人却不退缩，记者乙从手机里调出文献截图：“那怎的小组赛上的关键论据，报告里面连调查对象都没有呢？”\n\n辩手青白的面皮陡然涨作猪肝色，纸页簌簌抖着，嘴里迸出些“模型偏差”“统计口径”之类艰涩术语。不知谁嗤笑出声，那辩手急急扯过队友的文献夹，哗啦啦翻出满屏马赛克处理的参考文献，偏又有眼尖的瞧见某页水印分明是某公众号搜来的野鸡机构。\n\n满屋子哄笑起来，连走廊里候场的对方辩友都把保温杯磕得叮当响。辩手的领结早歪到了肩膀，却仍梗着脖子念白：“凡赛事必有攻防...场下质疑...岂非...岂非...”哇哦，那可是冠军队，好了不起的，没有在大赛拿过全程佳辩的人没资格和冠军打攻防哦。\n\n在这时候，众人也都哄笑起来：房间内外充满了快活的空气。","categories":["一些碎碎念"]},{"title":"chapter8 | CPU的设计","url":"/posts/ae827a2f0766/","content":"\n[toc]\n\n## CPU概述\n\n**CPU执行指令的过程**：\n\n1.   根据pc取指令\n\n异常时内部异常，中断时由于外部事件的出现导致CPU停止执行指令； 即`内部异常，外部中断`\n\n---\n\n### **计算机的五大组成部件**\n\n-   Memory\n-   I/O\n-   Datapath 数据通路 **执行部件**\n-   Control Unit 控制部件 **控制器**：控制器对执行部件发出信号。\n\n---\n\n#### **数据通路Datapath的基本结构**\n\n数据通路是由**操作元件和存储元件**通过**总线**方式或**分散**方式连接而成的进行***数据存储、处理、传送***的路径\n\n**操作元件**：（是组合逻辑电路）\n\n**存储元件**：（时序逻辑电路）\n\nsetup时间：在时钟边沿到来**之前**，输入端保持不变的时间；\n\nhold时间：在时钟边沿**之后**，输入端必须保持不变的时间；\n\nclk-to-q锁存延迟：从时钟边沿到输出端稳定的时间；\n\n#### 数据通路和时序控制\n\n指令周期 : CPU执行一条指令需要的时间。\n\n![image-20250421114837747](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250421114837747.png)\n\n指令周期：**Cycle Time = Latch Prop + Longest Delay Path + Setup + Clock Skew**\n\n为了满足数据通路的要求，要能够满足下面这个约束关系：\n$$\nholdTime< ClkToQ+shortestDelay\n$$\n即，**在下一个信号到来前，能够hold不变，防止输出异常**\n\n---\n\n### 计算机性能\n\n衡量CPU性能的是**用户CPU时间**，执行用户的作业所需的时间，不考虑IO等\n\nCPU的执行时间：\n\nT= CPU的时钟周期数*时钟周期/程序= 指令条数/程序 *CPI *时钟周期\n\n>   一个程序的时钟周期数x时钟周期\n\n**CPI**： Cycle Per Instruction，每一条指令需要多少个时钟周期\n\nCPI是一个确定值--和CPU的设计,指令类型有关。\n\n某个程序的CPU时间为：\n$$\nCPU \\space Time= \\sum_{i=1}^n {CPI_i * C_i}\n$$\nCi为第i类指令，CPI_i 是这种指令的CPI。 再除以指令总数，即可得到程序的平均CPI.\n\n---\n\n为什么 ISA也会影响CPI？ 因为RISC-V没有提供像乘法和除法的指令，每个指令的时钟周期都比较短。\n\n时钟频率翻倍但是\n\n基准测试程序：专门用于测试性能测试的程序，使得计算机有个公共的比较方法。\n\n**计算机性能由三个关键因素决定：指令数目，CPI，时钟周期**\n\n-   指令数目由编译器和ISA决定\n-   CPI由ISA和CPU决定\n-   时钟周期由CPU的实现来决定\n\nCPU时间 = 指令数目 * CPI* 时钟周期\n\n## 单周期的CPU设计\n\n**单总线数据通路**\n\n这一部分没有听懂，请自行看ppt。\n\n时钟周期的宽度：以read、write为准（因为要以最长的为准）\n\n**常见的指令！！！**\n\n| 指令              | 功能 这里用的不是RTL！是我自己写的 | 说明             |\n| ----------------- | ---------------------------------- | ---------------- |\n| add rd rs1 rs2    | R[rd]=R[rs1]+R[rs2]                |                  |\n| slt rd rs1 rs2    | rd = 1 if R[rs1]<R[rs2] else 0     | 使用signed比较   |\n| sltu rd rs1 rs2   | rd= 1 if R[rs1]<R[rs2] else 0      | 使用unsigned比较 |\n| ori rd rs1 imm12  | R[rd]= rs1 \\| SEXT[imm12]          | ori：or immedia  |\n| lui rd imm20      | R[rd]= SEXT[imm20]                 | U型imm           |\n| lw rd rs1 imm12   | R[rd] = M[rs1+SEXT[imm12]]         |                  |\n| sw rs1 rs2 imm12  | M[R[rs1]+SEXT[imm12]] =            |                  |\n| beq rs1 rs2 imm12 | PC=PC+SEXT[imm12*2] if rs1= rs2    | 注意imm12要乘以2 |\n| jal rd im20       |                                    |                  |\n\n>   注意： 有关imm乘以几的问题，可以参考这个文章[RV32I控制转移指令的偏移量计算问题 - 知乎](https://zhuanlan.zhihu.com/p/377200438)\n>\n>   省流不看版本：除了jalr指令，所有的B和J型指令的imm都表示跳转imm*2 bytes(显然PC+1代表比PC往前了一个byte)，而指令是按照`字`来编码的（32位机器字长代表4个bytes），因此需要对imm进行乘以2，这样子，就能成功地实现跳转。 \n\n\n\n**存储数据的指定**：\n\n寄存器编号只需5位\n\n32bit machine的总线只有32位，理论上最大访问的内存为2的32次方，也就是4GB；\n\n---\n\n### **单流水线CPU的设计**\n\n除R-型外，其他5类都带有立即数   ——立即数扩展器\n\n核心运算类功能的实现  \t\t  ——ALU\n根据PC取指令和PC+4\t    \t——取指令部件\n指令的RTL最终实现\t\t        ——完整数据通路\n\n#### 立即数扩展器\n\n为什么需要一个立即数扩展器？ 因为RISCV的指令二进制表示中，imm的排列很混乱，而且不同的指令的imm位数和排列往往不同，因此需要立即数扩展器\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250425114704950.png\" alt=\"image-20250425114704950\" style=\"zoom:50%;\" />\n\n除了R型指令不需要寄存器，其他都有寄存器。因此需要一个5选1的选择器。ExtOP为3位，具体如何得到ExtOP呢？**需要根据编码Instr得到**\n\n#### ALU 算数逻辑部件的设计\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250425115156719.png\" alt=\"image-20250425115156719\" style=\"zoom:50%;\" />\n\n实现的功能：\n\n-   add or slt sltu srcB,判0\n\n    即实现了加法，或运算，比较，将B直接输出，判断是否为0；\n\n因为上述的9条指令需要这些运算，比如lw指令，需要加法（lw rd rs1 imm12: R[rd] <--- M[R[]]  \n\n#### 取指令部件 Instruction Fetch Unit\n\n每一次运行指令都有一步**更新PC**的步骤，需要依靠取指令部件；\n\n![image-20250427103915530](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427103915530.png)\n\n\n\n#### R型指令的数据通路\n\nR型指令：\n\n-   add rd rs1 rs2: \n-   slt rd rs1 rs2;\n-   sltu rd rs1 rs2;\n\nR型指令无需imm，直接从寄存器组中读取、写入数据即可：\n\n**写使能端信号不能乱取！！！防止出现错误**\n\n R型指令中，RegWr（**Reg**ister **Wr**ite）为1；\n\n![image-20250427104315618](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427104315618.png)\n\n#### I型指令的型号通路（ori)\n\n因为除了R型指令，其他的指令都有imm，rs只有一个，因此需要ALU的输入端需要一个多路选择器，以**ALUBSrc**为控制信号。\n\n![image-20250427104604542](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427104604542.png)\n\n#### U型指令的信号通路\n\nU型指令只有一个lui\n\n-   lui rd imm20\n\n![image-20250427110900124](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427110900124.png)\n\n#### Load&Store指令的信号通路\n\n指令详情：\n\n-   load rd rs1 imm12; R[rd] = M[R[rs1]+SEXT[imm12]] 。 **注意：这里的imm不需要乘以2，因为数据是按字节寻址的**\n-   store rs1 rs2 imm12; M[R[rs1]+SEXT[imm12]]<--R[rs2]。 \n\nLoad和Store指令涉及到了存储器的访问，这里以理想存储器为例：\n\n![image-20250427110804853](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427110804853.png)\n\n>   MemtoReg: 即 Memory To Register\n\n注意：B和J型指令的imm通常需要左移一位，这是因为在设计的时候省略了1位，或者说默认最后一位为0（处于对齐指令的目的）；在RISCV规范中，给出了相关的内容，可以参考[RV32I控制转移指令的偏移量计算问题 - 知乎](https://zhuanlan.zhihu.com/p/377200438)\n\n#### B型指令的数据通路\n\n指令为：\n\n-   beq rs1 rs2 imm12; if(R[rs1]=R[rs2]) PC<-- PC+(SEXT(imm12)<<1) else PC<-- PC+4;\n\n\n![image-20250427112357474](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427112357474.png)\n\n其中下地址逻辑为：（只有当ALU计算结果为0，并且是Branch指令，才会将imm和PC相加，否则PC=PC+4）\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427112744627.png\" alt=\"image-20250427112744627\" style=\"zoom:50%;\" />\n\n\n\n#### J型指令\n\nJ型指令：\n\n-   jal rd imm20; R[rd]<- PC+4, PC<- PC+SEXT(imm20<<1);\n\nJ型指令除了需要跳转，还需要将下一条指令存入寄存器（实现call的操作）\n\n![image-20250427113923927](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427113923927.png)\n\n---\n\n**指令的执行结果总是在新的时钟周期到来之前，才会将其保存在寄存器、PC、存储器中**\n\n一个时钟周期的时间为：clk-to-q+longest delay +setup+ 时钟偏移，可以看出，时钟周期应该根据最长的delay来决定。\n\n\n\n---\n\n>   考试的时候以 短周期和流水线的数据通路图、控制器，很清楚地知道每一个控制信号，每一条线的内容，指令必须看得到，不一定会写汇编代码。\n\n### 控制器的设计\n\n前面提过，CPU的核心是数据通路（执行部件）和控制器（控制部件），前面已经设计好了数据通路，但是数据通路中的很多信号，比如ALUctr需要控制器的作用。\n\n#### 控制信号的取值分析\n\n1.   **所有指令执行的共同操作**  \n\n     每一条指令运行的过程都是：Clk信号到来，经过一个Clk-To-Q（锁存延时）之后，PC被写入**指令存储器**，经过取数时间，指令被取出，送入控制器，**在控制器中译码，并且发出控制信号**，之后进入数据通路计算，下一个时钟周期到来，新的数据被写入。\n\n     >   对于R型指令，新的PC很快得到，到那时对于跳转指令，需要等待运算才能得到新的PC值。\n\n2.   **R型指令的执行过程**\n\n     Rd,Rs1,Rs2来自取指令单元（指令存储器），各种控制信号来自控制器。（回顾过程：PC寄存器经过clk2q之后MAR得\n\n     R型指令的执行过程可以概括为：Rigister(rs1,rs2) -> busA,busB->buwW->Rigister(rd)\n\n     ![image-20250428101709013](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250428101709013.png)\n\n     >   留心这些控制信号的取值和含义，比如MemWr应该一定为0，MemtoReg也是为0\n\n     R型指令的时间分析：\n\n     ![image-20250428102812207](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250428102812207.png)\n\n3.   I型指令的执行过程\n\n     Rigister(rs1)->busA,扩展器(imm12)-> ALU-> Rigister(rd)\n\n     ![image-20250428103132649](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250428103132649.png)\n\n4.   U型指令的执行过程\n\n5.   Load指令\n\n6.   Store指令\n\n7.   B型指令\n\n8.   J型指令\n\n9.   最终指令和真值表的取值\n\n     ![image-20250428103320124](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250428103320124.png)因此可以通过极小项写出每一个控制信号的 逻辑表达式\n\n     比如：Branch=op<6>&op<5>&~op<4>&~op<3>&~op<2>&op<1>&op<0>    (B-type)\n\n     Jump=op<6>&op<5>&~op<4>&op<3>&op<2>&op<1>&op<0>           (J-type)\n\n     >   这里没有考虑funct3功能码，是因为B-type指令的op都是1100011，具体功能由funct3决定，即，B型指令的op都相同，只要保证op为1100011时Branch信号为1即可；而J-type的指令没有funct3字段；\n\n     我们依次分析每一个控制信号的真值表达式，最后链接电路：\n\n     ![image-20250428105102309](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250428105102309.png)\n\n#### 时钟周期的设计\n\n时钟周期应该要满足最慢的指令（load）的要求\n\nload指令：（load rd rs1 imm12）\n\n-   clk2q+取指令时间\n-   译码时间（控制单元延迟）\n-   寄存器读数延迟（得到R[rs1]）\n-   ALU延迟（得到addr=R[rs1]+SEXT[imm12]）\n-   存储器读数延迟 （读取M[addr]）\n-   寄存器setup时间\n\n---\n\n\n\n例子：<a id=\"q\"> </a>假设在单周期处理器中，各主要功能单元的操作时间为： \n\n存储单元：200ps\\  ALU和加法器：100ps\\ 寄存器堆（读/写）：50ps\n\n假设MUX、控制单元、PC、扩展器和传输线路都没有延迟，则单周期实现方式（每条指令在一个固定长度的时钟周期内完成）中，CPU执行时间如何计算？\n\n那么我们可以确定：\n\nR-type： 取指令200+读rs1、rs2 50+ALU100+写rd 50= 400\n\nLoad Word指令：取指令200+读rs1 50+ ALU100+ 存储器读取 200+ 写入rd 50= 600\n\nStore Word指令：取指令200 +   读取rs1，rs2 50 +ALU100 + store 200= 550（注意rs1和rs2的读取是并行的）\n\nBranch： 取指令200+ 读取rs1，rs2, 50 +ALU100 = 350\n\nJump： 取指令200+ 存入PC+4 50 + ALU计算跳转位置 100 =350；\n\n\n\n\n\n\n\n---\n\n## 多周期CPU设计\n\n下面以实现一个简单的指令系统为例，讲解多周期CPU的设计\n\n>   这个指令系统不用记！！！\n\n![image-20250428112505398](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250428112505398.png)\n\n**多周期的数据通路**\n\n![image-20250428112702885](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250428112702885.png)\n\n### 指令执行的过程\n\n>   Note: 多周期的CPU的时钟周期取的是任何一条指令、所有阶段中最长的那一个；在下面的各种阶段中，取指令阶段因为涉及到一次存储器访问和一次寄存器保存过程，因此耗时最长（访问寄存器的耗时比较长，可以参考<a href=\"#q\">上面的例题</a>\n\n\n\n#### 取指令并计算下条指令地址\n\n该阶段对应状态记为IFetch。因为采用定长指令字，故PC增量操作可在取指令阶段完成。取指阶段的功能是：将PC内容作为地址访问主存以取出指令，将指令存入指令寄存器IR中，并将PC+4作为下条指令地址送PC。实现上述功能的有效控制信号及其取值如下。\n\n-   R[IR]<-M[PC]:PCout=1,MARout=0,MemWr=0,IRWr=1。\n-   PC<-PC+4:Add1MUX=0,Add2MUX=1,PCWr=1。、\n-   其他寄存器写使能信号(如MARWr、CCWr、MDRWr、ALUoutWr、RegWr)全部为0。\n\n\n\n---\n\n#### 译码并取数\n\n将IR中的op段送入控制器，得到控制信号；将Rs,Rt输入到寄存器组的Ra，Rb端；\n\n同时会进行“投机计算”：计算Load、Store指令中的地址，并且存放在MAR中。\n\n#### 执行指令\n\n3)执行指令\n控制部件对指令译码后，会和条件码中的标志信息组合生成控制信号，从而使CPU在控制信号的控制下执行指令。针对不同指令的功能，其对应的有效控制信号如下。\n\n1.   R-型指令：R[Rt]-R[Rs]op R[Rt]\n     R-型指令的执行需要两个时钟周期，对应状态分别记为RExec和RFinish。\n\n     -   RExec状态的功能为：进行ALU运算并将结果存入ALUout和CC寄存器。其有效控制信号及其取值为 BMUX=1,ALUOp=xxx,ALUoutWr=1,CCWr=1,其他寄存器写使能信号全部为0。其中，ALUOp的取值由指令操作码决定，以控制ALU进行不同的运算。\n     -   RFinish状态的功能为：将ALUout的内容存入Rt。其有效控制信号及其取值为：RegMUX=1,RegWr=1,其他寄存器写使能信号全部为0。\n\n     问题：为什么不把这两个阶段给合并？如果两个周期合并，可能来不及把异常结果转去进行异常处理，就可能把错误结果写入寄存器了如果Rfinish之后再进入溢出异常处理状态，则需要保证RegWr修改为0；简而言之：为了异常处理。\n\n2.   I-型运算指令：R[Rt]←R[Rs]op EXT[imm16]\n     I-型运算指令的执行需要两个时钟周期，对应状态分别记为IExec和IFinish。\n\n     -   IExec状态的功能为：进行ALU运算并将结果存入ALUout和CC寄存器。其有效控制信号及其取值为：ExtOp=0或1,BMUX=0,ALUOp=xxx,ALUoutWr=1,CCWr=1,其他寄存器写使能信号全部为0。与R-型指令一样，ALUOp的取值由指令操作码决定，不同的取值控制ALU进行不同的运算。\n     -   IFinish状态的功能为：将ALUout的内容存入Rt。其有效控制信号及其取值为：RegMUX=1,RegWr=1,其他寄存器写使能信号全部为0。经分析可知，IFinish和RFinish两个状态的功能完全一样，因此，可以将两个状态合并成一个状态：RIFinish。\n\n3.   Load指令：R[Rt]-M[R[Rs]+SEXT[imm16]]\n     Load指令的执行包含三个子功能，需要三个时钟周期。因为在“译码并取数”阶段已经计算出地址并存入MAR中，因而还需要两个时钟周期，对应状态分别记为lwExec和lwFinish。\n\n     -   lwExec状态的功能为：读主存内容并保存到MDR。其有效控制信号及其取值为：MARout=1,PCout=0,MemWr=0,MDRMUX=0,MDRWr=1,其他寄存器写使能信号全部为0。\n     -   lwFinish状态的功能为：将MDR内容存入Rt。其有效控制信号及其取值为：RegMUX=0,RegWr=1,其他寄存器写使能信号全部为0。\n\n4.    Store指令：M[R[Rs]+SEXT[imm16]]-R[Rt]\n\n      Store指令的执行包含三个子功能，需要至少三个时钟周期。因为在“译码并取数”阶段已经计算出地址并存入MAR中，因而只需要两个时钟周期，对应状态分别记为swExec和swFinish。\n\n      -   swExec状态的功能为：将Rt存入MDR并直送总线。其有效控制信号及其取值为：MDRMUX=1,MDRWr=1,MARout=1,PCout=0,MemWr-0,其他寄存器写使能信号全部为0。\n      -   swFinish状态的功能为：将MDR送入总线的数据写入主存。其有效控制信号及其取值为：MARout=1,PCout=0,MemWr=1,其他寄存器写使能信号全部为0。\n\n      \n\n5.    Jump指令：PC+PC+SEXT[imm16]\n      Jump指令的功能为：进行转移目标地址计算并送PC。它只需要一个时钟周期，对应状态记为JFinish。\n\n      -   其有效控制信号及其取值为：ExtOp=1,Add1MUX=0,Add2MUX=0,PCWr=1,其他寄存器写使能信号全部为0。\n\n      根据上述对每条指令执行过程的分析，得到一个状态转换图。图8.32是一个支持R-型指令、I-型运算指令、Load/Store指令和Jump指令执行的状态转换示意图。\n\n      图中每个状态用一个状态编号和状态名标识，例如，0:IFetch表示第0状态，执行取指令(IFetch)操作，圆圈中示意性地给出了该状态下部分控制信号的取值，其中，有取值为0和取值为1的两种有效控制信号，以及多值有效控制信号ALUOp,ALUOp=xxx表示根据操作码OP译码得到的一个ALU操作控制信号取值为xxx。此外，图中的x表示取值为任意的无效控制信号。\n\n      在图8.31所示的多周期数据通路中，每条指令的执行过程就是图8.32所示的状态转换过程。每来一个时钟，进入下一个状态。从图8.32可看出，R-型指令、I-型运算指令、Load和Store指令的CPI都为4,跳转指令Jump的CPI为3。如果不在译码/取数阶段“投机”计算访存地址，则Load和Store指令的CPI为5。\n\n      ![image-20250428115548563](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250428115548563.png)\n\n---\n\n>   五一假期结束，现在看不懂自己的笔记了\n\n时钟周期的= clock-to-q+setup+longest-delay\n\n注意无论是那一条指令，都有两个步骤是相同的，即IFetch和RFetch/ID，其中IFetch进行取指令，并且计算PC+4；RFetch/ID有‘投机计算’\n\n状态1之后，按照指令的译码进入不同的指令。\n\n除了Jump指令是3个周期之外，所有的指令都是4个周期，即除了Jump的CPI为3其他都是为4\n\n>   如果没有投机计算，那么lw和sw的CPI为5\n\n### PLA控制器的设计\n\nPLA控制器又称为组合逻辑控制器，或者硬连线控制器。\n\n![image-20250509104343151](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250509104343151.png)\n\n**下一状态是当前状态和操作码的函数**\n\n我们可以画出一个状态转换表来实现PLA电路，\n\n![image-20250509104713007](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250509104713007.png)\n\n硬连线方式可以自行看ppt了解，因为不是重点，故不在这里展示。\n\n特点是：1. 速度快 2. 硬件实现复杂、灵活性差。\n\n### 微程序控制器设计\n\n>   这是一个很有趣的思想，尽管在这里用不上。\n\n基本思想：用微程序来描述机器指令，每一个微程序都有多个微指令，微指令有多个微命令。\n\n每一条微指令和一个状态对应（这里的状态指的是上述的状态转换图的圈圈图）\n\n所有的微程序只存出在制度存储器中，称为控制存储器，Control Storage 简称控存CS。\n\n---\n\n#### 执行指令\n\n-   从CS中取出微程序\n-   执行微程序也就是执行其中的微指令\n-   对微指令译码就是产生对应的微命令-控制信号\n-   按照微命令来执行程序\n\n可以了解一下微程序控制器的基本结构：\n\n其中$\\mu$ 开头的代表**微**\n\n![image-20250509110118838](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250509110118838.png)\n\n#### 微指令的设计\n\n![image-20250509113020592](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250509113020592.png)\n\n\n\n\n\n>   在这里我就想吐槽了： 也没有铺垫，也没说为什么要在这里将异常处理机制\n\n### 异常处理机制\n\n#### 带异常处理机制的数据通路设计\n\n添加，两个寄存器EPC和Cause，前者存储断点，后者存储异常状态；\n\n同样的，需要添加这两个寄存器的写使能信号，\n\n-   EPCWr：在保存断点的时候有效，存入断点的PC\n-   CauseWr： 发现异常的的时候有效，将异常类型存入Cause寄存器\n\n示意图：\n\n![image-20250509114300857](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250509114300857.png)\n\n重点关注其中有关Casue和EPC的部分，是在原先的数据通路下添加的。\n\n#### 带异常处理机制的控制器设计\n\n前面数据通路使用到的新的寄存器写使能端信号需要由控制器生成，并且需要设计两个异常状态。\n\n加入异常和中断事件后的状态转换图：\n\n![image-20250509114755501](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250509114755501.png)\n\n### 多周期和时钟周期的CPU比较\n\n**多周期的时钟周期是所有阶段的最长值** (就是上面的那个图中所有最长的周期！)\n\n单周期的时钟周期是所有指令中的最大值。（一般是lord指令）\n\n![image-20250509114657162](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250509114657162.png)\n\n![image-20250509114650257](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250509114650257.png)\n\n---\n\n\n\n\n\n\n\n## 流水线CPU的设计\n\n前面提到，多周期CPU并不能很明显地提升性能，下面介绍流水线CPU。\n\n### 核心思想\n\n流水线CPU的核心思想是，将指令分成不同的阶段，在前一个指令的某一个阶段完成之后，紧接着开始执行下一个指令的这一个阶段。如图，以load指令为例。\n\n![image-20250509115710725](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250509115710725.png)\n\n>   必须保证不同阶段不会冲突，即不会用到相同的部件，比如在夏木木寄存器堆的读和写是分开的，可以看成两个独立的部件\n>\n>   结构冒险：同一个时钟周期内，多个指令都使用了同一个部件。\n\n>   流水线每一个阶段的时间是相同的（都是所有阶段的最大值），应该很好理解，因为是并行执行不同指令的不同阶段，所以必须满足最大的时间要求。\n\n### 与其他CPU比较\n\n性能比较：\n\n![image-20250509115926577](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250509115926577.png)\n\n**流水线能够大大提高指令的吞吐率**(单位时间内执行的指令条数)\n\n>   在理想状态下（忽略流水线启动的初始4个周期），流水线一直都是五个部件，每一个周期都有指令执行完成，也有指令开始执行；\n>\n>   因此流水线CPU的理想下的CPI为1，虽然每一条指令都需要5个周期，但是同时可以执行5个指令，因此CPI为1。\n>\n>   回顾： 1. 单周期CPU的CPI为1，以最长的指令load来取周期宽度。  2. 流水线的CPU的CPI为1，周期宽度为5个阶段最长的那个（实际执行的时候每一个阶段都会占用一个周期的时间） 3.多周期的CPI需要知道不同指令的比例，jump指令占用3个周期，其他的指令占用四个周期，需要知道比例进行计算。多周期的时钟周期宽度为最长的那个。\n\n\n\n### 指令执行分析\n\n流水线CPU将指令分成以下五个阶段：\n\nIfetch,Reg/Dec (取数和译码),Exec(执行), Mem（读存储器）, Wr（写寄存器）\n\n先以load指令为例：\n\n>   load rs1 rs2 imm12 RTL功能为 R[rs1]<-M[R[rs2]+STEX(imm12)]\n\n-   Ifetch： 取指令、计算PC+4，需要用到指令存储器、Adder\n-   Reg/Dec : 取数并且译码，需要用到寄存器、指令译码器\n-   Exec：执行，ALU、扩展器\n-   Mem： 数据存储器\n-   Wr： 写使能端\n\n>   流水线CPU设计使得每一条指令的执行的时候占用的资源都是不一样的。\n>\n>   同一个功能部件\n>\n>   同时被多条指令使用的现象叫做**结构冒险**\n>\n>   为了流水线能够正常地工作，我们规定：\n>\n>   -   每一个功能部件在一条指令中 只能使用一次\n>   -   每一个部件使用的时候必须在同一个阶段\n>\n>   我们需要设计每一种类型的指令，使得所有的指令都能符合这个规定\n\n\n\n---\n\n#### R-Type\n\nR型指令因为不需要进行\n\n\n\n![image-20250516105219861](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250516105219861.png)\n\nIfetch: 取指令 \n\nReg/Dec：取操作数rs1 rs2，指令译码\n\nExec：进行运算，使用ALu\n\nWr：将结果写入目的寄存器\n\n\n\n\n\n---\n\n#### Store\n\n![image-20250516110435256](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250516110435256.png)\n\nIfetch：取指令并计算PC+4 （写入PC）\n\nReg/Dec： 从寄存器（rs1）取数，同时指令在译码器进行译码\n\nExec：12位立即数（imm12）符号扩展后与寄存器值（ rs1 ）相加，计算主存地址Mem：将寄存器（rs2）读出的数据写到主存\n\n---\n\n#### I-Type\n\n\n\n\n\n---\n\n#### Beq\n\n与其他指令不同的区别是，Beq中间的Exec阶段需要用到ALU和adder，因此必须单独加上一个adder，防止和其他指令冲突\n\n>   每一个功能部件只能在同一阶段使用、每一个周期只能用一次。即上述的adder只能在第三周期使用。\n\n![image-20250516105727514](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250516105727514.png)\n\nIfetch: 取指令并计算PC+4 （写入PC，但后续可能需要修改PC）\n\nReg/Dec:从寄存器（rs1，rs2）取数，同时指令在译码器进行译码\n\nExec:  执行阶段ALU中比较两个寄存器（rs1，rs2）的大小（做减法）Adder中计算转移地址（PC+SEXT（imm12）<<1）\n\nMem: 如果比较相等, 则：转移目标地址写到PC\n\n>   这里转移目标地址的方法可以参考单周期的相关指令，通过控制信号生成下一个PC地址\n\n#### J-Type\n\n![image-20250516110036021](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250516110036021.png)\n\n`Ifetch`: 取指令并计算PC+4 （写入PC ，但后续肯定需要修改PC ）\n\n`Reg/Dec:`从寄存器取数，同时指令在译码器进行译码\n\n`Exec`:  执行阶段ALU中计算PC+4（准备写入rd）Adder中计算转移地址（PC+SEXT（imm20）<<1）\n\n`Mem`:把转移地址写入PC\n\n>   PC可以修改多次，因为更新PC的时候前一个PC已经没有用了，不会出现冲突。\n\n`Wr`: 把ALU运算结果（PC+4）写入rd.\n\n---\n\n### 数据通路设计\n\n![image-20250516111552870](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250516111552870.png)\n\n和单周期的区别在与中间的`流水段寄存器`，用于保存每一个周期的执行结果，属于内部寄存器，可以理解为，每一个寄存器里面存储的都是某一条指令的当前状态（寄存器和它右边的部分属于当前状态）。\n\n>   \"The pipelined datapath consists of combination logic blocks separated by pipeline registers. If you get rid of all these registers (not the PC), this pipelined datapath is reduced to the single-cycle datapath.\"\n\n>   ppt中还提到了其他的一个细节：下一个clock tick来临之后需要一个clock-to-Q才能进行下一阶段（或者说写入下一个阶段）\n\n#### IUnit设计\n\n![image-20250516114408758](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250516114408758.png)\n\n在IF/ID寄存器中存储有PC和指令\n\nIF段的功能PC+4、取指令 \n\n#### Reg/Dec\n\n在ID/EX寄存器中，存储`R[Rs1], R[Rs2], Rd, Imm, PC`\n\n#### Exec Unit的设计\n\n>   详细内容请见ppt，不同的指令需要的信号来自不同的地方\n>\n>   可以留心的是，这里使用了Adder和ALu，进行并行计算，因为前面有一个步骤在这里需要同时进行两个计算（如果都用ALU算的话，显然会冲突）。\n\n![image-20250516115523660](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250516115523660.png)\n\n在EX/M寄存器中存储了，跳转地址、Zero、ALU运算结果、busB、rd\n\n---\n\n#### M段\n\n>   没来得及做笔记，下同\n\n#### WB写回段\n\n\n\n\n\n>   1.   M段有PC写回的操作，出现数据回流，可能出现结构冒险\n>   2.   WB段可能有写入寄存器的操作，也可能会出现结构冒险的问题\n\n---\n\n#### 流水线中的Control Signals\n\n1.   PC不需要写使能\n2.   流水段寄存器不需要写使能信号\n\n在流水线中的控制信号：\n\n![image-20250523104536906](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250523104536906.png)\n\n1.   每一个时钟周期到来，五个流水段寄存器都会进行更新，所有的控制信号在ID阶段**一次性生成**，main control的设计和单周期的控制器设计原理一模一样。\n2.   任何一条指令在执行的过程中，其信号是不变的（在ID阶段一次性生成，之后不需要的信号不再保存）\n\n\n\n#### 流水线举例\n\n最开始的时候，将流水段寄存器都初始化为0，保证了不会出现错误的写入等等。\n\n以下面的这个流水线为例\n\n![image-20250523105300126](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250523105300126.png)\n\n分析指令的运行结果：\n\n1.   第一周期\n2.   第二周期\n3.   第三周期\n4.   第四周期\n5.   第五周期\n6.   第六周期\n7.   第七周期\n\n注意：\n\n1.   只有在B、J型指令在M阶段的时候才会将新的PC更新为Target，此后下一个周期新出现的指令就是target对应的指令。也就是和target指令之间间隔了3个指令。（取错了3个指令，称之为`控制冒险`）\n2.   load指令尽管在第一周期就被取出，但是数据在第五周期才写入，在第六周期才能使用，期间可能会错误访问这个数据得到的不是目的结果，称为`数据冒险`\n\n#### 单周期vs流水线计算机的性能比较\n\n**流水线除了要考虑每一个阶段的最多时间，但是还要考虑流水段寄存器的延迟，具体看是不是**\n\n### 流水线的冒险和处理\n\n>   这里是本书最后一个知识点，最后一个高级CPU不会涉及\n\nhazard：流水线无法正确执行后续指令，或者执行了不该执行的指令。\n\n冒险有：\n\n1.   结构冒险：同一部件在同时被多个指令所使用\n2.   数据冒险：后面的指令使用用到了前面还没有生成的数据\n3.   控制冒险：在跳转或者处理异常的步骤中，后续指令仍然被错误地取出\n\n#### 结构冒险的解决\n\n**确保每一个指令只会在特定的阶段被使用**\n\n#### 数据冒险的解决\n\n给定下面的一串指令序列\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250523113752599.png\" alt=\"image-20250523113752599\" style=\"zoom:25%;\" />\n\n由于add指令需要在第五个周期才能写入新的数据，此时xor指令在IF阶段，到了第六周期的时候，xor指令处于ID阶段，从寄存器堆中取数计算。\n\n---\n\n##### 解决方法一：硬件阻塞stall\n\n硬件上强制要求阻塞，效率低下\n\n![image-20250523114516205](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250523114516205.png)\n\n##### 解决方法二：软件上插入无关指令\n\n在编译器中插入空指令NOP，在会出现数据冲突的时候插入空指令。编译时间增加，速度也不是很快。\n\n##### 解决方案三：同一周期内寄存器先写后读\n\n>   “合理优化寄存器的读写操作”前半周期写、后半周期读，但是不能用解决所有的数据冒险，只能解决需要写入和读取的情况（貌似是，请看ppt进行回顾）。只有上面两个解决方法才能解决全部的数据冒险问题。\n\n方案三需要和1或者2合作，改为阻塞两个周期，因为要求先写后读，这样使得ID段指令读到的值是当前M段指令写入的值。\n\n##### 解决方案四：转发\n\n将ALU的A，B端增加mux，允许从其他的流水段寄存器（第五阶段`WB`在写的时候已经有数据了，可以将这个数据送到前面去）进行读取数据，进行运算。\n\nppt中介绍了三种转发的情况。（这几种情况都是在Exec/M寄存器存储\n\n>   **无法转发的情况（load-use）：**在书上还提到了`load-use`这一个特殊的情况，也就是前一个指令是load、下一个指令需要用到load的数据的话，无法通过转发进行解决： load在`M`段之后才能得到数据，而下一个指令在load执行`M`段的时候正在执行`Exec`，需要用到数据，冲突无法解决。\n>\n>   不过需要注意：使用了寄存器前半后半分开+数据转发可以分别解决load指令之后第三个指令和第二个指令的毛线问题；load-use冲突指的是，load和接下来的紧接着的指令一定会冲突（即使使用了`数据转发`和寄存器前`半后先写`后读优化）\n\n**解决Load use**问题:\n\n1.  检测什么时候需要阻塞\n\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250530103937038.png\" alt=\"image-20250530103937038\" style=\"zoom:33%;\" />\n\n    也就是说：在第三周期执行的过程中，检查是否前一个指令为load，并且load的Rd为下一个指令的Rs1或Rs2\n\n    >   检测是否需要阻塞的原理和检测是否需要转发类似\n\n2.  修改数据通路来实现阻塞\n\n    -   流水段寄存器加上写使能信号，当需要延迟一个周期的时候，控制相关流水段寄存器不变\n\n3.  通过编译优化，避免出现load-use的情况\n\n    参考这里的例题：\n\n    >   <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250530105205351.png\" alt=\"image-20250530105205351\" style=\"zoom:50%;\" />\n    >\n    >   左侧的Slow code的前提是硬件做了专门的修改，实现阻塞才能这样做；否则必须在编译的源程序就要加上NOP指令（替换硬件的阻塞）\n    >\n    >   右侧的指令是进行优化之后的结果。\n\n**总结：**\n\n1.   修改硬件和插入nop指令可以彻底解决问题，但是通常配合其他的方法\n2.   同一周期寄存器先读后写可以使得只需要在两条数据冲突的指令插入两个nop指令\n3.   使用数据转发可以解决除`load-use`之外的数据冲突问题，load-use的冲突解决，可以通过编译器调整指令的顺序、插入nop指令来解决\n\n#### 控制冒险的解决\n\n延迟损失时间片C：发生转移的时候，给流水线带来的损失（CPU错取的指令数）\n\n##### 解决方法一： 硬件阻塞\n\n修改数据通路，强制阻塞三个周期。延迟损失时间片C=3；\n\n##### 解决方法二：NOP指令\n\n由编译器插入三条NOP指令，无需修改数据通路；延迟损失时间片C=3；\n\n##### 解决方法三：分支预测\n\n分支预测成功，那么branch指令只需要一个周期；否则branch指令需要`1+分支延迟槽`个周期；\n\nJump指令不能预测，需要两个周期。**总要等到译码阶段结束才能得到转移地址**\n\n1.   静态检测\n\n     >   总预测条件不满足(not taken)，即：不跳转\n     >   可加启发式规则：\n     >   在特定情况下总是预测满足(taken)，其他情况总是预测不满足\n     >   如：循环顶部（底部）分支总是预测为不满足（满足）。能达65%-85%的预测准确率\n     >   **预测失败时，需把流水线中三条错误预测指令（C=3）丢弃掉** \n     >   将被丢弃指令的控制信号值或指令设置为0\n     >      （注：涉及到当时在IF、ID和EX三个阶段的指令）\n\n2.   动态检测\n\n     原理比较复杂，我不是很理解为什么可以预测？\n\n     一位预测图：\n\n     -   如果是1，那么预测发生（跳转）；否则预测不发生（跳转）\n     -   如果预测正确，那么不变；如果预测错误，那么改变\n     -   其实就是：如果上一次跳转了，那么我这一次也要预测跳转；如果预测错误，那么修改预测图。（也就是说，在一个很长的loop，只有第一次和最后一次跳转回预测错误；到那时如果是双重loop，第一次外循环的时候只有一次预测错误、之后每一次外循环都回产生两次预测错误）\n\n     两位预测图：\n\n     -   用一个状态图来表示：\n     -   <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250530114024656.png\" alt=\"image-20250530114024656\" style=\"zoom:33%;\" />\n\n     \n\n##### 解决方法四：延迟分支\n\n注意：C值是可以改变的：\n\n越早判断是否需要转移，付出的代价越低。将跳转判断的逻辑往前移，就能降低相关的C值\n\n详细见ppt\n\n**填充C**： 将分支指令前面和分支指令无关的指令转移到跳转指令之后的指令执行（如果不够的话，用nop指令填充）\n\n>   前面多次提到了用nop填充，比如处理load-use的数据冒险的时候， 可能会出现\n\n>   Jump和Branch指令不涉及到寄存器堆的操作，因此寄存器先读后写对其没有影响\n\n**至少要学会看是否出现冒险**\n\n比如：在左侧，如果时间片为3的话，lw x3 0(x2)和add x3 x3 x2出现了数据冒险，但是如果时间片为2（比如实现了寄存器的先读后写功能的话） \n\n![image-20250530114645722](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250530114645722.png)\n\n>   注意：这里十分的细节！！在这里beq本来是 跳转4*2=8，也就是2个指令，但是在调度之后，beq后面加上了两个指令，因此需要将原先的4改成8，这样的话，额外增加了4 *2=8位，即2条指令\n\n\n\n##### 异常、中断导致的控制冒险\n\n只需要知道，内部异常和外部中断会引起控制冒险即可\n\n### 比较单周期、多周期、流水线CPU\n\n>   感觉这个题目很重要，一定要学会！！！\n\n采用转发处理数据冒险->需要\n\n跳转需要的\n\n\n\n注意：\n\n流水线的CPU在非理想条件下（数据冒险、控制冒险等）的指令CPI不是都等于1！！！\n\nJUMP不能预测！！！\n\nBranch可以预测！！预测成功则1个时钟，否则2个时钟\n\n\n\n","categories":["NJUCS","数字逻辑与计算机组成"]},{"title":"Chapter7 | 指令系统","url":"/posts/bbb2a202562a/","content":"\n## 概述与指令系统设计\n\n**指令的执行过程**\n\n![image-20250411114304240](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250411114304240.png)\n\n**一条指令必须明显或隐含包含的信息**：\n\n-   操作码：指定操作类型\n    (操作码长度：固定／可变)\n    \n-   源操作数参照：一个或多个源操作数所在的地址\n\n    （源操作数或其地址，由取址方式决定）\n\n    (操作数来源：主(虚)存/寄存器/I/O端口/指令本身）\n\n-   结果值参照：产生的结果存放何处（目的操作数）\n    (结果地址：主(虚)存/寄存器/I/O端口)\n    \n-   下一条指令地址：下条指令存放何处\n    (下条指令地址：主(虚)存)\n    (正常情况**隐含在PC**中，改变顺序时由指令给出）(PC会自动改变)\n\n---\n\nISA的要素：指令集\n\n指令的要素：操作码，地址码\n\nCPU执行指令的步骤：读取指令、译码、取操作数、运算、存数、读取下一条指令。\n\n>   操作码和译码、运算有关\n\n---\n\n指令按照地址码的字段个数可以分为0地址操作码，1地址操作码，等等。RISC-V的风格是三地址指令。`OP A1 A2 A3`.\n\n---\n\n指令设计的要求：\n\n-   一个编码对应唯一的操作码\n-   长度是字节的整数倍\n\n---\n\n### **操作数类型和存储方式**：\n\n1.   操作数类型：\n\n     -   地址\n     -   数值数据\n     -   位串等\n     -   布尔数据\n\n2.   操作数可以存放在：1. 寄存器 2. 内存单元 3. 立即数（和指令放在一起） 中\n\n**寻址方式**\n\n根据地址找到指或操作数的方法。\n\n**地址码编码原则**： 编码地址尽量短（指令短->汇编代码短->机械码短），位置尽量灵活、空间尽量大（利于编译器优化），地址的计算尽量简单（指令执行速度快）。\n\n指令的寻址相对简单：\n\n1.   PC增加\n2.   特殊的跳转：JUMP，call，return等\n\n---\n\n**下面主要讲操作数的寻址方式：**\n\n-   寻址方式确定：\n\n    1.   无单独的寻址方式位，由操作码确定寻址方式\n    2.   由单独的寻址方式\n\n-   有效地址：\n\n    操作数所在存储单元的地址（可能是逻辑地址或物理地址），可通过指令的**寻址方式和地址码计算**得到\n\n基本寻址方式的算法和优缺点：\n\n>   A表示地址段值，R位寄存器编号，EA为有效地址，（X）为X存储的值\n\n![image-20250414104410961](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250414104410961.png)\n\n>   有效地址其实都是操作数在内存里面的位置！\n\n总结：\n\n-   直接寻址和寄存器直接寻址的操作数分别是在指令和寄存器中\n\n    >   直接寻址的操作数在内存里，只需要访问一次内存（存储器），得到的就是数据；间接寻址第一次得到的是有效地址EA\n\n-   间接寻址是先找到存储有效地址EA的地址，然后在从EA地址中取出（EA)\n\n-   寄存机间接寻址，寄存器中存储的是EA。\n\n-   偏移寻址：EA=A+（R)。\n![image-20250414105327810](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250414105327810.png)\n  变址寻址可以实现通过I的改变，寻得不同的数据，而指令可以用同一个指令，可以用于实现类似for循环的功能。 即，相对寻址和基址寻址都是以寄存器中的为基准，偏移A个位置；而变址寻址是以A为基准，偏移（R）个位置。\n\n>   期末复习注：基址寻址和变址寻址都是需要有**基址寄存器**和**变址寄存器**；相对寻址是相对PC进行寻址\n\n---\n\n### **指令格式**\n\n**操作码的编码**:\n\n1.   定长操作码 \n2.   变长操作码 （减少空间消耗，性能开销大）\n\n>   变长操作码一定是和变长指令字相配合；\n\n**定长操作码**\n\n>   作业题里面涉及到如何设计一个定长操作码的指令编码\n\n操作码的位数固定的编码形式：\n\n![image-20250616174119844](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250616174119844.png)\n\n**变长操作码**\n\n![image-20250616174229345](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250616174229345.png)\n\n---\n\n**如何找到下一位指令？**\n\n-   顺序执行：在PC加1后找。加1的含义：按顺序找到下一条指令；如果地址是按照字节编码的，所以要按照指令的长度上字节的长度，即如果指令的为4个字节，那么应该PC*加4* 。\n-   改变顺序时，指令显式地给出下一条地址和条件转移指令。\n\n**条件测试方法**\nppt都写的什么鬼。没有结构。。\n\n---\n\n**指令风格介绍**\n\n从指令风格可以分为： \n\n-   stack型\n-   Accumulator型\n-   通用寄存器型\n-   装入、存储型；load store型，比如RISC-V\n\n指令设计风格：\n\n-   CISC：复杂，用的多；变长操作码、变长指令字\n-   RISC:   精简，效率高：定长指令字\n\n---\n\n**异常和中断**\n\nCPU停止正在执行的程序，转到处理异常情况的程序。\n\n分为：\n\n-   内部异常：\n    -   硬故障中断：\n    -   程序性中断：各种`Exception` 的指令\n-   外部中断：\n    -   在CPU外部发生的特殊事件，通过中断请求的信号，向CPU发送请求处理异常的信号。\n\n异常的处理\n\n![image-20250414115517513](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250414115517513.png)\n\n---\n\n这里还有几页ppt，但是没有讲，自己看。\n\n## 指令系统实例：RISC-V架构\n\nRISC-V 的模块化设计：\n\n-   核心模块：RI32I\n-   拓展模块：RV32M等\n\n几种长度：\n\n>   指令长度，RI32G 和RI64G的指令长度都是16位。\n>\n>   机器的架构长度32/64：机器字长=通用寄存器长度=定点运算器的长度，设计硬件的时候，将大量的GPR的长度设计为32/64位\n>\n>    处理数据的长度\n>\n>   一个字节=8bit （地址可以按字节编码）\n\n以下是32位与64位机器、x86与x64架构的简要对比表格：\n\n| **特性**         | **32位机器（x86）** | **64位机器（x64）**            |\n| ---------------- | ------------------- | ------------------------------ |\n| **数据宽度**     | 一次处理32位数据    | 一次处理64位数据               |\n| **地址空间**     | 32位地址空间        | 64位地址空间                   |\n| **指令集**       | x86指令集           | x64指令集（兼容x86）           |\n\n\n- **32位 vs 64位**：主要是数据处理能力和内存支持的区别。\n- **x86 vs x64**：x86是32位架构，x64是64位扩展架构，且兼容x86。\n\n---\n\n![image-20250418103150918](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250418103150918.png)\n\n在这里，X0代表的是固定的32个0（硬编码为0）。ABI是Aplication  Binnary Interface\n\n---\n\n### 32位的RISC-V 指令风格\n\n**六种格式**：\n\nR-型为寄存器操作数指令，7+5+5+3+5+7；\n\nI-型为短立即数或装入（Load）指令\n\nS-型为存储（Store）指令\n\nB-型为条件跳转指令 【B即branch，条件跳转】\n\nU-型为长立即数操作指令 ：20位立即数\n\nJ-型为无条件跳转指令：Jump\n\n![image-20250418104227961](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250418104227961.png)\n\n![image-20250421101000621](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250421101000621.png)\n\n>   这里的imm的位置如此地混乱是为了提高效率\n\n---\n\n\n\n**几个常见的缩写**：\n\n-   **opcode：最末尾的7位！！**\n-   rd  ： rigister destination目标寄存器 **【需要5位，因为有32个通用寄存器】**\n-   rs1 rs2 ： rigister source源操作数的寄存器地址、【也是5位】\n-   imm： immediate 立即数\n-   funtc3和funct7，表示3为和7位功能码，**和opcode一起定义指令的操作功能。**\n\n\n\n在这里，注意： 通用寄存器的地址都要对齐，比如rs2，rs1，rd都是对齐的5为位；\n\n---\n\n### 16为RISC-V的设计风格\n\n共有8种指令格式。与32位指令相比，16位指令中的一部分寄存器编号还是占5位。指令变短了，但还是32位架构，处理的还是32位数据，还是有32个通用寄存器。\n\n为了缩短指令长度，操作码op、功能码funct、立即数imm和另一部分，寄存器编号的位数都减少了。每条16位指令都有功能完全相同的32位指令，在执行时由硬件先转换为32位指令再执行。**目的是：缩短程序代码量，用少量时间换空间！**\n\n---\n\n只能压缩：op，imm，和寄存器的个数；（寄存器编码的长度如果使用低于5位，肯定有解压缩的过程）\n\n-   16位的exe文件变短了，但是因为16位指令还是要转换成32位，因为最后的执行时间其实比32位更短。\n\n---\n\n### 基础整数指令集 RV32I\n\n**RTL（Rigister Transfer Language）**\n\n-   R[r]：取出寄存器r中的内容。\n-   M[addr]： 取出内存中addr的内容。\n-   PC: PC地址指向的内容。\n-   M[PC]：读取PC所指的地址的内容。\n-   SEXT[imm]：Sign Extension,符号位扩展。\n-   ZEXT[imm]：Zero Extension， 0扩展。\n\n\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250418105716660.png\" alt=\"image-20250418105716660\" style=\"zoom:50%;\" />\n\n---\n\n**一个例子：**\n\n![image-20250418105918091](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250418105918091.png)\n\n在这里的I类指令，移位类指令，前6位用于区分是什么移位(左移，逻辑右移，算数右移)，shamt是5位，因为，每一个寄存器就是32位，\n\n只需要5位shamt就能实现。\n\n---\n\n**几个I型指令**\n\n一个例子： `int a= -8191`\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250418111855476.png\" alt=\"image-20250418111855476\" style=\"zoom:50%;\" />\n\n因为 lui （load upper immediate）指令只有20位的立即数，因而只能将高20位送入（进行**符号扩展SEXT**），一个寄存器，之后再使用addi指令将低12位加入。\n\n>   **在ISA中，imm都是进行符号位扩展！**\n>\n>   ---\n\n**几个I型指令**：\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250418113233467.png\" alt=\"image-20250418113233467\" style=\"zoom: 33%;\" /> \n\n---\n\n**R型指令**\n\n-   操作码opcode都是0110011，功能由funct3决定；\n\n**4条比较指令：带符号小于（slt、slti）、无符号小于（sltu、sltiu）**：\n\n-   sltiu rd, rs1 imm12 按顺序，rs1和imm12比较，如果rs1小于imm12那么，rd中存入1，否则为0； （进行无符号比较）\n-   无论是有符号比较还是无符号比较，都是要将imm12扩展为32位，才能进行比较。\n\n---\n\n对于指令的要求：\n\n-   能够看懂每一个指令的意义，谁和谁做运算，怎么做运算\n-   能看将指令和汇编进行一一对应\n-   区分谁是rd和rs\n\n---\n\n一个例子：\n\n![image-20250421102816908](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250421102816908.png)\n\n为什么是这样的呢？ bne(branch not equal),将立即数40按照要求B类型指令的要求，将其组合上去。\n\n\n\n****\n\n**内存访问指令**\n\nload指令：R[rd]<-M[R[rs1]+SEXT[imm[12]]\n\nstore指令：\n\n**乘法和除法**\n\n 乘法指令: mul，mulh，mulhu，mulhsu\n– mul rd, rs1, rs2：将低32位乘积存入结果寄存器rd\n– mulh、mulhu：将两个乘数同时按带符号整数（mulh）、同时按无符号\n整数（mulhu）相乘，高32位乘积存入rd中\n– mulhsu：将两个乘数分别作为带符号整数和无符号整数相乘后得到的高\n32位乘积存入rd中\n– 得到64位乘积需要两条连续的指令，其中一定有一条是mul指令，实际执\n行时只有一条指令\n– 两种乘法指令都不检测溢出, 而是直接把结果写入结果寄存器。由软件根据\n结果寄存器的值自行判断和处理溢出\n 除法指令: div ，divu，rem，remu\n– div / rem：按带符号整数做除法，得到商 / 余数\n– divu / remu：按无符号整数做除法，得到商 / 余数\nRISC-V指令不检测和发出异常，而是由系统软件自行处理\n\n---\n\n## 写在最后\n\n本章总结：\n\n![image-20250616193300368](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250616193300368.png)\n\n![image-20250616193309795](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250616193309795.png)\n\n![image-20250616193322392](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250616193322392.png)\n","categories":["NJUCS","数字逻辑与计算机组成"]},{"title":"司法案件整理","url":"/posts/64ee6b0ef1a2/","content":"\n\n\n\n\n## 2025-4-17 山西大同\n\n可以和[5·17王忠贵强奸案_百度百科](https://baike.baidu.com/item/5·17王忠贵强奸案/20843110#:~:text=2011年贵州省一起强奸案2011年5月17日，贵州省毕节市阿市乡国土资源管理所所长王忠贵强奸当地中学26岁的初中英语女教师周某。隔日周某向阿市乡派出所报警，警方回应称“戴避孕套不算强奸”。)相比较\n\n<center><strong>订婚本喜事，一夕变强奸。捞女与渣男？网友站两边。</strong></center>\n\n---\n\n评论员 邱延波\n\n　　订婚本喜事，一夕变强奸。捞女与渣男？网友站两边。\n\n　　订婚与强奸，这两个看似毫不相关的词，因一起案件而紧紧联系在一起，甚至产生了一个专有名词：订婚强奸案。\n\n![img](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/007YAdaely1hzu9h5p4r3j30ta0hbjs2.jpg)\n\n　　2023年1月30日，席某某与吴某某经当地某婚介所介绍认识。5月1日双方订立婚约。5月2日中午，女方按照当地习俗宴请席某某。饭后，席某某和吴某某一同前往席某某位于阳高县某小区某楼14层的房内，席某某向吴某某提出发生性关系，遭到拒绝。据报警记录和女方证词，男方强奸了女方。\n\n　　2023年12月25日上午，山西大同“订婚强奸案”一审宣判，以强奸罪判处席某某有期徒刑3年，席某某当庭上诉。2025年3月25日，“订婚强奸案”二审在大同市中级人民法院开庭，案件将择日宣判。这案件因其特殊性，引起广泛关注，网上争论不休。只有厘清其中的三大疑点，才能平息纷争。\n\n![img](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/007YAdaely1hzu9hss9x3j30xi0kvdge.jpg)\n\n　　一、女方是否有性同意？\n\n　　传统观念认为，订婚即是婚约，亲密不算出格。但现代法律只认意愿，不问身份。别说双方只是订婚，就算已经结婚，只要女方不同意，男方就不能用强。一旦男方使用暴力手段，就构成强奸。\n\n　　退一步说，就算女方一开始同意，但在双方发生性关系的过程中，女方反悔了，要求中止，男方就必须中止。如果男方强行继续，仍然构成强奸。\n\n　　一审判决认定，席某某“违背被害人意志”。证据是女方手臂淤青，报警录音，男方电话中一句模糊的“嗯”。但男方坚持认为订婚当晚，两人浓情蜜意，事后因房产证未加名，女方翻脸。电话录音里，席某某被问“你对女方强暴不可否认”时答“嗯”。这声“嗯”，是认罪，还是随口敷衍？\n\n　　性同意，事关案件的性质，必须厘清。男方若真有暴力，就应该依法严惩。但女方若借“不同意”谋利，那就是另外一回事了。 \n\n![img](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/007YAdaely1hzu9i29boqj30zu0ll753.jpg)\n\n　　二、双方是否发生实质性性行为？\n\n　　强奸罪成立，性行为是前提。可这案子，证据链却像断了线的珠子，散落一地。女方坚称被强暴，男方却说“没那回事”。席某某在上诉状中称，他仅是下体有接触，并未进入。大同市公安司法鉴定中心出具的鉴定书显示，送检的女方内裤、下体擦拭物上可疑斑迹中，未检出人精斑及STR分型。这种情况下，很难认定双方有实质性性行为。当然，特殊情况下，也有双方发生性关系而处女膜完整的。但法律讲的是证据，而不是“特殊情况”的推测。\n\n　　双方是否发生实质性性关系，事关事实真相，更关系到法律的判决，不容模糊。\n\n![img](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/007YAdaely1hzu9i7qq8oj30zu0n23zn.jpg)\n\n　　三、彩礼是导火索还是遮羞布？\n\n　　彩礼，这一民间习俗，在此案中扮演着极为重要的角色。\n\n　　男方在订婚时支付了10万元彩礼，并承诺婚后支付另一半及在房本上加名。然而，案发后女方要求提前支付剩余彩礼及加名，双方因此产生争执。这一争执，直接导致了案件爆发。试想，如果男方第一时间满足了女方的要求，这件事可能就无声无息地过去了，真相更可能永远无法浮出水面了。\n\n　　不管如何，婚姻不应该被高额彩礼束缚。即便没有强奸事件，被高额彩礼重压的婚姻，很难说有多幸福。高额彩礼是陈规陋俗，相关部门多次提倡易风移俗。对照这起案件，2025年中央一号文件剑指高额彩礼，其意义不言而喻。\n\n　　在这起案件中，如果女方真的是因为彩礼问题而诬告男方强奸，那么这不仅是对男方权益的严重侵害，也是对司法公正的公然挑战。反之，如果男方确实存在强奸行为，那么彩礼问题也不能成为其逃避法律制裁的借口。\n\n　　法如青天不可欺，人心似水最难测。这起订婚强奸案，撕开了性同意、彩礼文化的裂痕。席某某是否有罪，吴某某是被害还是算计，留待法庭裁决。公众期待的，不只是判决书上的黑字白纸，更是社会观念的觉醒。愿真相早现，愿正义不迟。\n\n责任编辑：崔理斯\n\n\n\n**知乎**：\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250419115524473.png\" alt=\"image-20250419115524473\" style=\"zoom:50%;\" />\n\n---\n\n![image-20250420110721405](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250420110721405.png)\n\n---\n\n## 胖猫重庆长江大桥\n\n岁月史书，不予评价\n\n---\n\n## 丰县生育八孩女子事件\n\n待补充\n\n---\n\n","categories":["一些碎碎念"]},{"title":"物理期中复习纲要","url":"/posts/66252c0b5992/","content":"\n## Before Reading\n\nI shouldn't upload this passage to my blog due to the copyright. But I wanna to help everyone who wants to get well prepared for this course--a course that has little to do with our major.\n\n## The problems that important on PowerPoint Slide\n\n<div style=\"display: flex; flex-wrap: wrap;\">\n  <div style=\"flex: 1 1 50%; padding: 5px;\">\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250407224704196.png\" alt=\"image-20250407224704196\" style=\"max-width: 100%; height: auto;\">\n  </div>\n  <div style=\"flex: 1 1 50%; padding: 5px;\">\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250407224427383.png\" alt=\"image-20250407224427383\" style=\"max-width: 100%; height: auto;\">\n  </div>\n</div>\n\n\n<div style=\"display: flex; flex-wrap: wrap;\">\n  <div style=\"flex: 1 1 50%; padding: 5px;\">\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250407224413314.png\" alt=\"image-20250407224413314\" style=\"max-width: 100%; height: auto;\">\n  </div>\n  <div style=\"flex: 1 1 50%; padding: 5px;\">\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250407224747814.png\" alt=\"image-20250407224747814\" style=\"max-width: 100%; height: auto;\">\n  </div>\n</div>\n\n<div style=\"display: flex; flex-wrap: wrap;\">\n  <div style=\"flex: 1 1 50%; padding: 5px;\">\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250407224904846.png\" alt=\"image-20250407224904846\" style=\"max-width: 100%; height: auto;\">\n  </div>\n  <div style=\"flex: 1 1 50%; padding: 5px;\">\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250407224919967.png\" alt=\"image-20250407224919967\" style=\"max-width: 100%; height: auto;\">\n  </div>\n</div>\n\n<div style=\"display: flex; flex-wrap: wrap;\">\n  <div style=\"flex: 1 1 50%; padding: 5px;\">\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250407224940686.png\" alt=\"image-20250407224940686\" style=\"max-width: 100%; height: auto;\">\n  </div>\n  <div style=\"flex: 1 1 50%; padding: 5px;\">\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250407225009913.png\" alt=\"image-20250407225009913\" style=\"max-width: 100%; height: auto;\">\n  </div>\n</div>\n\n<div style=\"display: flex; flex-wrap: wrap;\">\n  <div style=\"flex: 1 1 50%; padding: 5px;\">\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250407225032842.png\" alt=\"image-20250407225032842\" style=\"max-width: 100%; height: auto;\">\n  </div>\n  <div style=\"flex: 1 1 50%; padding: 5px;\">\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250407171236498.png\" alt=\"image-20250407171236498\" style=\"max-width: 100%; height: auto;\">\n  </div>\n</div>\n\n<div style=\"display: flex; flex-wrap: wrap;\">\n  <div style=\"flex: 1 1 50%; padding: 5px;\">\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250407171822171.png\" alt=\"image-20250407171822171\" style=\"max-width: 100%; height: auto;\">\n  </div>\n  <div style=\"flex: 1 1 50%; padding: 5px;\">\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250407171931234.png\" alt=\"image-20250407171931234\" style=\"max-width: 100%; height: auto;\">\n  </div>\n</div>\n\n<div style=\"display: flex; flex-wrap: wrap;\">\n  <div style=\"flex: 1 1 50%; padding: 5px;\">\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250407171950898.png\" alt=\"image-20250407171950898\" style=\"max-width: 100%; height: auto;\">\n  </div>\n  <div style=\"flex: 1 1 50%; padding: 5px;\">\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250407171019618.png\" alt=\"image-20250407171019618\" style=\"max-width: 100%; height: auto;\">\n  </div>\n</div>\n\n<div style=\"display: flex; flex-wrap: wrap;\">\n  <div style=\"flex: 1 1 50%; padding: 5px;\">\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250407171058150.png\" alt=\"image-20250407171058150\" style=\"max-width: 100%; height: auto;\">\n  </div>\n  <div style=\"flex: 1 1 50%; padding: 5px;\">\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250407172805004.png\" alt=\"image-20250407172805004\" style=\"max-width: 100%; height: auto;\">\n  </div>\n</div>\n\n<div style=\"display: flex; flex-wrap: wrap;\">\n  <div style=\"flex: 1 1 50%; padding: 5px;\">\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250407173546271.png\" alt=\"image-20250407173546271\" style=\"max-width: 100%; height: auto;\">\n  </div>\n  <div style=\"flex: 1 1 50%; padding: 5px;\">\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250407173559129.png\" alt=\"image-20250407173559129\" style=\"max-width: 100%; height: auto;\">\n  </div>\n</div>\n\n<div style=\"display: flex; flex-wrap: wrap;\">\n  <div style=\"flex: 1 1 50%; padding: 5px;\">\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250407173613486.png\" alt=\"image-20250407173613486\" style=\"max-width: 100%; height: auto;\">\n  </div>\n  <div style=\"flex: 1 1 50%; padding: 5px;\">\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250407173935676.png\" alt=\"image-20250407173935676\" style=\"max-width: 100%; height: auto;\">\n  </div>\n</div>\n\n<div style=\"display: flex; flex-wrap: wrap;\">\n  <div style=\"flex: 1 1 50%; padding: 5px;\">\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250407173949476.png\" alt=\"image-20250407173949476\" style=\"max-width: 100%; height: auto;\">\n  </div>\n  <div style=\"flex: 1 1 50%; padding: 5px;\">\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250407174505321.png\" alt=\"image-20250407174505321\" style=\"max-width: 100%; height: auto;\">\n  </div>\n</div>\n\n<div style=\"display: flex; flex-wrap: wrap;\">\n  <div style=\"flex: 1 1 50%; padding: 5px;\">\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250407175129631.png\" alt=\"image-20250407175129631\" style=\"max-width: 100%; height: auto;\">\n  </div>\n  <div style=\"flex: 1 1 50%; padding: 5px;\">\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250407175145165.png\" alt=\"image-20250407175145165\" style=\"max-width: 100%; height: auto;\">\n  </div>\n</div>\n\n\n<div style=\"display: flex; flex-wrap: wrap;\">\n  <div style=\"flex: 1 1 50%; padding: 5px;\">\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250407210523428.png\" alt=\"image-20250407175129631\" style=\"max-width: 100%; height: auto;\">\n  </div>\n  <div style=\"flex: 1 1 50%; padding: 5px;\">\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250408124011043.png\" alt=\"image-20250407175145165\" style=\"max-width: 100%; height: auto;\">\n  </div>\n</div>\n\n<div style=\"display: flex; flex-wrap: wrap;\">\n  <div style=\"flex: 1 1 50%; padding: 5px;\">\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250408124600191.png\" alt=\"image-20250407175129631\" style=\"max-width: 100%; height: auto;\">\n  </div>\n  <div style=\"flex: 1 1 50%; padding: 5px;\">\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/20250408124637.png\" alt=\"image-20250407175145165\" style=\"max-width: 100%; height: auto;\">\n  </div>\n</div>\n\n## The midterm exam of 2025 Spring\n\nApparently , it's far too easy.\n\n![c8fb7e7e0797e5ec80881b154f5fb45](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/c8fb7e7e0797e5ec80881b154f5fb45.jpg)\n\n*2025-06-24*\n\n*<a href=\"https://github.com/yama-lei\">yama</a>*\n","categories":["NJUCS","普通物理学（上）"]},{"title":"知识武装头脑","url":"/posts/e07adf0e1246/","content":"\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/20250403203926.png\" alt=\"s\" style=\"zoom: 25%;\" />\n\n# 名词检索\n\n## 小布尔乔亚\n\n>   作者：知乎用户7bUIIs\n>   链接：https://www.zhihu.com/question/462514575/answer/1985328626\n>   来源：知乎\n>   著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n小资产阶级通病产生于小资产阶级的阶级不稳定性，在资本主义制度下小资产阶级随时可能滑落至无产阶级，但是又好像有那么一点能进入资产阶级行列的机会。\n\n这就使他们内部产生了分化，那些过的好一点的会基本一边倒地支持资本主义制度，因为他们马上就要得到他们梦寐以求的生活了——起码是他们是这么想的。坏一点的又因为自己有那么一点学识，彻底地看清了这个社会，被社会压迫的喘不过来气，但是他们同样也怀念自己目前的这种“小康的生活”，就想要一场立即的、疯狂的、一哄而上的、立即成功的革命。\n\n小资产阶级又因为缺乏组织性与斗争性，经常会因为一些眼前的小利小惠而放弃、甚至背叛革命。因此以小资产阶级为领导的革命通常是松散的、转瞬即逝的（他们管这种松散叫民主、[去中心化](https://zhida.zhihu.com/search?content_id=391050421&content_type=Answer&match_order=1&q=去中心化&zhida_source=entity)，但是这只是小资产阶级的民主、去中心化）。\n\n在今天，我们也可以看见小资产阶级因为在社会中碰的头破血流，而嘲笑或“同情”无产阶级的行为，本质都是因为他们比不过资产阶级，就跟无产阶级比一比，来满足一下自己的虚荣心。\n\n至于所谓“小布尔乔亚行为”，其行为主体不是小资产阶级，而是过的比较富裕的无产阶级，他们幻想自己已经成为了小资产阶级，做了一些他们眼中小资产阶级该做的事。其他没这么做的、比较富裕的无产阶级也以为这些人就是小资产阶级，就盖个小布尔乔亚的名字，但实际上都是无产阶级\n\n**小布尔乔亚的特点**\n\n1.   生活方式与消费观念：小布尔乔亚阶层的生活方式通常带有浓厚的个性化特征。他们注重生活品质，追求精致与品味，往往喜欢通过消费来表达自己的社会地位和文化认同。这个群体偏爱时尚、艺术、旅行等能够提升个人形象和社会地位的消费品。他们的消费观念通常带有强烈的自我表达意图，既希望与众不同，又渴望被社会主流认可。\n\n2.   文化心理与价值观：小布尔乔亚的文化心理表现为一种独特的矛盾性。他们既希望通过努力上升到社会的更高层次，又害怕跌入无产阶级的行列。因此，他们往往表现出一种焦虑和不安感。在价值观方面，小布尔乔亚倾向于中庸和保守，既维护现有的社会秩序，又在一定程度上渴望改革。他们支持个人奋斗和自我提升，但对激进的社会变革持谨慎态度。\n\n3.   社交与身份认同：小布尔乔亚阶层的社交圈往往比较封闭，倾向于与同类人群交往，以保持一定的身份认同和社会地位。他们重视社会形象，注重外部的认可和评价。与资产阶级和无产阶级相比，小布尔乔亚更容易受到社会流行趋势和主流文化的影响，并通过追随这些趋势来确立自己的社会身份。\n\n----\n\n**我的思考**\n\n1. 生活在象牙塔里的大学生不乏小布尔乔亚\n1. 我也是小布尔乔亚，只是当惯了无产。\n\n---\n\n\n## 左？右？\n\nauthor:  [深海](https://www.zhihu.com/people/fanshihuan) \n\n不敢高声语，恐惊天上人。公号《弹幕集》\n\n关注他\n\n4835 人赞同了该文章\n\n我们每天看国际新闻时，在介绍某国领导人和他们的政策时，常常能听到左与右、激进与保守、或自由与保守之类的基本评价。在国际政治舞台上，任何一个政客，基本上都免不了被贴上左或右的标签，为的是给群众形成一个**最基本的**印象，也能对他们日后所要实行的政策做一个简单的预测。\n\n![img](https://pic3.zhimg.com/v2-888aef8648ae6aa6081e2faaa38d9178_1440w.jpg)\n\n\n\n*（首发绿号《弹幕集》）*\n\n但这样笼统的划分，也会在一些时候使人们产生困惑。这主要是由于左派与右派常常与激进与保守相联系，受到字面意义的影响，人们在理解时会有些混乱。\n\n**当然，这个问题很大，也很复杂。甚至有人说，当下的左与右，早就乱套了，无法再以近乎冷战思维那样明确地界定左与右了。**\n\n这话不假，如今的左与右，是要放在具体问题与情境下讨论的，而且，左与右是一个相对概念，它们无法完全脱离对方而存在。人，皆是复杂和矛盾的，但在整体理念上，还可以有较为粗犷的区分。\n\n需要说明的是，在马克思主义学说的观点中，左与右又有更细微的区分。左派与右派自然是对立的，但马克思主义学说又细分了左倾、右倾、左翼、右翼。其中，左倾、右倾都是左派，只是具体理念有一定分歧，但都以社会主义乃至共产主义为方向；而左翼、右翼则都是右派，也只是具体理念有分歧。\n\n所以，在我国的语境下，如果你定为右倾——还有救；如果被定为右派——基本凉凉。参见十年期间。\n\n在另一些定义中，左派、右派是政党之分，左翼、右翼是党内之分。\n\n但这以上区分，实际上都不是最普遍的、最公认的。在世界范围的语境下，左右派与左右翼基本是同义词，在英文中都是（the left/right或者the left/right wing），它们**在非马克思主义学说的基础上**，并无明显不同。所以，本文在此不做具体细分，只做最普遍、最简单、最清晰的方法去区分左与右、激进与保守之分。\n\n### **法国大革命为世界政治提供了左与右的概念**\n\n\n\n中国和法国有些相近的地方，比如，两国都是文化大国，而且在进入现代社会的过程中，社会都发生过激烈动荡，革命战争此起彼伏。都曾在极大的内耗中，折损了大量国力。\n\n![img](https://pic4.zhimg.com/v2-a0d6accbcbf20bcb5642e04d05c04983_1440w.jpg)\n\n**不过，对于革命这件事——法国有点上瘾。**上街游行已经成为法国人民喜闻乐见的户外活动。在国际上，法国也是公认的，有革命传统的国家。这传统，就来自轰轰烈烈的法国大革命。\n\n![img](https://pic3.zhimg.com/v2-948f443ad6ffe0b6f71096d5b48c8762_1440w.jpg)\n\n大革命期间，法国国民议会中，两伙持不同政见的人分别坐在议会的两侧。\n\n**坐在左侧的议员们主张平等、反对君主制、支持共和、反教权、提倡世俗主义。这一伙人，在当时被称为左派。**\n\n**而坐在右侧的议员们则多为保王党、维护天主教会和贵族利益，以及已经晋升为资产阶级者的利益、守护传统价值。这一伙人，在当时被称为右派。**\n\n**当时，两者最大的差别在于，左派想要实行革新（或激进的革命），而右派则想要维持已有的现状，因此，前者被称为激进主义者，而后者被称为保守主义（渐进的改良）者。**\n\n\n\n### **左与右简单定义**\n\n\n\n法国大革命为世界贡献了两个重要的政治词汇——左与右。\n\n由于当时世界上多数独立国家都面临着类似的问题，即新兴的无产阶级崛起，谋求更加平等的利益，与已经初步成型的资产阶级与新贵们的故有利益产生巨大冲突。\n\n因此，左与右，这个原本根基于法国自身情况的“政治俚语”，很快在世界通用起来。\n\n![img](https://pic4.zhimg.com/v2-de6a0c1f85d78c886fd9b2e0fabc5907_1440w.jpg)\n\n久而久之，左与右有了更宽泛的定义：\n\n**左——支持平等原则，限制权贵富裕阶层，倡导社会资源分配平等，社会财富向多数人倾斜，缩减贫富差距，主张政府干预经济，反对资产阶级独大、垄断。**\n\n**右——追求自由主义，最大限度地为个人松绑（也可以说是为权贵松绑，毕竟平民也不涉及什么松不松绑的问题），倡导利己主义，能者多得，反对政府干预经济，维护既得利益者的地位，倡导个人奋斗，拒绝以高福利政策滋养闲人。**\n\n*由于左派多为无产阶级，以工人为主，所以他们的个人力量很弱小，必须将所有无产阶级联合起来，才能形成强大的影响力；而右派多为权贵阶级，他们是社会的少数精英，本身就掌握许多资源与生产资料，*如一些世家财阀甚至可以凭一己之力影响国家。\n\n也因此，左与右又多了一层内涵：\n\n![img](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/v2-c72b82417196e33ca3daa1e12025f139_1440w.jpg)\n\n**左——强调集体主义、甚至国际主义、世界主义（全世界无产者联合起来），主张形成大政府。**\n\n**右——强调个人主义，强调民族与国家利益至上，主张形成小政府。**\n\n（这里我补充两句，大政府、小政府多是作为一种经济观念。我这里说的左与右，都是普遍意义上的。先前有评论说左追求无政府，但无政府主义实际上只是左派的一个分支，被认为是极左，但它并不代表所有的左派都将无政府视为最终目标。事实上，在法国大革命期间，各个派别经常指责对方为无政府主义。当今世界，多数情况下，当我们说左派时，都是认为主张干预经济，即大政府的。另外，还有用共产主义消灭一切国家和阶级来说左派不主张大政府，可要知道，在“各取所需，各尽所能”的理想时代没来之前，如果你不主张大政府干预经济，那最后一定是资本主义复辟，也就无法共产了。所以，这里说的区分，是现行的、普遍的。事实上，无政府主义流派本身就很怪异、矛盾，似乎无论左与右的观点、政策，它都反对，它否认任何国家、法律、政府，可是若没有这些干预手段，社会将自然而然地发展出资本主义，所以才有无政府资本主义一说，除非人性本身产生变化，否则“资本主义高估了道德，共产主义低估了欲望”这句话我认为还是最恰当的。）\n\n这一套左与右的定义，在一段时间内，可以较为准确地区分。\n\n比如，1930年代，美国遭遇大萧条，罗斯福总统施行新政，主张干预经济，他便被认为是左派总统，而他的经济政策，被称为自由派。\n\n又比如，我国在建设探索阶段，曾分别出现了反右扩大与严重的左倾错误WG、公社。\n\n这些当时的历史事件，以这种定义，都可以较为明确地区分。\n\n\n\n### **左与右的定义逐渐模糊**\n\n\n\n到了二十世纪八九十年代，即冷战末期，先前的那种左与右的区分逐渐模糊起来。\n\n![img](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/v2-814092b47bd190b84d01e0dc1fa0315f_1440w.jpg)\n\n**当代许多政治家、思想家认为，左与右的区分，在21世纪的语境下，毫无意义。**因为，当今世界，绝大多数国家的政策制度，虽然在称呼上仍有姓资姓社的区别，但在实际上，两者之间的界限已经非常模糊。\n\n**一方面，老牌资本主义国家渐渐认识到，他们的统治阶层，毕竟是少数权贵、资本家，为了维持社会稳定，也开始引入左派的相关理念，**诸如构建福利社会、缩减贫富差距，主张适当的政府干预等等，其中最典型的便是西欧和北欧诸国。\n\n**另一方面，社会主义国家也渐渐认识到，个人主观能动性与市场经济的益处，不再执着于强调集体利益，也开始逐渐引入右派相关理念，**诸如开放市场经济、国有企业改革、适当放宽经济干预，其中最典型的便是我们中国。\n\n与此同时，一些社会观点也渐渐被两派所共同接受。这时，两者之间的区分就渐渐模糊起来。两者不再执着于姓资姓社的刻板观念，凡能为我所用，促我发展者，便借鉴应用。而这其中做的最好的，莫过于中国和北欧（不是西欧）。\n\n![img](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/v2-adedf72114b00d1a131ea2be9b9b53b9_1440w.jpg)\n\n我国没有过多的思想禁锢，秉持实践是检验真理的唯一标准，不拘泥任何形式，发展是硬道理。\n\n\n\n### **欧美白左的进步意义与极端化过程**\n\n\n\n从早期的法国大革命时期，我们知道，左派强调社会进步，右派则倾向于维持既得利益者的现状。\n\n虽然如今，白左已经成了一个贬义词，饱含乌托邦似的理想主义，在网上甚至可以直接与“圣母”划上等号。**但玩笑归玩笑，以社会进步的角度而言，在未走向极端化前的白左，为世界社会进步作出了不小的贡献。**\n\n![img](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/v2-1f5cb5bb08f19965b1c5ab8d7bb5681c_1440w.jpg)\n\n比如，白左们主张的女权运动、环保主义、福利社会、多元文化、民族交融、世界主义、国际主义、人道主义、维护同性恋权益、提高人权。\n\n这些主张，世界绝大多数国家都不会予以否认，但前提是，这种主张必须结合实际出发，是偏向理性和客观发展规律的。\n\n**但白左们却陷入了激进主义的泥沼，在偏执的极端化过程中，带来了许多问题。**因此，也就不难理解，欧美国家开始陆续反思这种左倾错误。\n\n我们所熟知的[政治正确](https://zhida.zhihu.com/search?content_id=113579895&content_type=Article&match_order=1&q=政治正确&zhida_source=entity)，主要的提出者和维护者，便是左派人士。\n\n\n\n### **具体问题具体分析**\n\n\n\n说到这，看官也许有疑问。既然左代表社会改革进步的激进主义（有时甚至强调革命），而右代表维持已有的制度的保守主义。为何在我国的语境下，它们**似乎**是相反的（其实并没有），左代表保守，而右代表激进呢？\n\n就像我之前说的，造成这种误区的最根本原因在于，人们被保守与激进这两个词的字面意思误导。\n\n事实上，无论左与右，它们在行为上都可以是激进的或保守的，这取决于具体情况，包含历史因素。建议大家在理解的时候，**不要直接把“左”完全与“激进”捆绑在一起**（或罗斯福以后的所谓“自由派”），**也不要直接把“右”完全与“保守”捆绑在一起。**而是要做到具体问题具体分析。\n\n![img](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/v2-2d2f8baf82094f5f0a21635a5af43118_1440w.jpg)\n\n比如，美国共和党一向被认为是右派政党，特朗普也有明显的右派特征，但他的行为本身是激进的，而非保守的（如修墙、贸易战），其原因在于，先前的奥巴马政府是由左派民主党执政，推行的政策（如医保）是左的，所以特朗普必须以激进的方式拨回到右这一边。\n\n**简言之，行为本身的保守与激进（形容措施程度），与政治词汇中的保守与激进（形容理念），是两回事。我们经常容易把「措施的程度」与「措施的理念」混为一谈。**\n\n*欧美等老牌资本主义国家，他们立国的基本，在右，基本制度也在右。所以，奥巴马推行的医保，在共和党看来，是左，改变了原有的制度，因此是激进的**（形容理念而非措施）**。**奥巴马的行为本身并不是激进的，但他的政策理念是激进的。**这是美国的语境。*\n\n*我国是中国特色社会主义国家，我们的立国基本，在左，基本制度也在左。所以，当我们引进市场经济时，是右，改变了原有的制度，因此是激进的**（形容措施而非理念）**。**打破公有制，引进市场经济的行为是激进的，但其政策理念是保守的。**这是我国的语境。*\n\n这些都是政治话语中的激进，而非我们日常生活用语所说的激进。\n\n同时，冷战结束后，世界已不是非黑即白，主义高于一切的时候了。情况也变得更复杂、更实际，因此，才有了所谓“政左经右”、“政右经左”之类的表述。\n\n在这种整体实用主义的情况下，特朗普可谓是异类。多数情况下，特朗普被称为右派（也符合共和党的基本方向），甚至是极右派，因为他有太多明显的右派特质，如：反全球化、反女权、种族主义倾向、减税、减福利、取消全民医保、反文化交融（穆斯林）。\n\n发达国家中，美国的福利政策可以说是较差的，因为他们主张个人奋斗、美国梦，号称“美国不养闲人”。可以说，整个美国在他的带领下，是在向右转。当然，英国也可以算一个例子，但没有当下的美国这么极端。\n\n除这英美以外，多数国家整体还秉持着较为中间的态度，或有左倾，或有右倾（欧洲出现端倪），但还没到极端的程度（以二战希特勒、斯大林，或冷战时相比，确实还不算极端）。\n\n\n\n### **你是哪一派？**\n\n在具体问题具体分析的情况下，有时需要把政治、经济、文化区分来看。这里有一些社会观点，可以帮助看官们简单、粗略地判断自己的立场。\n\n政治上：*你是否支持大政府，是否认同平等原则、集体主义，世界主义，国际主义，社会主义（包括中国特色），提倡世俗主义。*\n\n如果你的回答是赞同，那么，你整体便是左。当然，至于是不是极端，要看你自己的认同程度。\n\n经济上：*你是否认为政府应该干预经济，生产资料应该公有，构建福利社会，主张社会资源分配应该向多数倾斜，主张向富人多征税。*\n\n如果你的回答是赞同，那么，你整体也是左。程度看个人。\n\n文化上：*你是否主张主张社会进步（包括女权、同性、环保、人权等问题），政府与法律应该加强对文化事业的引导。*\n\n如果你的回答是赞同，那么，你整体还是左。程度看个人。\n\n我相信，以实用主义为原则的国人，多数情况下都是中间偏左一边的。就如我之前所说，就算是白左，他们对世界也有积极意义与影响。只不过，虚伪的白左和极端的圣母白左，就只能称之为愚蠢了。\n\n具体问题中，每个人都有差异，需要具体分析。比如，我个人赞同集体主义，但也认同个人主义，因此是个中间派。对于世界主义这个问题而言，我个人又是国家利益至上、民族利益至上的拥护者，所以，在这个问题上，我又是右的。经济问题上，我整体左，但在社会福利上，又反对过高福利滋养闲人，在这方面，又可以说是偏右的。\n\n说这些，是让看官们了解，**这世界上没有人可以被简单地贴上左与右的标签**（即便特朗普也有维护本国工人的一面），左与右的标签曾给我们国人带来过沉重的灾难，希望不要重演。\n\n![img](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/v2-49cb97454ecf57d64ded68f99dd931d6_1440w.jpg)\n\n\n","categories":["一些碎碎念"]},{"title":"例会汇报 | 第四次","url":"/posts/275d177c429b/","content":"\n[toc]\n\n## Pytorch basics\n\n**References:** \n\n-   [Dive-into-DL-PyTorch](https://tangshusen.me/Dive-into-DL-PyTorch/) 动手学习深入学习pytorch版\n-   [Welcome to PyTorch Tutorials — PyTorch Tutorials 2.6.0+cu124 documentation](https://pytorch.org/tutorials/) Pytorch官方教材\n-   [Pytorch学习 | Myblog](https://yama-lei.top/posts/科研启蒙/Pytorch学习.html#tensor张量的创建) 网上的博客\n\n**The process of training a model :**\n\nData-> Model->Criterion and optimizer->Train the model ->save\n\n### DataSet and Dataloader\n\n在pytorch中，提供了`torch.utils.data`模块来处理数据；\n\n在该模块中，提供了`Dataset` 和`Dataloader`两个类：\n\n```py\nform torch.utils.data import Dataloader, Dataset\n```\n\n----\n\n我们需要准备`tranin_data` and `test_data`， 分别用于训练和测试。\n\n用到的数据集可以直接从一些库里import，并下载，比如：\n\n```python\nfrom torchvision import datasets\n# Download training data from open datasets.\ntraining_data = datasets.FashionMNIST(\n    root=\"data\",\n    train=True,\n    download=True,\n    transform=ToTensor(),\n)\n# Download test data from open datasets.\ntest_data = datasets.FashionMNIST(\n    root=\"data\",\n    train=False,\n    download=True,\n    transform=ToTensor(),\n)\n```\n\n从hugging face导入数据集：\n\n```py\nfrom datasets import load_dataset\n\nds = load_dataset(\"refoundd/NailongClassification\")\n```\n\n也可以先下载到本地再导入：\n\n```python\nhf_dataset=load_dataset(\"parquet\",\"path_to_dataset\")\n```\n\n\n\n通常需要自己写数据类，来对下载的数据集进行一些处理：\n\n```py\nclass MyDataset(Dataset):\n    //自定义的dataset类继承自torch里面的`Dataset`\n    def __init__(self,size=1000):\n        self.inputs= # size个数据\n        self.labels= # size个标签\n    def  __len__(self):\n        # return the size of the dataset\n        return \n    def __getitem__(self,idx):\n    \t#return the data and label.\n    \treturn \n    \n```\n\n注意，`__len_`and `__getitem__`需要自己重载，分别返回的是数据集的大小，以及如何根据index得到对应的数据。\n\n\n\n---\n\n在数据处理的时候，`dataset`是一个对象实例，成员变量有inputs(or data)和labels等；\n\n`dataloader`是一个迭代器对象，用于按batch遍历dataset。\n\n```py\ndataloader= Dataloader(dataset,batch_size=32)\n# batch_size的含义是train过程中，每一次送入模型一起训练的数据数量大小\n```\n\n迭代的过程：\n\n```py\nfor batch in dataloader: #每一个batch是(X,y)\n\tinputs,labels=batch  #解包unpacking\n    #这里的inputs和labels的形状是(batch_size, ...)，即第一维是batch_size,代表有inputs/labels这个张量有batch_size个数据。之后的维数代表了每一个数据的特征\n    #例子：形状为（32，10）的labels说明每一个batch是32个数据，每一个数据的形状是（10），即一个特征数为10的一位向量；\n    #例子：形状为（32，3，32，32）的inputs说明了每一个batch是32个数据，每一个数据的形状是（3，32，32）;\n    #例子：形状为 （32，）的labels说明了每一个batch是32个数据，数据是一个标量！\n    # labels和inputs的形状往往不相同。\n```\n\n\n\n### Neural Network\n\n在 PyTorch 中，自定义神经网络的核心是继承 `torch.nn.Module` 类，并实现以下两个方法：\n\n1.  **`__init__` 方法** ：定义神经网络的结构。\n2.  **`forward` 方法** ：定义前向传播的逻辑（即输入如何通过这些层生成输出）。\n\n---\n\n一个例子：\n\n```py\nfrom torch import torch.nn as nn\nclass SimpleNet(nn.Module):\n    def __init__(self):\n        super(SimpleNet, self).__init__()\n        self.fc1 = nn.Linear(10, 50)  # 输入维度 10，隐藏层维度 50\n        self.dropout = nn.Dropout(p=0.5)  # Dropout 层\n        self.fc2 = nn.Linear(50, 1)   # 输出维度 1\n\t\t//定义了结构\t\n    def forward(self, x):\t\n        x = torch.relu(self.fc1(x))   # 第一层 + ReLU 激活\n        x = self.dropout(x)           # Dropout\n        x = torch.sigmoid(self.fc2(x))  # 输出概率值（Sigmoid）\n        return x\n    \t//将输入得到输出\n  model=SimpleNet()\n```\n\n### Train & Test the model\n\n在每一次训练的时候，模型根据输入得到prediction，根据prediction计算loss，再反向传播，更新参数\n\n---\n\n**Pytorch的计算图**\n\n在每一个batch的数据送入后，pytorch会创建一个计算图，记录每一步的运算步骤，中间结果，以及各个参数。\n\nforward: 记录操作，记录中间结果，参数等\n\nbackward：根据记录的内容，计算梯度，以供优化器（optimizer）调整参数，之后计算图会自动被销毁。\n\n---\n\n**Train the model**\n\n我们需要定义一个`criterion` function and `optimizer` function：\n\n````cpp\ncriterion = nn.CrossEntropyLoss()\noptimizer = torch.optim.SGD(model.parameters(), lr=1e-3)\n````\n\n其中optimizer的第一个参数是模型的参数，它可以知道每一个参数对loss的影响（也就是每一个参数的grad属性）从而根据这个来动态地调整每一个参数的大小，来使得loss最小.\n\n---\n\n定义训练：\n\n```python\ndef train(dataloader,model,criterion,optimizer):\n    model.train() # 设置为训练模式\n    for datas,labels in dataloader:\n        pred=model(datas)  #将输入传入模型，会调用它的forward方法\n        loss=criterion(pred,labels) #根据prediction和实际的值label进行基表计算得到loss\n        loss.backward() \t\t#backprapopagate反向传播计算梯度\n        optimizer.step()\t\t#根据每一个参数的grad值来调整参数的大小\n        optimizer.zero_grad() #清空每一个参数的grad值\n```\n\n---\n\n**Test the model**\n\n评估模型的好坏，需要用数据来测试：\n\n```py\ndef test(test_dataloader,model,criterion):\n    model.eval() # 设置为评估模式\n    correct=0\n    total=0\n    test_loss=0.0\n    with torch.no_grad():# 在关闭梯度计算的条件下\n    \tfor datas,labels in test_dataloader:\n        \tpred=model(datas)  #将输入传入模型，会调用它的forward方法\n        \tloss=criterion(pred,labels) #根据prediction和实际的值label进行基表计算得到loss\n            test_loss=loss.item()\n           \ttotal+=labels.size(0) #取出label第0维的size，也就是前面说的batch\n            correct+=(predicted==labels).sum().item()\n            # 这里的==操作符是被pytorch重载过的，得到的是一个布尔张量，一个一维的、特征为batch_size的张量，即这个张量的内容是batch_size个true or false, 分别代表了predicted和labels里面每一个张量是否相等。\n    test_loss/=len(test_dataloader)\n    test_accuracy=correct/total\n    print(......)\n    return test_loss,test_accuracy\n\t\t\t\n```\n\n\n\n### Save & load the model\n\n**保存状态字典**\n\n模型的参数存储在状态字典`state dict`中，模型重要的是参数，因此我们只需要保存模型的参数，并且在使用的时候导入参数即可。\n\n---\n\nSave the `state dict`:\n\n```py\ntorch.save(trained_model.state_dict(),\"path_to_save\")\n```\n\nLoad the model:\n\n```python\nclass MyNet():\n    ...\n    \nmodel= MyNet()\nmodel.load_state_dict(torch.load(\"path\"))\n#需要先定义一个结构相同的模型，然后将参数导入\n```\n\n---\n\n**保存整个模型**\n\n也可以保存整个模型：\n\n```python\ntorch.save(trained_model,\"path_to_save\")\n```\n\n在导入的时候：\n\n```python\nloaded_model = torch.load(\"path\")\n#直接导入整个模型\n```\n\n","categories":["科研启蒙","Reports"]},{"title":"String, buffer and file operation","url":"/posts/409805ea00ab/","content":"\n# I/O Stream\n\nInput/Output (I/O) operations in C++ are managed through a set of libraries that provide abstractions for handling streams of data. These libraries allow you to interact with various sources like the console, files, and strings seamlessly.\n\n## `iostream`\n\nThe `<iostream>` library provides functionality for reading from and writing to the standard input (`std::cin`) and standard output (`std::cout`). It also includes error streams (`std::cerr` and `std::clog`).\n\n### Key Features:\n1. **Standard Input (`std::cin`)**:\n   - Reads input from the console.\n   - Example:\n     ```cpp\n     int number;\n     std::cin >> number; // Reads an integer from the user\n     ```\n\n2. **Standard Output (`std::cout`)**:\n   - Writes output to the console.\n   - Example:\n     ```cpp\n     std::cout << \"Hello, World!\" << std::endl;\n     ```\n\n3. **Error Streams (`std::cerr`, `std::clog`)**:\n   - `std::cerr`: Unbuffered, used for immediate error messages.\n   - `std::clog`: Buffered, used for logging diagnostic information.\n   - Example:\n     ```cpp\n     std::cerr << \"Error: Invalid input!\" << std::endl;\n     ```\n\n## `fstream`\n\nThe `<fstream>` library extends the capabilities of `<iostream>` to handle file-based input and output. It provides classes like `std::ifstream`, `std::ofstream`, and `std::fstream`.\n\n### Key Classes:\n1. **`std::ifstream`**:\n   - Used for reading data from files.\n   - Example:\n     ```cpp\n     std::ifstream inputFile(\"data.txt\");\n     if (!inputFile.is_open()) {\n         std::cerr << \"Failed to open file!\" << std::endl;\n     }\n     ```\n\n2. **`std::ofstream`**:\n   - Used for writing data to files.\n   - Example:\n     ```cpp\n     std::ofstream outputFile(\"output.txt\");\n     outputFile << \"Writing to file.\" << std::endl;\n     ```\n\n3. **`std::fstream`**:\n   - Supports both reading and writing to files.\n   - Example:\n     ```cpp\n     std::fstream file(\"data.txt\", std::ios::in | std::ios::out);\n     ```\n\n## `stringstream`\n\nThe `<sstream>` library allows you to treat strings as streams, enabling formatted input and output operations on strings.\n\n### Key Classes:\n1. **`std::istringstream`**:\n   - Used for reading data from strings.\n   - Example:\n     ```cpp\n     std::string data = \"42 3.14 Hello\";\n     std::istringstream iss(data);\n     int intValue;\n     double doubleValue;\n     std::string stringValue;\n     iss >> intValue >> doubleValue >> stringValue;\n     ```\n\n2. **`std::ostringstream`**:\n   - Used for writing data to strings.\n   - Example:\n     ```cpp\n     std::ostringstream oss;\n     oss << \"Integer: \" << 42 << \", Double: \" << 3.14;\n     std::string result = oss.str();\n     ```\n\n3. **`std::stringstream`**:\n   - Combines the functionality of `std::istringstream` and `std::ostringstream`.\n   - Example:\n     ```cpp\n     std::stringstream ss;\n     ss << \"Hello\" << \" \" << \"World!\";\n     std::string message = ss.str();\n     ```\n\n---\n\n# File Operation\n\nFile operations involve interacting with files on disk or other storage devices. The typical workflow follows the pattern: **Open -> Perform Operations -> Close**.\n\n## Open and Check\n\nBefore performing any file operation, you must ensure the file is successfully opened. This can be done using:\n\n1. **`is_open()`**:\n   - Checks if the file stream is open.\n   - Example:\n     ```cpp\n     std::ifstream file(\"example.txt\");\n     if (!file.is_open()) {\n         std::cerr << \"Failed to open file!\" << std::endl;\n     }\n     ```\n\n2. **`try-catch` Block**:\n   - Handles exceptions during file operations.\n   - Example:\n     ```cpp\n     try {\n         std::ifstream file(\"example.txt\");\n         if (!file) throw std::runtime_error(\"File not found!\");\n     } catch (const std::exception& e) {\n         std::cerr << e.what() << std::endl;\n     }\n     ```\n\n3. **`assert`**:\n   - Ensures the file is open during debugging.\n   - Example:\n     ```cpp\n     std::ifstream file(\"example.txt\");\n     assert(file.is_open());\n     ```\n\n## File Operation\n\nOnce the file is open, you can perform various operations such as reading, writing, appending, and binary file handling.\n\n### Reading from a File\n- Use `>>` for formatted input or `getline()` for line-based input.\n- Example:\n  ```cpp\n  std::ifstream file(\"example.txt\");\n  std::string line;\n  while (std::getline(file, line)) {\n      std::cout << line << std::endl;\n  }\n  ```\n\n### Writing to a File\n- Use `<<` for formatted output.\n- Example:\n  ```cpp\n  std::ofstream file(\"output.txt\");\n  file << \"Writing to file.\" << std::endl;\n  ```\n\n### Appending to a File\n- Open the file in append mode (`std::ios::app`).\n- Example:\n  ```cpp\n  std::ofstream file(\"log.txt\", std::ios::app);\n  file << \"Appending new line.\" << std::endl;\n  ```\n\n### Binary File Handling\n- Open the file in binary mode (`std::ios::binary`).\n- Example:\n  ```cpp\n  std::ofstream file(\"data.bin\", std::ios::binary);\n  int data = 42;\n  file.write(reinterpret_cast<char*>(&data), sizeof(data));\n  ```\n\n### Close the File\nClosing the file ensures all buffered data is flushed and resources are released.\n- Example:\n  ```cpp\n  file.close();\n  ```\n\n---\n\n# Buffer\n\nA buffer is a temporary storage area used to hold data during input/output operations. Buffers improve performance by reducing direct interactions with slow devices like disks.\n\n## What is Buffer?\n\nBuffers act as intermediaries between programs and external devices. They store data temporarily while it's being read from or written to a device.\n\n### Why Use Buffers?\n- Optimize performance by batching I/O operations.\n- Reduce the number of expensive system calls.\n- Handle partial reads/writes gracefully.\n\n## Common API\n\n1. **Accessing Buffers**:\n   \n   - Use `rdbuf()` to access the underlying stream buffer.\n   - Example:\n     ```cpp\n     std::ifstream file(\"example.txt\");\n     std::streambuf* buf = file.rdbuf();\n     ```\n   \n2. **Flushing Buffers**:\n   \n   - Use `flush()` to manually flush the buffer.\n   - Example:\n     ```cpp\n     std::cout << \"Flushing buffer...\" << std::flush;\n     ```\n   \n3. **Customizing Buffers**:\n   \n   - Use `pubsetbuf()` to set a custom buffer.\n   - Example:\n     ```cpp\n     char buffer[1024];\n     std::ofstream file(\"output.txt\");\n     file.rdbuf()->pubsetbuf(buffer, sizeof(buffer));\n     ```\n   \n4. **Disabling Buffering**:\n   \n   - Set the buffer size to 0 to disable buffering.\n   - Example:\n     ```cpp\n     file.rdbuf()->pubsetbuf(nullptr, 0);\n     ```\n\n## Usage in File Operation\n\nBuffers are integral to file operations, especially when dealing with large files or binary data.\n\n### Example: Copying File Content Using Buffers\n```cpp\n#include <iostream>\n#include <fstream>\nint main() {\n    std::ifstream inputFile(\"source.txt\", std::ios::binary);\n    std::ofstream outputFile(\"destination.txt\", std::ios::binary);\n    if (!inputFile.is_open() || !outputFile.is_open()) {\n        std::cerr << \"Failed to open files!\" << std::endl;\n        return 1;\n    }\n    // Use buffers to copy file content\n    outputFile << inputFile.rdbuf();\n    inputFile.close();\n    outputFile.close();\n    return 0;\n}\n```\n\n\n\n\n\n>   The buffer of filestream and stringstream are the same. \n\n","categories":["NJUCS","高级程序设计"]},{"title":"专题：D，T寄存器和D锁存器之间的转换","url":"/posts/cd82ef212fbf/","content":"\n推荐阅读：\n\n[四种触发器的相互转换（卡诺图法与直接法） - asandstar - 博客园](https://www.cnblogs.com/asandstar/p/16949856.html)\n\n<!--more-->\n\n### \n\n","categories":["NJUCS","数字逻辑与计算机组成"]},{"title":"高级程序设计课程笔记","url":"/posts/42accc7a7361/","content":"\n高程的一些课程笔记\n\n课程ppt: [高级程序设计2025春季](https://cslab-cms.nju.edu.cn/classrooms/noivrc5f/attachment)\n\n这里笔记的顺序是按照单元顺序来写的，只有大纲；\n\n标注的**必考**和**200%必考**的更加注意。\n<!--more-->\n\n# 抽象与封装\n\n抽象与封装使得开发者无需关心底层\n\n内部实现不影响外部的使用\n\n例子：用链表封装stack\n\n```c++\n#include <bits/stdc++.h>\nusing namespace std;\ntypedef struct Node\n{\n    int num;\n    Node *prev;\n    Node(int num, Node *prev = nullptr) : num(num), prev(prev) {}\n} node;\nclass Stack\n{\npublic:\n    void push(int num);\n    void pop();\n    int get_size();\n    bool empty();\n    int& top();\n    Stack();\n// 在pubulic 里面定义的是interface\nprivate:\n    node *tail;\n    int size = 0;\n// 数据常常标为private   \n \n};\n\nvoid Stack::push(int num)\n{\n    size += 1;\n    tail = new node(num, tail);\n}\nvoid Stack::pop()\n{\n    if (!empty())\n    {\n        delete tail;\n        tail = tail->prev;\n        size -= 1;\n    }\n}\n\nint Stack::get_size()\n{\n    return size;\n}\n\nbool Stack::empty()\n{\n    return size == 0;\n}\n\nint& Stack::top(){\n    return (tail->num);\n}\n\nStack::Stack():tail(nullptr),size(0){}\nint main()\n{   \n    Stack st;\n    for(int i=0;i<10;i++){\n        st.push(i);\n    }\n    for(int i=0;i<10;i++){\n        cout<<st.top()<<\" \";\n        st.pop();\n    }\n    cout<<\"\\n\";\n    for(int i=0;i<10;i++){\n        st.push(i);\n    }\n    for(int i=0;i<10;i++){\n        st.top()+=1;\n        cout<<st.top()<<\" \";\n        st.pop();\n    }\n    cout<<\"\\n-------------------\\n\";\n    cout<<\"size: \"<<st.get_size()<<\" isEmpty? \"<<st.empty();\n    return 0;\n}\n```\n\n# 面向对象\n\n<a href=\"./class\">另外一篇与class有关的文章</a>\n\n细节：**class在定义完成之前是不能创建实例的**；但是可以创建这个类型的pointer和reference\n\n```cpp\nclass A{\n    public:\n    A a;//Error! Compiler don't konw how much memory to allocate\n    A* p;//OK\n    A& r;//OK\n}\n```\n\n**下面内容必考，前面不是重点**\n\n## 对象的创建方式（**注意不同创建的方式，高频考点**）\n\n-   直接创建 : A a; 内存在stack区，作用域结束后内存自动释放\n\n-   间接方式创建动态变量:A* p=new A;\n\n    ```cpp\n    //在最后记得要delete p！！delete对应的是p所指的heap上面的空间\n    //p是栈上的变量，但是p所指的是heap上的一段空间\n    delete p;\n    ```\n\n### public, private,protected:\n\n-   public:   可以在class之外被访问\n-   private: 在class之外不能访问，不能被derived class继承\n-   protected：在class之外不能别访问，可以被derived class继承\n\n>    友元函数可以访问public和protected\n\n### 对象作为函数参数进行传递,作为函数返回值（**必考点**，区分下面的区别）！！！**必考**\n\n```cpp\nvoid fun(A a){\n    //...\n}\n//传入对象，并创建一个临时的A对象\nvoid g(A& a){\n    //....\n}\n//传入的是原先对象的引用\nDate f1(A& a){\n    return a;\n}\n//会创建一个临时变量并返回\nDate& f1(A& a){\n    return a;\n}\n//只会return 临时的变量！\n\n```\n\n注意`f1`return了原来的对象！！\n\n## 构造函数和析构函数\n\n-   构造函数可以有多个，可以重载：\n\n    ```cpp\n    class A{\n        public:\n        A();\n        A(int a);\n        A(A& a);\n    }\n    A::A(){\n        cout<<\"Default class constructor\\n\";\n    }\n    A::A(int a){\n        cout<<\"This is \"\n    }\n    ```\n\n    此外，还可以本地初始化，在类创建的时候，还可以\n\n-   如果在instance中申请了额外的内存空间，那么**必须**自定义一个析构函数来销毁这个类的instance\n\n什么时候必须要析构函数**下面这个200%必考！！！！！！！！！！！**\n\n![image-20250226105914264](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250226105914264.png)\n\n>   图中讲str赋值为nullptr是为了更加地安全。也可以没有；\n>\n>   NOTE：析构函数注意要判断nullptr！！！delete之后一定要将指针赋值为nullptr，防止有手动析构的样例！！！\n\n**内存是怎么分配的？**\n\n-   stack里面有一个String instance: int 4bytes, char* 4bytes; 8bytes in total;\n-   在调用构造函数的时候，在heap上要了5个char位置，存放'a','b','c','d','\\n'.\n\n当这个类的instance的作用域消失以后，编译器会自动调用这个类的析构函数；如果没有的话，就会自动创造一个析构函数，但是这个默认的够细函数是不会自己去销毁heap上的内存，需要手动销毁，防止内存泄露！\n\n### this指针\n\n每一个类的成员函数其实都会隐藏一个默认的`this`指针。面向对象其实是一种思想。\n\n不重要，不是考点。\n\n### 拷贝构造函数（考点之一）\n\n你必须care拷贝构造函数。\n\n相当于是构造函数一种特殊的重载。\n\n```cpp\nclass A{\n    public:\n    int data;\n    A(int data):data(data)\n    A(A& a):data(a.data)//拷贝构造函数\n}\n```\n\n三种情况下会调用这个拷贝构造函数：\n\n1.   利用一个instance 创造另一个instance\n2.   当一个instance作为参数传递给一个函数时（pass by value,会在函数内部调用拷贝构造函数创建一个新的临时对象）\n3.   当一个instance作为函数返回值时 （注意，和上面一样，不是referece，而是pass by value）\n\n如果没有构造函数，就会生成一段简单的拷贝构造函数。\n\n-    直接将成员里面的变量赋值给被拷贝的对象，是`shallow copy`！\n\n比如，以下面这个200%会考的内容为例：\n\n```cpp\n//例如，在下面的类中没有自定义拷贝构造函数：\nclass String\n{    int len;\n    char *str;\n public:\n  String(char *s) \n  { len = strlen(s); \n     str = new char[len+1]; \n     strcpy(str,s); \n  }\n  ~String() { delete []str; len=0; str=NULL; }\n};\n......\nString s1(\"abcd\");\nString s2(s1);\n```\n\n>   -   系统提供的隐式拷贝构造函数将会使得s1和s2的成员指针str指向同一块内存区域！\n\n会带来一系列的内存安全问题\n\n-   如果对一个对象（s1或s2）操作之后修改了这块空间的内容，则另一个对象将会受到影响。如果不是设计者特意所为，这将是一个隐藏的错误。\n-   当对象s1和s2消亡时，将会分别去调用它们的析构函数，这会使得同一块内存区域将被归还两次，从而导致程序运行错误。\n-   当对象s1和s2中有一个消亡，另一个还没消亡时，则会出现使用已被归还的空间问题！\n\n我们需要自定义拷贝构造函数，进行`deep copy`\n\n```cpp\nString(String& s){\n    len=s.len;\n    str=new char[len+1];\n    strcpy(str,s.str);//将s.str的内容复制到str中\n}\n```\n\n---\n\n## 3.2常成员函数\n\n#### 常成员函数\n\n1.   可以用const约束函数，使得这个函数不能修改类成员的值：\n\n```cpp\nclass A{\n    int a;\n    int* b;\n    public:\n    void func() const{\n        a=1;//Error, 不能改；\n       \tb=new int(1);//Error不能修改b的值\n        *b=1;//正确，因为b的值没有改变，只是改变了b所指的地址的值。\n    }\n}\n//But you can modify static member fo the class!\n```\n\n2.   常成员只能调用常成员函数 \n\n![image-20250305102533844](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250305102533844.png)\n\n#### **静态数据成员**\n\n1.   存储在**静态存储区**，内存为所有类的实例共享。\n2.   必须在类的内部声明，并且在类的外部初始化：\n\n```cpp\nclass A{\npublic:\nstatic int a;//不能在类的内部赋值\n}\n\\\\.....\nint A::a=10;//在类的外面赋值    \n```\n\n#### 静态成员函数\n\n只能访问到静态成员对象\n\n### 3.3友元\n\n友元不是类的成员，但是可以访问类的所有成员，包括private和protected。\n\n如:\n\n**熟悉下面这个即可**\n\n```cpp\nclass A{\n    int a;\n    public:\n    friend ostream& operator<<(ostream& os, A& a){\n        os<<\"A(\"<<a<<\")\";\n        return os;\n    }\n \tfriend istream& operator>>(istream& os,A& a){\n        os>>a.a;\n        return os;\n    }   \n};\n```\n\n### 3.4类的模块化设计\n\n\n\n>    **cpp里面的模块化设计**\n>\n>   -   接口：包含被外界使用的类型定义、常量定义以及全局变量和函数的声明。（.h文件）\n>   -   实现：包含本模块中所有的类型、常量、全局变量和函数的定义。（.cpp文件）\n\n## 4.1Inheritance继承\n\n派生类(derived class)，即子类。\n\n基类(base class)，即父类。\n\n继承从基类的数量，分为`多继承（很少考）`和`单继承`\n\n继承按照继承的方式可以分为` public继承`  `private继承(by default)` ` protected继承 `\n\n---\n\n**派生类：**\n\n-   有子类的所有成员和函数，但是不能访问`private`成员;有，但是不能访问！\n-   可以override base class的成员\n\n```cpp\n#include<iostream>\nusing namespace std;\n\nclass A{\n    int a;\n    public:\n    int fun(){\n        cout<<\"驿站寄旧衣，七毛一公斤\"<<endl;\n    }\n};\n\nclass B:public A{\n    void fun(){\n        cout<<a;//Error\n    }\n};\n\nclass C: public A{\n    int a;//override\n    void fun(){\n        cout<<a;//It's ok!\n    }\n};\n```\n\n-   注意，如果要覆盖的话，就需要用作用域修饰符：\n\n```cpp\n#include<iostream>\nusing namespace std;\n\nclass A{\n    int a;\n    public:\n    void fun(){\n        cout<<\"sdddsds\";\n    }\n};\nclass B:public A{\n    public:\n    void fun(){\n        cout<<\"I am a member function of B\"<<endl;\n    }\n    void f(){\n        fun();\n        A::fun();\n        //output:  I am a member function of B\n        //         sdddsds\n    }\n};\n```\n\n**派生类的成员对外访问情况** | **百分之一百的考点！！！**\n\n>   考法为程序分析题，给一段代码，找出错误。\n\n从base class继承而来的成员的访问限定情况，和继承的方式有关：\n\n![image-20250305114142277](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250305114142277.png)\n\n关注ppt上的那个例题。\n\n**子类型**\n\n派生类就是基类的一个子类型；\n\n-   派生类对象可以直接赋值给基类，其中不属于基类的成员将被忽略。\n-   基类的指针可以指向派生类。\n\n**drived class对象的创建和消亡**\n\n从基类集成的数据由基类的构造函数初始化，派生类的数据类型由派生类的构造函数初始化；\n\n-   先执行基类的构造函数，再执行派生类的构造函数\n-   默认是执行基类的默认构造函数，除非在派生类的构造函数的成员初始化列表中给出\n\n```cpp\nclass B: public A{\n    public:\n    B(): A(int a){\n        //初始化列表里面调用A的构造函数\n    }\n}\n//这样的话，B的默认构造函数会调用A的一个构造函数（ A(int i){};）\n```\n\n>   如果派生类里面没有提供构造函数，则会生成一个derived class的默认构造函数，这个函数会自动调用基类的默认构造函数；\n\n**继承构造函数**：允许派生类通过简单的声明来继承基类的构造函数\n\n```cpp\nclass B: public A{\n  using A::A;//继承了A的所有构造函数\n  //如果想要给派生类的成员赋值，那就需要自己写\n  B(int a,int b): A(a){\n      //在成员的初始化列表里面初始化A\n      //....这里可以给B的成员赋值\n  }\n}\n```\n\n\n\n**拷贝构造函数**：如果不写，就会自动调用基类的拷贝构造函数；但是如果在子类的拷贝构造函数中需要调用base的拷贝构造函数，那么应该显式地在成员初始化列表中调用，**否则调用的是base的默认构造函数**\n\n```cpp\n...\nB(const B& b): A(b){}    \n...\n```\n\n**赋值的操作符重载**：需要显式地调用base的赋值拷贝构造函数\n\n```cpp\nclass A { ...... };\nclass B: public A\n{\t\t......\n\tpublic:\n\t\tB& operator =(const B& b)\n\t\t{\tif (&b == this) return *this;  //防止自身赋值。\n\t\t\t *(A*)this = b; //调用基类的赋值操作符对基类成员\n\t\t\t\t\t\t          //进行赋值。也可写成： \n\t\t\t\t\t\t          //this->A::operator =(b); \n\t\t\t...... //对派生类的成员赋值\n\t\t\treturn *this;\n\t\t}\n};\n```\n\n\n\n**派生类的构析函数**\n\n<center>上面的笔记不够完整，请去看4-1ppt</center>\n\n---\n\n\n\n>   老师说：期末会参考这个例子：“继承的实例：一个公司中的职员类和部门经理类的设计。”（PPT 42）\n>\n>   可能考点：为什么要用 指针数组；\n>\n>   1.   修改了这个对象之后其他的拷贝不会修改，但是用指针的话都是访问同一个对象\n>   2.   减少内存的开销，提升性能\n>   3.   是聚合的关系而非组合composition（或者拥有）\n\n**一个例子**\n\n```cpp\nclass Employee //普通职员类\n{\t\tString name; //String为字符串类。\n\t\tint salary;\n\tpublic:\n\t\tEmployee(const char *s, int n=0):name(s) \n\t\t{\tsalary = n; \n\t\t}\n\t\tvoid set_salary(int n) { salary = n; }\n\t\tint get_salary() const { return salary; }\n\t......\n};\n```\n\n```cpp\nconst int MAX_NUM_OF_EMPS=20;\nclass Manager: public Employee //部门经理类\n{\t\tEmployee *group[MAX_NUM_OF_EMPS];\n\t\tint num_of_emps;\n\tpublic:\n\t\tManager(const char *s, int n=0): Employee(s,n) \n\t\t{ num_of_emps = 0; \n\t\t}\n\t\tbool add_employee(Employee *e);\n\t\tbool remove_employee(Employee *e); \n\t\tint get_num_of_emps() { return num_of_emps; }\n\t......\n};\n```\n\n```cpp\n//创建职员对象Jack和Jane\nEmployee e1(\"Jack\",1000),e2(\"Jane\",2000); \n//创建经理对象Mark\nManager m(\"Mark\",4000); \n//把职员Jack和Jane纳入经理Mark的管理m.add_employee(&e1);\nm.add_employee(&e2);\n//老师上课说： 这里不一定是要用new在堆上来创建一个带地址的对象，在stack上创建之后完全可以将栈上的地址作为指针传入；\n//显示经理Mark的工资\ncout << \"Mark's salary is \" << m.get_salary() << '.' \n\t<< endl; \n//显示经理Mark的管理人数\ncout<< \"Number of employees managed by Mark is \" \n\t<< m.get_num_of_emps() << '.' << endl; \n//职员Jack脱离经理Mark的管理\nm.remove_employee(&e1); \n......\n```\n\n>   老师上课说：可能出一个没有错误的纠错题，找出错误之后扣分。                 --  2025.3.12 10.45\n\n### 4.2 多继承\n\n多继承：同时继承多个成员\n\n>   老师：**考试不考，平时也不建议你用**\n\n### 4.3 聚合、组合\n\n>   会有一到两个程序分析题考这个，主要要区分哪个是组合哪个是聚合\n\n继承不是唯一代码复用的方式；继承体现的是：\"is a type of\",但是还有一种“a part of\"的关系；\n\n**聚合**:在聚合关系中，被包含的对象与包含它的对象**独立创建**和消亡，被包含的对象**可以脱离**包含它的对象独立存在。`聚是一团火，散是满天星`\n\n```cpp\nclass A { ...... };\nclass B //B与A是聚合关系\n{ A *pm; //指向成员对象\npublic:\n   B(A *p) { pm = p; } //成员对象在聚合类对象外部创建，然后传入\n   ~B() { pm = NULL; } //传进来的成员对象不再是聚合类对象的成员\n   ......\n};\n......\nA *pa=new A; //创建一个A类对象\nB *pb=new B(pa); //创建一个聚合类对象，其成员对象是pa指向的对象\n......\ndelete pb; //聚合类对象消亡了，其成员对象并没有消亡\n...... // pa指向的对象还可以用在其它地方\ndelete pa; //聚合类对象原来的成员对象消亡\n```\n\n在这里A和B就是聚合关系，B的对象消亡的时候并不会导致B对象里面的A对象消亡，因为在B的析构函数里面，只是将对象A的指针赋值为`NULL`，但是并没有delete对象A；\n\n**组合 | Composition**：在组合关系中，被包含的对象随包含它的对象创建和消亡，被包含的对象不能脱离包含它的对象独立存在。\n\n实现组合的方法：\n\n1.   直接在内部创建成员对象；\n2.   如果用指针的话：记得在组合类的构析函数中delete成员对象；\n\n**继承更容易实现子类型、多态，组合和聚合是无法实现的**\n\n\n\n\n\n## 5.1 虚函数和消息的动态绑定\n\n[C++中的静态绑定与动态绑定：深入解析与比较 - 知乎](https://zhuanlan.zhihu.com/p/661551054)\n\n**静态绑定**\n\n如果一个对象有两个同名的函数（一个是从base class继承而来），一般情况下，会在编译时刻根据对象的类型来决定采用那个消息处理函数`（静态绑定）`\n\n>   静态绑定调用哪个函数 要看调用点的这个形参的类型！\n\n在编译的时候就已经确定了，调用那个函数由形参决定：\n\n**这个代码是必考的内容！！！！** \n\n```cpp\nclass A\n{\tpublic:\n      void f();\n };\nclass B: public A\n{\tpublic:\n\t  void f();\n\t  void g(); \n};\n......\nA a;\nB b;\na.f(); //A的f\nb.f(); //B的f\nb.A::f(); //A的f\n```\n\n```cpp\nvoid main(){\n\tA a;\n\tfunc1(a);\n\tfunc2(&a);\n\tB b;\n\tfunc1(b);\n\tfunc2(&b);\n}\n//无论传入的是A还是B，都是调用A的f，因为这里的形参已经确定\nvoid func1(A& x)\n{\t......\n\tx.f(); //调用A::f还是B::f ？\n\t......\n}\nvoid func2(A *p)\n{\t......\n\tp->f(); //调用A::f还是B::f ？\n\t......\n}\n```\n\n>   答案均为a.f()\n\n**消息的动态绑定 | Dynamic Dispatch**\n\n我们通常希望，在代码中能够根据对象的类型来执行对应的函数。\n\n这个时候我们需要引入`virtual function`\n\n在base class中，将某个函数声明为虚函数,则在调用这个函数的时候，就能根据对应的对象来调用对应的函数\n\n<center><em>200%必考的内容</em></center>\n\n```cpp\nclass A\n{\t int x,y;\n  public:\n\t virtual void f();\n};\nclass B: public A\n{\t int z;\n  public:\n   \tvoid f(); \n   \tvoid g();\n};\nvoid func1(A& x)\n{\t......\n\tx.f(); //调用A::f或B::f\n\t......\n}\nvoid func2(A *p)\n{\t......\n\tp->f(); //调用A::f或B::f\n\t......\n}\n......\nA a;\nfunc1(a); //在func1中调用A::f\nfunc2(&a); //在func2中调用A::f\nB b;\nfunc1(b); //在func1中调用B::f\nfunc2(&b); //在func2中调用B::f\n\n```\n\n>   Warning: \n>\n>   -   静态成员函数不能是虚函数\n>\n>   -   派生类不要写`virtual` 派生类要写`override`\n>\n>   -   **只有通过指针或者引用来调用函数，才能`dynamic bonding`!!!!!**必考内容！\n>\n>   -   构造函数不能是虚函数，析构函数往往是虚函数\n>\n>       -   如果构造函数也动态绑定，老师说，会导致baseclass的成员初始化不完全 -- 存疑 （6月11日补充：结合前面继承中的初始化相关知识，应该指的是如果只调用派生类的构造函数而不调用基类的构造函数，会导致出现基类的成员没有被初始化）\n>       -   析构函数如果不用虚函数的话，当删除基类指针的时候，就只会进行静态绑定，调用基类的析构函数\n>\n>       >   **如果基类的析构函数不是虚函数，那么在删除基类指针时，只会调用基类的析构函数，而不会调用派生类的析构函数。**\n>\n>   -   在构造函数和析构函数里面如果调用了虚函数，不进行动态绑定 \n>\n>       reason:\n>\n>       -   因为先调用的是基类构造函数，这个时候derived class的成员还没初始化，如果就调用derived class的函数会出错\n>       -   因为先调用的是derived class的析构函数，已经删除了派生类的成员对象，会出错。\n>\n>       ```cpp\n>       class A\n>       {  ......\n>         public:\n>       \tA() { f(); }\n>       \t~A() { f(); }\n>       \tvirtual void f();\n>       \tvoid g();\n>       \tvoid h() { f(); g(); }\n>       };\n>       class B: public A\n>       {  .......\n>        public:\n>          B() { ...... }\n>       \t~B();\n>       \tvoid f(); \n>       \tvoid g(); \n>       };\n>       ......\n>       A a;  //调用A::A()和A::f\n>       a.f();  //调用A::f,f是虚函数，但是因为没有通过指针或引用调用，是静态绑定\n>       a.g();  //调用A::g，静态绑定\n>       a.h();  //调用A::h、A::f和A::g，这里调用A::f是动态绑定，因为是隐式地用this指针调用，f也是虚函数；\n>       //a消亡时会调用A::~A()和A::f\n>           \n>       B b;  //调用B::B()、A::A()和A::f\n>       b.f();  //调用B::f\n>       b.g();  //调用B::g\n>       b.h();  //调用A::h、B::f和A::g 在这里调用f函数的时候是`dynamic bonding`;但是调用g的时候，因为这不是一个虚函数，所以只能是静态绑定\n>       //b消亡时会调用B::~B()、A::~A()和A::f\n>       A *p;   //p是A类（基类）指针\n>       p = &a; //p指向A类对象\n>       p->f();  //调用A::f\n>       p->g();  //调用A::g\n>       p->h();  //调用A::h, A::f和A::g\n>       p = &b;  //p指向B类对象\n>       p->f();  //调用B::f\n>       p->g();  //调用A::g，非虚函数采用静态绑定\n>       p->h();  //调用A::h, B::f和A::g\n>       p = new B;  //调用B::B(), A::A()和A::f\n>       .......\n>       delete p;  //只调用A::~A()和A::f ，\n>                      //没调用B:~B()，为什么？\n>                        //没有把A的析构函数定义为虚函数！\n>       ```\n>       \n>       check the type of bonding in each case above ! ! ! ! ! ! ! ! ! !\n\n**虚函数动态绑定的实现**: 背后维护了一个`vtable`;\n\n### 纯虚函数和抽象类\n\n将虚函数声明为纯虚函数，此时这个类变成了一个抽象类，不能创建对象，仅做为接口；\n\n纯虚函数必须在derived class里面重写；\n\n抽象类可以真正地实现继承和封装.\n\n**可能考** ：\n\n```cpp\n例如： \n//A.h （类A的对外接口）\nclass A\n{\tint i,j;\n  public:\n\tA();\n\tA(int x,int y);\n\tvoid f(int x);\n};\n//A.cpp （类A的实现，不公开）\n#include \"A.h\"\nvoid A::A() { ...... }\nvoid A::A(int x,int y) { ...... }\nvoid A::f(int x) { ...... }\n......\n\n//B.cpp （A类对象的某个使用者）\n#include \"A.h\"\nvoid func(A *p)  //绕过对象类的访问控制！\n{\tp->f(2); //Ok\n\tp->i = 1; //Error\n\tp->j = 2; //Error\n\t*((int *)p) = 1; //Ok，访问p所指向的对象的成员i\n\t*((int *)p+1) = 2; //Ok，访问p所指向的对象的成员j\n}\n```\n\n这样子打破了封装的效果！！！！\n\n如何防止上面的情况？\n\n只给一个抽象接口，让使用者只能看到抽象的接口，而看不到别的数据；\n\n```cpp\n\n\n用抽象类I_A给类A提供一个抽象接口\n\n    //A.cpp （类A的实现，不公开）\n#include \"I_A.h\"\nclass A: public I_A\n{\tint i,j;\n   public:\n\tA();\n\tA(int x,int y);\n\tvoid f(int x);\n};\nvoid A::A() { ...... }\nvoid A::A(int x,int y) { ...... }\nvoid A::f(int x) { ...... }\n......\n\n//I_A.h （类A的对外接口）\nclass I_A\n{ public:\n   \t  virtual void f(int)=0;\n};\n\n//B.cpp （A类对象的某个使用者）\n#include \"I_A.h\"\nvoid func(I_A *p)\n{\tp->f(2);  //Ok\n\n\t *((int *)p) = 1; //这里不知道p所指向的对象有哪些数据成员，\n      //用户不知道数据定义情况，并不知道这样访问的是哪个数据成员\n}\n```\n\n## 6 操作符重载\n\n操作符重载可通过下面两个途径来实现：\n\n​\t•作为一个类的非静态的成员函数（操作符new和delete除外）。\n\n​\t•作为一个全局（友元）函数。\n\n至少应该有一个参数是类、结构、枚举或它们的引用类型。\n\n不管是采用成员函数还是全局函数，重载的函数名字都为：\n\n`\toperator #`  “#”代表任意可重载的操作符。\n\n---\n\n#### **操作符重载的原则**：\n\n只能重载C++语言中已有的操作符，不可臆造新的操作符。\n\n可以重载C++中除下列操作符外的所有操作符：\n\n“. ”， “.* ”，“?: ”，“:: ”，“sizeof ”\n\n遵循已有操作符的语法:\n\n​\t•不能改变操作数个数。\n\n​\t•不改变原操作符的优先级和结合性。\n\n尽量遵循已有操作符原来的语义：\n\n​\t•语言本身没有对此做任何规定，使用者自己把握 ！\n\n#### **单元操作符**\n\n-   自增自减操作符\n\n>   **注意自增自减操作符有 前和后的区别**\n>\n>   x++的值是x，++x的值是x+1; 且，x++得到的是一个right-value expression,但是++x是left-value expression\n>\n>   也就是说： ++(x++)或者 (x++)++都会报错，因为x++得到的是左值表达式\n\n```cpp\nclass Complex{\n    //...\n    Complex& operator++(){\n        //定义前增操作符\n        real++;\n        imag++;\n        return *this;\n    }\n    Complex operator++(int){\n        //定义后增操作符\n        Complex p=*this; //记得 1 。\n        real++;\n        imag++;\n        return p;\n    }\n}\n```\n\n下面这个例子很重要，曾经考过：**这个是必考内容！！！！！！！！**（前++和后++的操作符重载！）\n\n```cpp\nclass Counter\n{\t\tint value;\n\tpublic:\n\t\tCounter() { value = 0; }\n\t\tCounter& operator ++()  //前置的++重载函数\n\t\t{\tvalue++;\n\t\t\treturn *this;\n\t\t}\n\t\tconst Counter operator ++(int)  //后置的++重载函数\n\t\t{\tCounter temp=*this; //保存原来的对象\n\t\t\tvalue++; //写成：++(*this);更好！调用前置的++重载函数\n\t\t\treturn temp; //返回原来的对象\n         //temp的生存期仅在这个函数内，而会赋值temp给一个临时的对象。\n\t\t}\n};\n```\n\nCheck your understanding:\n\n```cpp\nCounter a,b,c;\n++a;  //使用的是不带参数的操作符++重载函数\na++;  //使用的是带int型参数的操作符++重载函数\nb = ++a;  //加一之后的a赋值给b\nc = a++;  //加一之前的a赋值给c\n++(++a);或 (++a)++; //OK，a加2\n++(a++);或 (a++)++; //Error，编译不通过\n```\n\n>   请问c的类型是const吗？不是，仍为普通的，是否为const是由创建时声明决定的！(注：const的对象实例只能调用声明为const的成员函数，成员不能被改变)\n>\n>   请问可以写成Complex operator++()吗？会有什么影响？\n>\n>   ans: 只会影响到类似`(++a)++`的句子，因为这个只会加一次，后面的后置++其实是对一个临时对象的++；\n>\n>   请问后置++那个改成const Counter& operator++(int) 可以吗？\n>\n>   不可以！因为temp是临时的对象，不能return它的&，会出现`悬浮指针`问题，*实际上编译器也会报错*\n\n####  **双元操作符**\n\n#### 特殊的操作符重载\n\n**赋值操作符** | **必考！！！** \n\n如果没有自定义赋值操作符，会自动生成有一个shallow copy的赋值函数；\n\n但是如果涉及到指针，通常要自定义一个deepcopy的函数，防止指向同一块区域，并且释放原先自己指向的内存区域，防止内存泄露。\n\n比如经典的String类：\n\n```cpp\n解决上面问题的办法是针对String类自己定义赋值操作符重载函数：\nclass String\n{  ......\nString& operator = (const String& s)\n\t{\t\n    \tif (&s == this) return *this;  //防止自身赋值：a=a\n\t\tdelete []str;\n\t\tstr = new char[s.len+1];\n\t\tstrcpy(str,s.str);\n   \t\tlen = s.len; \n\t\treturn *this;\n\t}\n};\n```\n\n>   注： 下面这一部分是使用了ai进行整理，使得ppt上面的内容更加的清晰，实际使用的时候建议和ppt一起使用。\n>\n>   **NOTE：** 赋值操作符要记得检查自赋值逻辑！！！OJ因此丢过好多分！！！\n\n#### C++ 自定义 `new` 和 `delete` 操作符详解\n\n##### 1. `operator new` 重载基础\n\n基本语法\n\n`operator new` 必须作为静态成员函数重载（`static` 关键字可省略）：\n\n```cpp\nvoid* operator new(size_t size);\n```\n- **返回类型**：必须是 `void*`\n- **参数**：`size_t size` 表示对象所需空间大小\n  - `size_t` 是 `sizeof()` 操作符返回的类型（通常为 `unsigned long`）\n\n使用方式\n\n```cpp\nclass A {\npublic:\n    void* operator new(size_t size) {\n        void* p = malloc(size);\n        memset(p, 0, size);  // 初始化内存为0\n        return p;\n    }\n};\n\nA* p = new A;  // 调用重载的operator new\n```\n\n特点\n\n1. 自动计算类大小并作为 `size` 参数传递\n2. 可以初始化内存（即使类没有构造函数）\n3. 不一定要在堆上分配内存（后面会讲placement new）\n\n##### 2. Placement New（定位new）\n\n允许在已分配的内存上构造对象：\n\n```cpp\nclass A {\n    int x, y;\npublic:\n    A(int i, int j) : x(i), y(j) {}\n    void* operator new(size_t size, void* p) {\n        return p;  // 直接返回传入的指针\n    }\n};\n\nchar buf[sizeof(A)];  // 预分配内存（栈上）\nA* p = new (buf) A(1, 2);  // 在buf上构造对象\np->~A();  // 必须显式调用析构函数！\n```\n\n关键点\n\n- 不分配内存，只构造对象\n- 必须手动调用析构函数\n- 常用于内存池、特殊硬件地址操作\n\n##### 3. `operator delete` 重载\n\n基本语法\n\n```cpp\nvoid operator delete(void* p[, size_t size]);\t\n```\n- 必须是静态成员函数\n- 第二个参数 `size_t` 是可选的\n- 必须与 `operator new` 配对实现\n\n示例\n\n```cpp\nclass A {\n    int x, y;\t\npublic:\n    void* operator new(size_t size) {\n        void* p = malloc(size);\n        memset(p, 0, size);\n        return p;\n    }\n    void operator delete(void* p) {\n        free(p);\n    }\n};\n\nA* ptr = new A;\ndelete ptr;  // 调用重载的delete\n```\n\n##### 4. 内存池实现（必考）\n\n设计思路\n\n1. 第一次创建对象时申请一大块内存\n2. 将大内存分割为对象大小的块，用链表管理\n3. 从链表中分配/回收内存，避免频繁系统调用\n\n完整实现\t\n\n```cpp\nclass A {\n    // 类原有成员\n    static A* p_free;  // 自由链表头指针\n    A* next;          // 链表指针\npublic:\n    static void* operator new(size_t size);\n    static void operator delete(void* p);\n};\n\nA* A::p_free = nullptr;\nconst int NUM = 32;  // 每次申请的对象数量\n\nvoid* A::operator new(size_t size) {\n    if (p_free == nullptr) {  // 首次分配\n        // 申请NUM个对象的大内存块\n        p_free = static_cast<A*>(malloc(size * NUM));\n        \n        // 初始化自由链表\n       for (int i = 0; i < NUM-1; ++i) {\n            p_free[i].next = &p_free[i+1];\n        }\n        p_free[NUM-1].next = nullptr;\n}\n    \n    // 从链表分配一个对象\n    A* p = p_free;\n    p_free = p_free->next;\n    memset(p, 0, size);\n    return p;\n}\n\nvoid A::operator delete(void* p) {\n    // 将内存块插回链表头部\n    static_cast<A*>(p)->next = p_free;\n    p_free = static_cast<A*>(p);\n}\n```\n\n内存布局示例\n\n初始状态：\n```\n[对象1] -> [对象2] -> ... -> [对象32] -> NULL\n```\n经过多次分配释放后可能变成：\n```\n[对象5] -> [对象2] -> [对象10] -> ...（非连续）\n```\n\n关键优势\n\n1. 避免内存碎片\n2. 分配/释放效率高（O(1)时间复杂度）\n3. 减少系统调用开销\n\n##### 5. 内存释放问题（必考）\n\n问题描述\n\n当程序不再需要内存池时，如何释放所有申请的大内存块？\n\n解决方案\n\n需要额外维护一个列表记录所有申请的大内存块：\n\n```cpp\nclass A {\n    static A* p_free;\n    static std::vector<void*> big_blocks;  // 记录所有大内存块\n    A* next;\npublic:\n    static void* operator new(size_t size);\n    static void operator delete(void* p);\n    static void release_memory();  // 释放所有内存\n};\n\nvoid A::release_memory() {\n    for (void* block : big_blocks) {\n        free(block);\n    }\n    big_blocks.clear();\n    p_free = nullptr;\n}\n\nvoid* A::operator new(size_t size) {\n    if (p_free == nullptr) {\n        void* block = malloc(size * NUM);\n        big_blocks.push_back(block);\n        // 初始化链表...\n    }\n    // 分配逻辑...\n}\n```\n\n##### 6. 重载new/delete的意义\n\n1. **提高效率**：避免频繁系统调用\n2. **避免碎片**：固定大小分配减少碎片\n3. **特殊需求**：\n   - 调试/统计内存使用\n   - 硬件特定地址分配\n   - 实时系统（确定性的分配时间）\n\n##### 7. 注意事项\n\n1. 必须成对实现new/delete\n2. placement new必须手动调用析构函数\n3. 多线程环境需要加锁保护\n4. 继承情况下的行为（派生类会使用基类的operator new）\n5. 不要轻易替换全局new/delete\n\n![image-20250326115553726](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250326115553726.png)\n\n---\n\n**自定义类型转换**\n\n1.   通过带参数的构造函数\n\n2.   通过操作符重载\n\n     ```cpp\n     class A{\n         int a;\n         operator int(){\n             return a;\n         }\n     }\n     ...\n     A a;\n     int b=(int)a;//类型转换\n     \n     ```\n\n     **歧义问题**：\n\n     1.   比如我如果重载了int和A的加法，在执行`int b=1+a;`时，应该是调用int和A重载的加法呢？还是调用a到int的重载呢？\n     2.   如果我有从A到int的转换，也有从int到A的转换，那么执行`a+b`的时候应该调用哪一个呢？\n\n     **解决方法：**\n\n​\t1. 手动显示类型转换\n\n\t2. 在函数前面加上`explict` 关键字，不允许隐式类型转换；`explict operator int(){...}`;\n\n---\n\n## 第七章: IO,Handle Exception and Debug\n\n### 输入输出  \n\n**Warning:OJ必考！！！！**\n\nIO模式有三种：\n\n-   文件输入输出\n-   面向控制台的输入输出\n-   面向字符串常亮的输入输出\n\n![image-20250402102126315](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250402102126315.png)\n\n\n\n(图为c++里面文件相关库)\n\n>   -   The `istream` class itself does not have a public constructor that you can directly use. Instead, it is designed to be inherited by derived classes like `ifstream`, `istringstream`, and others.\n\n`istream` is the base class of `ifstream` and `istringstream` , so you can define a function whose parameter is `istream` type to handle both `ifstream` and `istringstream`. \n\n例子：\n\n>   Pay attention to the cases of PPT form page20-page25, the OJ would have related problems. But the final exam won't.\n\n---\n\n\n\n\n\n\n\n\n\n*cin和cout的格式化输入输出*：\n\n-   flush\n-   endl\n\n>   cin和cout是有缓冲区的，请查询相关内容\n\n等等。\n\n文件的读写有三步：1. 打开文件 2. 进行操作 3. **关闭文件**\n\n1.   打开文件\n\n     -   ofstream out_file(<文件名> [,<打开方式>])\n\n     -   ofstream out_file;\n\n          out_file.open(<文件名> [,<打开方式>]);\n\n     -   打开方式有 `ios::app`,`ios::out`等\n\n2.   判断文件是否成功打开\n\n     -   out_file.is_open() \n     -   out_file.fail()\n\n3.   文件的读写\n\n     >   n以文本方式输出的文件要以文本方式输入；以二进制方式输出的文件要以二进制方式输入！\n\n4.   文件的关闭\n\n     >   n以文本方式读写的文件要以文本方式打开；以二进制方式读写的文件要以二进制方式打开！\n\n### 异常处理\n\n很多时候，程序没有语法错误，但是存在隐式的错误，比如 x/y在某个事件段出现 y=0\n\n则会出现`Division by zero`的错误。还有比如内存溢出的错误。\n\n\n\n\n\n---\n\n异常处理的方法：\n\n-   本地处理\n\n-   异地处理\n\n    >   一个case是PA1的FileSimulator，当输入的cmd有错误时，error不是就地处理，而是回到循环调用readCommand函数里，处理异常。\n\n---\n\n在c++中除了可以通过函数的返回值来判断函数执行是否正常（Liunx用c写的，出现了很多这样的逻辑） 还可以用c++的结构化处理异常的机制`try catch`\n\n\n\n-   try: 把有可能遭遇异常的代码（语句或函数调用）构成一个try语句块。\n\n-   throw: 如果try语句块中的某部分代码在执行中发生了异常，则由throw语句产生一个异常对象，之后的操作不再进行。\n\n-   catch: 抛掷的异常对象通过catch语句块来捕获并处理之。 \n\n**注意：不一定是throw一个字符串或者一个runtime_error，你可以throw anything， but 要在catch中捕获相同的代码**\n\n\n\n```cpp\nvoid fun(fstream* fs){\n    if(!fs->open()){\n        throw fs;\n    }\n}\n...\ntry{\n    fun(fs1);\n}catch(fstream* failed_file){\n    ...\n}\n```\n\n一个try后可以接多个catch，用于捕获不同的异常\n\n\n\n```cpp\nvoid f(){\n\ttry{\n        throw 1;\n    } catch(int a){\n        cout<<\"Catch \"<<a<<endl;\n        throw 2;\n    }\n}\n\n\ntry{\n\tf();\n    g();\n}catch(int ){\n...\n}catch(char* ){\n... \n}\n```\n\n\n\n\n\n---\n\n如果当前的`throw`没有被`catch`,那么会回退到上一层，看是否会被捕获，如果最终也没有被捕获，那么就会`abort`并退出。\n\n\n\n\n\n**try catch的例子是期末必考的题目！！！！** 必考 10分左右！！\n\n\n\n看ppt的例子h(),g(),f()\n\n---\n\n*异常处理机制*\n\n-   每一个函数都有一个catch表\n-   执行throw的时候看当前catch表是否能够正常捕获\n-   如果不行，那么退栈，回到上一个函数\n-   如果能够被catch，那么从这个函数继续执行\n-   否则，回到main函数执行`terminate()` to end the program.\n\n---\n\n\n\n### 基于断言的调试\n\n`assert(expr)` will throw an error when `expr` is false otherwise noting happend.\n\n-   Easy to understand\n-   Debug\n\nassert的实现：assert其实是一个宏，定义类似这样：\n\n```cpp\n#define assert(exp) ((exp)?(void)0:<输出诊断语句 and call abort( to end the program)>))\n```\n\n\n\n\n\n\n\n\n\n### 事件驱动的程序设计\n\n略，自己看ppt\n\n---\n\n## 第八章\n\n### 泛型程序设计\n\n一个程序实体能对多种类型的数据进行操作或描述的特性称为类属或泛型（Generics）。\n\n具有类属特性的程序实体通常有：\n\n-   类属函数：一个能对不同类型的数据完成相同操作的函数。\n\n-   类属类：一个成员类型可变、但功能不变的类。\n\n基于具有类属特性的程序实体进行程序设计的技术称为：泛型程序设计（Generic Programming）\n\n**类属函数**\n\n能对不同类型的参数实现相同的操作。\n\n比如：\n\n*不排除考察的可能性，因为指针是c++的精华*\n\n```cpp\n//函数定义：\ntypedef unsigned char byte;\nvoid sort(void *base, //需排序的数据（数组）内存首地址\n\tunsigned int num, //数据元素的个数\n\tunsigned int element_size, //一个数据元素所占内存大小（字节数）\n \tbool (*cmp)(const void *, const void *) ) //比较两个元素的函数\n{   //不论采用何种排序算法，一般都需要对数组进行以下操作：\t\n     //取第i个元素\n        (byte *)base+i*element_size\n     //比较第i个和第j个元素的大小 （利用调用者提供的回调函数cmp实现）\n        cmp((byte *)base+i*element_size,(byte *)base+j*element_size)\n     //交换第i个和第j个元素的位置\n        byte *p1=(byte *)base+i*element_size,\n\t     *p2=(byte *)base+j*element_size;\n        for (int k=0; k<element_size; k++)\n        {\t byte temp=p1[k]; p1[k] = p2[k]; p2[k] = temp;\n        } \n}\n```\n\n使用void*的指针来实现对不同的数据进行操作，很Amazing！！！\n\n**函数模板**\n\n函数模板是带有**类型参数**的函数定义\n\n定义的模板如下：\n\n```cpp\ntemplate<class T>\nvoid sort(T element[], unsigned int count){\n    //...\n    \n}\n```\n\n其中，`template<class T> or template<typename T> `的含义是声明一个模板。\n\n在调用函数的时候，可以显式的声明模板类型`func<int>(a,b)` ,这样的话强制设置模板为int,末班也可以设定一个默认值：`template<typename T=int>`\n\n同时要注意，这里的template必须连着函数或者类的定义\n\n```cpp\ntemplate<typename T=int>\nT add(T a,T b){\n    return a+b;\n}\n\nT sub(T a, T b){ //Error, T is undefined\n    return a-b;\n}\n```\n\n**类模板**\n\n如果一个类定义中用到的类型可变、但操作不变，则该类称为类属类。\n\n在C++中，类属类用类模板实现。\n\n类模板的格式为：\n\n```cpp\ntemplate <class T1,class T2,...> //class也可以写成typename\n\nclass <类名>\n\n{ <类成员说明>\n}\n```\n\n-   T1、T2等为类模板的类型参数，在类成员的说明中可以用T1、T2等来作为它们的类型。 \n\n比如我们可以使用模板来实现适合多种类型的模板类：\n\n```cpp\n例如，用类模板实现类属的栈类：\ntemplate <class T> \nclass Stack\n{\t\tT buffer[100];\n\t\tint top;\n\tpublic:\n\t\tStack() { top = -1; }\n\t\tvoid push(const T &x);\n\t\tvoid pop(T &x);\n};\ntemplate <class T> \nvoid Stack <T>::push(const T &x) { ...... }\ntemplate <class T> \nvoid Stack <T>::pop(T &x) { ...... }\n```\n\n在创建类的实例时：\n\n```cpp\nStack<int> a; //显式地指出\n```\n\n在实现类的各个函数时：\n\n```cpp\ntemplate<typename T>\nvoid Stack<T>::pop(T &X)\n```\n\n注意：不同模板的类成员不会共享相同的静态成员；即Stack\\<int\\>和 Stack\\<double\\>的静态成员相互独立。友元函数也是这样的！\n\n---\n\n**因为只有实例化的时候才又实实在在的class生成!**\n\n-   使用一个模板之前首先要对其实例化（用一个具体的类型去替代模板的类型参数），实例化是在（预）编译时刻进行。\n\n-   模板实例化一定要见到相应的源代码，否则无法实例化\n\n一个例子：\n\n```cpp\n// file1.h\ntemplate <class T> \nclass S //类模板S的定义\n{    T a;\n  public:\n      void f();\n};\nextern void func();\n\n// file1.cpp\n#include \"file1.h\"\ntemplate <class T> \nvoid S<T>::f() //类模板S中f的实现\n{ ......\n}\nvoid func()\n{ S<float> x; //实例化“S<float>”并创建该类的一个对象x\n   x.f(); //实例化“void S<float>::f()”并调用之\n} \n// file2.cpp\n#include \"file1.h\"\nint main()\n{ S<float> s1; //实例化“S<float>”并创建该类的一个对象s1\n   s1.f(); //没有实例化“void S<float>::f()”，但调用之\n   S<int> s2; //实例化“S<int>”并创建该类的一个对象s2 \n   s2.f(); //没有实例化“void S<int>::f()”，但调用之\n   func();\n   return 0;\n}/* \n两个模块都能通过编译，但在链接时出错，链接程序指出：\nfile2中调用的“void S<int>::f()”不存在！\nS<float>::f() 没错的原因 ：S<float>::f() 的实例化发生在 file1.cpp 中，因此链接器可以找到它的定义。\nS<int>::f() 出错的原因 ：S<int>::f() 的实例化未发生，因为其实现对 file2.cpp 不可见。\n*/\n```\n\n\n\n---\n\n>   在模板实例化的时候，编译器会根据相应的类型*复制*出相同逻辑，类型不同的代码。 也就是在做代码的拷贝和类型的替换！\n\n代码替换的情况：\n\n1.   头文件的include\n2.   类的一些默认生成的函数\n3.   模板函数和模板类\n4.   inline函数\n5.   宏定义\n\n### STL编程\n\nSTL由容器，算法，迭代器构成。\n\n自己看ppt吧，内容还挺多的。\n\n\n\n# 其他内容\n\n## 并行程序设计\n\n**并发和并行：**\n\n-   并发： 同一时间段可以交替处理多个操作\n-   并行：同一个事件可以同时进行多个操作\n\n**进程和线程**：\n\n-   process 进程： 在一个内存空间上运行的应用程序。每一个进程都有多个线程。\n-   thread 线程： 进程中的一个执行任务。同类的多个线程共享进程的堆和方法区，但是也有自己的程序计数器和本地方法栈。![image-20250509151156595](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250509151156595.png)\n\n## 内存安全程序设计\n\n\n\nwoc！！忘记保存了！，做了那么久的笔记。。。\n\n### Temporal Memory Problem\n\n#### **RAII** ：Constructor Aqusition， Destrucror Release\n\n```cpp\nclass FileObj{\n    //1.将指针封装到class里面  2. 对象是local地创建的，而非使用new\n\tFileObje(char* name){\n        FILE* file= fopen(name,'r');\n    }\n    //自己看ppt吧\n}\n```\n\n用相似的思想我们可以封装一个指针对象：(之后只要local地创建对象)**100%必考！！！期末考试必考**\n\n```\ntemplate<typename T> \nclass Toy_ptr{\n\t\n}\n```\n\n#### **SmartPoint** 依赖于泛型和RAII思想实现\n\n-   unique_ptr\n-   shared_ptr\n-   weadk_ptr\n\n**unique_ptr**:\n\nA unique_ptr takes ownership of a pointer. Destorys the object when goes out of the scope by invoking `delete()`\n\n```\n#include<memory>\nint main(){\n\tunique_ptr<int> p(new int(10));\n\t//可以正常使用p,注意unique_ptr是local创建的\n}\n```\n\nInitialization:\n\n-   Constructor\n\n    ```cpp\n    std::unique_ptr<T> pT(new T());\n    ```\n\n-   make_unique\n\n    ```cpp\n    auto pT= make_unique<int>(10);\n    //make_unique<T>  is also a template function which needs a template!s\n    ```\n\n-   move\n\n    ```cpp\n    // move 是一个 高效的拷贝，许多其他的地方也有move操作\n    // move= release+ reset\n    auto p1=move(p2)//p2 is a unique_ptr\n    ```\n\n\n>   The copy constructor and assignment operator is not allowed !\n>\n>   `std::unique_ptr<int> y(x)` or `std::unique_ptr<int> y= x` are not allowed !\n>\n>   老师说：为什么不行？ 因为如果支持这样的操作的话，会导致shallow copy的发生，导致别的对象也拥有这个指针，但是可能原先的那个对象已经out of scope ，释放了对象\n\n`reset`  and  `release()`:\n\n-   release(): release the pointer and set the wrapped pointer to nullptr;\n\n    ```cpp\n    //release the pointer which is no longer managed by the pointer\n    unique_ptr<int>p= make_unique(10); \n    int *a=p.release(); \n    //a get the pointer of p\n    ```\n\n    \n\n-   reset(): delete the current pointer and stores a new one\n\n    ```cpp\n    int* p1= new int(10);\n    int* p2= new int(1);\n    unique_ptr<int> a(p1);\n    unique_ptr<int> b=move(a);\n    b.reset(p2);\n    //p1所指地址被释放,a为空，b为p2\n    ```\n\n    \n\n    其他的细节： 每一个unique_ptr在out of scope的时候都会进行delete指针：\n\n    ```cpp\n        unique_ptr<int> p1;\n        p1.reset(new int(10));\n        unique_ptr<int> p2(p1.get());\n        cout<<p1.get()<<\" \"<<p2.get();\n        //ERROR!! 会Double Free！\n    ```\n\n    \n\n\n\n\n\n**shared_ptr**:\n\n In some scenerios, myltiple pointer needs to point to one pointer.\n\n比如在多线程中：**考试可能出现相同内容、可能出现！！**\n\n```cpp\nvoid inc(unique_ptr<int> p){\n\t(*p)++;\n    cout<<*p<<\"\\n\";\n}\nint main(){\n    unique_ptr<int>p(new int(1));\n    thread t1(inc,p);\n    thread t2(inc,p);//Error: unique_ptr is an instance, 当对象作为参数闯入函数时，会拷贝构造函数，而unique_ptr是不允许的；\n    //假如运行这个操作，因为拷贝对象在out of scope之后会自己吧原先的指针给释放！！\n    t1.join();\n    t2.join();\n    return 0;\n}\n```\n\n\n\n在unique_ptr的基础上，进行计数：\n\n-   Constructor/ Copy Constructor / Assignment operator : increment the count by one\n-   desturctor: decrease the counter by one. \n-   When count equals to zero, delete the pointer;\n\n```cpp\nshared_ptr<int> p1(new int (10));\nshared_ptr<int> p2=p1;\nauto p3(p2);\n```\n\nInitialization:\n\n-   make_shared\n\n    ```cpp\n    auto p= make_shared<T>();\n    ```\n\n-   constructor/ copy constructor /  operator =\n\n    ```cpp\n    //省略，但是需要注意的是shaed_ptr是支持等号赋值和拷贝构造的，会导致shared_ptr加1\n    ```\n\n一些接口：\n\n-   reset: release the current pointer and set a new pointer(nullptr default)\n\n    ```cpp\n    shared_ptr<int> p1(new int(10));\n    auto p2=p1;\n    auto p3=shared_ptr<int>(p1);\n    cout<<\"Use counts: \"<<p1.use_count()<<\"\\n\";//3\n    p2.reset();\n    cout<<\"Use counts: \"<<p1.use_count()<<\"\\n\"; //2\n    ```\n\n    \n\n    \n\n-   use_count: get the counts of the shared_ptr that shares the current pointer;\n\n    >   All shared_ptr (that points to the same pointer) has a membership pointer that stores the counts of shared_ptrs;\n\n    \n\n    **Note: Avoid duplicated creatation of share_ptrs to the same pointer**\n\n    即，不要用同一个裸指针创建多个share_ptrs！！！同样的，当然也不要用同一个裸指针创建多个unique_ptr!!!\n\n    会出现类似的问题：会出现double free。\n\n    ```cpp\n        int* p =new int(1);\n        shared_ptr<int> p1(p);\n        {\n            shared_ptr<int> p2(p);\n            cout<<\"P1 points to\"<<p1.get()<<\" value: \"<<*p1;\n            cout<<\"P2 points to\"<<p2.get()<<\" value: \"<<*p2;\n            cout<<p1.use_count()<<endl;\n            cout<<p2.use_count()<<endl;\n        }\n        cout<<\"P1 points to\"<<p1.get()<<\" value: \"<<*p1;\n    //因为\n    ```\n\n\n一个问题： `cyclic reference of shared_ptrs` \n\n![image-20250507102250380](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250507102250380.png)\n\n解决方法：\n\n\n\n（为什么不能是把next改成weak_ptr? 会出现什么问题？**这个是期末考题**，每一个例题都要注意，都有可能成为考题。）\n\n（有同学提问：将prev换成裸指针可以吗）\n\n老师回答： weak_ptr相当于可以理解为shared_ptr不计数，但是毕竟可以获取到shared_ptrs的相关信息，比如use_counts等等。裸指针也可以实现，只是没有这些接口了。\n\n**weak_ptr**:\n\nweak_ptr is similiar to share_ptr but doesn't effect the count;\n\nweak_ptr的接口：\n\n-   use_counts\n-   expired\n-   lock()：implemnted as `expired()?shared_ptr<T>(this):shared_ptr<T>(this)`\n\n考试会加上：1、并行程序设计（OJ会考，下次就会考） 2. 内存安全程序设计（OJ和考试都会考） 3. 函数式编程\n\n**第一年考这些新的内容，难度会下降一点**。\n\n会占大概30-40分；\n\n### 空间类内存安全（Spatial safety caused by wrong access）\n\n**常见的spacial safety problem错误**\n\n缓冲区溢出（Buffer overflow）\n\n解引用空指针（Null pointer dereferencing）\n\n访问未初始化内存（Dereference uninitialized pointer）\n\n**Fat-Pointer**\n\n除了存储指针信息，还存储一些**meta data**来进行动态检查，增强安全性。\n\n![image-20250507113601646](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250507113601646.png)\n\n在malloc之后还需要存储相关的meta data，比如base 和 bound，代表起始位置和最后的位置\n\n但是会出现一个问题：加入了base和bound之后可能会出现内存对齐和兼容性问题：\n\n![image-20250507114121808](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250507114121808.png)\n\n因此需要更好的方法：\n\n![image-20250507114653612](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250507114653612.png)\n\n将meta data存储在一片单独的空间中，比如上面的p指针对应的disjoint  space的相应位置就存储了p指针的bound和base信息。**原理** ：对于每个普通指针 `p`，其元数据存储在 `shadow_space[p]` 中。\n\n但是空间利用率不高，我们可以用tire（字典树）的方式解决这个问题\n\n![image-20250507115026627](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250507115026627.png)\n\n## 函数式编程\n\n声明式程序设计,老师说这个不是考点，往年都不一定出题目\n\n---\n\n程序设计范式：\n\n-   命令式Imperative programming . 如面向过程和面向对象程序设计\n-   声明式Declarative programming. 如函数式程序设计（scheme）和逻辑式程序设计（SQL）\n\n函数式程序设计的基本特征：\n\n-   pure function纯函数 1. 相同输入相同输出  2. 无副作用\n-   没有状态\n-   函数也是值\n-   递归为主要的控制结构\n-   lazy evaluation\n-   并行性：程序没有状态，以及函数引用的透明，无副作用等特点，有的操作可以进行并行。\n\n**函数式程序设计的基本手段**\n\n-   递归和尾递归\n-   过滤/映射/规约操作（Filter/Map/Reduce）\n-   部分函数应用（Partial Function Application）\n-   柯里化（Currying）\n-   ......\n\n**递归和尾递归**\n\n`tail recursion`\n\n例子：使用尾递归实现fib的计算\n\n```cpp\nint fib(int n, int a, int b){\n    if(n==1)return a;\n    else if(n==2)return b;\n    else return fib(n-1,b,a+b);\n}\n```\n\n\n\n## 其他的老师：仓颉语言架构师，大厂\n\n","categories":["NJUCS","高级程序设计"]},{"title":"FPGA设计和硬件描述语言","url":"/posts/f39878f331ca/","content":"\n这一章不是重点。\n\n<!--more-->\n\n\n\n## PLD 器件\n\n简单了解一下PLD的画法：\n\n![image-20250324105932569](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250324105932569.png)\n\n注意，**列阵表示**的含义：第一个`固定连接`和之后所有的`可编程连接`的变量都相连，相连的方式是右侧具体的逻辑门。\n\n### 可编程逻辑阵列（Programmable Logic Array，PLA）是一种与阵列、或阵列都可编程的逻辑阵列:\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250324111338892.png\" alt=\"image-20250324111338892\" style=\"zoom:33%;\" />\n\n### 存储器阵列\n\n存储器阵列可以用于存储大量数据，但是读取速度比寄存器稍慢：\n\n\n\n\n\n按照功能，可以分为ROM和RAM\n\n**ROM**：Read-Only-Memory\n\nROM根据晶体管的有无，来存储01.\n\nRAM：\n\nRAM又可以区分为SRAM(静态的RAM)，和DRAM（动态的RAM）。\n\n### FPGA程序设计\n\n>   Field Programmable Gate Array，FPGA\t\n\n​\t\n\n\n\n---\n\n下面JacyCui的笔记作为补充：\n\n# Chapter 05 FPGA设计和硬件描述语言\n\n\n\n**崔家才 201220014**\n\n\n\n## 1 可编程逻辑器件\n\n**可编程逻辑器件(Programmable Logic Device, PLD)**：主要由与阵列和或阵列构成，逻辑门可以通过编程开关连接，以形成所需要的逻辑电路。\n\n**可编程只读储存器(Programmable Read Only Memory, PROM)**：与阵列固定，或阵列可编程的简单PLD，将逻辑表达式转化成标准与-或表达式之后可以很容易的由PROM实现。\n\n**可编程逻辑阵列(Programmable Logic Array, PLA)**：与阵列和或阵列都可以编程的逻辑阵列。用PLA实现逻辑函数时，只需要讲逻辑表达式转化成最简与-或表达式即可。\n\n**可编程阵列逻辑(Programmable Array Logic, PAL)**：与阵列可编程，或阵列固定的PLD。\n\n**通用阵列逻辑(Generic Array Logic, GAL)**：可擦写、可重复编程、设置加密、输出端设置了可编程的**逻辑宏单元(Output Logic Macro Cell, OLMC)**。\n\n**复杂可编程逻辑器件(Complex Programmable Logic Device, CPLD)**：**逻辑阵列块(Logic Array Block, LAB)** + I/O控制块 + 可编程互联阵列(PIA)。\n\n**现场可编程门阵列(Field Programmable Gate Array, FPGA)**：基于查找表(Look-Up Table, LUT)技术构建的集成度更高的CPLD。\n\n\n\n## 2 储存器阵列\n\n**随机存取储存器(RAM)**：\n\n- **静态RAM(Static RAM, SRAM)**：MOS管较多，占硅片面积大，因而价格高、功耗大、集成度低；但无需刷新和读后再生；特别是它读写速度快，其储存原理可看作RS触发器的读写过程\n- **动态RAM(Dynamic RAM, DRAM)**：MOS管少，占硅片面积小，因而价格便宜、功耗小、集成度高；但必须定时刷新和读后再生；特别使它的读写速度相对于SRAM慢，其储存原理可看作电容的充放电过程\n\n**只读存储器(Read Only Memory, ROM)**\n\n\n\n## 3 专用集成电路\n\n**专用集成电路(Application-Specific Integrated Circuit, ASIC)**：应特定用户要求和特定电子系统的需要而设计、制造的集成电路\n\n\n\n\n\n\n\n","categories":["NJUCS","数字逻辑与计算机组成"]},{"title":"时序逻辑电路","url":"/posts/c6c6eb81d50d/","content":"\n[TOC]\n\n## 第一讲 | 时序逻辑电路概述\n\n输出结果的输出不仅由外部输入决定，还由当前的状态决定（or 由过去时刻的行为）\n\n当输入新的信号之后，电路的状态可以改变，**也可以保持在当前状态**\n\n### 有限状态机 | Finite state machine (FSM)\n\n有限状态机时用来刻画状态转换的工具\n\n通常，用**状态图**来表示有限状态机\n\n-   状态用圆圈表示\n-   状态转换用箭头(`有向边`)，并**标注状态转变的输入信号和输出信号**;\n\n>   在图中，状态转换的箭头上面用 输入信号/输出信号 表示输入和输出\n\n**例：检测输入序列是否为连续4个“1”**\n\n​\tA-初始态：若输入1，则转B \n\n​\tB-连续1个“1”：若输入1，则转C\n\n​\tC-连续2个“1”：若输入1，则转D\n\n​\tD-连续3个“1”：若输入1，则状态不变 ，并输出为1（表示检测到连续4个1）\n\n​\t任何状态下，输入0都会转到初态A\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250314105927158.png\" style=\"width:50%\"/>\n\n---\n\n**如何用数字逻辑实现一个FSM？** \n\n用二进制编码的方式，表示输入输出，状态（关键是状态）\n\n-   **输出函数**：由初态来决定输出（`Moore型`）、由输出和初态来决定输出(`Mealy` 型) \n\n>   实际采取Moore型还是Mearly型由设计得到的**输出函数**决定\n\n-   **激励函数**：输入初态，得到激励输出\n-   **记忆模块**：用D触发器存储当前状态（每一位状态编码用一个D触发器来存储）\n\n### **时序逻辑电路的结构**\n\n状态记忆模块：由多个状态记忆单元构成（存储元件）\n\n次态激励逻辑模块F ：激励函数（现态和外部输入的逻辑函数）\n\n>   激励函数和输出函数都是**组合逻辑电路**，状态记忆模块是**时序逻辑电路** \n\n输出逻辑模块G ：输出函数（现态和外部输入的逻辑函数）\n\n-   **Mealy型：输出依赖于当前状态和当前输入信号** \n\n-   **Moore型：输出仅依赖于当前状态，和当前输入信号无关**\n\n![image-20250314112122667](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250314112122667.png)\n\n<center>Mealy</center>\n\n![image-20250314112743952](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250314112743952.png)\n\n<center>Moore</center>\n\n**其中的激励函数和输出函数模块都是`组合逻辑电路`！！！**\n\n记忆模块把旧的状态给激活函数和输出模块，然后激励模块才把新的状态给记忆模块；\n\n>   拿旧状态去算新状态和输出！\n\n---\n\n**同步时序逻辑电路 和 异步时序逻辑电路**\n\n-   同步时序逻辑电路：在统一的时钟信号控制下进行状态转换\n\n​\t通过Clk来控制记忆模块\n\n异步时序逻辑电路：没有统一的时钟信号来控制状态的改变\n\n**时钟脉冲**\n\n时钟脉冲之间的时间间隔称为`时钟周期`。单位是秒。通常将1秒内所产生的脉冲个数称为`时钟频率`。单位是Hz计算机中的系统时钟就是一个典型的、频率精确和稳定的脉冲信号发生器。\n\n### 时序逻辑电路的定时\n\n![image-20250314113535631](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250314113535631.png)\n\n## 第二讲 | 锁存器和触发器\n\n### 双稳态元件\n\n一种可以表示两种状态的元件。\n\n-   状态1：置位态（Set）\n-   状态0：复位态（Reset)\n\n**双稳态元件的简单实现：**\n\n串联两个反相器，则反相器的输出状态不同，且保持稳定Q为高电平时，为置位状态；Q为低电平时，为复位状态\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250314114119774.png\" style=\"width:50%\" />\n\n**用两个反相器串联构建的   双稳态元件无法改变电路状态** \n\n用1个或多个输入信号能驱动   双稳态元件进入稳定状态，这   些输入信号称为激励信号   或激励输入。 \n\n---\n\n### 锁存器 | latch\n\n通过**激励信号的电平信号**来控制存储元件的状态\n\n置位复位锁存器(Set-Reset latch)：\n\n-   具有置位和复位激励信号置位激励信号Set有效时，强制存储元件的输出Q为1\n-   复位激励信号Reset有效时，强制存储元件的输出Q为0\n\n![image-20250314114631262](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250314114631262.png)\n\n### 触发器 | flip-flop\n\n具有时钟控制信号(clock) 通过**时钟信号的边沿**和set/reset的电平共同来触发存储元件改变状态\n\n![image-20250314114853081](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250314114853081.png)\n\n### SR 锁存器\n\nSR锁存器：使用一对交叉耦合的或非门构成双稳态电路，也称为置位-重置（复位）锁存器。\n\n**S是置位输入端，R是重置输入端**\n\n**从输入驱动信号有效开始，到输出达到稳定为止有一定的延迟**，这个延迟称为**触发延迟**或**`锁存延迟`**\n\n![image-20250317095218420](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250317095218420.png)\n\n-   S和R至多一个为高电平\n-   如果S为高电平的话，Q输出高电平；如果R为高电平的话，Q输出低电平。\n\n**状态转移表**，**状态转移方程** \n\n<span><img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250317102612290.png\" style=\"width: 30%;\"/></span> 使用**状态转移表**来表示状态的转移。\n\n状态转移方程：\n$$\nQ*= S+ \\overline R \\cdot Q\n$$\n\n$$\nS \\cdot Q \\neq 1\n$$\n\n### D锁存器\n\nD锁存器有一个驱动信号和一个使能端\n\n当使能端为高电平的时候，驱动信号才能有效，驱动信号为高电平的时候，输出高电平；\n\n![image-20250317095604714](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250317095604714.png)\n\n>   D为数据输入端，C为控制端；**只有一个激励输入端** \n\nC=0的时候，电路状态不变；C=1时，将D的数据**锁存**。\n\n**状态图，状态转移表，状态方程,时序图**：\n\n|  D   |  Q*  |\n| :--: | :--: |\n|  0   |  0   |\n|  1   |  1   |\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250317104318075.png\" style=\"width:50%;\"/>\n\n\n\n### D触发器\n\n主从结构的D触发器\n\n![image-20250317105212890](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250317105212890.png)\n\n\n\n| **CLK**    | **主锁存器**                  | **从锁存器**                  |\n| ---------- | ----------------------------- | ----------------------------- |\n| L      | 写入  QM变为D | 不变Q=last            |\n| 上升沿| 锁存QM=D        | 写入Q变为QM |\n| H      | 不变 QM=D          | 不变Q=QM       |\n\n![image-20250317105551072](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250317105551072.png)\n\n（上升沿到来之前，把D已经存入QM，之后在上升沿结束以后把QM存入Q）\n\n**锁存延迟 | Clock -> Q延迟**\n\n在clk边沿到来后，到Q输出改变为D的时间。\n\n![image-20250317111333422](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250317111333422.png)\n\n**建立时间 | setup**\n\n输入信号D在时钟边沿到来前，需要稳定的时间**`主锁存器`稳定下来的时间**。\n\n**保持时间 | hold time**\n\n输入信号D在时钟边沿到来后，需要稳定的时间，**要让`从锁存器`成功写入的时间**。\n\n>   **避免主锁存器在上升沿过程中写入新的D值**\n\n>   Hold时间和Setup时间常常在定时分析中涉及到\n\n**这个D触发器是*上升沿*触发**，还有*下降沿*触发的触发器\n\n\n\n![image-20250317095932508](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250317095932508.png)\n\n当Clk信号为高电平时，左边的D锁存器打开，Q和D的信号一致；\n\n当Clk信号由高电平转成低电平的时候，右边的寄存器打开，使得第二个寄存器能够输出原先D的信号。\n\n#### 带使能端的D触发器\n\n能够通过使能端控制是否要写入激励输入端D的值\n\n![image-20250317112102309](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250317112102309.png)\n\n>   注意到： 前面其实接入了一个**二路选择器**，输入分别是D和Q，使能端为EN；\n\n\n\n---\n\n\n\n#### 带复位功能的D触发器\n\n同步触发：在时钟信号才能更改触发器的状态\n\nPR: preset,CLR:clear\n\n![image-20250317112326003](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250317112326003.png)\n\n\n\n---\n\n### T触发器\n\n在每一次时钟周期都会改变存储的状态,每一次时钟周期到来都会取反。\n\n>   隐藏了初始化的线路，实际上是有初始化的功能的。\n\n![image-20250317112847603](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250317112847603.png)\n\n可以加入使能端En，当使能端为高电平时才能改变触发器；\n\n---\n\n**存储？** 电路在一直工作的时候，只要在一定的激励输入下，输出稳定不不变，Q值保持稳定，因此为**存储**\n\n组合逻辑电路只能按照输入计算出输出，不是存储。\n\n最简单的时序逻辑电路： 存储元件（锁存器和触发器）\n\n经典的时序逻辑电路：寄存器\n\n## **第三讲** | **同步时序逻辑设计**\n\n设计一个检测是否由连续的“101”的电路\n\n### 分析需求，画状态图\n\n![image-20250317114922785](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250317114922785.png)\n\n状态图/状态表的要求：\n\n-   互斥性：从每个状态出发的所有状态转换路径上的转换条件都 是互斥的，如本例中，转移条件分别是X=0和X=1，互斥。 \n\n-   完备性：从每个状态出发的所有状态转换路径上的转移表达式 的逻辑或等于1（逻辑真）。如X=0和X=1，0+1=1。\n\n**即，线不少（所有的有向边都要画出），线不重（同一个输入只能有一个输出）**\n\n### 化简状态图\n\n **等价状态**：两个状态等价指在所有输入组合下，它们的**输出相同**且(**次态相同 *或*次态等价**)\n\n我们合并等价状态可以获得简单的状态表\n\n![image-20250317115627046](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250317115627046.png)\n\n将所有**给定相同的输入X**得到**相同的次态**的**现态**编码为同一种。\n\n### 状态编码\n\n将化简之后的状态表中的每一个状态进行编码。显然，编码尾数m要满足$2^m > n$ ，n为状态数目。\n\n通常采取相邻法来寻求较优的编码方案：\n\n-   次态相同，编码最好相邻\n-   同一个现态的次态最好相邻\n-   输出相同的现态最好相邻\n\n>   考试会给出确定的编码\n\n有了编码以后，就可以用编码来表示状态了：\n\n![image-20250321102905968](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250321102905968.png)\n\n之后，我们可以得出次态的每一位(Y1* and Y0* )以及输出(Z)的*次态输出函数*和*输出逻辑函数*：\n$$\nY1^{*} = \\overline Y1 \\cdot Y2 \\cdot   \\overline X\n$$\n\n$$\nY0\\text{有多个1，写起来比较复杂，但是我们可以通过无关项化简}\n$$\n\n$$\nZ=...\n$$\n\n因为我们有一个编码没有用上:10，所以这个是无关项，我们在上面三个逻辑函数的卡诺图中都加上无关项d\n\n![image-20250321104254685](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250321104254685.png)\n\n![image-20250321104335563](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250321104335563.png)\n\n![image-20250321104352646](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250321104352646.png)\n\n### 电路设计\n\n#### 推导激励函数\n\n我们需要根据`次态函数`和存储元件的`特征方程`，通常我们使用D触发器\n$$\n\\text{状态转移方程为} Q^*=D\n$$\n所以我们可以得到激励函数：\n\n![image-20250321104858879](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250321104858879.png)\n\n$$\n\\text{次态方程： }  Y1^* = \\overline Y1 \\cdot Y0 \\cdot \\overline X\n$$\n\n$$\n\\text{次态方程： }  Y0^* = \\overline Y1 \\cdot Y0 \\cdot X\n$$\n\n含义是，`现态`(Y1,Y0)和输入(X)经过运算，作为触发器的激励输入，得到次态(Y1* ,Y0*)。\n\n#### 画电路图\n\n![image-20250321105328804](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250321105328804.png)\n\n在这里，包括了**次态激励模块**，**状态记忆存储模块**，**输出模块**\n\n### 电路分析\n\n#### 未用状态分析\n\n因为编码空间大于实际的状态数目，所以存在**未用状态**；可能在未用状态进入了循环，称为**挂起**现象。\n\n如果电路能够在有限的时钟内，进入正确的工作状态，有正确的输出，称为电路能够**自启动**。\n\n---\n\n对于我们前面的未用状态：10\n\n当输入x为0时，带入激励函数，得到次态00，输出0；次态正确，输出正确。\n\n输入x为1时，得到次态01，次态正确，但是输出为1，错误；\n\n因此需要对输出函数进行一些修改：\n$$\nZ=Y1*X \\rightarrow Z=Y1*Y0*X\n$$\n​\t\n\n#### 电路定时分析\n\n![image-20250321111836795](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250321111836795.png)\n\n\n\n-   时钟信号改变 -> D触发器的输出改变->计算次态 | clk-to-Q延迟+ 组合逻辑延迟+ 触发器setup\n\n>   需要setup的原因，setup时间是将D1信号存入`主锁存器`,如果没有setup时间，那么当时钟沿到来的时候，没法成功地将正确的信号给`从锁存器`；\n\n-   而输出因为只依赖于现态和输入，因此只要输出延迟小于一个clk周期就行。\n\n**延迟限制：**\n\n1.   clk周期  >  clk_to_Q + 次态激励函数延迟+D触发器的setup时间\n2.   clk周期 < 输出逻辑函数的延迟\n3.   hold时间 < clk_to_Q+次态函数逻辑延迟\n\n>   第三条需要的原因是： 我们知道输出函数一定是依赖于初态的，如果在锁存延迟和激励函数延迟太短的话（低于setup）就会导致输出信号的异常。因为setup的定义就是：输入端D，在setup时间内，一定不能改变，否则就会导致输出信号的错误。\n\n## 第四讲 | 典型的同步时序逻辑电路设计\n\n### 计数器\n\n#### **异步行波加法计数器**\n\n>   这里的异步指的是clk信号不同，前面章节说的异步时序逻辑电路指的是没有一个统一clk来驱动电路\n\n我们可以借助T触发器来设计一个计数器\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250321114457700.png\" alt=\"image-20250321114457700\" style=\"zoom: 25%;\" />\n\n因为每一个T触发器都是在clk信号`下降沿`时触发, 前一个触发器改变两次（一个周期）才能引起下一个触发器变化一次，从而实现计数的原理。\n\n**延迟**： 四个锁存延迟\n\n#### 同步并行加法计数器\n\n-   所有的触发器都使用同一个clk信号\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250321115123268.png\" alt=\"image-20250321115123268\" style=\"zoom:50%;\" />\n\n延迟： 与门传播延迟+触发延迟\n\n#### 异步行波减法计数器\n\n>   这里虽然用的是D触发器，但是其实和T触发器的功能是类似的，只不过多了一个**RST**\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250321115622151.png\" alt=\"image-20250321115622151\"  />\n\n这里的触发器是**上升沿触发**，即从0->1的时候，才会引起下一位的变化\n\n### 寄存器\n\n寄存器是一种**时序逻辑电路**，只能存储数据，在没有新的clk脉冲到来之前，寄存器能够保持内容不变。\n\n在CPU里面寄存器通过三态门和总线相连（同一时刻，只能有一个寄存器将数据送入总线）\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250324102201127.png\" alt=\"image-20250324102201127\" style=\"zoom: 50%;\" />\n\n可以给寄存器中，加入复位，清零，使能等功能。\n\n#### **寄存器堆**\n\n寄存器堆也称`GPRs(通用寄存器组：Gerneal Purpose Register set)` \n\n寄存器堆中的每一个寄存器都有它的编号。\n\n>   bus的意思是`总线`\n\n图中为一个简单的寄存器堆的示意图：\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250324103039982.png\" alt=\"image-20250324103039982\" style=\"zoom:25%;\" />\n\n1.   busW是写入的信号，具体写入那个寄存器要由RW(写入寄存器的编号)决定。busW的数据有n位，说明每一个寄存器也是n位，即每一个寄存器都有n个D锁存器。\n2.   RW，RA，RB代表的寄存器的编号，因此最多只能有$2^k$个寄存器。\n3.   **读操作是组合逻辑操作** ，写操作属于时序逻辑操作。\n\n![image-20250328101503247](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250328101503247.png)\n\n一个可能的结构如下图所示：\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250324103832149.png\" alt=\"image-20250324103832149\" style=\"zoom: 25%;\" />\n\n-   其中busA和busB一直有数据，不由clk决定。 As long as the circut is working!\n\n-   每一个寄存器是32位，里面有32个D锁存器；\n-   寄存器有2^5个。\n\n>   思考：如果正在写寄存器1，到那时又要读寄存器1，那么读出来额度是旧的还是新的？\n\n**注意busW，busA和busB的位数都代表数据的位数，而RA，RB，RW的位数代表了选择端的位数，最多从2的多少次方里面选择**\n\n#### 移位寄存器\n\n能够根据clk的信号来控制，实现左移 or 右移的操作。\n\n![image-20250324104525507](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250324104525507.png)\n\n**四位通用移位寄存器**：\n\n![image-20250324105054531](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250324105054531.png)\n\n具体实现比较复杂，这里略去。\n\n**桶型移位器**：\n\n>   这其实是一个组合逻辑电路，而非时序逻辑电路，在Lab2中有涉及\n\n![image-20250324105427506](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250324105427506.png)\n\n---\n\n## 写在最后\n\n>   新增于2025/6/16，笔者期末复习时\n\n本章节是期末的重点章节之一，分数占比达到20%以上。\n\n重点掌握：1. 锁存器、触发器； 2. 电路的设计 3. 电路的分析（未用状态等等）\n\n>   建议复习的时候参考往年卷\n\n---\n\n问：什么是次态逻辑函数？输出逻辑函数？状态转移方程？激励（生成）函数？\n\n-   次态逻辑函数就是状态转移方程，是描述下一个状态由当前状态和当前输入所决定的函数，即$Q*=f(Q,X) $\n-   输出逻辑函数，检测出现了某种特殊状态时输出特定值的函数，比如检测110电路；$Mealy:Z=f(Q,X) \\\\ Moore: Z=f(Q) $\n-   激励生成函数：状态激励模块的输出函数$D= f(Q,X)$\n\n**根据状态转移表+卡诺图化简可以求出 次态转移方程 和 输出逻辑函数，根据具体选择的存储器、触发器的特征方程，可以求出需要的输出函数**\n\n比如：\n\n假设$Y_0^*=Y_1 \\overline Y_0 +X$，是我们求出的状态转移方程，题目中给了我们D锁存器，D锁存器的状态方程为$Q*=D$，那么存储Y0的D锁存器的输入$D_0= Y_1\\overline Y_0 +X$，也就是说，**应该输入到D0锁存器的数据是$Y_1\\overline Y_0 +X$**;\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250616150248590.png\" alt=\"image-20250616150248590\" style=\"zoom:33%;\" />\n\n（貌似只会考D触发器？，但是其他的触发器应该也是可以的：[四种触发器的相互转换（卡诺图法与直接法） - asandstar - 博客园](https://www.cnblogs.com/asandstar/p/16949856.html)）\n\n---\n\n问：什么是挂起？什么是自启动？电路有什么时序要求（定时分析）？\n\n-   挂起：无论如何都无法进入工作状态\n\n-   自启动：在有限个状态下可以进入装作状态\n\n    >   注：有多个循环状态 可以通过预设初始值来进入工作状态\n\n-   定时分析：\n\n    -   $$\n        T_{CLK}> Clk2Q+SetUp+LongestDealy \\\\ Hold< Clk2Q++ShortestDelay\n        $$\n\n---\n\n","categories":["NJUCS","数字逻辑与计算机组成"]},{"url":"/posts/68fc9bc1a5c8/","content":"\n# STL算法\n\n### sort\n\nsort(arr.begin(),a.end(),cmp);按照cmp的方式进行排序，其中cmp函数接受两个参数（arr中的两个相邻元素），如果cmp返回的值为false，那么交换这两个元素。\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\ntypedef struct Student{\n    string name;\n    string id;\n    int score;\n}S;\n\nbool cmp(S&s1,S&s2){\n    if(s1.score==s2.score){\n        return s1.name>s2.name;\n    }\n    return s1.score>s2.score;\n}\n\n\nint main{\n    int n,m;\n    cin>>n;\n    vector<S>students;\n    for(int i=0;i<n;i++){\n        stirng name,id;\n        int score;\n        cin>>string>>id>>score;\n        students.push_back((S){name,id,score});\n    }\n    sort(students.begin(),students.end(),cmp);\n    for(S& stu:students){\n        cout<<\"Student name:\"<<stu.name<<\"score: \"<<stu.score<<endl;\n    }\n}\n```\n\n### lower_bound 和 upper_bound\n\n**lower_bound** return 第一个**大于或等于**目标元素的迭代器\n\n**upper_bound** return 第一个**大于**目标元素的迭代器\n\n结合lower_bound和upper_bound我们可以找到任意一个排序好的数据的区间\n\n```cpp\n    int len=10;\n    int arr[len]={9,8,7,7,6,5,4,3,3,0};\n    mySort(arr,0,len-1);\n    cout<<\"[3,7]\"<<\": \";\n    int left1=lower_bound(arr,arr+len,3)-arr;\n    int right1=upper_bound(arr,arr+len,7)-arr-1;\n    print(arr,left1,right1);\n    cout<<\"[3,7)\"<<\": \";\n    int left2=lower_bound(arr,arr+len,3)-arr;\n    int right2=lower_bound(arr,arr+len,7)-arr-1;\n    print(arr,left2,right2);\n    cout<<\"(3,7]\"<<\": \";\n    int left4=upper_bound(arr,arr+len,3)-arr;\n    int right4=upper_bound(arr,arr+len,7)-arr-1;\n    print(arr,left4,right4);\n    cout<<\"(3,7)\"<<\": \";\n    int left3=upper_bound(arr,arr+len,3)-arr;\n    int right3=lower_bound(arr,arr+len,7)-arr-1;\n    print(arr,left3,right3);\n/*\n输出：\n[3,7]: 3 3 4 5 6 7 7 \n[3,7): 3 3 4 5 6\n(3,7]: 4 5 6 7 7\n(3,7): 4 5 6\n*/\n\n```\n\n**注意**：使用lower_bound来查找元素的时候，要确定：1. 得到的不是尾迭代器 2. 迭代器所指的值正是需要找的！\n\n### swap\n\n交换两个元素\n\n### reverse\n\n将序列进行翻转\n\n```cpp\nvector<int> arr={1,2,3};\nreverse(a.begin(),a.end());\n```\n\n### next_permutation\n\n将两个迭代器中间的部分按照自定义规则（默认是字典序）形成下一个排序，但是要注意，如果还存在可以排序的情况那么就return true， 如果没有新的排序了那就回return false。\n\n**本质是得到下一个排序！！！**\n\n如果想要得到某个序列的全排列，需要先将序列按照某种规则**进行排序**,\n\n再将按照该规则的**升序序列** 不断运用`next_permutation`即可\n\n```cpp\nint arr[]={3,2,1};\nsort(arr,arr+3,cmp);\nwhile(next_permutaion(arr)){\n    print(arr,arr+3);\n}\n//会打印5种排序（最开始的第一中没有打印，因为打印前已经用了next_permutaion）\n```\n\n","categories":["NJUCS","高级程序设计"]},{"title":"组合逻辑电路","url":"/posts/3f4faaff9611/","content":"## 第一讲 | 组合逻辑电路概述 \n数字逻辑电路分为**组合逻辑电路**和**时序逻辑电路**\n-   组合逻辑电路：输出只依赖于输入\n-   时序逻辑电路：输出和输入、电路状态有关\n\n>   1.   CPU是时序逻辑电路\n>   2.   组合逻辑电路和时序逻辑电路混在一起用也是时序逻辑电路\n\n### 组合逻辑电路构成规则\n\n1.   元件是组合逻辑电路\n\n2.   输出端只能相互连接 | 即，每一个点的信号来源只能有一个\n\n     >   也就是多个组件的输出不连在一起\n\n3.   输出节点不能反馈到输入端\n\n     >   也就是不能输出不能\"回头\"\n\n### 逻辑电路图\n\n一个逻辑电路对应一个逻辑表达式（单输出）\n\n一个元件可以是多个逻辑电路图和在一起，比如有多输出的元件。\n\n**扇出系数**： 一个逻辑门允许的最大输入数目\n\n**扇出系数**：最大输出数目\n\n#### **画逻辑门**\n\n-   根据优先级\n-   **非>与、与非 >异或、同或 >或、或非**\n\n-   多位二进制运算，需要标志位数：\n\n![image-20250307113324303](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250307113324303.png)\n\n### 多级逻辑电路\n\n**门的传播延迟 | 门延迟**： 输入信号改变到输出信号发生改变之间的时间；\n\n**任何逻辑电路都可以是两级电路**：可以画真值表，再写成**与-或表达式**或**或-与表达式**\n\n>   将多级变成两级：\n>\n>   -    减少时间延迟，提高速度\n>   -   增加电路的复杂程度；使用的电路硬件数目会增加\n>   -   速度up，成本up\n\n### 组合逻辑电路设计\n\n1.   逻辑抽象\n2.   真值表\n3.   卡诺图化简\n4.   画图 \n\n>   注： 任何表达式都可以化简成为二级**与-或**表达式，将与或表达式两次取反，可以得到**与非 -与非**表达式；\n\n**示例：红绿灯正常工作状态**\n\n1.   数字抽象：三位输出，每一位代表一个灯，每个灯要么亮要么关（0 or 1）\n\n2.   真值表和卡诺图：\n\n![image-20250310101940750](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250310101940750.png)\n\n最后得到F的表达式（最简表达式）\n\n**两级的与-或表达式可以变成与非-与非表达式**：通过两次取反！\n$$\nF= \\overline{\\overline{\\overline R \\cdot \\overline{Y} \\cdot \\overline{G}} \\cdot \\overline{R \\cdot Y} \\cdot \\overline{R \\cdot G} \\cdot \\overline{Y \\cdot G} }\n$$\n\n\n### 无关项，非法值，高阻态，三态门\n\n#### **无关项**\n\n-   **不在乎的输入组合**即是无关项：压根不会出现的输入组合，或者没有影响的项；如BCD码里面大于1001的编码都是无关项。\n-   无关项在真值表中用d表示，意思是0 or 1毫不关心。\n-   无关项在卡诺图中**可以全部填上**，如果这有利于你化简卡诺图的话。你只需要在乎真的输出为1的项，无关项你可以选择是否保留，**只要有利于你化简**。\n\n\n\n#### **非法值**\n\n-   既不是0也不是1\n\n#### **高阻态**\n\n-   处于一种非正常状态的第三种电气态，**电路就项断开一样**\n\n#### **三态门**\n\n-   一种总线接口电路，可以输出0,1，高组态\n\n-   有一个**输出使能控制端** EN\n\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250310103629211.png\" alt=\"image-20250310103629211\" style=\"zoom:33%;\" />\n\n-   使用例子：用于连接总线，多个三台逻辑连接在一起，使得每一次，只能有一个输入端可以输入总线。\n\n-   三态门有两种，一种是当使能端为H时可以工作，另一种是当其为L时工作。\n\n-   使能端也可以同时有多个，比如有三个使能端G,G2A_L,G2B_L，则只有为1 0 0的时候才能正输出0 or 1。 ）\n\n-   在将EN端写入真值表后，每一个最小项、最大项都要将EN的输入考虑进去；\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250310110012505.png\" alt=\"image-20250310110012505\" style=\"zoom:33%;\" />\n\n根据这个，可以写出：\n$$\nY0=\\overline{EN}+ EN \\cdot \\overline{A1} \\cdot A0+ EN \\cdot A1 \\cdot \\overline{A0}+EN \\cdot A1  \\cdot A2\n$$\n\n>   需要将EN端也要考虑到这里的输出表达式；因为EN端相当于也是一个输入端\n\n## 第二讲 | 典型组合逻辑部件\n\n### 译码器\n\n-   多数入，多输出；通常是$n-2^n$ 型；\n-   最简单的译码器：从$2^n$ 个输出端中，选择一个输出；即，根据输入的数据，\"翻译\"出对应的输出信号。\n-   每一个输出都对应了一个数字逻辑电路，多输出有多个电路，最后将其组合在一起\n\n**应用实例**： 数字灯\n\n1.   输入信号：四位二进制，代表0-9；多出来的几种表示一些字母（图中有）\n\n2.   输出信号：a~g的输出信号，代表 a~g的对应的管子是否亮；\n\n3.   真值表：\n\n     <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250310111606460.png\" style=\"width: 50%\"/>\n\n<center>（多出来的A b C d E F，如果不需要的话，可以当成<em>无关项</em>）</center>\n\n4.   最后可以画卡诺图(以a为例)\n\n![image-20250310112019639](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250310112019639.png)\n\n---\n\n### 编码器\n\n实现$2^n-n$的编码\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250310112417722.png\" style=\"width: 50%\"/>\n\n<center>示意图</center>\n\n\n\n#### 互斥编码器\n\n所有输入端互斥，只能有一个为高电位，其余都是低电位；这一个低电位，映射得到n个输出的结果；\n\n\n\n<div style=\"display:grid; grid-template-columns: 1fr 1fr 1fr;\">\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250310112449336.png\"/>\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250310112458266.png\"/>\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250310112512746.png\"/>\n</div>\n\n<center>真值表是简化的</center>\n\n#### 优先级编码器\n\n-   输入端可以有多个高电位\n-   按照输入端的优先级来决定输出什么\n\n<div style=\"display:grid  ;grid-template-columns: 1fr 1fr\">\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250310113140218.png\"/>\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250310113149719.png\"/>\n</div>\n\n>   真值表 和 示意图\n\n### 多路选择器\n\n-   多个输入，一个输出，通过控制端来决定输出哪个；\n-   输入端和输出端的**位数要一致**；但是，控制端的位数可以和输入输出端不一致；\n\n选择器的实现：\n\n![image-20250310114125426](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250310114125426.png)\n\n<center>1位2路选择器</center>\n\n![image-20250310114250807](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250310114250807.png)\n\n<center>1位4路选择器</center>\n\n多路选择器还可以实现类似门电路的性质：\n\n![image-20250310114759765](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250310114759765.png)\n\n### 多路分配器\n\n将一个输入信号，输出到某一个输出端里面；具体输出到哪个电路，由控制端决定;\n\n**一个输入，多个输出，其中某一些为1**\n\n### 半加器、全加器\n\n#### 半加器 HA （Half Adder） \n\n只考虑加数和被加数，**不考虑低位的进位**；\n$$\nF= A  \\oplus B\n$$\n 当前数字为F\n$$\ncout=A \\cdot B\n$$\n进位为cout\n\n#### 全加器FA （Full Adder)\n\n考虑加数、被加数和低位的进位；\n$$\nF= A  \\oplus B \\oplus Cin\n$$\n含义是，A，B，Cin如果只有一个或者有三个为1，则F为1；\n\n>   在数学中，异或就是模二加法，因此$A \\oplus B \\oplus Cin$就是三个相加对2取模，取模即进位\n\n输出为：\n$$\ncout=A \\cdot B+A \\cdot cin+B \\cdot cin\n$$\n含义是，A，B，Cin如果有两个以上为1，则F为1；\n\n## 第三讲 | 组合逻辑电路的时序分析\n\n#### tpLH和tpHL\n\n**tpLH**是`上升沿电路延时`，从输入信号改变到输出信号由Low变High的时间\n\n**tpHL**是`下降沿电路延时`，从输入信号改变到输出信号由High变Low的时间\n\n![image-20250314100910471](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250314100910471.png)\n\n<center>通常，我们忽略上升下降的过程</center>\n\n#### 传输延迟 和 最小延迟\n\n传输延迟 | Propogation delay `Tpd`：由输入信号改变到**所有**输出端得到**稳定**的信号所需的时间；\n\n最小延迟 | Contamination delay `Tcd`：由输出信号改变到**任何一个**输出信号**开始改变**所需的时间； \n\n关键路径： 从输入端到输出端的**最长路径** ；整个电路的传输延迟的时间即关键路径上所有的元件的**传输延迟之和**\n\n最小路径：电路的最小延迟是最短路径上所有的元件的最小延迟之和\n\n**例子：**\n\n假设每一个逻辑门电路的传输延时和最小延时分别是90ps和60ps；求下面这个电路的传输延迟和最小延迟\n\n<img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250314102739355.png\" alt=\"image-20250314102739355\" style=\"zoom:33%;\" />\n\n1.   关键路径：必须经过3个逻辑门，则tpd=90ps*3=270ps；\n2.   最小延迟：至少经过2个逻辑门，则tcd=60ps*2=120ps；\n\n>   最小延迟只是 有输出信号所需的最小时间，此时**输出的并不是最终稳定的结果**\n\n#### 竞争与冒险\n\n某个输入信号通过多个路径作用到输出端，由于延迟不同，导致输入信号对于输出端造成不同的影响，称为**竞争**\n\n由于竞争，在输入信号发生变化的时候  输出端短时间可能出现不正确的电路信号，称为**毛刺**\n\n有毛刺，称为存在**冒险**\n\n<div style=\"display:grid;grid-template-columns: 1fr 1fr 1fr;\">\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250314103910590.png\"/>\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250314103926203.png\"/>\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250314103936138.png\"/>\n</div>\n\n<center>在A段从高点位变成低电位时出现竞争冒险</center>\n\n**判断出现竞争、冒险**\n\n1.   如果将逻辑表达式固定一个变量，其余变量任取，如果出现$X \\cdot \\overline X$或$X + \\overline X$ 那么存在毛刺\n2.   **如果卡诺图里面任何两个相邻的1没有包含在同一个卡诺圈中**\n\n**消除竞争冒险**\n\n1.   增加冗余项 （在卡诺图中多加几个圈，使得全部相邻的1都被包在一起）\n2.   低通滤波\n\n","categories":["NJUCS","数字逻辑与计算机组成"]},{"title":"排序算法","url":"/posts/f533a447f93c/","content":"\n>   学了这么久的计算机，结果还是只会冒泡排序，是时候做个了解了。\n\n## Bubble sort 冒泡排序\n\n>   We import the pacage 'bits/stdc' and all codes are in the std namespace \n\n```cpp\nvoid bubble_sort(int* arr,int len,bool(*cmp) (int,int)){\n    for(int i=0;i<len-1;i++){\n        for(int j=0;j<len-i-1;j++){\n            if(!cmp(arr[j],arr[j+1])){\n                swap(arr[j],arr[j+1]);\n            }   \n        }\n    }\n}\n```\n\n## Quick sort 快速排序\n\n>   Main idea: Devide and Conquer\n>\n>   We devide the array into three parts: the pivot, the nums that all smaller than the pivots and the nums that are larger than it.\n\n```c++\nint partition(int* arr, int low,int high){\n    int pivot=arr[high];\n    int part_index=low;\n    for(int i=low;i<high;i++){\n        if(arr[i]<=pivot){\n            swap(arr[i],arr[part_index]);\n            part_index++;\n        }        \n    }\n    swap(arr[part_index],arr[high]);\n    return part_index;\n}\n\nvoid quick_sort(int* arr, int low,int high){\n    if(low<high){\n        int part_index=partition(arr,low,high);\n        quick_sort(arr,low,part_index-1);\n        quick_sort(arr,part_index+1,high);\n    }\n}\n```\n","categories":["NJUCS","高级程序设计"]},{"title":"VQA视觉问答系统学习笔记","url":"/posts/1c4c5d57d48c/","content":"\n# VQA 综述阅读：\n\n>   This passage is a reading note of a survey on VQA. Reading the raw passage is recommened:[A Comprehensive Survey on Visual Question Answering Datasets and Algorithms](https://arxiv.org/pdf/2411.11150)\n\n## Abstract:\n\n**Datasets**: We can devide the datasets of VQA into 4 catecories, namely:\n\n•Available datasets that contain a rich collection of authentic images\n•Synthetic datasets that contain only synthetic images produced through artificial means\n•Diagnostic datasets that are specially designed to test model performance in a particular area, e.g., understanding the scene text\n•KB (Knowledge-Based) datasets that are designed to measure a model’s ability to utilize outside knowledge\n\n**Main paradigms**: In this survey, we wlii explore six main paradigms:\n\n-   Fusion is where we discuss different methods of fusing information between visual and textual modalities.\n-    Attention is the technique of using information from one modality to filter information from another. External knowledge base where we discuss different models utilizing outside information.\n-    Composition or Reasoning, where we analyze techniques to answer advanced questions that require complex reasoning steps.\n-    Explanation, which is the process of generating visual and/or textual descriptions to verify\n    sound Reasoning.\n-    Graph models which encode and manipulate relationships through nodes in a graph. \n\nWe also discuss some miscellaneous topics, such as scene text understanding, counting, and bias reduction.\n\n**Problems**: VQA compasses the following questions:\n\n• Object recognition: What is behind the chair?\n• Object detection: Are there any people in the image?\n• Counting: How many dogs are there?\n• Scene classification: Is it raining?\n• Attribute classification: Is the person happy?\n\n## Datasets\n\n### General datasets\n\nGeneral datasets are the largest, richest, and most used datasets in VQA. General datasets contain many thousands of\nreal-world images from mainstream image datasets like MSCOCO [74] and Imagenet [32]. These datasets are notable for\ntheir large scope and diversity. This variety is important as VQA datasets need to reflect the general nature of VQA. Although\nthese datasets do not necessarily capture the endless complexity and variety of visuals in real life, they achieve a close approximation.\n\n![image-20250222220048981](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250222220048981.png)\n\n### Synthetic datasets (虚构的)\n\nSynthetic datasets contain artificial images, produced using software, instead of real images. A good VQA model should\nbe able to perform well on both real and synthetic data like  humans do. Synthetic datasets are easier, less expensive, and\nless time-consuming to produce as the building of a large dataset can be automated. Synthetic datasets can be tailored\nso that performing well on them requires better reasoning and  composition skills.\n\n![image-20250222220150232](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250222220150232.png)\n\n### Dignostic datasets\n\nDiagnostic datasets are specialized in the sense that they test a model’s ability in a particular area. They are usually small in size and are meant to complement larger, more general datasets by diagnosing the model’s performance in a distinct area which may not have pronounced results in the more  general dataset.\n\n![image-20250223085514869](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250223085514869.png)\n\n### KB datasets\n\nSometimes it is not possible to answer a question with  only the information present in the image. In such cases, the required knowledge has to be acquired from external  sources. This is where KB datasets come in. They provide questions that require finding and using external knowledge. KB datasets can teach a model to know when it needs to search for absent knowledge and how to acquire that knowledge.\n\n![image-20250223090140313](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250223090140313.png)\n\n### Evaluation datasets\n\nA model’s performance being correctly evaluated depends on the evaluation metric used. Unfortunately, a major problem of VQA is that there is no widely agreed upon evaluation metric. Many different metrics have been proposed.\n\n## Algoritms\n\n### Image Representation\n\n**1. CNN**\n\n-   When given an input image, a CNN goes through several  convolution and pooling layers to produce a C × W × H shaped output.\n-   Devide the image into grids\n-   Problem: be distracted by noise (could be solved by Attention mechanism); one boject could be devided into multi adjacent blocks. \n\n**2. Object Detection**\n\n-   Example: Fast R-CNN\n\n-   They produce multiple bounding boxes. Each bounding box usually contains an object belonging to a specific object class.\n-   Devide the image into multiple 'bounding box'\n-   Problem: possible information loss (some information that is not in the bounding boxes would be dismissed)\n\n![image-20250223092722130](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250223092722130.png)\n\n​\t\t\t\t\t\t\t\t**CNN(left) and Faster R-CNN(right).**\n\n### Questions Representation\n\nQuestion representation in VQA is usually done by first embedding individual words and then using an RNN or a CNN to produce an embedding of the entire question.\n\n>   Here are the explanations from Grok3:\n>\n>   1.   Take a question like \"What color is the car?\"\n>\n>   2.   **Embed individual words**: Convert each word into a vector using a word embedding technique (e.g., \"What\" → [0.1, 0.3, ...], \"color\" → [0.4, -0.1, ...], etc.).\n>\n>   3.   **Process with an RNN or CNN**:\n>\n>        -   RNN: Feed the vectors in sequence, and the final hidden state is the question embedding.\n>\n>        -   CNN: Apply filters to the sequence, pool the results, and get the question embedding.\n>\n>   4.   The output is a single vector representing the whole question, which the VQA model can then combine with image features to generate an answer.\n\n\n\n### Fusion and Attention\n\nWe will tlk about it in the following part\n\n### Answering\n\nHere’s a quick summary of how \"answering\" works in Visual Question Answering (VQA) based on the \"Answering\" section (D) from the survey’s algorithm part:\n\nIn VQA, answering can be **open-ended** (free-form answers) or **multiple-choice** (choosing from options). There are two main ways to predict answers for open-ended VQA:\n\n1. **Non-Generative Approach** (Most Common):\n   - Treats answers as predefined classes (e.g., all unique answers in the dataset).\n   - Two types:\n     - **Single-Label Classification**: The model predicts one answer by outputting a probability distribution (using softmax) over all possible answers, trained to maximize the probability of the most agreed-upon answer from annotators. It’s simple but ignores multiple valid answers.\n     - **Multi-Label Regression**: The model predicts scores for multiple candidate answers, reflecting how many annotators agreed (e.g., VQA-v1 uses a soft score like `min(# humans agreeing / 3, 1)`). This handles multiple correct answers better. The BUTD model pioneered this by treating it as a regression task, and most modern models follow this approach.\n   - **Pros**: Easy to implement and evaluate.\n   - **Cons**: Can’t predict new answers not seen in training.\n\n2. **Generative Approach**:\n   - Uses an RNN to generate answers word by word.\n   - **Issue**: Hard to evaluate, so it’s rarely used.\n\nFor **Multiple-Choice VQA**:\n- Treated as a ranking problem: The model scores each question-image-answer trio, and the highest-scoring answer wins.\n\n**Answer Representation**:\n\n- Most models use **one-hot vectors** (e.g., [1, 0, 0] for \"dog\") for answers, which is simple but loses semantic meaning—e.g., \"cat\" and \"German Shepherd\" are equally wrong compared to \"dog.\"\n- Some newer approaches embed answers into the same semantic space as questions (like word vectors), turning answering into a regression of answer vectors. This makes \"German Shepherd\" closer to \"dog\" than \"cat,\" improving the model’s understanding and training signal.\n\nIn short, modern VQA answering leans toward multi-label regression for open-ended questions, using soft scores from annotators, while multiple-choice uses ranking. Efforts are ongoing to make answer representations more semantically rich!\n\n### Mutilmodel Fusion\n\nIn order to perform joint reasoning on a QA pair, information from the two modalities have to mix and interact. This can be achieved by multimodal fusion. We divide fusion in VQA into two types, **vector operation** and **bilinear pooling**.\n\n\n\n#### Vector operation\n\nIn vector addition and multiplication, question and image features are projected linearly through fully-connected layers to match their dimensions. \n\n>   Namely: fusion the vector of image and question by vector operation\n\n-   cons: Bad Accuarcy\n\n#### Bilinear pooling\n\n>   The following content is generated by Grok3 for the raw survey is too hard for me.  ಥ_ಥ\n\n**Bilinear Pooling** combines question and image feature vectors (e.g., both 2048-dimensional) by computing their **outer product**, capturing all interactions between them. For an output \\( <z_i \\) (answer score), it’s defined as \\( z_i = x^T W_i y \\), where \\( x \\) is the question vector, \\( y \\) is the image vector, and \\( W \\) is a huge weight tensor. However, with 3000 answer classes, this requires billions of parameters (e.g., 12.5 billion), making it computationally expensive and prone to overfitting. Different models tweak this to balance complexity and performance:\n\n>   1. **MCB (Multimodal Compact Bilinear)**:\n>       - Uses a trick from math: the outer product’s \"count sketch\" can be computed as a convolution of individual sketches.\n>       - Replaces convolution with an efficient element-wise product in FFT space to indirectly get the outer product.\n>       - Still has many parameters due to fixed random settings.\n>\n>   2. **MLB (Multimodal Low-rank Bilinear)**:\n>       - Reduces parameters by decomposing \\( W = U V^T \\), turning \\( z_i = 1^T (U_i^T x \\circ V_i^T y) \\) (where \\( \\circ \\) is element-wise multiplication).\n>       - Limits \\( W \\)’s rank to \\( k \\), cutting complexity, and adds a matrix \\( P_i \\) for further reduction.\n>       - Downside: Slow to train and sensitive to tuning.\n>\n>   3. **MFB (Multimodal Factorized Bilinear)**:\n>       - Tweaks MLB by adjusting \\( U \\) and \\( V \\) dimensions and adding **sum pooling** over windows of size \\( k \\): \\( z = SumPool(U'^T x \\circ V'^T y, k) \\).\n>       - MLB is a special case when \\( k = 1 \\). **MFH** stacks MFBs for richer pooling.\n>\n>   4. **MUTAN (Multimodal Tucker Fusion)**:\n>       - Uses **Tucker decomposition**: \\( W = \\tau_c \\times W_q \\times W_v \\times W_o \\).\n>       - \\( W_q \\) and \\( W_v \\) project question and image vectors, \\( \\tau_c \\) controls interaction complexity, and \\( W_o \\) scores answers.\n>       - MCB and MLB are simpler versions of this.\n>\n>   5. **BLOCK**:\n>       - Uses **block-term decomposition**, balancing MLB (many small blocks, high-dimensional but weak interactions) and MUTAN (one big block, strong interactions but less accurate projections).\n>       - Strikes a middle ground and often performs better.\n\nIn short, bilinear pooling fuses question and image data via their outer product, but raw computation is impractical. These models (MCB, MLB, MFB, MUTAN, BLOCK) reduce parameters in clever ways, trading off expressiveness (how much they capture) and trainability (how easy they are to optimize). Each improves on the last, with BLOCK aiming for the best of both worlds!\n\n### Attention\n\nMake the model to focus on the object that are more relavant to **questions** to filter out noise and imrove accuarcy.\n\n####  Soft and hard attention\n\nBoth of **soft attention** and **hard attention** use the question to make a map, which assigns the objects on the picture to different values--the more relavent, the higher the value is.\n\nBut the difference lies in:\n\n-   **Soft attention**  assigns all the object to a cretain value, do not dismiss any objects;\n-   **Hard attention** discard those with low relavance, and only cares about those relavent to the questions\n\n#### Grid and objct based attention\n\n#### BOTTOM-UP AND TOP-DOWN ATTENTION\n\n#### CO-ATTENTION AND SELF-ATTENTION\n\n>   To get more about these attention machenism, read the raw paper.\n\n### External Knowledge\n\nSometimes the model need more information to solve the problem,int that case, we need to give the model the capability to query an **External Knowledge Base** or **EKB**.\n\n---\n\n\n\n\n\n\n\n","categories":["科研启蒙"]},{"title":"STL容器","url":"/posts/10ae6aa45f17/","content":"有关STL容器的内容\n\n> [!NOTE] 声明\n>  由于~~我实在懒~~ 不小心把自己写的文件给覆盖了，搞得我很不爽，不想再写了于是抄了一份别人的：https://github.com/ChrisKimZHT/Haotian-BiJi/blob/master/150~159/154%E3%80%90%E6%9D%82%E9%A1%B9%E3%80%91%E7%AE%97%E7%AB%9E%E5%B8%B8%E7%94%A8%20C%2B%2B%20STL%20%E7%94%A8%E6%B3%95.md\n\n\n**C++ 标准模板库 (STL, Standard Template Library)**：包含一些常用数据结构与算法的模板的 C++ 软件库。其包含四个组件——算法 (Algorithms)、容器 (Containers)、仿函数 (Functors)、迭代器 (Iterators)。\n\n示例：\n\n- 算法：`sort(a.begin(), a.end())`\n- 容器：`priority_queue<int> pque`\n- 仿函数：`greater<int>()`\n- 迭代器：`vector<int>::iterator it = a.begin()`\n\n# 1 前言\n\nSTL 作为一个封装良好，性能合格的 C++ 标准库，在算法竞赛中运用极其常见。灵活且正确使用 STL 可以节省非常多解题时间，这一点不仅是由于可以直接调用，还是因为它封装良好，可以让代码的可读性变高，解题思路更清晰，调试过程 ~~往往~~ 更顺利。\n\n不过 STL 毕竟使用了很多复杂的结构来实现丰富的功能，它的效率往往是比不上自己手搓针对特定题目的数据结构与算法的。因此，STL 的使用相当于使用更长的运行时间换取更高的编程效率。因此，在实际比赛中要权衡 STL 的利弊，不过这一点就得靠经验了。\n\n接下来，我会分享在算法竞赛中常用的 STL 容器和算法，对于函数和迭代器，就不着重展开讲了。\n\n\n\n# 2 常用容器\n\n## 2.1 内容总览\n\n打勾的是本次将会详细讲解的，加粗的是算法竞赛中有必要学习的。\n\n- 顺序容器\n\n  -  **array**\n\n  -  **vector**\n  -  **deque**\n  -  forward_list\n  -  **list**\n- 关联容器\n\n  -  **set**\n  -  **map**\n  -  **multiset**\n  -  **multimap**\n- 无序关联容器\n\n  -  **unordered_set**\n  -  **unordered_map**\n  -  **unordered_multiset**\n  -  **unordered_multimap**\n- 容器适配器\n\n  -  **stack**\n  -  **queue**\n  -  **priority_queue**\n  -  flat_set\n  -  flat_map\n  -  flat_multiset\n  -  flat_multimap\n- 字符串\n  -  **string** (basic_string\\<char\\>)\n\n- 对与元组\n  -  **pair**\n  -  **tuple**\n\n\n\n\n## 2.2 向量 [vector](https://zh.cppreference.com/w/cpp/container/vector)\n\n**`#include <vector>`**\n\n连续的顺序的储存结构（和数组一样的类别），但是有长度可变的特性。\n\n### 2.2.1 常用方法\n\n#### 构造\n\n**`vector<类型> arr(长度, [初值])`**\n\n时间复杂度：$O(n)$\n\n常用的一维和二维数组构造示例，高维也是一样的（就是会有点长）.\n\n```cpp\nvector<int> arr;         // 构造int数组\nvector<int> arr(100);    // 构造初始长100的int数组\nvector<int> arr(100, 1); // 构造初始长100的int数组，初值为1\n\nvector<vector<int>> mat(100, vector<int> ());       // 构造初始100行，不指定列数的二维数组\nvector<vector<int>> mat(100, vector<int> (666, -1)) // 构造初始100行，初始666列的二维数组，初值为-1\n```\n\n构造二维数组的奇葩写法，千万别用：\n\n```cpp\nvector<int> arr[100];         // 正确，构造初始100行，不指定列数的二维数组，可用于链式前向星存图\nvector<int> arr[100](100, 1); // 语法错误！\nvector<int> arr(100, 1)[100]; // 语法错误！\nvector<int> arr[100] {{100, 1}, 这里省略98个 ,{100, 1}}; // 正确但奇葩，使用列表初始化\n```\n\n#### 尾接 & 尾删\n\n- **`.push_back(元素)`**：在 vector 尾接一个元素，数组长度 $+1$.\n- **`.pop_back()`**：删除 vector 尾部的一个元素，数组长度 $-1$\n\n时间复杂度：均摊 $O(1)$\n\n```cpp\n// init: arr = []\narr.push_back(1);\n// after: arr = [1]\narr.push_back(2);\n// after: arr = [1, 2]\narr.pop_back();\n// after: arr = [1]\narr.pop_back();\n// after: arr = []\n```\n\n#### 中括号运算符\n\n和一般数组一样的作用\n\n时间复杂度：$O(1)$\n\n#### 获取长度\n\n**`.size()`**\n\n获取当前 vector 的长度\n\n时间复杂度：$O(1)$\n\n```cpp\nfor (int i = 0; i < arr.size(); i++)\n    cout << a[i] << endl;\n```\n\n#### 清空\n\n**`.clear()`**\n\n清空 vector\n\n时间复杂度：$O(n)$\n\n#### 判空\n\n**`.empty()`**\n\n如果是空返回 `true` 反之返回 `false`.\n\n时间复杂度：$O(1)$\n\n#### 改变长度\n\n**`.resize(新长度, [默认值])`**\n\n修改 vector 的长度\n\n- 如果是缩短，则删除多余的值\n- 如果是扩大，且指定了默认值，则新元素均为默认值**（旧元素不变）**\n\n时间复杂度：$O(n)$\n\n### 2.2.2 适用情形\n\n一般情况 `vector` 可以替换掉普通数组，除非该题卡常。\n\n有些情况普通数组没法解决：$n\\times m$ 的矩阵，$1\\leq n,m\\leq 10^6$ 且 $n\\times m \\leq 10^6$\n\n- 如果用普通数组 `int mat[1000010][1000010]`，浪费内存，会导致 MLE。\n- 如果使用 `vector<vector<int>> mat(n + 10, vector<int> (m + 10))`，完美解决该问题。\n\n另外，`vector` 的数据储存在堆空间中，不会爆栈。\n\n### 2.2.3 注意事项\n\n#### 提前指定长度\n\n如果长度已经确定，那么应当直接在构造函数指定长度，而不是一个一个 `.push_back()`. 因为 `vector` 额外内存耗尽后的重分配是有时间开销的，直接指定长度就不会出现重分配了。\n\n```cpp\n// 优化前: 522ms\nvector<int> a;\nfor (int i = 0; i < 1e8; i++)\n    a.push_back(i);\n// 优化后: 259ms\nvector<int> a(1e8);\nfor (int i = 0; i < a.size(); i++)\n    a[i] = i;\n```\n\n#### 当心 size_t 溢出\n\nvector 获取长度的方法 `.size()` 返回值类型为 `size_t`，通常 OJ 平台使用的是 32 位编译器（有些平台例如 cf 可选 64 位），那么该类型范围为 $[0,2^{32})$.\n\n```cpp\nvector<int> a(65536);\nlong long a = a.size() * a.size(); // 直接溢出变成0了\n```\n\n## 2.3 栈 [stack](https://zh.cppreference.com/w/cpp/container/stack)\n\n**`#include <stack>`**\n\n通过二次封装双端队列 (deque) 容器，实现先进后出的栈数据结构。\n\n### 2.3.1 常用方法\n\n| 作用                   | 用法              | 示例                 |\n| ---------------------- | ----------------- | -------------------- |\n| 构造                   | `stack<类型> stk` | `stack<int> stk;`    |\n| 进栈                   | `.push(元素)`     | `stk.push(1);`       |\n| 出栈                   | `.pop()`          | `stk.pop();`         |\n| 取栈顶                 | `.top()`          | `int a = stk.top();` |\n| 查看大小 / 清空 / 判空 | 略                | 略                   |\n\n### 2.3.2 适用情形\n\n如果不卡常的话，就可以直接用它而不需要手写栈了。\n\n另外，vector 也可以当栈用，vector 的 `.back()` 取尾部元素，就相当于取栈顶，`.push_back()` 相当于进栈，`.pop_back()` 相当于出栈。\n\n### 2.3.3 注意事项\n\n不可访问内部元素！**下面都是错误用法**\n\n```cpp\nfor (int i = 0; i < stk.size(); i++)\n    cout << stk[i] << endl;\nfor (auto ele : stk)\n    cout << stk << endl;\n```\n\n## 2.4 队列 [queue](https://zh.cppreference.com/w/cpp/container/queue)\n\n**`#include <queue>`**\n\n通过二次封装双端队列 (deque) 容器，实现先进先出的队列数据结构。\n\n### 2.4.1 常用方法\n\n| 作用                   | 用法              | 示例                   |\n| ---------------------- | ----------------- | ---------------------- |\n| 构造                   | `queue<类型> que` | `queue<int> que;`      |\n| 进队                   | `.push(元素)`     | `que.push(1);`         |\n| 出队                   | `.pop()`          | `que.pop();`           |\n| 取队首                 | `.front()`        | `int a = que.front();` |\n| 取队尾                 | `.back()`         | `int a = que.back();`  |\n| 查看大小 / 清空 / 判空 | 略                | 略                     |\n\n### 2.4.2 适用情形\n\n如果不卡常的话，就可以直接用它而不需要手写队列了。\n\n### 2.4.3 注意事项\n\n不可访问内部元素！**下面都是错误用法**\n\n```cpp\nfor (int i = 0; i < que.size(); i++)\n    cout << que[i] << endl;\nfor (auto ele : que)\n    cout << ele << endl;\n```\n\n## 2.5 优先队列 [priority_queue](https://zh.cppreference.com/w/cpp/container/priority_queue)\n\n**`#include <queue>`**\n\n提供常数时间的最大元素查找，对数时间的插入与提取，底层原理是二叉堆。\n\n### 2.5.1 常用方法\n\n#### 构造\n\n**`priority_queue<类型, 容器, 比较器> pque`**\n\n- 类型：要储存的数据类型\n- 容器：储存数据的底层容器，默认为 `vector<类型>`，竞赛中保持默认即可\n- 比较器：比较大小使用的比较器，默认为 `less<类型>`，可自定义\n\n```cpp\npriority_queue<int> pque1;                            // 储存int的大顶堆\npriority_queue<int, vector<int>, greater<int>> pque2; // 储存int的小顶堆\n```\n\n> 对于需要自定义比较器的情况，涉及一些初学时容易看迷糊的语法（重载小括号运算符 / lambda 表达式），在此就不展开讲了。如果想要了解，可以查阅 cppreference 中的代码示例。\n\n#### 其他\n\n| 作用            | 用法          | 示例                 |\n| --------------- | ------------- | -------------------- |\n| 进堆            | `.push(元素)` | `que.push(1);`       |\n| 出堆            | `.pop()`      | `que.pop();`         |\n| 取堆顶          | `.top()`      | `int a = que.top();` |\n| 查看大小 / 判空 | 略            | 略                   |\n\n进出队复杂度 $O(\\log n)$，取堆顶 $O(1)$.\n\n### 2.5.2 适用情形\n\n持续维护元素的有序性：每次向队列插入大小不定的元素，或者每次从队列里取出大小最小/最大的元素，元素数量 $n$，插入操作数量 $k$.\n\n- 每次插入后进行快速排序：$k\\cdot n\\log n$\n- 使用优先队列维护：$k\\cdot\\log n$\n\n### 2.5.3 注意事项\n\n#### 仅堆顶可读\n\n只可访问堆顶，其他元素都无法读取到。**下面是错误用法：**\n\n```cpp\ncout << pque[1] << endl;\n```\n\n#### 所有元素不可写\n\n堆中所有元素是不可修改的。**下面是错误用法：**\n\n```cpp\npque[1] = 2;\npque.top() = 1;\n```\n\n如果你恰好要修改的是堆顶元素，那么是可以完成的：\n\n```cpp\nint tp = pque.top();\npque.pop();\npque.push(tp + 1);\n```\n\n\n\n### 2.5.4 优先队列自定义排序：\n\n[C++ | priority_queue的用法（含自定义排序方式） - 山竹小果 - 博客园](https://www.cnblogs.com/shona/p/12163381.html)\n\npriority_quene接收三个参数，存储数据类型，容器类型，比较函数类型；\n\n如果没有显式地给出后两个参数，那么默认是采用vector作为容器，从top处递减的极大堆；\n\n如果想要生成递增的队列：\n\n```cpp\npriority_quene<int,vector<int>, greater<int>>pq;\n```\n\n如果是自定义的数据类型，或者想要一个更加复杂的自定义排序规则，那么就要自定义搞一个排序函数的类型。\n\n1.   定义一个struct:\n\n```cpp\nstruct Compare {\n    bool operator()(const Task& a, const Task& b) {\n        return a.priority > b.priority; // 最小堆\n    }\n};\n// 声明时无需传入对象（使用默认构造）\nstd::priority_queue<Task, std::vector<Task>, Compare> pq;\n```\n\n2.   使用decltype（全称：declare type）\n\n>   Lambda 表达式本身是一个对象（实例），而 `priority_queue` 的模板参数需要的是一个**类型**，不是对象。\n\n```cpp\nauto cmp = [](const Task& a, const Task& b) { return a.priority > b.priority; };\n// 必须传入 Lambda 对象，且类型用 decltype 推导\nstd::priority_queue<Task, std::vector<Task>, decltype(cmp)> pq(cmp);\n```\n\n\n\n## 2.6 集合 [set](https://zh.cppreference.com/w/cpp/container/set)\n\n**`#include <set>`**\n\n提供对数时间的插入、删除、查找的集合数据结构。底层原理是红黑树。\n\n| 集合三要素 | 解释                           | set           | multiset      | unordered_set |\n| ---------- | ------------------------------ | ------------- | ------------- | ------------- |\n| 确定性     | 一个元素要么在集合中，要么不在 | ✔             | ✔             | ✔             |\n| 互异性     | 一个元素仅可以在集合中出现一次 | ✔             | ❌（任意次）   | ✔             |\n| 无序性     | 集合中的元素是没有顺序的       | ❌（从小到大） | ❌（从小到大） | ✔             |\n\n### 2.6.1 常用方法\n\n#### 构造\n\n**`set<类型, 比较器> st`**\n\n- 类型：要储存的数据类型\n- 比较器：比较大小使用的比较器，默认为 `less<类型>`，可自定义\n\n```cpp\nset<int> st1;               // 储存int的集合（从小到大）\nset<int, greater<int>> st2; // 储存int的集合（从大到小）\n```\n\n> 对于需要自定义比较器的情况，涉及一些初学时容易看迷糊的语法（重载小括号运算符 / lambda 表达式），在此就不展开讲了。\n\n#### 遍历\n\n可使用迭代器进行遍历：\n\n```cpp\nfor (set<int>::iterator it = st.begin(); it != st.end(); ++it)\n    cout << *it << endl;\n```\n\n基于范围的循环（C++ 11）：\n\n```cpp\nfor (auto &ele : st)\n    cout << ele << endl;\n```\n\n#### 其他\n\n| 作用                   | 用法            | 示例                    |\n| ---------------------- | --------------- | ----------------------- |\n| 插入元素               | `.insert(元素)` | `st.insert(1);`         |\n| 删除元素               | `.erase(元素)`  | `st.erase(2);`          |\n| 查找元素               | `.find(元素)`   | `auto it = st.find(1);` |\n| 判断元素是否存在       | `.count(元素)`  | `st.count(3);`          |\n| 查看大小 / 清空 / 判空 | 略              | 略                      |\n\n增删查时间复杂度均为 $O(\\log n)$\n\n### 2.6.2 适用情形\n\n- 元素去重：$[1,1,3,2,4,4]\\to[1,2,3,4]$\n- 维护顺序：$[1,5,3,7,9]\\to[1,3,5,7,9]$\n- 元素是否出现过：元素大小 $[-10^{18},10^{18}]$，元素数量 $10^6$，vis 数组无法实现，通过 set 可以完成。\n\n### 2.6.3 注意事项\n\n#### 不存在下标索引\n\nset 虽说可遍历，但仅可使用迭代器进行遍历，它不存在下标这一概念，无法通过下标访问到数据。**下面是错误用法：**\n\n```cpp\ncout << st[0] << endl;\n```\n\n#### 元素只读\n\nset 的迭代器取到的元素是只读的（因为是 const 迭代器），不可修改其值。如果要改，需要先 erase 再 insert. **下面是错误用法：**\n\n```cpp\ncout << *st.begin() << endl; // 正确。可读。\n*st.begin() = 1;             // 错误！不可写！\n```\n\n#### 不可用迭代器计算下标\n\nset 的迭代器不能像 vector 一样相减得到下标。**下面是错误用法：**\n\n```cpp\nauto it = st.find(2);      // 正确，返回2所在位置的迭代器。\nint idx = it - st.begin(); // 错误！不可相减得到下标。\n```\n\n## 2.7 映射 [map](https://zh.cppreference.com/w/cpp/container/map)\n\n**`#include <map>`**\n\n提供对数时间的有序键值对结构。底层原理是红黑树。\n\n映射：\n$$\n\\begin{matrix}\n1&\\to&2\\\\\n2&\\to&2\\\\\n3&\\to&1\\\\\n4&\\to&5\\\\\n&\\vdots\n\\end{matrix}\n$$\n\n| 性质   | 解释                         | map           | multimap      | unordered_map |\n| ------ | ---------------------------- | ------------- | ------------- | ------------- |\n| 互异性 | 一个键仅可以在映射中出现一次 | ✔             | ❌（任意次）   | ✔             |\n| 无序性 | 键是没有顺序的               | ❌（从小到大） | ❌（从小到大） | ✔             |\n\n### 2.7.1 常用方法\n\n#### 构造\n\n**`map<键类型, 值类型, 比较器> mp`**\n\n- 键类型：要储存键的数据类型\n- 值类型：要储存值的数据类型\n- 比较器：键比较大小使用的比较器，默认为 `less<类型>`，可自定义\n\n```cpp\nmap<int, int> mp1;               // int->int 的映射（键从小到大）\nmap<int, int, greater<int>> st2; // int->int 的映射（键从大到小）\n```\n\n> 对于需要自定义比较器的情况，涉及一些初学时容易看迷糊的语法（重载小括号运算符 / lambda 表达式），在此就不展开讲了。\n\n#### 遍历\n\n可使用迭代器进行遍历：\n\n```cpp\nfor (map<int, int>::iterator it = mp.begin(); it != mp.end(); ++it)\n    cout << it->first << ' ' << it->second << endl;\n```\n\n基于范围的循环（C++ 11）：\n\n```cpp\nfor (auto &pr : mp)\n    cout << pr.first << ' ' << pr.second << endl;\n```\n\n结构化绑定 + 基于范围的循环（C++17）：\n\n```cpp\nfor (auto &[key, val] : mp)\n    cout << key << ' ' << val << endl;\n```\n\n#### 其他\n\n| 作用                   | 用法           | 示例                    |\n| ---------------------- | -------------- | ----------------------- |\n| 增 / 改 / 查元素       | 中括号         | `mp[1] = 2;`            |\n| 查元素（返回迭代器）   | `.find(元素)`  | `auto it = mp.find(1);` |\n| 删除元素               | `.erase(元素)` | `mp.erase(2);`          |\n| 判断元素是否存在       | `.count(元素)` | `mp.count(3);`          |\n| 查看大小 / 清空 / 判空 | 略             | 略                      |\n\n增删改查时间复杂度均为 $O(\\log n)$\n\n### 2.7.2 适用情形\n\n需要维护映射的场景可以使用：输入若干字符串，统计每种字符串的出现次数。(`map<string, int> mp`)\n\n### 2.7.3 注意事项\n\n#### 中括号访问时默认值\n\n如果使用中括号访问 map 时对应的键不存在，那么会新增这个键，并且值为默认值，因此中括号会影响键的存在性。\n\n```cpp\nmap<char, int> mp;\ncout << mp.count('a') << endl; // 0\nmp['a'];                       // 即使什么都没做，此时mp['a']=0已经插入了\ncout << mp.count('a') << endl; // 1\ncout << mp['a'] << endl;       // 0\n```\n\n#### 不可用迭代器计算下标\n\nmap 的迭代器不能像 vector 一样相减得到下标。**下面是错误用法：**\n\n```cpp\nauto it = mp.find('a');      // 正确，返回2所在位置的迭代器。\nint idx = it - mp.begin();   // 错误！不可相减得到下标。\n```\n\n## 2.8 字符串 [string](https://zh.cppreference.com/w/cpp/string)\n\n**`#include <string>`**\n\n顾名思义，就是储存字符串的。\n\n### 2.8.1 常用方法\n\n#### 构造\n\n构造函数：`string(长度, 初值)`\n\n```cpp\nstring s1;           // 构造字符串，为空\nstring s2 = \"awa!\";  // 构造字符串，并赋值awa!\nstring s3(10, '6');  // 构造字符串，通过构造函数构造为6666666666\n```\n\n#### 输入输出\n\nC++\n\n```cpp\nstring s;\ncin >> s;\ncout << s;\n```\n\nC\n\n```cpp\nstring s;\nchar buf[100];\nscanf(\"%s\", &buf);\ns = buf;\nprintf(\"%s\", s.c_str());\n```\n\n#### 其他\n\n| 作用                   | 用法                          | 示例                            |\n| ---------------------- | ----------------------------- | ------------------------------- |\n| 修改、查询指定下标字符 | `[]`                          | `s[1] = 'a';`                   |\n| 是否相同               | `==`                          | `if (s1 == s2) ...`             |\n| 字符串连接             | `+`                           | `string s = s1 + s2;`           |\n| 尾接字符串             | `+=`                          | `s += \"awa\";`                   |\n| 取子串                 | `.substr(起始下标, 子串长度)` | `string sub = s.substr(2, 10);` |\n| 查找字符串             | `.find(字符串, 起始下标)`     | `int pos = s.find(\"awa\");`      |\n\n#### 数值与字符串互转（C++11）\n\n| 源                                             | 目的        | 函数        |\n| ---------------------------------------------- | ----------- | ----------- |\n| int / long long / float / double / long double | string      | to_string() |\n| string                                         | int         | stoi()      |\n| string                                         | long long   | stoll()     |\n| string                                         | float       | stof()      |\n| string                                         | double      | stod()      |\n| string                                         | long double | stold()     |\n\n### 2.8.2 适用情形\n\n非常好用！~~建议直接把字符数组扔了，赶快投入 string 的怀抱。~~\n\n### 2.8.3 注意事项\n\n#### 尾接字符串一定要用 `+=`\n\nstring 的 += 运算符，将会在原字符串原地尾接字符串。而 + 了再 = 赋值，会先生成一个临时变量，在复制给 string.\n\n通常字符串长度可以很长，如果使用 + 字符串很容易就 TLE 了。\n\n```cpp\n// 优化前: 15139ms\nstring s;\nfor (int i = 0; i < 5e5; i++)\n    s = s + \"a\";\n\n// 优化后: < 1ms (计时器显示0)\nstring s;\nfor (int i = 0; i < 5e5; i++)\n    s += \"a\";\n```\n\n#### `.substr()` 方法的奇葩参数\n\n一定要注意，C++ string 的取子串的第一个参数是**子串起点下标**，第二个参数是**子串长度**。\n\n第二个参数不是子串终点！不是子串终点！要与 java 等其他语言区分开来。\n\n#### `.find()` 方法的复杂度\n\n该方法实现为暴力实现，时间复杂度为 $O(n^2)$.\n\n~~不要幻想 STL 内置了个 $O(n)$ 的 KMP 算法~~\n\n## 2.9 二元组 [pair](https://zh.cppreference.com/w/cpp/utility/pair)\n\n**`#include <utility>`**\n\n顾名思义，就是储存二元组的。\n\n### 2.9.1 常用方法\n\n#### 构造\n\n**`pair<第一个值类型, 第二个值类型> pr`**\n\n- 第一个值类型：要储存的第一个值的数据类型\n- 第二个值类型：要储存的第二个值的数据类型\n\n```cpp\npair<int, int> p1;\npair<int, long long> p2;\npair<char, int> p3;\n// ...\n```\n\n#### 赋值\n\n老式\n\n```cpp\npair<int, char> pr = make_pair(1, 'a');\n```\n\n列表构造 C++11\n\n```cpp\npair<int, char> pr = {1, 'a'};\n```\n\n#### 取值\n\n直接取值\n\n- 取第一个值：`.first`\n- 取第二个值：`.second`\n\n```cpp\npair<int, char> pr = {1, 'a'};\nint awa = pr.first;\nchar bwb = pr.second;\n```\n\n结构化绑定 C++17\n\n```cpp\npair<int, char> pr = {1, 'a'};\nauto &[awa, bwb] = pr;\n```\n\n#### 判同\n\n直接用 `==` 运算符\n\n```cpp\npair<int, int> p1 = {1, 2};\npair<int, int> p2 = {1, 3};\nif (p1 == p2) { ... } // false\n```\n\n### 2.9.2 适用场景\n\n所有需要二元组的场景均可使用，效率和自己定义结构体差不多。\n\n### 2.9.3 注意事项\n\n无\n\n\n\n# 3 迭代器简介\n\n## 3.1 迭代器是什么？\n\n不搞抽象，直接举例。\n\n对于一个 vector，我们可以用下标遍历：\n\n```cpp\nfor (int i = 0; i < a.size(); i++)\n    cout << a[i] << endl;\n```\n\n我们同时也可以用迭代器来遍历：\n\n```cpp\nfor (vector<int>::iterator it = a.begin(); it != a.end(); ++it)\n    cout << *it << endl;\n```\n\n- `a.begin()` 是一个迭代器，指向的是第一个元素\n- `a.end()` 是一个迭代器，指向的是最后一个元素**再后面一位**\n- 上述迭代器具有自增运算符，自增则迭代器向下一个元素移动\n- 迭代器与指针相似，如果对它使用解引用运算符，即 `*it`，就能取到对应值了\n\n## 3.2 为何需要迭代器？\n\n很多数据结构并不是线性的（例如红黑树），对于非线性数据结构，下标是无意义的。无法使用下标来遍历整个数据结构。\n\n迭代器的作用就是定义某个数据结构的遍历方式，通过迭代器的增减，代表遍历到的位置，通过迭代器便能成功遍历非线性结构了。\n\n例如，set 的实现是红黑树，我们是没法用下标来访问元素的。但是通过迭代器，我们就能遍历 set 中的元素了：\n\n```cpp\nfor (set<int>::iterator it = st.begin(); it != st.end(); ++it)\n    cout << *it << endl;\n```\n\n## 3.3 迭代器用法\n\n对于 vector 容器，它的迭代器功能比较完整，以它举例：\n\n- `.begin()`：头迭代器\n- `.end()`：尾迭代器\n- `.rbegin()`：反向头迭代器\n- `.rend()`：反向尾迭代器\n- 迭代器 `+` 整型：将迭代器向后移动\n- 迭代器 `-` 整型：将迭代器向前移动\n- 迭代器 `++`：将迭代器向后移动 1 位\n- 迭代器 `--`：将迭代器向前移动 1 位\n- 迭代器 `-` 迭代器：两个迭代器的距离\n- `prev(it)`：返回 it 的前一个迭代器\n- `next(it)`：返回 it 的后一个迭代器\n\n对于其他容器，由于其结构特性，上面的功能不一定都有（例如 set 的迭代器是不能相减求距离的）\n\n## 3.4 常见问题\n\n**`.end()` 和 `.rend()` 指向的位置是无意义的值**\n\n对于一个长度为 10 的数组：`for (int i = 0; i < 10; i++)`，第 10 位是不可访问的\n\n对于一个长度为 10 的容器：`for (auto it = a.begin(); it != a.end(); ++it)`，.end 是不可访问的\n\n**不同容器的迭代器功能可能不一样**\n\n迭代器细化的话有正向、反向、双向，每个容器的迭代器支持的运算符也可能不同，因此不同容器的迭代器细节很有可能是不一样的。\n\n**删除操作时需要警惕**\n\n为什么 3 没删掉？\n\n```cpp\nvector<int> a{1, 2, 3, 4};\nfor (auto it = a.begin(); it != a.end(); ++it)\n    if (*it == 2 || *it == 3)\n        a.erase(it);\n// a = [1, 3, 4]\n```\n\n为啥 RE 了？\n\n```cpp\nvector<int> a{1, 2, 3, 4};\nfor (auto it = a.begin(); it != a.end(); ++it)\n    if (*it == 4)\n        a.erase(it);\n```\n\n<center><b>建议：如无必要，别用迭代器操作容器。（遍历与访问没关系）</b></center>\n\n\n\n# 4 常用算法\n\n## 4.1 内容总览\n\n打勾的是本次将会详细讲解的，其他的是算法竞赛中建议学习的，不在下表列出的在比赛中基本用不到。\n\n（很多函数的功能很简单，自己都能快速写出来，但是使用函数可以让代码可读性变得更高，这在比赛中是至关紧要的）\n\n- 算法库 Algorithm\n\n  -  `count()`\n  -  `find()`\n  -  `fill()`\n  -  [`swap()`](https://zh.cppreference.com/w/cpp/algorithm/swap)\n  -  [`reverse()`](https://zh.cppreference.com/w/cpp/algorithm/reverse)\n  -  `shuffle()` C++11\n  -  [`unique()`](https://zh.cppreference.com/w/cpp/algorithm/unique)\n  -  [`sort()`](https://zh.cppreference.com/w/cpp/algorithm/sort)\n  -  [`lower_bound()`](https://zh.cppreference.com/w/cpp/algorithm/lower_bound) / [`upper_bound()`](https://zh.cppreference.com/w/cpp/algorithm/upper_bound)\n  -  [`max()`](https://zh.cppreference.com/w/cpp/algorithm/max) / [`min()`](https://zh.cppreference.com/w/cpp/algorithm/min)\n  -  `max_element()` / `min_element()`\n  -  `prev_permutation()` / `next_permutation()`\n- 数学函数 cmath\n  -  [`abs()`](https://zh.cppreference.com/w/cpp/numeric/math/fabs)\n  -  [`exp()`](https://zh.cppreference.com/w/cpp/numeric/math/exp)\n  -  [`log()`](https://zh.cppreference.com/w/cpp/numeric/math/log) / `log10()` / `log2()`\n  -  [`pow()`](https://zh.cppreference.com/w/cpp/numeric/math/pow)\n  -  [`sqrt()`](https://zh.cppreference.com/w/cpp/numeric/math/sqrt)\n  -  `sin()` / `cos()` / `tan()`\n  -  `asin()` / `acos()` / `atan()`\n  -  `sinh()` / `cosh()` / `tanh()`\n  -  `asinh()` / `acosh()` / `atanh()` C++11\n  -  [`ceil()`](https://zh.cppreference.com/w/cpp/numeric/math/ceil) / [`floor()`](https://zh.cppreference.com/w/cpp/numeric/math/floor)\n  -  [`round()`](https://zh.cppreference.com/w/cpp/numeric/math/round) C++11\n- 数值算法 numeric\n  -  `iota()` C++11\n  -  `accumulate()`\n  -  [`gcd()`](https://zh.cppreference.com/w/cpp/numeric/gcd) C++17\n  -  [`lcm()`](https://zh.cppreference.com/w/cpp/numeric/lcm) C++17\n- 伪随机数生成 random\n  -  `mt19937`\n  -  `random_device()`\n\n## 4.2 `swap()`\n\n交换两个变量的值\n\n**用法示例**\n\n```cpp\ntemplate< class T >\nvoid swap( T& a, T& b );\n```\n\n```cpp\nint a = 0, b = 1;\nswap(a, b);\n// now a = 1, b = 0\n\nint arr[10] {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\nswap(arr[4], arr[6]);\n// now arr = {0, 1, 2, 3, 6, 5, 4, 7, 8, 9}\n```\n\n**注意事项**\n\n这个 swap 参数是引用的，不需要像 C 语言一样取地址。\n\n## 4.3 `sort()`\n\n使用快速排序给一个可迭代对象排序\n\n**用法示例**\n\n```cpp\ntemplate< class RandomIt, class Compare >\nvoid sort( RandomIt first, RandomIt last, Compare comp );\n```\n\n默认排序从小到大\n\n```cpp\nvector<int> arr{1, 9, 1, 9, 8, 1, 0};\nsort(arr.begin(), arr.end());\n// arr = [0, 1, 1, 1, 8, 9, 9]\n```\n\n如果要从大到小，则需要传比较器进去。\n\n```cpp\nvector<int> arr{1, 9, 1, 9, 8, 1, 0};\nsort(arr.begin(), arr.end(), greater<int>());\n// arr = [9, 9, 8, 1, 1, 1, 0]\n```\n\n如果需要完成特殊比较，则需要手写比较器。\n\n比较器函数返回值是 bool 类型，传参是需要比较的两个元素。记我们定义的该比较操作为 $\\star$：\n\n- 若 $a\\star b$，则比较器函数应当返回 `true`\n- 若 $a\\not\\star b$，则比较器函数应当返回 `false`\n\n**注意：**如果 $a=b$，比较器函数必须返回 `false`\n\n```cpp\nbool cmp(pair<int, int> a, pair<int, int> b)\n{\n    if (a.second != b.second)\n        return a.second < b.second;\n    return a.first > b.first;\n}\n\nint main()\n{\n    vector<pair<int, int>> arr{{1, 9}, {2, 9}, {8, 1}, {0, 0}};\n\tsort(arr.begin(), arr.end(), cmp);\n    // arr = [(0, 0), (8, 1), (2, 9), (1, 9)]\n}\n```\n\n## 4.4 `lower_bound()` / `upper_bound()`\n\n在**已升序排序**的元素中，应用二分查找检索指定元素，返回对应元素迭代器位置。**找不到则返回尾迭代器。**\n\n- `lower_bound()`: 寻找 $\\geq x$ 的第一个元素的位置\n- `upper_bound()`: 寻找 $>x$ 的第一个元素的位置\n\n怎么找 $\\leq x$ / $< x$ 的第一个元素呢？\n\n- $>x$ 的第一个元素的前一个元素（如果有）便是 $\\leq x$ 的第一个元素\n- $\\geq x$ 的第一个元素的前一个元素（如果有）便是 $<x$ 的第一个元素\n\n返回的是迭代器，如何转成下标索引呢？减去头迭代器即可。\n\n**用法示例**\n\n```cpp\ntemplate< class ForwardIt, class T >\nForwardIt lower_bound( ForwardIt first, ForwardIt last, const T& value );\n```\n\n```cpp\nvector<int> arr{0, 1, 1, 1, 8, 9, 9};\nvector<int>::iterator it = lower_bound(arr.begin(), arr.end(), 7);\nint idx = it - arr.begin();\n// idx = 4\n```\n\n我们通常写成一行：\n\n```cpp\nvector<int> arr{0, 1, 1, 1, 8, 9, 9};\nidx = lower_bound(arr.begin(), arr.end(), 7) - arr.begin(); // 4\nidx = lower_bound(arr.begin(), arr.end(), 8) - arr.begin(); // 4\nidx = upper_bound(arr.begin(), arr.end(), 7) - arr.begin(); // 4\nidx = upper_bound(arr.begin(), arr.end(), 8) - arr.begin(); // 5\n```\n\n**找出区间内的元素**\n\n```cpp\nint main(){\n    int len=10;\n    int arr[len]={9,8,7,7,6,5,4,3,3,0};\n    mySort(arr,0,len-1);\n    cout<<\"[3,7]\"<<\": \";\n    int left1=lower_bound(arr,arr+len,3)-arr;\n    int right1=upper_bound(arr,arr+len,7)-arr-1;\n    print(arr,left1,right1);\n    cout<<\"[3,7)\"<<\": \";\n    int left2=lower_bound(arr,arr+len,3)-arr;\n    int right2=lower_bound(arr,arr+len,7)-arr-1;\n    print(arr,left2,right2);\n    cout<<\"(3,7]\"<<\": \";\n    int left4=upper_bound(arr,arr+len,3)-arr;\n    int right4=upper_bound(arr,arr+len,7)-arr-1;\n    print(arr,left4,right4);\n    cout<<\"(3,7)\"<<\": \";\n    int left3=upper_bound(arr,arr+len,3)-arr;\n    int right3=lower_bound(arr,arr+len,7)-arr-1;\n    print(arr,left3,right3);\n    return 0;\n}\n//输出：\n/*\n[3,7]: 3 3 4 5 6 7 7 \n[3,7): 3 3 4 5 6\n(3,7]: 4 5 6 7 7\n(3,7): 4 5 6\n*/\n```\n\n\n\n## 4.5 `reverse()`\n\n反转一个可迭代对象的元素顺序\n\n**用法示例**\n\n```cpp\ntemplate< class BidirIt >\nvoid reverse( BidirIt first, BidirIt last );\n```\n\n```cpp\nvector<int> arr(10);\niota(arr.begin(), arr.end(), 1);\n// 1, 2, 3, 4, 5, 6, 7, 8, 9, 10\nreverse(arr.begin(), arr.end());\n// 10, 9, 8, 7, 6, 5, 4, 3, 2, 1\n```\n\n## 4.6 `max()` / `min()`\n\n返回最大值 / 最小值的**数值**\n\n**用法示例**\n\n```cpp\nint mx = max(1, 2); // 2\nint mn = min(1, 2); // 1\n```\n\n在 C++11 之后，可以使用列表构造语法传入一个列表，这样就能一次性给多个元素找最大值而不用套娃了：\n\n```cpp\n// Before C++11\nint mx = max(max(1, 2), max(3, 4)); // 4\nint mn = min(min(1, 2), min(3, 4)); // 1\n\n// After C++11\nint mx = max({1, 2, 3, 4}); // 4\nint mn = min({1, 2, 3, 4}); // 1\n```\n\n## 4.7 `unique()`\n\n消除数组的重复**相邻**元素，数组长度不变，但是有效数据缩短，返回的是有效数据位置的结尾迭代器。\n\n例如：$[1,1,4,5,1,4]\\to[1,4,5,1,4,\\underline?]$，下划线位置为返回的迭代器指向。\n\n```cpp\ntemplate< class ForwardIt >\nForwardIt unique( ForwardIt first, ForwardIt last );\n```\n\n**用法示例**\n\n单独使用 unique 并不能达成去重效果，因为它只消除**相邻**的重复元素。但是如果序列有序，那么它就能去重了。\n\n但是它去重后，序列尾部会产生一些无效数据：$[1,1,2,4,4,4,5]\\to[1,2,4,5,\\underline?,?,?]$，为了删掉这些无效数据，我们需要结合 erase.\n\n最终，给 vector 去重的写法便是：\n\n```cpp\nvector<int> arr{1, 2, 1, 4, 5, 4, 4};\nsort(arr.begin(), arr.end());\narr.erase(unique(arr.begin(), arr.end()), arr.end());\n```\n\n## 4.8 数学函数\n\n所有函数参数均支持 `int` / `long long` / `float` / `double` / `long double`\n\n| 公式                    | 示例         |\n| ----------------------- | ------------ |\n| $f(x)=\\lvert x\\rvert$   | `abs(-1.0)`  |\n| $f(x)=e^x$              | `exp(2)`     |\n| $f(x)=\\ln x$            | `log(3)`     |\n| $f(x,y)=x^y$            | `pow(2, 3)`  |\n| $f(x)=\\sqrt x$          | `sqrt(2)`    |\n| $f(x)=\\lceil x\\rceil$   | `ceil(2.1)`  |\n| $f(x)=\\lfloor x\\rfloor$ | `floor(2.1)` |\n| $f(x)=\\left<x\\right>$   | `rount(2.1)` |\n\n**注意事项**\n\n由于浮点误差，有些的数学函数的行为可能与预期不符，导致 WA。如果你的操作数都是整型，那么用下面的写法会更稳妥。\n\n> 原文地址：https://codeforces.com/blog/entry/107717\n\n- $\\lfloor\\frac{a}{b}\\rfloor$\n  - 别用：`floor(1.0 * a / b)`\n  - 要用：`a / b`\n- $\\lceil\\frac{a}{b}\\rceil$\n  - 别用：`ceil(1.0 * a / b)`\n  - 要用：`(a + b - 1) / b`  （$\\lceil\\frac{a}{b}\\rceil=\\lfloor\\frac{a+b-1}{b}\\rfloor$）\n- $\\lfloor\\sqrt a\\rfloor$\n  - 别用：`(int) sqrt(a)`\n  - 要用：二分查找 https://io.zouht.com/7.html\n- $a^b$\n  - 别用：`pow(a, b)`\n  - 要用：快速幂 https://io.zouht.com/18.html\n- $\\lfloor\\log_2 a\\rfloor$\n  - 别用：`log2(a)`\n  - 要用：`__lg` （不规范，但是这是竞赛）/ `bit_width`（C++20 可用）\n\n## 4.9 `gcd()` / `lcm()`\n\n（C++17）返回最大公因数 / 最小公倍数\n\n```cpp\nint x = gcd(8, 12); // 4\nint y = lcm(8, 12); // 24\n```\n\n如果不是 C++17，但是是 GNU 编译器（g++），那么可以用内置函数 `__gcd()`.\n\n当然，`gcd` / `lcm` 函数也挺好写，直接写也行（欧几里得算法）：\n\n```cpp\nint gcd(int a, int b)\n{\n    if (!b)\n        return a;\n    return gcd(b, a % b);\n}\n\nint lcm(int a, int b)\n{\n    return a / gcd(a, b) * b;\n}\n```\n\n","categories":["NJUCS","高级程序设计"]},{"url":"/posts/4e7138798b53/","content":"\n# class\n\n## 定义类&创建实例\n\n```cpp\nclass Car{\n    public:\n    \tstring owner;\n  \t\tvoid setOwner(string name){\n\t\t\twoner=name\n        \t};\n};\n//记得分号\nCar Model_Y;\n//创建一个Car的实例\nModel_Y.setOwner('yama');\ncout<<Model_Y.owner<<endl;\n//output: Model_Y \n```\n\n## 类访问修饰符\n\n### 1. public：\n\n可以在class的外部被访问\n\n### 2. private:\n\n只能在class的内部或者通过友元函数访问；**不能在派生类中被访问！！**\n\n>   如果您没有使用任何访问修饰符，类的成员将被假定为私有成员：\n\n### 3. protected:\n\n只能在class的**内部**或者在子类的**内部**访问；也可被友元函数访问。\n\n---\n\n### 实例：\n\n```c++\n#include<bits/stdc++.h>\nusing namespace std;\nclass Test{\n    public:\n    int a=0;\n    double b=1;\n    int  getPrivate(){\n        return c;\n    }\n    private:\n    int c=2;\n    double d=4;\n    protected:\n    char ch='k';\n};\n//可以直接获取并修改到这里的的public成员，但是private和protected不能够直接通过实例获取到。\n\nclass sonClass: public Test{\n    //采取public继承，有三种继承分别是public, private（by default）, protected.\n    public: \n    char getFatherProtected(){\n        return ch;\n    }\n};\nint main(){\n    sonClass son;\n    Test t;\n    cout<<t.a<<\" \"<<t.b<<\" \"<<t.getPrivate()<<endl;\n    cout<<son.a<<\" \"<<son.b<<\" \"<<son.getFatherProtected();\n}\n```\n\n>   注意\n>\n>   1.   protected和private无论在什么时候都不可以在类的外面通过实例直接访问到，如'instance.a'。\n>   2.   protected中的成员可以在类和子类的内部访问。所谓内部访问其实就是只有在这个类的成员函数中才可以访问。\n>   3.   private中的成员只有自己类和友元函数可以访问到。\n>   4.   protected中的成员当然也可以被友元函数和友元\n\n---\n\n## 友元函数和友元类\n\n友元函数在类的内部声明，但是并不是类的私有方法；友元函数可以访问private和protected的成员。\n\n```cpp\nclass Car{\n    public:\n    string company=\"Tesla\";\n    void changeOwner(stirng newOwner){\n        owner=newOwner;\n    }\n    private:\n    string owner=\"yama\";\n    friend friendFunction(Car &car)；\n    //友元函数可以访问到这里的private和protected方法\n      friend class XiaomiCar;\n    protected:\n    string type=\"Model Y\"; \n};\n\nfriendFunction(Car &car){\n\tcout<<car.owner<<endl; \n}\n\nclass XiaomiCar{\n    pubilc:\n  \tvoid getOwner(){\n\treutrn owner;\n    }\n    //友元类空访问所有的成员\n}\n```\n\n## Inheritance\n\n继承使得derived class获得base class的非private的properties和methods。\n\n三种继承方式: 1. public 2. private 3. protected\n\n### Public Inheritance\n\n完全不变，public在derived class里面依旧是public；protected依旧是protected.\n\n### Private Inheritance\n\npublic和protected都变成private，只能在类的内部访问，这也是默认的继承方式。\n\n### Protected Inheritance\n\npublic变成protected\n\n>   **无论哪种继承方式，都只改变原来类的protected和public的properties与methods；而private始终不变**\n\n![image-20250126222042198](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250126222042198.png)\n\n## 操作符重载\n\n重载的操作符要在public中定义\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nclass Complex{\n\n    public:\n    int real=0;\n    int imaginary=0;\n    Complex(int r, int m){\n        real=r;\n        imaginary=m;\n    }\n    Complex operator+(Complex& other){\n        return Complex(this->real+other.real,this->imaginary+other.imaginary);\n    }\n};\nvoid print(Complex& c){\n    printf(\"%d+%di\",c.real,c.imaginary);\n}\n\nint main(){\n    Complex c1(1,1);\n    Complex c2(2,3);\n    Complex c3=c1+c2;\n    print(c3);\n}\n```\n\n## 构造函数、拷贝函数、折构函数\n\n### 构造函数\n\n```cpp\nclass animal{\n\tpublic:\n        animal(string name);//不能这样写：animal(string:name)\n        string name;\n};\nanimal::animal(string name): name(name){\n//初始化列表\n    cout<<\"the animal is created!\"<<endl;\n};\n```\n\n### 拷贝函数\n\n```c++\nclass animal{\n\tpublic:\n        animal(string name);//不能这样写：animal(string:name):name(name){}，如果这样的话，就不需要在class之外再\n    \tanimal(animal& animal)\n        string name;//It is recommened not to use the same name! \n};\nanimal::animal(string name): name(name){\n//初始化列表\n    cout<<\"the animal is created!\"<<endl;\n};\n\n//usage:\n\n```\n\n>   可以自定义一个“深度拷贝”的拷贝函数，如果没有拷贝函数，那么就会默认生成一个浅拷贝的拷贝函数\n\n**写类的时候拷贝函数和重载赋值操作符都是推荐的操作！！！**\n\n### 折构函数 \n折构函数在销毁的时候调用：\n\n```cpp\nclass Car{\n    Car(){\n        printf(\"I am created!\\n\");\n    }\n    ~Car(){\n        printf(\"I am destoryed!\");\n    }\n};\n```\n\n### 例子\n\n```cpp\nVector(Vector& other):vsize(other.vsize),vcapacity(other.vcapacity){\n    arr=new int[other.vcapacity];\n    for(int i=0;i<other.vsize;i++){\n        arr[i]=other.arr[i];\n    }\n}\n~Vector(){\n    cout<<\"the Vector is destoryed successfully!\"<<endl;\n    delete[] arr;\n}\nVector& operator=(Vector& other){\n    if(other.arr!=arr){\n        delete[] arr;\n        vsize=other.vsize;\n        vcapacity=other.vcapacity;\n        arr=new int[vsize];\n        for(int i=0;i<vsize;i++){\n            arr[i]=other.arr[i];\n        }\n    }\n    return *this;\n}\n```\n\n### 操作符重载\n\n#### 重载赋值=\n\n#### 重载<<\n\n[C++ 输入输出运算符重载 | 菜鸟教程](https://www.runoob.com/cplusplus/input-output-operators-overloading.html)\n\n```cpp\n    friend ostream operator<<(ostream& os, Vector& v){\n        os<<\"[ \";\n        for(int i=0;i<v.vsize;i++){\n            os<<v.arr[i]<<', ';\n        }\n        os<<\"]\"<<endl;\n    }\n//需要写一个友元函数，重载<<操作符。\n```\n\n### 静态成员\n\n#### 变量\n\n1.   **Shared** across all objects of the class.\n2.   Declared with `static` inside the class.Must be **initialized outside the class** (e.g., `int Counter::count = 0;`).\n\n\n\n#### 函数\n\n1.   可以通过类来访问，也可由instance来访问\n2.   **只能访问到类的静态成员（函数，和变量）以及类之外的全局函数**\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\n\nclass Counter{\n    public:\n    static int counts;\n    string name;\n    Counter(string name):name(name){\n        cout<<\"A new Counter called \"<<name<<\" is created!\\n\";\n    }\n    ~Counter(){\n        cout<<\"Counter \"<<name<<\" is distroyed!\\n\";\n    }\n    Counter(Counter& c):name(c.name){\n        cout<<\"A copy of \"<<c.name<<\"is created!\\n\";\n    }\n    static void count(){\n        counts+=1;\n    }\n    /*static void callName(){\n        cout<<name<endl;\n    }\n    Error! Because you can't access the unstatic members!\n    */\n    Counter& operator=(Counter& c){\n        if(c.name!=name){\n            name=c.name;\n        }\n        return *this;\n    }\n    friend ostream& operator<<(ostream& out, const Counter& c){\n        out<<\"Counter \"<<c.name<<\" is printed! \";\n        return out;\n    }\n};\nint Counter::counts=0;//the static member of a nnumber should be initialized outside the calss(but should //be declared inside the class)\n//Counter::counts=0 is false,because we haven't initailize it yet!\n\nint main(){\n    Counter c1(\"Xiao\");\n    cout<<Counter::counts<<endl;\n    Counter c2(c1);\n    cout<<Counter::counts<<endl;\n    Counter::counts+=1;\n    cout<<Counter::counts<<endl;\n    c1.count();\n    c2.count();\n    cout<<Counter::counts<<endl;\n    cout<<c1<<endl;\n    cout<<c1.counts<<\" \";\n    return 0;\n}\n```\n\n但是在定义静态成员变量的时候也是可以采取`inline static int count=0;`的方法\n\n## Polymorphism \n\n### Virtual function\n\n1.   defined inside the class with a keyword `virtual`\n2.   can be **overriden** in the derived class\n\n```cpp\nclass A{\n    public:\n    virtual void fun() const{\n        cout<<\"a\"<<endl;\n    }\n};\n//A public 继承B, base class的public仍是public，private仍是private。\nclass B: public A{\n\tpublic:\n    void fun() const override {\n\tcout<<\"b\\n\";\n    }\n    int other_varible=10;\n\tprotected：\n    void f(){\n        cout<<\"Protected function\"\\n<<endl;\n    }\n};\nint main(){\n\tA* ptr=new B;\n    ptr->fun();\n    //output: b\n    cout<<ptr->other_varible<<endl;//Error\n    ptr->f();//Error\n}\n```\n\nAnd it's easy to find we have used `const` keyword, it's used to declare that the function cannot modify the state of the class.\n\n**It’s a promise to the compiler and users of the class that the function is \"read-only.\"**\n\nBut the keyworfd `const` is **not mandatory** (We can define a virtual function that is readable and writable)\n\n \n\n###  Dynamic cast\n\nWe konw that we can define a pointer of base class like this :\n\n```cpp\nBaseClass* ptr=new DerivedClass\n```\n\nAnd we can access the virtual function :\n\n```cpp\nptr->virtualFunction();\n//If the base class overrides the virtual function, then call that function in the derived class, otherwise the base class.\n```\n\nBut this pointer is base class type, which **cannot access other members of the derived class!**\n\nWe need **Dynamic cast** to achieve this!\n\n```cpp\n#include<bits/stdc++.h>\nusing namespace std;\nclass A{\n    public:\n    virtual void fun() const{\n        cout<<\"a\"<<endl;\n    }\n};\n//A public 继承B, base class的public仍是public，private仍是private。\n\nclass B: public A{\n\tpublic:\n    void fun() const override {\n\tcout<<\"b\\n\";\n    }\n    int other_varible=10;\n\tprotected:\n    void f(){\n        cout<<\"Protected function\\n\"<<endl;\n    }\n};\n\nint main(){\n\tA* ptr=new B; // Base pointer to derived object\n    ptr->fun();\n    //output: b\n    B* p=dynamic_cast<B*>(ptr);\n    //cast the pointer to B* type.\n    cout<<p->other_varible<<endl;\n    p->f();//Error because 'f' is a protected member.\n}\n```\n\n>   base class的对象 不能赋值到derived class；但是derived class 的对象可以赋值给 base class；\n>\n>   derived class的指针可以赋值给base class的指针；反之不行，需要`dynamic cast`\n\n## This pointer\n\n​\t在 C++ 中，**this** 指针是一个特殊的指针，它指向当前对象的实例。在 C++ 中，每一个对象都能通过 **this** 指针来访问自己的地址。**this**是一个隐藏的指针，可以在类的成员函数中使用，它可以用来指向调用对象。\n\n​\t当一个对象的成员函数被调用时，编译器会隐式地传递该对象的地址作为 this 指针。\n\n​\t友元函数没有 **this** 指针，因为友元不是类的成员，只有成员函数才有 **this** 指针。\n\n​\tthis 虽然用在类的内部，但是只有在对象被创建以后才会给 this 赋值，并且这个赋值的过程是编译器自动完成的，不需要用户干预，用户也不能显式地给 this 赋值。（`this` is a const pointer！）\n\n```cpp\nA* ptr=new A;\n//then ptr==this\n```\n\n## 模态化设计\n\nWe can depart the declaration and the implemtation.\n\n```cpp\nproject/\n├── Vector.h    // Class declaration (header)\n├── Vector.cpp  // Class definition (implementation)\n└── main.cpp    // Usage (driver code)\n```\n\n>   An example from deepseek\n\nWhen we run the project, we have compiler each `.cpp` file respectly and link them together.\n\n### **4. Compilation & Linking**\n\nC++ requires compiling each `.cpp` file separately and then linking them together. Here’s how to do it:\n\n```bash\ng++ -c Vector.cpp -o Vector.o\ng++ -c main.cpp -o main.o\ng++ Vector.o main.o -o program        #Link both object files into an executable\n./program\n```\n\nOr we can take the following short cut:\n\n```bash\ng++ Vector.cpp main.cpp -o program    # Compile + link → \"program\" executable\n./program                             # Run it\n```\n\nThe follwing are some place to pay attention to.\n\n>   1.  **Never compile `.h` files directly**:\n>\n>       -   Headers are included via `#include` in `.cpp` files.\n>       -   Example: `main.cpp` includes `Vector.h`, which is processed during compilation.\n>\n>   2.  **Common Errors**:\n>\n>       -   **Linker Error**: If you forget to compile `Vector.cpp`, you’ll see errors like:\n>\n>           ```\n>           undefined reference to `Vector::push_back(int)'\n>           ```\n>\n>       -   **Missing Header Guards**: If `Vector.h` is included multiple times, use `#pragma once` to avoid redefinition errors.\n\n","categories":["NJUCS","高级程序设计"]},{"url":"/posts/f994f4f9e85c/","content":"# String\n\n## string的method\n\n（generated by ChatGPT）\n\n| **Method**               | **Description**                                              | **Example**                        |\n| ------------------------ | ------------------------------------------------------------ | ---------------------------------- |\n| `length()` or `size()`   | Returns the number of characters in the string.              | `s.length();` or `s.size();`       |\n| `empty()`                | Checks if the string is empty.                               | `s.empty();`                       |\n| `clear()`                | Clears the string, making it empty.                          | `s.clear();`                       |\n| `append(str)`            | Appends `str` to the end of the string.                      | `s.append(\" world\");`              |\n| `operator+=`             | Concatenates another string or character.                    | `s += \" world\";`                   |\n| `insert(pos, str)`       | Inserts `str` at position `pos`.                             | `s.insert(5, \" hello\");`           |\n| `erase(pos, len)`        | Erases `len` characters from position `pos`.                 | `s.erase(5, 3);`                   |\n| `replace(pos, len, str)` | Replaces `len` characters starting at `pos` with `str`.      | `s.replace(5, 3, \"world\");`        |\n| `substr(pos, len)`       | Returns a substring starting at `pos` with `len` characters. | `s.substr(0, 5);`                  |\n| `find(str)`              | Finds the first occurrence of `str` and returns its position. Returns `std::string::npos` if not found. | `s.find(\"hello\");`                 |\n| `rfind(str)`             | Finds the last occurrence of `str`.                          | `s.rfind(\"hello\");`                |\n| `find_first_of(str)`     | Finds the first occurrence of any character in `str`.        | `s.find_first_of(\"aeiou\");`        |\n| `find_last_of(str)`      | Finds the last occurrence of any character in `str`.         | `s.find_last_of(\"aeiou\");`         |\n| `find_first_not_of(str)` | Finds the first character not in `str`.                      | `s.find_first_not_of(\"abc\");`      |\n| `find_last_not_of(str)`  | Finds the last character not in `str`.                       | `s.find_last_not_of(\"abc\");`       |\n| `compare(str)`           | Compares the string with `str`. Returns 0 if equal, <0 if less, >0 if greater. | `s.compare(\"hello\");`              |\n| `c_str()`                | Returns a C-style null-terminated character array.           | `const char* c = s.c_str();`       |\n| `data()`                 | Returns a pointer to the underlying character array (similar to `c_str()` but not null-terminated). | `const char* d = s.data();`        |\n| `at(pos)`                | Returns the character at position `pos` (with bounds checking). | `char c = s.at(5);`                |\n| `operator[]`             | Returns the character at position `pos` (no bounds checking). | `char c = s[5];`                   |\n| `push_back(ch)`          | Appends a character `ch` to the end of the string.           | `s.push_back('!');`                |\n| `pop_back()`             | Removes the last character from the string.                  | `s.pop_back();`                    |\n| `resize(n)`              | Resizes the string to contain `n` characters.                | `s.resize(10);`                    |\n| `swap(str)`              | Swaps the contents of the string with `str`.                 | `s.swap(otherString);`             |\n| `begin()`                | Returns an iterator to the beginning of the string.          | `auto it = s.begin();`             |\n| `end()`                  | Returns an iterator to the end of the string.                | `auto it = s.end();`               |\n| `rbegin()`               | Returns a reverse iterator to the beginning of the reversed string. | `auto it = s.rbegin();`            |\n| `rend()`                 | Returns a reverse iterator to the end of the reversed string. | `auto it = s.rend();`              |\n| `to_string(val)`         | Converts a number (`int`, `float`, etc.) to a string.        | `std::to_string(123);`             |\n| `stoi(str)`              | Converts a string to an integer.                             | `int num = std::stoi(\"123\");`      |\n| `stof(str)`              | Converts a string to a floating-point number.                | `float num = std::stof(\"123.45\");` |\n| `getline(cin, str)`      | Reads an entire line of input into the string.               | `std::getline(std::cin, s);`       |\n\n>   注意rbegin的含义是reversed的string起始字符串的迭代器\n\n## Note:\n\nstring 风格的字符串用printf(\"%s\")打印会出现乱码，因为这个不适合string风格。想要用printf的话，需要这么写：printf(\"%d\",str.c_str());即调用成员函数c_str();\n\n\n\n","categories":["NJUCS","高级程序设计"]},{"title":"github入门--the missing class for cs learner","url":"/posts/a66cf0c9308c/","content":"\n\n\n## git基本使用Quick Start\n ![](https://www.runoob.com/wp-content/uploads/2015/02/git-command.jpg)\n\n ### 安装与初始化\n 从官网下载git，之后从终端中输入下面两条指令，设置名字和邮箱\n ```\n git config --global \"name\"\n git config --global \"email\"\n ```\n **注意: name 和 Email 是用英文双引号包裹起来的**\n### 初始化一个仓库\n1.从零开始：在你想要创建项目的地方打开终端，输入git init\n```\ngit init //从头开始\n\n```\n\n2.直接clone别人的仓库：在目标文件夹打开终端，使用git clone +仓库名\n```\ngit clone https://github.com/yama-lei/yama-lei.github.io.git  `\n```\n这里的url可以直接点开仓库右上角的绿色“code”按钮，下面可以直接复制\n\n### 连接远程仓库\n命令行中输入：\n```\ngit remote add origin https://github.com/yama-lei/yama-lei.github.io.git\n```\n第一次连接需要配置SSH key\n```\nssh-keygen -t rsa -b 4096 -C \"github 注册账号\"\n```\n接下来按照提示，保存SSH key，设置密码（也可以不设置）。\n依次执行：\n```\neval \"$(ssh-agent -s)\"\nssh-add ~/.ssh/id_rsa\ncat ~/.ssh/id_rsa.pub\n```\n就会在终端中输出ssh-rsa开头的SSH key,复制这段输出。\ngithub->点开头像->出现的侧边栏中间有个setting->点开后会进入到设置，找到\"SSH and GPG keys\"->在SSH key右侧有个绿色按钮“Add SSh ey”\n\n### 如何更新远程的仓库？\n在本地修改了文件后，可以直接“一键三连”\n```\ngit add .\ngit commit\ngit push origin main\n```\n在这里三个指令分别代表了三个操作：\n#### 1. 将文件添加到暂存区(staging area)\n如果只修改/添加某个文件，可以使用\n```\ngit add filename\n```\n指定那个名叫‘filename’的文件\n如果嫌麻烦，直接\n```\ngit add .\n```\n但是请注意！！！ add后面有个点' . '\n#### 2. 将暂存区的文件提交到本地仓库\n使用指令：\n```\ngit commit\n```\n如果想要在提交的时候，备注上更新什么内容，可以用下面这个\n```\ngit commit -m \"本次更新解决了提出bug的用户\"\n```\n加上这个备注 ，有助于清晰地了解各个版本修改的内容，如果出现了什么问题，可以回溯之前的版本，提高了是错成本，避免因为某处错误而导致整个项目崩溃。\n#### 3. 将本地仓库的文件提交到远程仓库（即上文中连接的github仓库）\n将本地仓库里的内容push到远程仓库的xx分支（如果没有特殊改变分支，一般是main分支）\n```\ngit push origin branchname\n```\n### 如何回溯过往版本？\n#### 1.查询提交记录\n使用git log来获取到提交记录,下面是我某一次博客的部分修改日志\n输入\n```\ngit log\n```\n输出：\n```\ncommit adf721c24faa3f355468ae5400fd63f6f193a942 (HEAD -> main, origin/main)\nAuthor: yama-lei <1908777046@qq.com>\nDate:   Thu Jan 16 10:39:33 2025 +0800\n\n    add a new game: 2048\n\ncommit 7933b8b303b170ab0cf360ce4d5e3f8de37b972d\nAuthor: yama-lei <1908777046@qq.com>\nDate:   Wed Jan 15 15:41:58 2025 +0800\n\n    add mores blogs and created some new demos\n```\n可以看到，日志的内容呈现倒叙：最后提交的内容在最上面。\n每一次的提交都会有commit、Author、Date\ncommit是这一次提交的唯一标识。\nAuthor是前文设置的name和email，date为日期。\n\n#### 2.切换到历史提交记录\n运行\n```\ngit checkout commit\n```\n可以回到原先某一次（由对应commit决定）的状态。\n再把commit换成main即可回到原先的main分支\n```\ngit checkout main\n```\n#### 3. 恢复历史记录\n将某次历史记录保存在暂存区：\n```\ngit reset --soft commit\n```\n将历史记录彻底覆盖\n```\ngit reset --hard commit\n```\n> 这里的commit说的都是前文提到过的唯一标识\n\n#### 4.切换分支\n列出所有的分支\n```\ngit branch\n```\n创建并进入某个新分支\n```\ngit checkout -b branchname\n```\n合并分支(将名为'branchname'的分支合并到main分支)\n```\ngit merge branchname\n```\n删除分支\n```\ngit branch -d branchname\n```\n\n### 5.如何merge代码？\n\n```\ngit fetch origin //拉取\ngit merge origin/main //将代码和本地的进行合并\n```\n\n\n\n\n### fork别的仓库\n\n下面是deepseek对于fork的描述：\n\n-   Fork 的仓库是你的独立副本，修改不会影响原仓库。\n\n-   Fork 的仓库**不会自动同步**原仓库的更新，需要手动同步。\n-   你可以通过命令行或网页端将原仓库的更新同步到你的 Fork 仓库。\n-   如果你想贡献代码，可以通过 Pull Request 提交更改。\n\n## github page\n\ngithub提供了部署静态网页相对简单的一个方案--github page\n\n## github action\n\ngithub action是一个工作流(workflow)\n","categories":["Mics"]},{"title":"例会汇报 | 第五次","url":"/posts/b43c24c0d1ab/","content":"\n---\n\n## 一个成功在服务器上跑起来的模型\n\n很久以前，组会分享中介绍过一个VQA的baseline模型[arxiv-1512.02167](https://arxiv.org/pdf/1512.02167)。\n\n因为其结构简单，数据集仅使用了COCO数据集\n\n![Refer to caption](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/x1.png)\n\n但是原先项目是用 lua写的，我想试试pytorch改写。\n\n于是~~我在ai的帮助下~~**ai在我的帮助下**，尝试构造了这个模型：\n\n\n\n过程：\n\n-   本地构建模型（本地可以也用一个venv环境，然后再导出一个requiremnets.txt文件即可）\n-   服务器创建环境并运行模型\n-   将保存好的模型下载到本地\n-   成功运行\n\n\n\n**在部署中遇见的困难和踩到的坑**\n\n1.   数据大，传输速度慢\n\n2.   环境搭建\n\n3.   数据集出问题\n\n4.   下载\n\n5.   给ai坑了。。。\n\n     训练了一个小时，发现正确率依旧是33%上下，我觉得很纳闷，回去看模型发现：\n\n     ![1745410249937](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/1745410249937.png)\n\n![image-20250423201121073](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250423201121073.png)\n\n---\n\n使用真实数据之后，最后成功开始训练，20个Epoch，batchsize为320，GPU利用率平均75%；\n\n![image-20250423202924246](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250423202924246.png)\n\n每一个epoch大概用时3min，一共训练了20个epoch，准确率提升到了92%,总用时57min\n\n![image-20250423213926209](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250423213926209.png)\n\n![Figure_1](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250423213913139.png)\n\n![](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/Figure_1.png)\n\n\n\n\n\n但是当我把训练好的模型拿到本地进行测试时，发现了很尴尬的一幕：\n\n<div style=\"display: flex; gap: 20px;\">\n  <div style=\"text-align: left;\">\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/20250423215715.png\"  />\n  </div>\n  <div style=\"text-align: left;\">\n    <img src=\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/20250423215741.png\" />\n  </div>\n</div>\n\n所有的问题，都会回答`the`。\n\n检查发现，**论文里面说的是COCO VQA数据集，我虽然使用的是COCO2017图像，但是使用的标注集都是caption**，用于训练图像描述的；\n\n<center><del>但凡我和ai有一个会深度学习，也不会出现这么尴尬的事情</del></center>\n\n---\n\n之后还尝试了在COCO2017基础上的一些数据集，但是模型还是不太靠谱，最后效果十分地差。\n\n~~这个悲伤的故事告诉我们，学习要按部就班，一步一个脚印，踏踏实实地学习，夯实基础。~~\n\n......\n\n\n\n---\n\n但是我还是不死心，在4/25再试了一次：\n\n-   下载了COCO2014数据集和VQA-v2对这个数据集的标注\n-   仍然使用预训练好的CNN模型来提取图像特征，使用LSTM对问题进行编码，使用简单的拼接来特征融合\n\n![image-20250425224401342](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250425224401342.png)\n\n训练了30个epoch，每一个epoch耗时约20min，batchsize设置为64。\n\n早上起来之后发现还没训练完，一看acc和loss，觉得没有训练的必要了\n\n![image-20250426084020076](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250426084020076.png)\n\n\n\n![image-20250426085312953](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250426085312953.png)\n\n没错，我又浪费了国家的电。\n\n---\n\n\n\n我还是不服气，最后找了一个论文的复现：\n\n\n\n\n\n---\n\n\n\n## VQA早期论文阅读\n\n[1704.03162](https://arxiv.org/pdf/1704.03162)\n\n![image-20250426205954215](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250426205954215.png)\n\n---\n\n模型结构\n\n```py\nclass Net(nn.Module):\n    \"\"\"\n    重新实现论文 ``Show, Ask, Attend, and Answer: A Strong Baseline For Visual Question Answering'' [0]\n\n    这个类定义了一个用于视觉问答（VQA）的神经网络。\n    它处理视觉特征（图像）和文本特征（问题）以预测答案。\n\n    [0]: https://arxiv.org/abs/1704.03162\n    \"\"\"\n    def forward(self, v, q, q_len):\n        \"\"\"\n        网络的前向传播。\n        参数:\n            v (torch.Tensor): 视觉特征（图像嵌入），形状：(batch_size, vision_features, height, width)\n            q (torch.Tensor): 问题嵌入，形状：(batch_size, max_question_length)\n            q_len (torch.Tensor): 每个问题的实际长度，形状：(batch_size)\n        返回:\n            torch.Tensor: 预测答案的 logits，形状：(batch_size, num_answers)\n        \"\"\"\n        # 通过 LSTM 处理问题，得到问题特征\n        q = self.text(q, list(q_len.data)) \n        # 对视觉特征进行 L2 归一化\n        v = v / (v.norm(p=2, dim=1, keepdim=True).expand_as(v) + 1e-8)\n\n        # 基于问题特征计算视觉特征的注意力权重\n        a = self.attention(v, q) \n        # 应用注意力机制到视觉特征上，得到加权后的视觉特征\n        v = apply_attention(v, a)  \n        # 将加权后的视觉特征和问题特征拼接在一起\n        \n        combined = torch.cat([v, q], dim=1)\n        vision_features + question_features)\n\n        # 将组合后的特征传递给分类器，预测答案\n        answer = self.classifier(combined)  \n        return answer \n```\n\n\n\n\n\n### **图像特征提取**\n\n- 采用152层深度残差网络（ResNet-152）作为图像编码器，基于ImageNet预训练权重进行特征提取。  \n\n---\n\n### **问题特征提取**\n- 使用单向长短期记忆网络（LSTM）对问题进行编码。 \n\n---\n\n### **特征融合与注意力机制**\n\n这一部分我没看懂，这是ai生成的内容:\n\n- **多模态交互**：通过堆叠注意力机制（Stacked Attention）实现图像与问题的协同推理。  \n  - **注意力权重计算**：  \n    1. **特征拼接**：将问题向量$\\mathbf{s}$沿空间维度复制为$14 \\times 14 \\times 1024$，与图像特征$\\phi \\in \\mathbb{R}^{14 \\times 14 \\times 2048}$拼接，形成联合特征$\\psi \\in \\mathbb{R}^{14 \\times 14 \\times 3072}$。  \n    2. **卷积映射**：通过两层卷积操作生成注意力分布：  \n       - 第一层：$1 \\times 1$卷积，输出通道数512，激活函数为ReLU。  \n       - 第二层：$1 \\times 1$卷积，输出通道数$C=2$，对应两个独立的注意力头。  \n    3. **归一化**：对每个注意力头$c$在空间维度上应用Softmax，得到归一化权重$\\alpha_{c,l} \\propto \\exp(F_c(\\psi_l))$，满足$\\sum_{l=1}^{14 \\times 14} \\alpha_{c,l} = 1$。  \n  - **特征聚合**：每个注意力头$c$生成的特征向量为：  \n    $$\\mathbf{x}_c = \\sum_{l=1}^{14 \\times 14} \\alpha_{c,l} \\phi_l \\in \\mathbb{R}^{2048}$$  \n    最终拼接两个注意力头的结果$\\mathbf{x} = [\\mathbf{x}_1, \\mathbf{x}_2] \\in \\mathbb{R}^{4096}$。\n\n---\n\n### **分类器与输出生成**\n将注意力特征$\\mathbf{x}$与问题向量$\\mathbf{s}$拼接，输入分类器。  \n\n**网络结构**：  \n\n1. **全连接层**：维度降至1024，激活函数为ReLU，应用Dropout（概率0.5）。  \n2. **输出层**：线性映射至答案空间$\\mathbb{R}^{3000}$，覆盖训练集中最高频的3000个答案（覆盖率92%）。  \n\n**概率生成**：通过Softmax函数计算答案概率分布：  \n$$P(a_i | I, q) = \\frac{\\exp(G_i(\\mathbf{h}))}{\\sum_{j=1}^{3000} \\exp(G_j(\\mathbf{h}))}$$  \n\n---\n\n复现的仓库：[Cyanogenoid/pytorch-vqa: Strong baseline for visual question answering](https://github.com/Cyanogenoid/pytorch-vqa)\n\n1.   提取图像特征\n2.   从答案中得到词汇表\n3.   开始训练\n","categories":["科研启蒙","Reports"]}]