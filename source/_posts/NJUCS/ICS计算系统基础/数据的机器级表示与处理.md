---
title: Part1，chapter2 数据的机器级表示和处理
categories:
  - NJUCS
  - ICS计算系统基础
---

## 定点编码方式

**原码、补码、反码、移码**

-   2的31次方=2147438648；
-   2的7次方为128

2147438647用signed int来表示的时候是7FFF FFFF； 用unsigned int来表示也是7FFF FFFF。

但是-2147483647用signed int来表示为8000 0001，如果强转为signed int那么结果为2147483649

并且-2147483648强转为unsigned之后还是2147483647



## 浮点编码方式

**IEEE754标准**

32位浮点数：1+8+23       

64位浮点数：1+11+52

阶码为移码，偏置常数为127；尾数是原码，默认前导1；符号为1位，0代表正数，1代表负数；

>   127刚好是0111 1111！！

**规格化数**：

规格化的方法： 将尾数部分进行左规或者右规，直到

对于32位的浮点数，**绝对值最小的非规格化数**为$2^{-149}$ 次方！因为非规格化数的阶码为0（即$2^{-127}$）且不含默认的前导1

能够精确地表示 阶码*（1+n个$2^{-23}$)

float能够表示的有效位数约为7位，而double为15位



## 数据宽度和存储

**字长和字**

字用于度量数据类型的宽度，比如XX数据类型宽度是双字/是单字

字长是数据通路的宽度





**大端和小端模式**

对于某个数据（以int型为例），其可能占用多个字节，其地址位是 LSB还是MSB决定了其是BigEndian还是LittleEndian。

大端BIgEndian，先读取最高位有效字节（因为大端低地址放的是最高有效字节）

小端LittleEndian，先读取最低位有效字节（因为小段地址存放的是最低有效字节）

比如说，0x12345678，占四个字节，如果小端机器的话，从低字节从高字节读取出来是78->56->34->12

>   因此，如果是小端机器要读取一个立即数，都要注意正确读法！

如果是大端机器，那么读取出来是12 34 56 78（因为12是MSB，大端机器从12开始）





**浮点数相加减**

先对阶，小阶对大阶，如果阶差大于25，则出现**大阶吃小阶**的情况

两个移码的加减法得到的不是两个数加减法之后的移码！！！

那为什么阶码不使用补码，而是使用补码？一个好处是，可以通过直接比较阶码的机器数来判断大小

IEEE754规定，浮点数运算的中间结果必须要有两位附加位（分别称作“保护位gaurd”和“舍入位round”）

在IEEE754中规定：**01舍，11入，10结果为偶数**

1.1101**10**-> 1.1110（为了让结果为偶数）



>   浮点数只能表示有限个数字，比如float在754标准下，在[1,2)之间可以表示$2^{23}$次方个数，每一个数字的间隔是$2^{-23}$.
>
>   float可以表示的数字最大到$2^{127}*(2-2^{23})$，而int最多才$2^{31}-1$ 到$-2^{31}$ ，把int转换成float会出现一些精度的舍入（因为只有23位的尾数，但是int有32位，但是转成double的话是可以的）

浮点数的运算满足交换律：a+b=b+a，但是不满足结合律，比如a+b-c!=a-c+b，因为存在**大数吃小数**的情况



**Kahan累加算法**：大量浮点数累加算法

不能直接用float来进行大规模的浮点数累加，避免大数吃小数的现象。

在对阶的时候，如果一个数字非常的大，两外一个数字非常地小，常常由于精度问题，导致较小的一个数字出现低位被省略的情况。

**可能出现a+b-a!=b**

Kahan算法的核心思想，用一个数字来记录误差值，详细见[Kahan 求和 - OI Wiki](https://oi-wiki.org/misc/kahan-summation/)