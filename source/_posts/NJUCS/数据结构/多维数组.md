---
categories:
  - NJUCS
  - 数据结构
title: 多维数组
date: 2025-10-01
---

**二维数组**
1. `typedef T a[m][n]` 等价于 `typedef T b[m]` + `typedef b a[n]`
2. 如果 `int a[m][n];` 那么 `a[i][j]` 代表的位置是 `a + i * n + j`
3. 递归计算位置：$Loc(i) = \alpha$ if $i = 0$ else $Loc(i-1) + l$； $Loc(i,j)= Loc(i,0)+j=Loc(0,0)+i*m+j$
**三维数组**
 4. `int a[m][n][p]` 如果访问`a[i][j][k]`，访问的地址为`a+i*n*p+j*p+k`


**对称矩阵**
$$
	M=M^T
$$
对于对称矩阵来说，有`M[i][j]=M[j][i]`,因此我们只需要存储一个上三角矩阵或者一个下三角矩阵就能够把所有的有效元素访问到。
只需要存储1+2+3+...+n=(1+n)n/2个元素，以下三角矩阵为例：
```cpp
class Matrix{
int n=0;
int* arr;
public:
	Matrix(int n):n(n){
		arr=new int[n(n+1)/2];
	}
	~Matrix(){
		delete[] arr;
	}
	int* Get(int i, int j){
		if(i<j){
			return Get(j,i);
		}else{
			int pos=(i+1)*i/2+j;
			return arr+pos;
			//The position (i,j) is (i+1)*i/2 +j when row is priority 
		}
	}	
};
```



> 注：老师提到，有一次考试中采取了列优先的策略，相当比例的同学都出现了错误。行优先还是列优先只是i和j的顺序问题

上面的例子是下三角矩阵，如果是上三角的矩阵，那么`a[i][j]=n+n-1+...+n-i+n-j`(自己推导一下，我这个写的可能不对)

---

**三对角矩阵**
特点：只有当$|i-j|<=1$的时候才不为0，元素总数为$3n-2$个。

![image.png](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/20250925103309.png)

如果先按照行存储，再按照列存储，那么对于第aij，其在数组中的位置是：
$k=(3i-1)+j-i+1=2i+j$ 
如果知道k（也就是在数组中的位置）如何求i和j呢（其在矩阵中的位置呢）？
由于 $3i-1<=k=2i+j<=3i+1$
所以有：
**稀疏矩阵（Sparse Matrix）**  
矩阵 $A_{mn}$ 中有 $s$ 个元素，其中 $s$ 远小于 $m \times n$，因此可以选择这样的方式存储：  
保存 $(i, j, a_{ij})$，其中 $i$ 和 $j$ 分别代表其在稀疏矩阵中的 row 和 col，可以采取行优先的方式进行存储，比如：  

| index in array | row | col | value |
| -------------- | --- | --- | ----- |
| 0              | 0   | 1   | 123   |
| 1              | 0   | 4   | 134   |
| 2              | 2   | 2   | 111   |
| 3              | 9   | 0   | 1999  |
> Row priority, sorted by row

稀疏矩阵的转置：
1. 将row和col进行交换
2. 按照row进行排序（如果需要保留原先的行优先）
转置的算法1：
假设矩阵为A_mn，则转置后的A^T有n行。
- 遍历n次，每k次遍历时，把col=k的元素先进行保存到新的矩阵中（只要按照顺序进行遍历，那么一次遍历之后，保存的部分都是按照新的col排序的，因为原先是按照row排序的）。
- n次之后，所有元素都转置成功。

转置的算法2：
维护一个数组rowSize，表示转置之后的第i行已经有了`rowSize[i]`个数据；再维护一个数组`rowStart`，`rowStart[i]`表示第i行从这个位置开始。
先遍历一遍item，统计每一行的个数，再遍历一次所有的item，遇见之后，直接把每一个item(i,j,k)存入`rowStart[j] + rowSize[j]`这个位置，新的item为(j,i,k)。


稀疏矩阵的链表表示
我们可以使用正交链表来实现稀疏矩阵的功能，设定一个头结点和元素节点：
设计为
![image.png](https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/20250925115853.png)
