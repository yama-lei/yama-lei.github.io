import{_ as p,c as s,d as n,b as a,f as i,o as l}from"./app-CTmIiTWD.js";const t={};function o(c,e){return l(),s("div",null,e[0]||(e[0]=[n('<p>[TOC]</p><h2 id="第一讲-基本运算部件" tabindex="-1"><a class="header-anchor" href="#第一讲-基本运算部件"><span>第一讲 | 基本运算部件</span></a></h2><p>想要实现高级语言程序设计的各种运算，需要将表达式转换成指令。</p><p>比如</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a,b</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>将数据以<code>补码</code>的形式存入寄存器中。指令-&gt;汇编-&gt;机器指令。</p><p>软件（高级语言设计），指令（ISA），硬件设计，环环相扣。</p><hr><p>所有的运算都可以通过ALU+逻辑部件实现。</p><blockquote><p>有关门延迟这一部分,建议阅读：<a href="https://zhuanlan.zhihu.com/p/590151247" target="_blank" rel="noopener noreferrer">全加器以及行波进位加/减法器时延的计算 - 知乎</a>，因为ppt就是一坨。</p></blockquote><h3 id="串行-行波-进位加法器" tabindex="-1"><a class="header-anchor" href="#串行-行波-进位加法器"><span>串行(行波)进位加法器:</span></a></h3><p>我们先回顾一下什么是全加器FA：</p><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250328110827793.png" alt="image-20250328110827793" style="zoom:33%;"><p>在这个全加器里，Cout的延迟是2，F的延迟是3；</p><p>由多个全加器相连接，前一个全加器的进位作为这一个加法器的cin。</p><p><strong>效率慢</strong></p><p>每一个FA（全加器）需要经过两级门延迟，n位的串行进位加法器就需要2n个门延迟得到Cn进位，2n+1个延迟得到Fn。</p><blockquote><p>生成最后一位的Cout在2n时生成，因此最后一位的F在2n+1位生成。</p></blockquote><h3 id="并行-先行-进位加法器-cla" tabindex="-1"><a class="header-anchor" href="#并行-先行-进位加法器-cla"><span>并行(先行)进位加法器 CLA</span></a></h3><p>先行进位部件：（CLU)</p><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250328102746927.png" alt="image-20250328102746927" tabindex="0" loading="lazy"><figcaption>image-20250328102746927</figcaption></figure><p>一共需要6级延迟就能得到最终的和。</p><p>其中xi和yi在第一个时间段生成gi和pi</p><p>接着两个门延迟后，生成了Ci1</p><p>最后三个门延迟生成和Fi。</p><blockquote><p>因此c4其实在第三个</p></blockquote><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250328103202290.png" alt="image-20250328103202290" tabindex="0" loading="lazy"><figcaption>image-20250328103202290</figcaption></figure><hr><h3 id="局部先行进位加法器" tabindex="-1"><a class="header-anchor" href="#局部先行进位加法器"><span><strong>局部先行进位加法器</strong></span></a></h3><p>比如：使用4个4位先行进位加法器进行串行，实现一个16位的加法器。</p><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250328103710902.png" alt="image-20250328103710902" tabindex="0" loading="lazy"><figcaption>image-20250328103710902</figcaption></figure><p>（图中的数字代表的是时刻）</p><p><strong>多级先行进位加法器</strong></p><p>组内并行，组间仍然并行。</p><h3 id="n位带标志加法器" tabindex="-1"><a class="header-anchor" href="#n位带标志加法器"><span>n位带标志加法器</span></a></h3><p>我们在加法器中加入一些标志输出，用于指示一些特殊状态（如：溢出）</p><p>对于signed类型，有意义的是：</p><ol><li><p>ZF：0标志位</p></li><li><p>OF：代表是否出现溢出。</p><blockquote><p>判断是否出现Overflow的方法：</p><ol><li>看X+Y的和，如果$C_n$(符号位的进位)和$C_{n-1}$(即X和Y相加之后得到的符号位)的相同，则没有发生溢出。即$OF= C_n \\oplus C_{n-1}$</li><li>看X，Y，以及X+Y的符号位。如果$X_{n-1}=Y_{n-1} \\neq C_{n-1}$ 那么$OP=1$.</li></ol></blockquote></li><li><p>SF:符号位标志。</p></li></ol><p>对于unsigned类型，有意义的是：</p><ol><li>ZF</li><li>CF借位进位标志 ($CF= cin \\oplus cout$)</li></ol><hr><ol><li>溢出标志$OF=C_n \\oplus C_{n-1}$</li><li>符号标志SF $SF=F_{n-1}$ (即，最高位)</li><li>零标志$ZF=1 \\space \\text{if F=0 else 0}$</li><li>进位借位标志$CF=Cout \\oplus Cin$</li></ol><h3 id="alu-算数逻辑运算单元" tabindex="-1"><a class="header-anchor" href="#alu-算数逻辑运算单元"><span>ALU：算数逻辑运算单元</span></a></h3><p>通过一个操作控制端（ALUop），来决定ALU进行什么样的运算</p><blockquote><p>通过多路选择器来决定输出哪一个信号。</p></blockquote><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250328105550124.png" alt="image-20250328105550124" style="zoom:33%;"><p>核心是加减运算，输出结果和标志信息</p><h2 id="第二讲-定点数运算" tabindex="-1"><a class="header-anchor" href="#第二讲-定点数运算"><span>第二讲 | 定点数运算</span></a></h2><h3 id="加减法" tabindex="-1"><a class="header-anchor" href="#加减法"><span>加减法</span></a></h3><p>$[x+y]_补 =2^n+x+y= 2<sup>n+x+2</sup>n+y= [x]_补+[y]_补 (mod 2n )$</p><p>$[x-y]_补=2^n+x-y= 2<sup>n+x+2</sup>n-y= [x]_补+[-y]_补 (mod 2n )$</p><p>补码的和就是和的补码，差的补码也是补码的和。</p><p>因此补码可以实现加减法的统一.</p><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250328111952848.png" alt="image-20250328111952848" style="zoom:50%;"><p>上面这个部件十分的神奇！Sub为1的时启动加法，sub还同时作为cin输入，相当于计算$A+\\overline B+1 (mod \\space 2^n)$ ； sub为0的时候，就正常计算就好。</p><p><strong>有符号数singed整数加减法</strong>：</p><p>用上述加减法器件进行运算signed整数，例子如下：</p><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250328123830680.png" alt="image-20250328123830680" style="zoom:50%;"><blockquote><p>OF: overflow; SF: 符号标志位 ZF: 零标志位。</p></blockquote><p>如果用减法来判断两个数的大小，那么在这里我们要看是否有<code>OF=SF</code>，如果满足的话，说明前一个操作数大于后一个操作数。即$less= OF \\cdot SF$ (如果OF=SF，那么前一个数大于后一个数)</p><p><strong>无符号数unsigned整数的加减法</strong>：</p><p>用这个部件对补码进行加减法显然是可以实现的：都是将输入的两个机器码输入，如果加法，则直接相加并取模；如果是减法，那么将第二个操作数取反再相加取模。</p><p>这个部件实际上也可以实现无符号数的加减法。</p><p>对于加法很好理解，无非是一位一位相加，求进位。</p><p>如果比较两个数的大小，那么就看溢出位，$less=cin \\oplus cout$，即，如果有借位就说明前者比后者小。</p><h3 id="乘法运算" tabindex="-1"><a class="header-anchor" href="#乘法运算"><span>乘法运算</span></a></h3><h4 id="无符号数-unsigned-原码乘法" tabindex="-1"><a class="header-anchor" href="#无符号数-unsigned-原码乘法"><span>无符号数 unsigned 原码乘法</span></a></h4><p>原码乘法可以由加法和移位实现：<br> $$<br> X×Y= \\sum_{i=1}^{i=n}(X × yi×2^{-i})<br> $$<br> 利用递归的方法，可以得到如下的算法：</p><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250331102900167.png" alt="image-20250331102900167" style="zoom:50%;"><p>以32位原码的乘法为例，两个32位的原码相乘，至少需要64位存储积。</p><blockquote><p>注意在高级语言程序中，有溢出的可能，比如只要32位，那么只会从64位中取低32位。</p></blockquote><p>在实际的硬件实现中：1. C存储循环次数 2. 一个寄存器存储一个乘数 3. 一个存储器同时存储一个乘数和积。</p><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250331104724755.png" alt="image-20250331104724755" tabindex="0" loading="lazy"><figcaption>image-20250331104724755</figcaption></figure><p>即每一次都将高32位和原先的X相加，如果Y的最后一位是0，那么直接将高32位返回，如果是1，那么相加。循环32次。</p><hr><h4 id="浮点数的乘法" tabindex="-1"><a class="header-anchor" href="#浮点数的乘法"><span>浮点数的乘法：</span></a></h4><ol><li>数值部分是原码，因此直接相乘。</li><li>阶码是移码，直接相加。</li><li>符号位取异或。</li></ol><h4 id="原码两位乘法" tabindex="-1"><a class="header-anchor" href="#原码两位乘法"><span>原码两位乘法</span></a></h4><p>前面介绍的都是一位乘法，即一位一位的运算，如果运算32位就需要32次循环，实际上，可以一次运算两位。</p><p>类似的，我们一次性从乘数Y中取两位，如果Y=00，那么无需相加，直接右移；如果为01，则加上X并右移两位；10则加上2个X并右移；11的话按理是加上3个X并右移。但是实际上采取的是先减去一个X右移两位，<strong>并通知下一位多加一个X</strong>。</p><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250331110003790.png" alt="image-20250331110003790" tabindex="0" loading="lazy"><figcaption>image-20250331110003790</figcaption></figure><p>因此，考虑到前一位的标志，一共分成了8种情况。</p><hr><p>原码2位乘法举例：</p><p>（由于移位2位需要用到减法，因此采取补码实现加法）</p><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250331111755147.png" alt="image-20250331111755147" style="zoom:80%;"><p>采取模8补码，算术移位。</p><p>（此处看ppt）</p><hr><h4 id="补码的乘法运算" tabindex="-1"><a class="header-anchor" href="#补码的乘法运算"><span>补码的乘法运算</span></a></h4><p><strong>布斯算法 | Booth Algorithm</strong>：</p>',91),a("p",null,[i("推导过程（过个眼瘾就行）:"),a("br"),i(" $$"),a("br"),i(" \\space y= -y_{n-1}"),a("em",null,[i("2"),a("sup",{i:"n-2"},"{n-1}+\\sum_{i=0}"),i("y_i")]),i("2^i"),a("br"),i(" $$"),a("br"),i(" If we define that $y_{-1}=0$, then we can get that"),a("br"),i(" $$"),a("br"),i(" y=\\sum_{i=0}"),a("sup",null,"{i=1}(y_{i-1}-y_i)*2"),i("i"),a("br"),i(" $$"),a("br"),i(" 可以得到部分积公式："),a("br"),i(" $$"),a("br"),i(" P_n=2^{-1}(P_{n-1}+(y_{i-1}-y_i)x)"),a("br"),i(" $$"),a("br"),i(" 根据当前的位数和前一次的位数可以分成下面这四种可能：")],-1),n('<figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250331113749466.png" alt="image-20250331113749466" tabindex="0" loading="lazy"><figcaption>image-20250331113749466</figcaption></figure><p>一个运算的例子：</p><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250331114008479.png" alt="image-20250331114008479" tabindex="0" loading="lazy"><figcaption>image-20250331114008479</figcaption></figure><ul><li><p>那么什么时候会出现溢出呢？</p><ul><li>如果高四位都是符号位，那么结果不会溢出</li></ul></li><li><p>如果[-x]的补码溢出了呢？</p><ol><li>方法1，增加符号位，（比如-8用四位补码无法表示，但是我们可以加一位符号位）</li><li>方法2，移位实现（因为我不清楚，所以略去）</li></ol></li></ul><h4 id="补码两位乘法" tabindex="-1"><a class="header-anchor" href="#补码两位乘法"><span>补码两位乘法</span></a></h4><p>类似原码两位乘法，需要根据当前的位数去查表，确定在右移之前需要加多少X，or 多少个X的补码</p><p>（自行看ppt）</p><h4 id="补充-快速乘法" tabindex="-1"><a class="header-anchor" href="#补充-快速乘法"><span>补充：快速乘法</span></a></h4><ol><li><p>流水快速乘法器</p><ul><li><p>n位运算需要n个ALU</p></li><li><p>完全采取组合逻辑电路，不需要clk的控制，速度快</p></li></ul></li><li><p>CRA整列乘法器</p></li></ol><hr><p>**The End: **</p><p>注意：只有原码的一位乘法才是逻辑又移，其他的都是算术右移。因为原码的两位补码需要用到补码来表示负数。而补码乘法显然使用算术移码。</p><h3 id="除法运算" tabindex="-1"><a class="header-anchor" href="#除法运算"><span>除法运算</span></a></h3><h2 id="第三讲-浮点数运算" tabindex="-1"><a class="header-anchor" href="#第三讲-浮点数运算"><span>第三讲 | 浮点数运算</span></a></h2>',14)]))}const r=p(t,[["render",o],["__file","运算方法和运算部件.html.vue"]]),h=JSON.parse('{"path":"/posts/NJUCS/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E9%83%A8%E4%BB%B6.html","title":"运算方法和运算部件","lang":"zh-CN","frontmatter":{"title":"运算方法和运算部件","description":"[TOC] 第一讲 | 基本运算部件 想要实现高级语言程序设计的各种运算，需要将表达式转换成指令。 比如 将数据以补码的形式存入寄存器中。指令->汇编->机器指令。 软件（高级语言设计），指令（ISA），硬件设计，环环相扣。 所有的运算都可以通过ALU+逻辑部件实现。 有关门延迟这一部分,建议阅读：全加器以及行波进位加/减法器时延的计算 - 知乎，因为...","head":[["meta",{"property":"og:url","content":"https://github.com/yama-lei/yama-lei.github.io/posts/NJUCS/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E9%83%A8%E4%BB%B6.html"}],["meta",{"property":"og:site_name","content":"Myblog"}],["meta",{"property":"og:title","content":"运算方法和运算部件"}],["meta",{"property":"og:description","content":"[TOC] 第一讲 | 基本运算部件 想要实现高级语言程序设计的各种运算，需要将表达式转换成指令。 比如 将数据以补码的形式存入寄存器中。指令->汇编->机器指令。 软件（高级语言设计），指令（ISA），硬件设计，环环相扣。 所有的运算都可以通过ALU+逻辑部件实现。 有关门延迟这一部分,建议阅读：全加器以及行波进位加/减法器时延的计算 - 知乎，因为..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250328102746927.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-31T03:58:10.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-31T03:58:10.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"运算方法和运算部件\\",\\"image\\":[\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250328102746927.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250328103202290.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250328103710902.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250331104724755.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250331110003790.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250331113749466.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250331114008479.png\\"],\\"dateModified\\":\\"2025-03-31T03:58:10.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Yama-lei\\",\\"url\\":\\"/underbuilding.html\\"}]}"]]},"headers":[{"level":2,"title":"第一讲 | 基本运算部件","slug":"第一讲-基本运算部件","link":"#第一讲-基本运算部件","children":[{"level":3,"title":"串行(行波)进位加法器:","slug":"串行-行波-进位加法器","link":"#串行-行波-进位加法器","children":[]},{"level":3,"title":"并行(先行)进位加法器 CLA","slug":"并行-先行-进位加法器-cla","link":"#并行-先行-进位加法器-cla","children":[]},{"level":3,"title":"局部先行进位加法器","slug":"局部先行进位加法器","link":"#局部先行进位加法器","children":[]},{"level":3,"title":"n位带标志加法器","slug":"n位带标志加法器","link":"#n位带标志加法器","children":[]},{"level":3,"title":"ALU：算数逻辑运算单元","slug":"alu-算数逻辑运算单元","link":"#alu-算数逻辑运算单元","children":[]}]},{"level":2,"title":"第二讲 | 定点数运算","slug":"第二讲-定点数运算","link":"#第二讲-定点数运算","children":[{"level":3,"title":"加减法","slug":"加减法","link":"#加减法","children":[]},{"level":3,"title":"乘法运算","slug":"乘法运算","link":"#乘法运算","children":[]},{"level":3,"title":"除法运算","slug":"除法运算","link":"#除法运算","children":[]}]},{"level":2,"title":"第三讲 | 浮点数运算","slug":"第三讲-浮点数运算","link":"#第三讲-浮点数运算","children":[]}],"git":{"createdTime":1742953027000,"updatedTime":1743393490000,"contributors":[{"name":"yama-lei","username":"yama-lei","email":"1908777046@qq.com","commits":3,"url":"https://github.com/yama-lei"}]},"readingTime":{"minutes":7.1,"words":2130},"filePathRelative":"posts/NJUCS/数字逻辑与计算机组成/运算方法和运算部件.md","localizedDate":"2025年3月26日","excerpt":"<p>[TOC]</p>\\n<h2>第一讲 | 基本运算部件</h2>\\n<p>想要实现高级语言程序设计的各种运算，需要将表达式转换成指令。</p>\\n<p>比如</p>\\n<div class=\\"language-cpp line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"cpp\\" data-title=\\"cpp\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">int</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\"> a,b</span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">=</span><span style=\\"--shiki-light:#986801;--shiki-dark:#D19A66\\">5</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">;</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{r as comp,h as data};
