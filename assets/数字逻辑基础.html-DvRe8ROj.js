import{_ as o,c as l,d as e,e as n,g as t,r as s,o as g,f as p,b as r}from"./app-tREGnUCO.js";const c="/assets/image-20250228105251394-CIhVIk1m.png",m="/assets/image-20250228105333434-BiChIym4.png",h="/assets/image-20250228105343896-4QC3DtGj.png",d="/assets/image-20250228110021775-vAgDz9OU.png",u="/assets/image-20250228112500139-CL3BJ4l0.png",f="/assets/image-20250228095605847-B13e1Wdn.png",y="/assets/image-20250228113834753-BnF3-2Qw.png",b="/assets/image-20250228114607715-BhXzE9eP.png",$={};function B(E,i){const a=s("center");return g(),l("div",null,[i[2]||(i[2]=e('<p>对应了实验123.</p><h2 id="逻辑门与数字抽象" tabindex="-1"><a class="header-anchor" href="#逻辑门与数字抽象"><span>逻辑门与数字抽象</span></a></h2><h3 id="逻辑门-logic-gate" tabindex="-1"><a class="header-anchor" href="#逻辑门-logic-gate"><span>逻辑门：logic gate</span></a></h3><p>直接上图：</p><div style="display:flex;width:33.3%;"><img src="'+c+'"><img src="'+m+'"><img src="'+h+'"></div> 上面的三种logic gate是基本逻辑门。 <figure><img src="'+d+'" alt="image-20250228110021775" tabindex="0" loading="lazy"><figcaption>image-20250228110021775</figcaption></figure><p>但是要记住这几种logic gate对应的运算符号。</p><ul><li>$A \\cdot B$, $\\overline{A}$, A+B</li><li>$A \\oplus B$</li><li>$A \\odot B$</li></ul><h3 id="数字抽象" tabindex="-1"><a class="header-anchor" href="#数字抽象"><span>数字抽象</span></a></h3><p><strong>数字抽象（逻辑采样）</strong>：将某个物理量的实际值集映射为两个子集，对应于两个状态或两个逻辑值0和1。</p><p>在数字系统中，将一定范围内的电压映射到两个状态：高态（high）和低态（low），并用0和1来表示。</p><p><strong>正逻辑</strong>将高电压映射为1，低电压映射为0；负逻辑则相反。</p><p>L or H stands for &#39;Low&#39; or &#39;High&#39;</p><ul><li>VIHmin：确保能被识别为高态的最小输入电压值。</li><li>VILmax：确保能被识别为低态的最大输入电压值。</li><li>VOHmin：输出为高态时的最小输出电压值。</li></ul><blockquote><p>VIHmin小于VOHmin,即<strong>输入识别的电压范围比较大，输出电压的范围比较窄</strong></p></blockquote><ul><li>VOLmax：输出为低态时的最大输出电压值。</li></ul><blockquote><p>VILmax大于VOLmax，理由同上。</p></blockquote><blockquote><figure><img src="'+u+'" alt="image-20250228112500139" tabindex="0" loading="lazy"><figcaption>image-20250228112500139</figcaption></figure><p>​ （图中表示输入输出的电压范围）</p></blockquote><h3 id="cmos晶体管" tabindex="-1"><a class="header-anchor" href="#cmos晶体管"><span>CMOS晶体管</span></a></h3><p>MOS是三极晶体管：</p><ul><li>gate栅极，通常是in的部分</li><li>source源极</li><li>drain漏极</li></ul><h4 id="nmos和pmos" tabindex="-1"><a class="header-anchor" href="#nmos和pmos"><span>NMOS和PMOS</span></a></h4><p>MOS常见的是下面这两种：<br><img src="'+f+'" width="50%/"></p><p>左边是NMOS,上面是漏极，下面是源极；右边的PMOS相反。</p><p>更重要的区别在与：</p><ul><li>对于NMOS，当Vgs&lt;=0的时候，电阻大不导通；当Vgs&gt;=0的时候导通</li><li>PMOS是，当Vgs&gt;=0的时候不导通，当Vgs&lt;0的时候导通。</li></ul><p><strong>即栅极和源极在上面的那个电平大的时候导通</strong></p><h4 id="cmos晶体管-1" tabindex="-1"><a class="header-anchor" href="#cmos晶体管-1"><span>CMOS晶体管</span></a></h4><p>利用NMOS和PMOS构成CMOS,下面是非门(左），与非门（右）的实现方式：</p><div style="display:flex;"><img src="'+y+'" width="50%"><img src="'+b+'" width="50%/"></div> **K输入**：输入k个电压，通常小于4；因为会导致噪音增大。 <p><strong>级联</strong>：将多个输入端较少的门电路级联，实现多数入。</p><p><strong>缓冲器</strong>：取两次非，将信号更加精准。</p><blockquote><p>由两个非门<strong>级联</strong>得到</p></blockquote><h4 id="设计cmos电路" tabindex="-1"><a class="header-anchor" href="#设计cmos电路"><span>设计cmos电路</span></a></h4><p>这篇文章值得一看<a href="https://www.cnblogs.com/Atsea/p/3885879.html" target="_blank" rel="noopener noreferrer">COMS门电路的设计及其优化--以异或门为例 - The Pisces - 博客园</a></p><p>这篇文章是和卡诺图有关讲得很好！ <a href="https://zhuanlan.zhihu.com/p/158535749" target="_blank" rel="noopener noreferrer">逻辑函数的卡诺图化简 || 卡诺图 || 重点 || 数电 - 知乎</a></p><p>由真值表得到CMOS电路：</p><ol><li>卡诺图化简</li><li>画图</li></ol><p>非门需要一对CMOS，与非门需要两对CMOS，与门需要三队CMOS。</p><h4 id="cmos的电路特性" tabindex="-1"><a class="header-anchor" href="#cmos的电路特性"><span>CMOS的电路特性</span></a></h4><ul><li>转换时间：输入信号（或输出信号）从一种状态变成另外一种状态的所需的时间。</li><li>传播延时：输入信号变化到输出信号变化的时间。</li></ul><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250303102631853.png" alt="image-20250303102631853" tabindex="0" loading="lazy"><figcaption>image-20250303102631853</figcaption></figure>',44)),n(a,null,{default:t(()=>i[0]||(i[0]=[p("(传播延时,tpHL是输出信号从high到low的时间，tpLH是输出信号从low到high需要的时间)")])),_:1}),i[3]||(i[3]=e('<h3 id="布尔代数" tabindex="-1"><a class="header-anchor" href="#布尔代数"><span>布尔代数</span></a></h3><p><strong>对偶定理</strong></p><ul><li>对偶式：将与和或互换，得到的新式子就是对偶式；（注意：运算的顺序不能改变，意味着，很多地方要加上括号）</li><li>如果两个逻辑表达式相等，那么逻辑表达式也相等。</li></ul><p><strong>乘积项</strong></p><ul><li>单独的几个变量相乘；</li></ul><p><strong>求和项</strong></p><ul><li>单独几个变量相加；</li></ul><p><strong>标准乘积项 | 最小项</strong></p><ul><li>出现所有变量的乘积项（出现一次）</li></ul><p><strong>标准求和项 | 最大项</strong></p><ul><li>出现所有变量的求和项（出现一次）</li></ul><p><strong>几个需要记忆的式子</strong></p><ul><li>$(X+Y) \\cdot (X+Z)=X+Y\\cdot Z$</li><li>$(X+X \\cdot Y)=X$</li><li>$X \\cdot (X+Y)=X$</li><li>$X \\cdot Y+\\overline X \\cdot Z+Y \\cdot Z= X \\cdot Y + \\overline X \\cdot Z$//有一项是多余的</li><li>$(X+Y)\\cdot (\\overline X +Z)\\cdot (Y+Z)=(X+Y)\\cdot (\\overline X +Z)$</li></ul><p><strong>De Morgan&#39;s law和香农定理</strong></p><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250303105327608.png" alt="image-20250303105327608" tabindex="0" loading="lazy"><figcaption>image-20250303105327608</figcaption></figure><h3 id="逻辑关系描述" tabindex="-1"><a class="header-anchor" href="#逻辑关系描述"><span>逻辑关系描述</span></a></h3><h4 id="逻辑函数" tabindex="-1"><a class="header-anchor" href="#逻辑函数"><span>逻辑函数</span></a></h4><p><strong>每一个输入组合都有一个确定的输出值</strong></p><p><strong>每个逻辑函数都有一组确定的输出分别对应各种输入组合)</strong></p><h4 id="真值表-truth-table" tabindex="-1"><a class="header-anchor" href="#真值表-truth-table"><span>真值表：truth table</span></a></h4><ul><li>输入组合按照数值大小排序</li><li>每一个真值表都对应了一个一个逻辑函数</li></ul><h4 id="波形图" tabindex="-1"><a class="header-anchor" href="#波形图"><span>波形图</span></a></h4><p>用来描述逻辑函数的输出对于输入变量的变化的响应。（忽略时间延迟）</p><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250303112030796.png" alt="image-20250303112030796" tabindex="0" loading="lazy"><figcaption>image-20250303112030796</figcaption></figure><h4 id="逻辑函数的标准表示形式" tabindex="-1"><a class="header-anchor" href="#逻辑函数的标准表示形式"><span>逻辑函数的标准表示形式</span></a></h4><ul><li>乘积项</li><li>求和项</li><li>与或表达式：先与后或；sum of product</li><li>或与表达式：先或后与：product of sum</li><li>标准乘积项（极小项），只有一种情况下能够取1</li><li>标准求和项（极大项） ，只有一个情况下能够取0；</li></ul><h4 id="根据真值表得到逻辑函数的表示" tabindex="-1"><a class="header-anchor" href="#根据真值表得到逻辑函数的表示"><span>根据真值表得到逻辑函数的表示</span></a></h4><p>将最小项取和或者将最大项取积；</p><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250303113829446.png" alt="image-20250303113829446" tabindex="0" loading="lazy"><figcaption>image-20250303113829446</figcaption></figure><h4 id="标准表示的好处-设计电路" tabindex="-1"><a class="header-anchor" href="#标准表示的好处-设计电路"><span>标准表示的好处：设计电路</span></a></h4><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250303112546676.png" alt="image-20250303112546676" tabindex="0" loading="lazy"><figcaption>image-20250303112546676</figcaption></figure><p>电路只有<strong>两级</strong>。</p><hr><p><strong>标准表示不是最简</strong>，如何将标准的表达式化成最简呢?</p><h2 id="逻辑函数的化简和变化" tabindex="-1"><a class="header-anchor" href="#逻辑函数的化简和变化"><span>逻辑函数的化简和变化</span></a></h2><h4 id="_1-代数化简" tabindex="-1"><a class="header-anchor" href="#_1-代数化简"><span>1. 代数化简</span></a></h4><p>如果表达式的层级超过了两级，那么需要先转换成两级；</p><p>如果有哦整体取反运算，则需要先转换为单变量取反运算；</p><p><strong>技巧性较强</strong></p><h4 id="_2-卡诺图化简" tabindex="-1"><a class="header-anchor" href="#_2-卡诺图化简"><span>2. 卡诺图化简</span></a></h4><p>推荐阅读：<a href="https://zhuanlan.zhihu.com/p/158535749" target="_blank" rel="noopener noreferrer">逻辑函数的卡诺图化简 || 卡诺图 || 重点 || 数电 - 知乎</a></p><p>将真值表图形化表示出来，相邻的几项是可以化简的。</p><blockquote><p>原理：$X \\cdot Y +X \\cdot \\overline Y=X$</p></blockquote><ol><li>卡诺图上找出所有的最小项（或者说真值表为1对应的所有赋值情况）</li><li>在卡诺图上将其按照相邻分块</li><li>取出所有没有相互覆盖的分块</li></ol><p>几种特殊情况：</p><div style="display:grid;grid-template-columns:repeat(2,50%);"><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/20250307103204.png"><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/20250307103322.png"><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/20250307103322.png"></div><blockquote><ol><li>注意“相邻”的含义，指的是符合格雷码的规则，不是物理含义上的相邻</li><li>遵守“最大圈”和“完全覆盖的原则”；比如，为了覆盖011这个位置其实可以选择$\\overline X Y Z$，或者$YZ$,但是圈要最大，因此要选择YZ</li></ol></blockquote><p><strong>蕴含项</strong></p><ul><li>最小项是蕴含项</li><li>由蕴含项通过或表达式得到的乘积项也是蕴含项</li></ul><p><strong>质蕴含项</strong></p><ul><li>质蕴含项不能被其他的蕴含项 包含</li></ul><p><strong>实质蕴含项</strong></p><ul><li><strong>包含有至少一个最小项不为其他的蕴含项所包括</strong> | 人话：卡诺图里面，这个蕴含项有一个点位只有他包括进去了</li></ul><p><strong>最小覆盖</strong></p><ul><li>一组<strong>蕴含项数量最少</strong>的情况</li><li>一定是要覆盖所有的点位</li></ul><blockquote><p>实质蕴含项的定义就说明，它有别人所不能取代的原因：每一个最小覆盖一定<strong>包含有所有的实质蕴含项</strong></p></blockquote><p>卡诺图的化简我觉得讲得最好的还是：<a href="https://zhuanlan.zhihu.com/p/158535749" target="_blank" rel="noopener noreferrer">逻辑函数的卡诺图化简 || 卡诺图 || 重点 || 数电 - 知乎</a></p><h4 id="逻辑函数变化" tabindex="-1"><a class="header-anchor" href="#逻辑函数变化"><span>逻辑函数变化</span></a></h4><p>可以通过对逻辑表达式进行<strong>化简</strong>，将逻辑表达式的形式改成更加适合电路设计；</p><p>比如全部换成与非和或非表达式，实现的效果更快；</p><p>比如对于下面这个逻辑函数<br> $$<br> F(X,Y,Z)=X \\cdot Y +X\\cdot Z +Y \\cdot Z<br> $$<br> 可以两次使用德摩根率：<br> $$<br> \\overline {\\overline{ X \\cdot Y +X\\cdot Z +Y \\cdot Z}}=\\overline {\\overline{X \\cdot Y}\\cdot \\overline{X \\cdot Z} \\cdot \\overline{Y \\cdot Z}}<br> $$</p><hr><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250307111246272.png" alt="image-20250307111246272" tabindex="0" loading="lazy"><figcaption>image-20250307111246272</figcaption></figure>',63)),n(a,null,{default:t(()=>i[1]||(i[1]=[r("strong",null,"图来自ppt",-1)])),_:1})])}const _=o($,[["render",B],["__file","数字逻辑基础.html.vue"]]),A=JSON.parse('{"path":"/posts/NJUCS/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E5%9F%BA%E7%A1%80.html","title":"数字逻辑基础","lang":"zh-CN","frontmatter":{"title":"数字逻辑基础","description":"对应了实验123. 逻辑门与数字抽象 逻辑门：logic gate 直接上图： 上面的三种logic gate是基本逻辑门。 image-20250228110021775image-20250228110021775 但是要记住这几种logic gate对应的运算符号。 $A \\\\cdot B$, $\\\\overline{A}$, A+B $A \\\\opl...","head":[["meta",{"property":"og:url","content":"https://github.com/yama-lei/yama-lei.github.io/posts/NJUCS/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E5%9F%BA%E7%A1%80.html"}],["meta",{"property":"og:site_name","content":"Myblog"}],["meta",{"property":"og:title","content":"数字逻辑基础"}],["meta",{"property":"og:description","content":"对应了实验123. 逻辑门与数字抽象 逻辑门：logic gate 直接上图： 上面的三种logic gate是基本逻辑门。 image-20250228110021775image-20250228110021775 但是要记住这几种logic gate对应的运算符号。 $A \\\\cdot B$, $\\\\overline{A}$, A+B $A \\\\opl..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250303102631853.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-07T13:37:45.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-07T13:37:45.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"数字逻辑基础\\",\\"image\\":[\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250303102631853.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250303105327608.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250303112030796.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250303113829446.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250303112546676.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250307111246272.png\\"],\\"dateModified\\":\\"2025-03-07T13:37:45.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Yama-lei\\",\\"url\\":\\"/underbuilding.html\\"}]}"]]},"headers":[{"level":2,"title":"逻辑门与数字抽象","slug":"逻辑门与数字抽象","link":"#逻辑门与数字抽象","children":[{"level":3,"title":"逻辑门：logic gate","slug":"逻辑门-logic-gate","link":"#逻辑门-logic-gate","children":[]},{"level":3,"title":"数字抽象","slug":"数字抽象","link":"#数字抽象","children":[]},{"level":3,"title":"CMOS晶体管","slug":"cmos晶体管","link":"#cmos晶体管","children":[]},{"level":3,"title":"布尔代数","slug":"布尔代数","link":"#布尔代数","children":[]},{"level":3,"title":"逻辑关系描述","slug":"逻辑关系描述","link":"#逻辑关系描述","children":[]}]},{"level":2,"title":"逻辑函数的化简和变化","slug":"逻辑函数的化简和变化","link":"#逻辑函数的化简和变化","children":[]}],"git":{"createdTime":1740819935000,"updatedTime":1741354665000,"contributors":[{"name":"yama-lei","username":"yama-lei","email":"1908777046@qq.com","commits":3,"url":"https://github.com/yama-lei"}]},"readingTime":{"minutes":6.69,"words":2008},"filePathRelative":"posts/NJUCS/数字逻辑与计算机组成/数字逻辑基础.md","localizedDate":"2025年3月1日","excerpt":"<p>对应了实验123.</p>\\n<h2>逻辑门与数字抽象</h2>\\n<h3>逻辑门：logic gate</h3>\\n<p>直接上图：</p>\\n<div style=\\"display:flex;width: 33.3%\\">\\n\\n\\n\\n</div>\\n上面的三种logic gate是基本逻辑门。\\n<figure><figcaption>image-20250228110021775</figcaption></figure>\\n<p>但是要记住这几种logic gate对应的运算符号。</p>\\n<ul>\\n<li>$A \\\\cdot B$, $\\\\overline{A}$, A+B</li>\\n<li>$A \\\\oplus B$</li>\\n<li>$A \\\\odot B$</li>\\n</ul>","autoDesc":true}');export{_ as comp,A as data};
