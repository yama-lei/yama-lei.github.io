import{_ as n,c as t,d as o,e,g as l,r as s,o as p,f as g,b as r}from"./app-BJE5mUcC.js";const c="/assets/image-20250228105251394-CIhVIk1m.png",m="/assets/image-20250228105333434-BiChIym4.png",d="/assets/image-20250228105343896-4QC3DtGj.png",h="/assets/image-20250228110021775-vAgDz9OU.png",u="/assets/image-20250228112500139-CL3BJ4l0.png",$="/assets/image-20250228095605847-B13e1Wdn.png",f="/assets/image-20250228113834753-BnF3-2Qw.png",b="/assets/image-20250228114607715-BhXzE9eP.png",y={};function _(A,i){const a=s("center");return p(),t("div",null,[i[2]||(i[2]=o('<p>对应了实验123.</p><h2 id="逻辑门与数字抽象" tabindex="-1"><a class="header-anchor" href="#逻辑门与数字抽象"><span>逻辑门与数字抽象</span></a></h2><h3 id="逻辑门-logic-gate" tabindex="-1"><a class="header-anchor" href="#逻辑门-logic-gate"><span>逻辑门：logic gate</span></a></h3><p>直接上图：</p><div style="display:flex;width:33.3%;"><img src="'+c+'"><img src="'+m+'"><img src="'+d+'"></div> 上面的三种logic gate是基本逻辑门。 <figure><img src="'+h+'" alt="image-20250228110021775" tabindex="0" loading="lazy"><figcaption>image-20250228110021775</figcaption></figure><p>但是要记住这几种logic gate对应的运算符号。</p><ul><li>$A \\cdot B$, $\\overline{A}$, A+B</li><li>$A \\oplus B$</li><li>$A \\odot B$</li></ul><h3 id="数字抽象" tabindex="-1"><a class="header-anchor" href="#数字抽象"><span>数字抽象</span></a></h3><p><strong>数字抽象（逻辑采样）</strong>：将某个物理量的实际值集映射为两个子集，对应于两个状态或两个逻辑值0和1。</p><p>在数字系统中，将一定范围内的电压映射到两个状态：高态（high）和低态（low），并用0和1来表示。</p><p><strong>正逻辑</strong>将高电压映射为1，低电压映射为0；负逻辑则相反。</p><p>L or H stands for &#39;Low&#39; or &#39;High&#39;</p><ul><li>VIHmin：确保能被识别为高态的最小输入电压值。</li><li>VILmax：确保能被识别为低态的最大输入电压值。</li><li>VOHmin：输出为高态时的最小输出电压值。</li></ul><blockquote><p>VIHmin小于VOHmin,即<strong>输入识别的电压范围比较大，输出电压的范围比较窄</strong></p></blockquote><ul><li>VOLmax：输出为低态时的最大输出电压值。</li></ul><blockquote><p>VILmax大于VOLmax，理由同上。</p></blockquote><blockquote><figure><img src="'+u+'" alt="image-20250228112500139" tabindex="0" loading="lazy"><figcaption>image-20250228112500139</figcaption></figure><p>​ （图中表示输入输出的电压范围）</p></blockquote><h3 id="cmos晶体管" tabindex="-1"><a class="header-anchor" href="#cmos晶体管"><span>CMOS晶体管</span></a></h3><p>MOS是三极晶体管：</p><ul><li>gate栅极，通常是in的部分</li><li>source源极</li><li>drain漏极</li></ul><h4 id="nmos和pmos" tabindex="-1"><a class="header-anchor" href="#nmos和pmos"><span>NMOS和PMOS</span></a></h4><p>MOS常见的是下面这两种：<br><img src="'+$+'" width="50%/"></p><p>左边是NMOS,上面是漏极，下面是源极；右边的PMOS相反。</p><p>更重要的区别在与：</p><ul><li>对于NMOS，当Vgs&lt;=0的时候，电阻大不导通；当Vgs&gt;=0的时候导通</li><li>PMOS是，当Vgs&gt;=0的时候不导通，当Vgs&lt;0的时候导通。</li></ul><p><strong>即栅极和源极在上面的那个电平大的时候导通</strong></p><h4 id="cmos晶体管-1" tabindex="-1"><a class="header-anchor" href="#cmos晶体管-1"><span>CMOS晶体管</span></a></h4><p>利用NMOS和PMOS构成CMOS,下面是非门(左），与非门（右）的实现方式：</p><div style="display:flex;"><img src="'+f+'" width="50%"><img src="'+b+'" width="50%/"></div> **K输入**：输入k个电压，通常小于4；因为会导致噪音增大。 <p><strong>级联</strong>：将多个输入端较少的门电路级联，实现多数入。</p><p><strong>缓冲器</strong>：取两次非，将信号更加精准。</p><blockquote><p>由两个非门<strong>级联</strong>得到</p></blockquote><h4 id="设计cmos电路" tabindex="-1"><a class="header-anchor" href="#设计cmos电路"><span>设计cmos电路</span></a></h4><p>这篇文章值得一看<a href="https://www.cnblogs.com/Atsea/p/3885879.html" target="_blank" rel="noopener noreferrer">COMS门电路的设计及其优化--以异或门为例 - The Pisces - 博客园</a></p><p>这篇文章是和卡诺图有关讲得很好！ <a href="https://zhuanlan.zhihu.com/p/158535749" target="_blank" rel="noopener noreferrer">逻辑函数的卡诺图化简 || 卡诺图 || 重点 || 数电 - 知乎</a></p><p>由真值表得到CMOS电路：</p><ol><li>卡诺图化简</li><li>画图</li></ol><p>非门需要一对CMOS，与非门需要两对CMOS，与门需要三队CMOS。</p><h4 id="cmos的电路特性" tabindex="-1"><a class="header-anchor" href="#cmos的电路特性"><span>CMOS的电路特性</span></a></h4><ul><li>转换时间：输入信号（或输出信号）从一种状态变成另外一种状态的所需的时间。</li><li>传播延时：输入信号变化到输出信号变化的时间。</li></ul><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250303102631853.png" alt="image-20250303102631853" tabindex="0" loading="lazy"><figcaption>image-20250303102631853</figcaption></figure>',44)),e(a,null,{default:l(()=>i[0]||(i[0]=[g("(传播延时,tpHL是输出信号从high到low的时间，tpLH是输出信号从low到high需要的时间)")])),_:1}),i[3]||(i[3]=o('<h2 id="布尔代数" tabindex="-1"><a class="header-anchor" href="#布尔代数"><span>布尔代数</span></a></h2><h3 id="一些定理" tabindex="-1"><a class="header-anchor" href="#一些定理"><span>一些定理</span></a></h3><p><strong>对偶定理</strong></p><ul><li>对偶式：将与和或互换，得到的新式子就是对偶式；（注意：运算的顺序不能改变，意味着，很多地方要加上括号）</li><li>如果两个逻辑表达式相等，那么逻辑表达式的对偶式也相等。</li></ul><p><strong>乘积项</strong></p><ul><li>单独的几个变量相乘；</li></ul><p><strong>求和项</strong></p><ul><li>单独几个变量相加；</li></ul><p><strong>标准乘积项 | 最小项</strong></p><ul><li>出现所有变量的乘积项（出现一次）</li></ul><p><strong>标准求和项 | 最大项</strong></p><ul><li>出现所有变量的求和项（出现一次）</li></ul><blockquote><p>n参数的逻辑函数，最大项/最小项数目为$2^n$个；</p><p><strong>所有最小项的和为恒为1，所有极大项的积恒为0</strong>；</p></blockquote><p><strong>几个需要记忆的式子</strong></p><ul><li>$(X+Y) \\cdot (X+Z)=X+Y\\cdot Z$</li><li>$(X+X \\cdot Y)=X$</li><li>$X \\cdot (X+Y)=X$</li><li>$X \\cdot Y+\\overline X \\cdot Z+Y \\cdot Z= X \\cdot Y + \\overline X \\cdot Z$//有一项是多余的</li><li>$(X+Y)\\cdot (\\overline X +Z)\\cdot (Y+Z)=(X+Y)\\cdot (\\overline X +Z)$</li></ul><h3 id="异或-同或-运算" tabindex="-1"><a class="header-anchor" href="#异或-同或-运算"><span><strong>异或 同或</strong> 运算</span></a></h3><ul><li><p>异或的性质：</p><ol><li><p>$A \\oplus A= 0$</p></li><li><p>$(A \\oplus B) \\oplus C=A \\oplus (B \\oplus C)$</p></li><li><p>$\\overline{A \\oplus B}=A \\oplus \\overline B=\\overline A \\oplus B=A \\odot B$</p></li></ol></li><li><p>同或的性质</p><ol><li>$A \\odot A=1$</li><li>同样满足交换律</li><li>取反的性质和异或式一样的</li></ol></li><li><p>神奇的性质<br> 对于一系列逻辑变量 $A_n, n \\in N^+$，定义两种运算:</p><ul><li>&quot;连续同或运算&quot;: (第一个省略号代表多个左半括号)</li></ul><p>$$M_k = (\\ldots (A_1 \\odot A_2) \\odot A_3) \\odot \\ldots) \\odot A_k, k \\in N^+$$</p><ul><li>&quot;连续异或运算&quot;: (第一个省略号代表多个左半括号)</li></ul><p>$$N_k = (\\ldots (A_1 \\oplus A_2) \\oplus A_3) \\oplus \\ldots) \\oplus A_k, k \\in N^+$$</p><p><strong>根据这两种运算得到的布尔变量 $M_k, N_k$ 根据 $k$ 的不同有以下关系:</strong></p><ol><li>$M_k = N_k$, when $k$ is odd;</li><li>$M_k = \\overline{N_k}$, when $k$ is even.</li></ol><p>举个例子, 当 $k = 3$:</p><ul><li><p>$$M_3 = (A_1 \\odot A_2) \\odot A_3, \\quad N_3 = (A_1 \\oplus A_2) \\oplus A_3$$</p></li><li><p>结论为: $M_3 = N_3$</p></li></ul></li></ul><p><strong>De Morgan&#39;s law和香农定理</strong></p><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250303105327608.png" alt="image-20250303105327608" tabindex="0" loading="lazy"><figcaption>image-20250303105327608</figcaption></figure><h2 id="逻辑关系描述" tabindex="-1"><a class="header-anchor" href="#逻辑关系描述"><span>逻辑关系描述</span></a></h2><h4 id="逻辑函数" tabindex="-1"><a class="header-anchor" href="#逻辑函数"><span>逻辑函数</span></a></h4><p><strong>每一个输入组合都有一个确定的输出值</strong></p><p><strong>每个逻辑函数都有一组确定的输出分别对应各种输入组合)</strong></p><h4 id="真值表-truth-table" tabindex="-1"><a class="header-anchor" href="#真值表-truth-table"><span>真值表：truth table</span></a></h4><ul><li>输入组合按照数值大小排序</li><li>每一个真值表都对应了一个一个逻辑函数</li></ul><h4 id="波形图" tabindex="-1"><a class="header-anchor" href="#波形图"><span>波形图</span></a></h4><p>用来描述逻辑函数的输出对于输入变量的变化的响应。（忽略时间延迟）</p><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250303112030796.png" alt="image-20250303112030796" tabindex="0" loading="lazy"><figcaption>image-20250303112030796</figcaption></figure><h4 id="逻辑函数的标准表示形式" tabindex="-1"><a class="header-anchor" href="#逻辑函数的标准表示形式"><span>逻辑函数的标准表示形式</span></a></h4><ul><li>乘积项</li><li>求和项</li><li>与或表达式：先与后或；sum of product</li><li>或与表达式：先或后与：product of sum</li><li>标准乘积项（极小项），只有一种情况下能够取1</li><li>标准求和项（极大项） ，只有一个情况下能够取0；</li></ul><h4 id="根据真值表得到逻辑函数的表示" tabindex="-1"><a class="header-anchor" href="#根据真值表得到逻辑函数的表示"><span>根据真值表得到逻辑函数的表示</span></a></h4><p>将最小项取和或者将最大项取积；</p><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250303113829446.png" alt="image-20250303113829446" tabindex="0" loading="lazy"><figcaption>image-20250303113829446</figcaption></figure><h4 id="标准表示的好处-设计电路" tabindex="-1"><a class="header-anchor" href="#标准表示的好处-设计电路"><span>标准表示的好处：设计电路</span></a></h4><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250303112546676.png" alt="image-20250303112546676" tabindex="0" loading="lazy"><figcaption>image-20250303112546676</figcaption></figure><p>电路只有<strong>两级</strong>。</p><hr><p><strong>标准表示不是最简</strong>，如何将标准的表达式化成最简呢?</p><h2 id="逻辑函数的化简和变化" tabindex="-1"><a class="header-anchor" href="#逻辑函数的化简和变化"><span>逻辑函数的化简和变化</span></a></h2><h4 id="_1-代数化简" tabindex="-1"><a class="header-anchor" href="#_1-代数化简"><span>1. 代数化简</span></a></h4><p>如果表达式的层级超过了两级，那么需要先转换成两级；</p><p>如果有哦整体取反运算，则需要先转换为单变量取反运算；</p><p><strong>技巧性较强</strong></p><ul><li>如果化简的对象比较复杂，可以先化简其对偶式，再将其取一次对偶即可；</li><li>与或表达式取反得到或与表达式，两次取反可以得到<strong>与非-与非表达式</strong>或<strong>或非-或非表达式</strong></li></ul><h4 id="_2-卡诺图化简" tabindex="-1"><a class="header-anchor" href="#_2-卡诺图化简"><span>2. 卡诺图化简</span></a></h4><p>推荐阅读：<a href="https://zhuanlan.zhihu.com/p/158535749" target="_blank" rel="noopener noreferrer">逻辑函数的卡诺图化简 || 卡诺图 || 重点 || 数电 - 知乎</a></p><p>将真值表图形化表示出来，相邻的几项是可以化简的。</p><blockquote><p>原理：$X \\cdot Y +X \\cdot \\overline Y=X$</p></blockquote><ol><li>卡诺图上找出所有的最小项（或者说真值表为1对应的所有赋值情况）</li><li>在卡诺图上将其按照相邻分块</li><li>取出所有没有相互覆盖的分块</li></ol><p>几种特殊情况：</p><div style="display:grid;grid-template-columns:repeat(2,50%);"><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/20250307103204.png"><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/20250307103322.png"><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/20250307103322.png"></div><blockquote><ol><li>注意“相邻”的含义，指的是符合格雷码的规则，不是物理含义上的相邻</li><li>遵守“最大圈”和“完全覆盖的原则”；比如，为了覆盖011这个位置其实可以选择$\\overline X Y Z$，或者$YZ$,但是圈要最大，因此要选择YZ</li></ol></blockquote><p><strong>蕴含项</strong></p><ul><li>最小项是蕴含项</li><li>由蕴含项通过或表达式得到的乘积项也是蕴含项</li></ul><p><strong>质蕴含项</strong></p><ul><li>质蕴含项不能被其他的蕴含项 包含</li></ul><p><strong>实质蕴含项</strong></p><ul><li><strong>包含有至少一个最小项不为其他的蕴含项所包括</strong> | 人话：卡诺图里面，这个蕴含项有一个点位只有他包括进去了</li></ul><p><strong>最小覆盖</strong></p><ul><li>一组<strong>蕴含项数量最少</strong>的情况</li><li>一定是要覆盖所有的点位</li></ul><blockquote><p>实质蕴含项的定义就说明，它有别人所不能取代的原因：每一个最小覆盖一定<strong>包含有所有的实质蕴含项</strong></p></blockquote><p>卡诺图的化简我觉得讲得最好的还是：<a href="https://zhuanlan.zhihu.com/p/158535749" target="_blank" rel="noopener noreferrer">逻辑函数的卡诺图化简 || 卡诺图 || 重点 || 数电 - 知乎</a></p><h4 id="逻辑函数转换" tabindex="-1"><a class="header-anchor" href="#逻辑函数转换"><span>逻辑函数转换</span></a></h4><p>可以通过对逻辑表达式进行<strong>化简</strong>，将逻辑表达式的形式改成更加适合电路设计；</p><p>比如全部换成<strong>与非和或非表达式</strong>，实现的效果更快；</p><p>比如对于下面这个逻辑函数<br> $$<br> F(X,Y,Z)=X \\cdot Y +X\\cdot Z +Y \\cdot Z<br> $$<br> 可以两次使用德摩根率：<br> $$<br> \\overline {\\overline{ X \\cdot Y +X\\cdot Z +Y \\cdot Z}}=\\overline {\\overline{X \\cdot Y}\\cdot \\overline{X \\cdot Z} \\cdot \\overline{Y \\cdot Z}}<br> $$</p><hr><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250307111246272.png" alt="image-20250307111246272" tabindex="0" loading="lazy"><figcaption>image-20250307111246272</figcaption></figure>',68)),e(a,null,{default:l(()=>i[1]||(i[1]=[r("strong",null,"图来自ppt",-1)])),_:1})])}const k=n(y,[["render",_],["__file","数字逻辑基础.html.vue"]]),x=JSON.parse('{"path":"/posts/NJUCS/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E5%9F%BA%E7%A1%80.html","title":"第二章 | 数字逻辑基础","lang":"zh-CN","frontmatter":{"title":"第二章 | 数字逻辑基础","description":"对应了实验123. 逻辑门与数字抽象 逻辑门：logic gate 直接上图： 上面的三种logic gate是基本逻辑门。 image-20250228110021775image-20250228110021775 但是要记住这几种logic gate对应的运算符号。 $A \\\\cdot B$, $\\\\overline{A}$, A+B $A \\\\opl...","head":[["meta",{"property":"og:url","content":"https://github.com/yama-lei/yama-lei.github.io/posts/NJUCS/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E5%9F%BA%E7%A1%80.html"}],["meta",{"property":"og:site_name","content":"Myblog"}],["meta",{"property":"og:title","content":"第二章 | 数字逻辑基础"}],["meta",{"property":"og:description","content":"对应了实验123. 逻辑门与数字抽象 逻辑门：logic gate 直接上图： 上面的三种logic gate是基本逻辑门。 image-20250228110021775image-20250228110021775 但是要记住这几种logic gate对应的运算符号。 $A \\\\cdot B$, $\\\\overline{A}$, A+B $A \\\\opl..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250303102631853.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-03-21T02:00:27.000Z"}],["meta",{"property":"article:modified_time","content":"2025-03-21T02:00:27.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"第二章 | 数字逻辑基础\\",\\"image\\":[\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250303102631853.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250303105327608.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250303112030796.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250303113829446.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250303112546676.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250307111246272.png\\"],\\"dateModified\\":\\"2025-03-21T02:00:27.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Yama-lei\\",\\"url\\":\\"/underbuilding.html\\"}]}"]]},"headers":[{"level":2,"title":"逻辑门与数字抽象","slug":"逻辑门与数字抽象","link":"#逻辑门与数字抽象","children":[{"level":3,"title":"逻辑门：logic gate","slug":"逻辑门-logic-gate","link":"#逻辑门-logic-gate","children":[]},{"level":3,"title":"数字抽象","slug":"数字抽象","link":"#数字抽象","children":[]},{"level":3,"title":"CMOS晶体管","slug":"cmos晶体管","link":"#cmos晶体管","children":[]}]},{"level":2,"title":"布尔代数","slug":"布尔代数","link":"#布尔代数","children":[{"level":3,"title":"一些定理","slug":"一些定理","link":"#一些定理","children":[]},{"level":3,"title":"异或 同或 运算","slug":"异或-同或-运算","link":"#异或-同或-运算","children":[]}]},{"level":2,"title":"逻辑关系描述","slug":"逻辑关系描述","link":"#逻辑关系描述","children":[]},{"level":2,"title":"逻辑函数的化简和变化","slug":"逻辑函数的化简和变化","link":"#逻辑函数的化简和变化","children":[]}],"git":{"createdTime":1740819935000,"updatedTime":1742522427000,"contributors":[{"name":"yama-lei","username":"yama-lei","email":"1908777046@qq.com","commits":4,"url":"https://github.com/yama-lei"}]},"readingTime":{"minutes":7.87,"words":2361},"filePathRelative":"posts/NJUCS/数字逻辑与计算机组成/数字逻辑基础.md","localizedDate":"2025年3月1日","excerpt":"<p>对应了实验123.</p>\\n<h2>逻辑门与数字抽象</h2>\\n<h3>逻辑门：logic gate</h3>\\n<p>直接上图：</p>\\n<div style=\\"display:flex;width: 33.3%\\">\\n\\n\\n\\n</div>\\n上面的三种logic gate是基本逻辑门。\\n<figure><figcaption>image-20250228110021775</figcaption></figure>\\n<p>但是要记住这几种logic gate对应的运算符号。</p>\\n<ul>\\n<li>$A \\\\cdot B$, $\\\\overline{A}$, A+B</li>\\n<li>$A \\\\oplus B$</li>\\n<li>$A \\\\odot B$</li>\\n</ul>","autoDesc":true}');export{k as comp,x as data};
