import{_ as l,c as e,d as n,b as i,f as a,e as t,g as o,r as h,o as g}from"./app-iw0frhaY.js";const r={};function c(d,s){const p=h("center");return g(),e("div",null,[s[1]||(s[1]=n('<p>[TOC]</p><h2 id="第一讲-基本运算部件" tabindex="-1"><a class="header-anchor" href="#第一讲-基本运算部件"><span>第一讲 | 基本运算部件</span></a></h2><p>想要实现高级语言程序设计的各种运算，需要将表达式转换成指令。</p><p>比如</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a,b</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">5</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">;</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>将数据以<code>补码</code>的形式存入寄存器中。指令-&gt;汇编-&gt;机器指令。</p><p>软件（高级语言设计），指令（ISA），硬件设计，环环相扣。</p><hr><p>所有的运算都可以通过ALU+逻辑部件实现。</p><blockquote><p>有关门延迟这一部分,建议阅读：<a href="https://zhuanlan.zhihu.com/p/590151247" target="_blank" rel="noopener noreferrer">全加器以及行波进位加/减法器时延的计算 - 知乎</a>，因为ppt就是一坨。</p></blockquote><h3 id="串行-行波-进位加法器" tabindex="-1"><a class="header-anchor" href="#串行-行波-进位加法器"><span>串行(行波)进位加法器:</span></a></h3><p>我们先回顾一下什么是全加器FA：</p><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250328110827793.png" alt="image-20250328110827793" style="zoom:33%;"><p>在这个全加器里，Cout的延迟是2，F的延迟是3；</p><p>由多个全加器相连接，前一个全加器的进位作为这一个加法器的cin。</p><p><strong>效率慢</strong></p><p>每一个FA（全加器）需要经过两级门延迟，n位的串行进位加法器就需要2n个门延迟得到Cn进位，2n+1个延迟得到Fn。</p><blockquote><p>生成最后一位的Cout在2n时生成，因此最后一位的F在2n+1位生成。</p></blockquote><h3 id="并行-先行-进位加法器-cla" tabindex="-1"><a class="header-anchor" href="#并行-先行-进位加法器-cla"><span>并行(先行)进位加法器 CLA</span></a></h3><p>先行进位部件：（CLU)</p><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250328102746927.png" alt="image-20250328102746927" tabindex="0" loading="lazy"><figcaption>image-20250328102746927</figcaption></figure><p>一共需要6级延迟就能得到最终的和。</p><p>其中xi和yi在第一个时间段生成gi和pi</p><p>接着两个门延迟后，生成了Ci1</p><p>最后三个门延迟生成和Fi。</p><blockquote><p>因此c4其实在第三个</p></blockquote><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250328103202290.png" alt="image-20250328103202290" tabindex="0" loading="lazy"><figcaption>image-20250328103202290</figcaption></figure><hr><h3 id="局部先行进位加法器" tabindex="-1"><a class="header-anchor" href="#局部先行进位加法器"><span><strong>局部先行进位加法器</strong></span></a></h3><p>比如：使用4个4位先行进位加法器进行串行，实现一个16位的加法器。</p><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250328103710902.png" alt="image-20250328103710902" tabindex="0" loading="lazy"><figcaption>image-20250328103710902</figcaption></figure><p>（图中的数字代表的是时刻）</p><p><strong>多级先行进位加法器</strong></p><p>组内并行，组间仍然并行。</p><h3 id="n位带标志加法器" tabindex="-1"><a class="header-anchor" href="#n位带标志加法器"><span>n位带标志加法器</span></a></h3><p>我们在加法器中加入一些标志输出，用于指示一些特殊状态（如：溢出）</p><p>对于signed类型，有意义的是：</p><ol><li><p>ZF：0标志位</p></li><li><p>OF：代表是否出现溢出。</p><blockquote><p>判断是否出现Overflow的方法：</p><ol><li>看X+Y的和，如果$C_n$(符号位的进位)和$C_{n-1}$(即X和Y相加之后得到的符号位)的相同，则没有发生溢出。即$OF= C_n \\oplus C_{n-1}$</li><li>看X，Y，以及X+Y的符号位。如果$X_{n-1}=Y_{n-1} \\neq C_{n-1}$ 那么$OP=1$.</li></ol></blockquote></li><li><p>SF:符号位标志。</p></li></ol><p>对于unsigned类型，有意义的是：</p><ol><li>ZF</li><li>CF借位进位标志 ($CF= cin \\oplus cout$)</li></ol><hr><ol><li>溢出标志$OF=C_n \\oplus C_{n-1}$</li><li>符号标志SF $SF=F_{n-1}$ (即，最高位)</li><li>零标志$ZF=1 \\space \\text{if F=0 else 0}$</li><li>进位借位标志$CF=Cout \\oplus Cin$</li></ol><h3 id="alu-算数逻辑运算单元" tabindex="-1"><a class="header-anchor" href="#alu-算数逻辑运算单元"><span>ALU：算数逻辑运算单元</span></a></h3><p>通过一个操作控制端（ALUop），来决定ALU进行什么样的运算</p><blockquote><p>通过多路选择器来决定输出哪一个信号。</p></blockquote><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250328105550124.png" alt="image-20250328105550124" style="zoom:33%;"><p>核心是加减运算，输出结果和标志信息</p><h2 id="第二讲-定点数运算" tabindex="-1"><a class="header-anchor" href="#第二讲-定点数运算"><span>第二讲 | 定点数运算</span></a></h2><h3 id="加减法" tabindex="-1"><a class="header-anchor" href="#加减法"><span>加减法</span></a></h3><p>$[x+y]_补 =2^n+x+y= 2<sup>n+x+2</sup>n+y= [x]_补+[y]_补 (mod 2n )$</p><p>$[x-y]_补=2^n+x-y= 2<sup>n+x+2</sup>n-y= [x]_补+[-y]_补 (mod 2n )$</p><p>补码的和就是和的补码，差的补码也是补码的和。</p><p>因此补码可以实现加减法的统一.</p><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250328111952848.png" alt="image-20250328111952848" style="zoom:50%;"><p>上面这个部件十分的神奇！Sub为1的时启动加法，sub还同时作为cin输入，相当于计算$A+\\overline B+1 (mod \\space 2^n)$ ； sub为0的时候，就正常计算就好。</p><p><strong>有符号数singed整数加减法</strong>：</p><p>用上述加减法器件进行运算signed整数，例子如下：</p><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250328123830680.png" alt="image-20250328123830680" style="zoom:50%;"><blockquote><p>OF: overflow; SF: 符号标志位 ZF: 零标志位。</p></blockquote><p>如果用减法来判断两个数的大小，那么在这里我们要看是否有<code>OF=SF</code>，如果满足的话，说明前一个操作数大于后一个操作数。即$less= OF \\cdot SF$ (如果OF=SF，那么前一个数大于后一个数)</p><p><strong>无符号数unsigned整数的加减法</strong>：</p><p>用这个部件对补码进行加减法显然是可以实现的：都是将输入的两个机器码输入，如果加法，则直接相加并取模；如果是减法，那么将第二个操作数取反再相加取模。</p><p>这个部件实际上也可以实现无符号数的加减法。</p><p>对于加法很好理解，无非是一位一位相加，求进位。</p><p>如果比较两个数的大小，那么就看溢出位，$less=cin \\oplus cout$，即，如果有借位就说明前者比后者小。</p><h3 id="乘法运算" tabindex="-1"><a class="header-anchor" href="#乘法运算"><span>乘法运算</span></a></h3><h4 id="无符号数-unsigned乘法" tabindex="-1"><a class="header-anchor" href="#无符号数-unsigned乘法"><span>无符号数 unsigned乘法</span></a></h4><p><strong>Warning:在学习的过程中，我不慎将无符号位，原码补码两个概念搞混</strong>：</p><p>无符号数：没有符号位。无符号数乘法默认是1位</p><p>有符号： 原码或者补码表示，都带有符号！！！前者有1位或者2位，后者的算法称为布斯（Booth)算法！</p><hr><p>无符号数乘法可以由加法和移位实现：<br> $$<br> X×Y= \\sum_{i=1}^{i=n}(X × yi×2^{-i})<br> $$<br> 利用递归的方法，可以得到如下的算法：</p><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250331102900167.png" alt="image-20250331102900167" style="zoom:50%;"><p>以32位原码的乘法为例，两个32位的原码相乘，至少需要64位存储积。</p><blockquote><p>注意在高级语言程序中，有溢出的可能，比如只要32位，那么只会从64位中取低32位。</p></blockquote><p>在实际的硬件实现中：1. C存储循环次数 2. 一个寄存器存储一个乘数 3. 一个存储器同时存储一个乘数和积。</p><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250331104724755.png" alt="image-20250331104724755" tabindex="0" loading="lazy"><figcaption>image-20250331104724755</figcaption></figure><p>即每一次都将高32位和原先的X相加，如果Y的最后一位是0，那么直接将高32位返回，如果是1，那么相加。循环32次。</p><hr><h4 id="浮点数的乘法" tabindex="-1"><a class="header-anchor" href="#浮点数的乘法"><span>浮点数的乘法：</span></a></h4><ol><li>数值部分是原码，因此直接相乘。</li><li>阶码是移码，直接相加。</li><li>符号位取异或。</li></ol><h4 id="原码两位乘法" tabindex="-1"><a class="header-anchor" href="#原码两位乘法"><span>原码两位乘法</span></a></h4><p>前面介绍的都是一位乘法，即一位一位的运算，如果运算32位就需要32次循环，实际上，可以一次运算两位。</p><p>类似的，我们一次性从乘数Y中取两位，如果Y=00，那么无需相加，直接右移；如果为01，则加上X并右移两位；10则加上2个X并右移；11的话按理是加上3个X并右移。但是实际上采取的是先减去一个X右移两位，<strong>并通知下一位多加一个X</strong>。</p><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250331110003790.png" alt="image-20250331110003790" tabindex="0" loading="lazy"><figcaption>image-20250331110003790</figcaption></figure><p>因此，考虑到前一位的标志，一共分成了8种情况。</p><hr><p>原码2位乘法举例：</p><p>（由于移位2位需要用到减法，因此采取补码实现加法）</p><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250331111755147.png" alt="image-20250331111755147" style="zoom:80%;"><p>采取模8补码，算术移位。</p><p>（此处看ppt）</p><hr><h4 id="补码的乘法运算" tabindex="-1"><a class="header-anchor" href="#补码的乘法运算"><span>补码的乘法运算</span></a></h4><p><strong>布斯算法 | Booth Algorithm</strong>：</p>',95)),s[2]||(s[2]=i("p",null,[a("推导过程（过个眼瘾就行）:"),i("br"),a(" $$"),i("br"),a(" \\space y= -y_{n-1}"),i("em",null,[a("2"),i("sup",{i:"n-2"},"{n-1}+\\sum_{i=0}"),a("y_i")]),a("2^i"),i("br"),a(" $$"),i("br"),a(" If we define that $y_{-1}=0$, then we can get that"),i("br"),a(" $$"),i("br"),a(" y=\\sum_{i=0}"),i("sup",null,"{i=1}(y_{i-1}-y_i)*2"),a("i"),i("br"),a(" $$"),i("br"),a(" 可以得到部分积公式："),i("br"),a(" $$"),i("br"),a(" P_n=2^{-1}(P_{n-1}+(y_{i-1}-y_i)x)"),i("br"),a(" $$"),i("br"),a(" 根据当前的位数和前一次的位数可以分成下面这四种可能：")],-1)),s[3]||(s[3]=i("figure",null,[i("img",{src:"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250331113749466.png",alt:"image-20250331113749466",tabindex:"0",loading:"lazy"}),i("figcaption",null,"image-20250331113749466")],-1)),s[4]||(s[4]=i("p",null,"一个运算的例子：",-1)),s[5]||(s[5]=i("img",{src:"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250331114008479.png",alt:"image-20250331114008479",style:{zoom:"50%"}},null,-1)),t(p,null,{default:o(()=>s[0]||(s[0]=[a("**注意：布斯算法右移的时候是补符号位！！！！**")])),_:1}),s[6]||(s[6]=n(`<ul><li><p>那么什么时候会出现溢出呢？</p><ul><li><strong>如果高四位都是符号位，那么结果不会溢出</strong></li></ul></li><li><p>如果[-x]的补码溢出了呢？</p><ol><li>方法1，增加符号位，（比如-8四位补码无法表示，但是我们可以加一位符号位）</li><li>方法2，移位实现（因为我不清楚，所以略去）</li></ol></li></ul><h4 id="补码两位乘法" tabindex="-1"><a class="header-anchor" href="#补码两位乘法"><span>补码两位乘法</span></a></h4><p>类似原码两位乘法，需要根据当前的位数去查表，确定在右移之前需要加多少X，or 多少个X的补码（自行看ppt）</p><h4 id="补充-快速乘法" tabindex="-1"><a class="header-anchor" href="#补充-快速乘法"><span>补充：快速乘法</span></a></h4><ol><li><p>流水快速乘法器</p><ul><li><p>n位运算需要n个ALU</p></li><li><p>完全采取组合逻辑电路，不需要clk的控制，速度快</p></li></ul></li><li><p>CRA整列乘法器</p></li></ol><hr><h4 id="溢出判断" tabindex="-1"><a class="header-anchor" href="#溢出判断"><span>溢出判断</span></a></h4><p>两个n位的机器数通过无符号和有符号乘法算出的低n位其实是相同的，WHY？</p><hr><ul><li>硬件: 在硬件中</li></ul><p>如果结果只保留n位：</p><ul><li>无符号：高n位全为0。</li><li>有符号：高n位全是低n位的符号位（比如1111 <strong>1</strong>001,or 0000 <strong>0</strong>011，容易验证均没有溢出）。</li></ul><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250411101811389.png" alt="image-20250411101811389" style="zoom:50%;"><p>应该要能判断这个表中的溢出与否情况</p><h4 id="乘法与指令" tabindex="-1"><a class="header-anchor" href="#乘法与指令"><span>乘法与指令</span></a></h4><p>机器指令包括：无符号成绩指令和有符号乘积指令</p><ul><li><p>在 RISC-V 中：</p><ul><li><p><code>mul</code> 指令执行普通的乘法，返回低 32 位乘积。</p></li><li><p><code>mulh</code> 和 <code>mulhu</code> 分别处理带符号整数乘法和无符号整数乘法，返回高 32 位乘积。</p><p>这里的乘法运算其实只有一次，而不是两次，只是在ISA中用两条指令来分别取出高32位和低32位。</p></li></ul></li></ul><p>两个n位的数相乘在硬件中会保留2n位的乘积，但是只会取n位。如果是无符号乘法，那么看高n位，不全位0，那么溢出；如果有符号位，那么看高n位是否全为低n位的符号位，如果不是，那么溢出。</p><p><strong>溢出指的都是只保留低n位的情况</strong></p><p>如何判断两个int类型的乘积是否溢出？</p><div class="language-cpp line-numbers-mode" data-highlighter="shiki" data-ext="cpp" data-title="cpp" style="--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34;"><pre class="shiki shiki-themes one-light one-dark-pro vp-code"><code><span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">1.</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">   bool</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> overflow</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> b){</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> (a</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">b)</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">/</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">b</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">!=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">a;}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#986801;--shiki-dark:#D19A66;">2.</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">   bool</span><span style="--shiki-light:#4078F2;--shiki-dark:#61AFEF;"> overflow</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> a, </span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> b){</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">		long</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> long</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> mul</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">long</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;"> long</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)a</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">*</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">b;</span></span>
<span class="line"><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">    	return</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;"> mul</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">!=</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">(</span><span style="--shiki-light:#A626A4;--shiki-dark:#C678DD;">int</span><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">)mul</span></span>
<span class="line"><span style="--shiki-light:#383A42;--shiki-dark:#ABB2BF;">     }</span></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><hr><p>**The End: **</p><p>注意：只有原码的一位乘法才是逻辑又移，其他的都是算术右移。因为原码的两位补码需要用到补码来表示负数。而补码乘法显然使用算术移码。</p><h2 id="除法运算" tabindex="-1"><a class="header-anchor" href="#除法运算"><span>除法运算</span></a></h2><h3 id="定点数的除法运算" tabindex="-1"><a class="header-anchor" href="#定点数的除法运算"><span>定点数的除法运算</span></a></h3><p><strong>在除之前</strong>：</p><ul><li><p>被除数=0，除数！=0，或者在定点除法中abs(dividend)&lt;abs(divisor),结果均为0</p></li><li><p>如果除数为0，那么除0错误</p><blockquote><p>如果是浮点数，可以用阶码全为1，尾数全为0来表示infinite</p></blockquote></li><li><p>如果dividend and divisor both are 0, then the result is &quot;NAN&quot;.</p><blockquote><p>The NAN 在浮点数中用阶码全为1，尾数不全为0来表示</p></blockquote></li></ul><p><strong>定点数除法的步骤：</strong></p><ol><li><p>将被除数补位到2n位。</p><blockquote><p>如果是定点小数，那么补低n位，；如果是定点整数，那么补高n位。</p></blockquote></li><li><p>将这个2n位数和被除数相除。</p></li><li><p>进行恢复余数除法或者不恢复余数除法</p></li></ol><p>硬件实现：</p><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250407111551314.png" alt="image-20250407111551314" tabindex="0" loading="lazy"><figcaption>image-20250407111551314</figcaption></figure><ul><li><p>除数寄存器Y：存放除数。</p></li><li><p>余数寄存器R：初始时高位部分为高32位被除数；结束时是余数。</p></li><li><p>余数/商寄存器Q：初始时为低32位被除数；结束时是32位商。</p></li><li><p>循环次数计数器Cn：存放循环次数。初值是32（不包括第一次试商），每循环（移位）一次，Cn减1，当Cn=0时，除法运算结束。</p></li><li><p>ALU：除法核心部件。在控制逻辑控制下，对于寄存器R和Y的内容进行“加/减”运算，在“写使能”控制下运算结果被送回寄存器R。</p></li></ul><h4 id="一个例子-恢复余数法" tabindex="-1"><a class="header-anchor" href="#一个例子-恢复余数法"><span><strong>一个例子（恢复余数法）：</strong></span></a></h4><p>因为除法需要用到减法，因此我们用补码来表示无符号数。</p><blockquote><p>X-Y=X+[Y]补; 别把补码和反码弄混了！</p></blockquote><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250407113000347.png" alt="image-20250407113000347" style="zoom:33%;"><ul><li>如果中间余数够减： 整体左移并且上1</li><li>如果中间余数不够减：先恢复余数，在左移，补0</li></ul><p><strong>最后得到的余数部分要右移一位，将绿色的0给移出。</strong></p><h4 id="不恢复余数法-交替加减法" tabindex="-1"><a class="header-anchor" href="#不恢复余数法-交替加减法"><span><strong>不恢复余数法（交替加减法）</strong></span></a></h4><p>根据恢复余数法(设D为除数，Ri=2Ri-1-D为第i次中间余数)，有：</p><p>l若Ri&lt;0,则商上“0”，做加法恢复余数，即：</p><p>Ri+1=2(Ri+D)-D=2Ri + D (“负，左移，上商0，加”)</p><p>l若Ri&gt;=0,则商上“1”，不需恢复余数，即：</p><p>Ri+1=2Ri - D (“正，左移，上商1，减”)</p><p>省去了恢复余数的过程</p><p>注意：最后一次上商为“0”的话，需要“纠余”处理，即把试商时被减掉的除数加回去，恢复真正的余数。</p><p>不恢复余数法也称为加减交替法</p><hr><h3 id="带符号除法" tabindex="-1"><a class="header-anchor" href="#带符号除法"><span><strong>带符号除法</strong></span></a></h3><h4 id="原码除法" tabindex="-1"><a class="header-anchor" href="#原码除法"><span>原码除法</span></a></h4><p>$Sign= Sign1 \\oplus Sign2$</p><p>数字部分直接当成无符号数来除即可。</p><h4 id="补码除法" tabindex="-1"><a class="header-anchor" href="#补码除法"><span>补码除法</span></a></h4><p>补码除法的被除数在进行位数扩展的时候，进行的是<strong>符号扩展</strong></p><p>补码的除法将符号位和数值位一起进行处理，采用的是不恢复余数法。</p><p>补码最终在寄存器中得到的一位都不能丢，而在无符号的除法运算中，因为采用了补码来实现减法，因而最后得到的也是补码，需要舍弃掉符号位，剩下的是得到的商；</p><hr><h3 id="其他内容" tabindex="-1"><a class="header-anchor" href="#其他内容"><span>其他内容</span></a></h3><p>除以2^k的快速算法：</p><ul><li><p>无符号整数：逻辑右移，高位补0，低位丢弃。</p></li><li><p>带符号整数：算术右移，高位补符，低位丢弃。</p></li></ul><hr><p>综合考虑了各类定点运算之后，发现所有的运算都可以通过<code>加</code>和<code>移位</code>来实现；</p><p>可以通过ALU（or 加法器）结合寄存器，选择器等部件实现一个<code>运算数据通路</code>；</p><h2 id="浮点数运算" tabindex="-1"><a class="header-anchor" href="#浮点数运算"><span>浮点数运算</span></a></h2><blockquote><p>浮点数的运算老师说不考，但是考研408会考</p></blockquote><p>先回顾之前的浮点数相关知识：</p><ul><li>非规格化数：阶码为0 （代表是-127），尾数不为0，没有前导1；</li><li>0，阶码和尾数都为0；</li><li>无穷：阶码全为1，尾数全为0；</li><li>NAN：阶码全为1，尾数不全为0；</li><li>其余的就都是规格化数，阶码的范围是1-254，尾数默认前导1；</li></ul>`,68)),s[7]||(s[7]=i("p",null,[a("浮点数规格化数的范围（以SP的正半部分为例）："),i("br"),a(" $$"),i("br"),a(" 2"),i("sup",{127:""},"{-126}-2"),a("*(2-2^{-23})"),i("br"),a(" $$"),i("br"),a(" 运算的方法：")],-1)),s[8]||(s[8]=n('<img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250411104022649.png" alt="image-20250411104022649" style="zoom:50%;"><p>可能出现下面的情况：</p><p>上述运算结果可能出现以下几种情况：</p><ul><li><p>阶码上溢：一个正指数超过了最大允许值 =〉+∞/-∞/溢出</p></li><li><p>阶码下溢：一个负指数比最小允许值还小 =〉+0/-0</p></li><li><p>尾数溢出：最高有效位有进位 =〉右规</p></li><li><p>非规格化尾数：数值部分高位为0 =〉左规</p></li><li><p>右规或对阶时，右段有效位丢失 =〉尾数舍入</p></li></ul><hr><p>IEEE754规定的几种异常情况：</p><p>① 无效运算（无意义）</p><ul><li><p>运算时有一个数是非有限数，如：加 / 减∞、0 x ∞、 ∞/∞等</p></li><li><p>结果无效，如：源操作数是NaN、0/0、x REM 0、 ∞ REM y 等</p></li></ul><p>② 除以0（即：无穷大）</p><p>③ 数太大（阶码上溢）: 对于SP，阶码 E &gt;1111 1110 (指数大于127)</p><p>④ 数太小（阶码下溢）: 对于SP，阶码 E &lt; 0000 0001(指数小于-126-23)</p><p>⑤ 结果不精确（舍入时引起），例如1/3，1/10等不能精确表示成浮点数</p><hr><h3 id="浮点数加减运算" tabindex="-1"><a class="header-anchor" href="#浮点数加减运算"><span>浮点数加减运算</span></a></h3><ol><li><p>对阶</p><p>采取的都是小阶向大阶表示（都是右移），防止尾数溢出（溢出的几位可以用附加位进行暂时存储）。</p></li><li><p>尾数相加减</p></li><li><p>规格化</p><p>将尾数进行规格化，左移或右移，使得小数点前有一个隐含的前导1。</p></li><li><p>如果尾数比规定的数长需要舍入；（舍入有可能导致进位，最终需要右规）</p></li><li><p>如果尾数全为0（包含隐藏位在内的）那么应该要把阶码也赋值为0，因为这才是浮点数表示0的方法。</p></li></ol><p>附加位的作用：以保护对阶时右移的位或运算的中间结果。提高运算精度。</p><p>（比如舍入的时候的精度）</p><hr><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250411111702873.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><h3 id="浮点数的乘法-1" tabindex="-1"><a class="header-anchor" href="#浮点数的乘法-1"><span>浮点数的乘法</span></a></h3><p>浮点数乘 / 除法步骤</p><p>（Xm、Ym分别是X和Y尾数原码， Xe和Ye 分别是X和Y阶移码 ）</p><p>(1)求阶： Xe + Ye + 127</p><p>(2)尾数相乘除： Xm */Ym （<strong>两个形为1.xxx的数相乘/除</strong>）注意有个**隐藏的1 **！！</p><blockquote><p>尾数相乘的时候最多要右规一次，尾数相除的时候左规的次数不定</p></blockquote><p>(3) 两数符号相同，结果为正；两数符号相异，结果为负；</p><p>(4) 当尾数高位为0，需左规；当尾数最高位有进位，需右规。</p><p>(5) 如果尾数比规定的长，则需考虑舍入。</p><p>(6)若尾数是0，则需要将阶码也置0。</p><p>(7) 阶码溢出判断</p>',31))])}const k=l(r,[["render",c],["__file","chapter6运算方法和运算部件.html.vue"]]),u=JSON.parse('{"path":"/posts/NJUCS/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/chapter6%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E9%83%A8%E4%BB%B6.html","title":"chapter6 | 运算方法和运算部件","lang":"zh-CN","frontmatter":{"title":"chapter6 | 运算方法和运算部件","description":"[TOC] 第一讲 | 基本运算部件 想要实现高级语言程序设计的各种运算，需要将表达式转换成指令。 比如 将数据以补码的形式存入寄存器中。指令->汇编->机器指令。 软件（高级语言设计），指令（ISA），硬件设计，环环相扣。 所有的运算都可以通过ALU+逻辑部件实现。 有关门延迟这一部分,建议阅读：全加器以及行波进位加/减法器时延的计算 - 知乎，因为...","head":[["meta",{"property":"og:url","content":"https://github.com/yama-lei/yama-lei.github.io/posts/NJUCS/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/chapter6%E8%BF%90%E7%AE%97%E6%96%B9%E6%B3%95%E5%92%8C%E8%BF%90%E7%AE%97%E9%83%A8%E4%BB%B6.html"}],["meta",{"property":"og:site_name","content":"Myblog"}],["meta",{"property":"og:title","content":"chapter6 | 运算方法和运算部件"}],["meta",{"property":"og:description","content":"[TOC] 第一讲 | 基本运算部件 想要实现高级语言程序设计的各种运算，需要将表达式转换成指令。 比如 将数据以补码的形式存入寄存器中。指令->汇编->机器指令。 软件（高级语言设计），指令（ISA），硬件设计，环环相扣。 所有的运算都可以通过ALU+逻辑部件实现。 有关门延迟这一部分,建议阅读：全加器以及行波进位加/减法器时延的计算 - 知乎，因为..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250328102746927.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-21T06:52:07.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-21T06:52:07.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"chapter6 | 运算方法和运算部件\\",\\"image\\":[\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250328102746927.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250328103202290.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250328103710902.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250331104724755.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250331110003790.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250331113749466.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250407111551314.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250411111702873.png\\"],\\"dateModified\\":\\"2025-04-21T06:52:07.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Yama-lei\\",\\"url\\":\\"/underbuilding.html\\"}]}"]]},"headers":[{"level":2,"title":"第一讲 | 基本运算部件","slug":"第一讲-基本运算部件","link":"#第一讲-基本运算部件","children":[{"level":3,"title":"串行(行波)进位加法器:","slug":"串行-行波-进位加法器","link":"#串行-行波-进位加法器","children":[]},{"level":3,"title":"并行(先行)进位加法器 CLA","slug":"并行-先行-进位加法器-cla","link":"#并行-先行-进位加法器-cla","children":[]},{"level":3,"title":"局部先行进位加法器","slug":"局部先行进位加法器","link":"#局部先行进位加法器","children":[]},{"level":3,"title":"n位带标志加法器","slug":"n位带标志加法器","link":"#n位带标志加法器","children":[]},{"level":3,"title":"ALU：算数逻辑运算单元","slug":"alu-算数逻辑运算单元","link":"#alu-算数逻辑运算单元","children":[]}]},{"level":2,"title":"第二讲 | 定点数运算","slug":"第二讲-定点数运算","link":"#第二讲-定点数运算","children":[{"level":3,"title":"加减法","slug":"加减法","link":"#加减法","children":[]},{"level":3,"title":"乘法运算","slug":"乘法运算","link":"#乘法运算","children":[]}]},{"level":2,"title":"除法运算","slug":"除法运算","link":"#除法运算","children":[{"level":3,"title":"定点数的除法运算","slug":"定点数的除法运算","link":"#定点数的除法运算","children":[]},{"level":3,"title":"带符号除法","slug":"带符号除法","link":"#带符号除法","children":[]},{"level":3,"title":"其他内容","slug":"其他内容","link":"#其他内容","children":[]}]},{"level":2,"title":"浮点数运算","slug":"浮点数运算","link":"#浮点数运算","children":[{"level":3,"title":"浮点数加减运算","slug":"浮点数加减运算","link":"#浮点数加减运算","children":[]},{"level":3,"title":"浮点数的乘法","slug":"浮点数的乘法-1","link":"#浮点数的乘法-1","children":[]}]}],"git":{"createdTime":1742953027000,"updatedTime":1745218327000,"contributors":[{"name":"yama-lei","username":"yama-lei","email":"1908777046@qq.com","commits":6,"url":"https://github.com/yama-lei"}]},"readingTime":{"minutes":14.31,"words":4292},"filePathRelative":"posts/NJUCS/数字逻辑与计算机组成/chapter6运算方法和运算部件.md","localizedDate":"2025年3月26日","excerpt":"<p>[TOC]</p>\\n<h2>第一讲 | 基本运算部件</h2>\\n<p>想要实现高级语言程序设计的各种运算，需要将表达式转换成指令。</p>\\n<p>比如</p>\\n<div class=\\"language-cpp line-numbers-mode\\" data-highlighter=\\"shiki\\" data-ext=\\"cpp\\" data-title=\\"cpp\\" style=\\"--shiki-light:#383A42;--shiki-dark:#abb2bf;--shiki-light-bg:#FAFAFA;--shiki-dark-bg:#282c34\\"><pre class=\\"shiki shiki-themes one-light one-dark-pro vp-code\\"><code><span class=\\"line\\"><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">int</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\"> a,b</span><span style=\\"--shiki-light:#A626A4;--shiki-dark:#C678DD\\">=</span><span style=\\"--shiki-light:#986801;--shiki-dark:#D19A66\\">5</span><span style=\\"--shiki-light:#383A42;--shiki-dark:#ABB2BF\\">;</span></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div></div></div>","autoDesc":true}');export{k as comp,u as data};
