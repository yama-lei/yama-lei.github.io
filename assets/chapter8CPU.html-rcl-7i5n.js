import{_ as a,c as i,d as n,o as e}from"./app-CTobDjGc.js";const r={};function s(p,t){return e(),i("div",null,t[0]||(t[0]=[n('<h2 id="cpu概述" tabindex="-1"><a class="header-anchor" href="#cpu概述"><span>CPU概述</span></a></h2><p><strong>CPU执行指令的过程</strong>：</p><ol><li>根据pc取指令</li></ol><p>异常时内部异常，中断时由于外部事件的出现导致CPU停止执行指令； 即<code>内部异常，外部中断</code></p><hr><h3 id="计算机的五大组成部件" tabindex="-1"><a class="header-anchor" href="#计算机的五大组成部件"><span><strong>计算机的五大组成部件</strong></span></a></h3><ul><li>Memory</li><li>I/O</li><li>Datapath 数据通路 <strong>执行部件</strong></li><li>Control Unit 控制部件 <strong>控制器</strong>：控制器对执行部件发出信号。</li></ul><hr><h4 id="数据通路datapath的基本结构" tabindex="-1"><a class="header-anchor" href="#数据通路datapath的基本结构"><span><strong>数据通路Datapath的基本结构</strong></span></a></h4><p>数据通路是由<strong>操作元件和存储元件</strong>通过<strong>总线</strong>方式或<strong>分散</strong>方式连接而成的进行<em><strong>数据存储、处理、传送</strong></em>的路径</p><p><strong>操作元件</strong>：（是组合逻辑电路）</p><p><strong>存储元件</strong>：（时序逻辑电路）</p><p>setup时间：在时钟边沿到来<strong>之前</strong>，输入端保持不变的时间；</p><p>hold时间：在时钟边沿<strong>之后</strong>，输入端必须保持不变的时间；</p><p>clk-to-q锁存延迟：从时钟边沿到输出端稳定的时间；</p><h4 id="数据通路和时序控制" tabindex="-1"><a class="header-anchor" href="#数据通路和时序控制"><span>数据通路和时序控制</span></a></h4><p>指令周期 : CPU执行一条指令需要的时间。</p><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250421114837747.png" alt="image-20250421114837747" tabindex="0" loading="lazy"><figcaption>image-20250421114837747</figcaption></figure><p>指令周期：<strong>Cycle Time = Latch Prop + Longest Delay Path + Setup + Clock Skew</strong></p><p>为了满足数据通路的要求，要能够盲注下面这个约束关系：<br> $$<br> holdTime&lt; ClkToQ+shortestDelay<br> $$<br> 即，<strong>在下一个信号到来前，能够hold不变，防止输出异常</strong></p><hr><h3 id="计算机性能" tabindex="-1"><a class="header-anchor" href="#计算机性能"><span>计算机性能</span></a></h3><p>衡量CPU性能的是<strong>用户CPU时间</strong>，执行用户的作业所需的时间，不考虑IO等</p><p>CPU的执行时间：</p><p>T= CPU的时钟周期数*时钟周期/程序= 指令条数/程序 *CPI *时钟周期</p><blockquote><p>一个程序的时钟周期数x时钟周期</p></blockquote><p><strong>CPI</strong>： Cycle Per Instruction，每一条指令需要多少个时钟周期</p><p>CPI是一个确定值--和CPU的设计,指令类型有关。</p><p>某个程序的CPU时间为：<br> $$<br> CPU \\space Time= \\sum_{i=1}^n {CPI_i * C_i}<br> $$<br> Ci为第i类指令，CPI_i 是这种指令的CPI。 再除以指令总数，即可得到程序的平均CPI.</p><hr><p>为什么 ISA也会影响CPI？ 因为RISC-V没有提供像乘法和除法的指令，每个指令的时钟周期都比较短。</p><p>时钟频率翻倍但是</p><p>基准测试程序：专门用于测试性能测试的程序，使得计算机有个公共的比较方法。</p><p><strong>计算机性能由三个关键因素决定：指令数目，CPI，时钟周期</strong></p><ul><li>指令数目由编译器和ISA决定</li><li>CPI由ISA和CPU决定</li><li>时钟周期由CPU的实现来决定</li></ul><p>CPU时间 = 指令数目 *</p><h2 id="单周期的cpu设计" tabindex="-1"><a class="header-anchor" href="#单周期的cpu设计"><span>单周期的CPU设计</span></a></h2><p><strong>单总线数据通路</strong></p><p>这一部分没有听懂，请自行看ppt。</p><p>时钟周期的宽度：以read、write为准（因为要以最长的为准）</p><p><strong>常见的指令！！！</strong></p><table><thead><tr><th>指令</th><th>功能 这里用的不是RTL！是我自己写的</th><th>说明</th></tr></thead><tbody><tr><td>add rd rs1 rs2</td><td>R[rd]=R[rs1]+R[rs2]</td><td></td></tr><tr><td>slt rd rs1 rs2</td><td>rd = 1 if R[rs1]&lt;R[rs2] else 0</td><td>使用signed比较</td></tr><tr><td>sltu rd rs1 rs2</td><td>rd= 1 if R[rs1]&lt;R[rs2] else 0</td><td>使用unsigned比较</td></tr><tr><td>ori rd rs1 imm12</td><td>R[rd]= rs1 | SEXT[imm12]</td><td>ori：or immedia</td></tr><tr><td>lui rd imm20</td><td>R[rd]= SEXT[imm20]</td><td>U型imm</td></tr><tr><td>lw rd rs1 imm12</td><td>R[rd] = M[rs1+SEXT[imm12]]</td><td></td></tr><tr><td>sw rs1 rs2 imm12</td><td>M[R[rs1]+SEXT[imm12]] =</td><td></td></tr><tr><td>beq rs1 rs2 imm12</td><td>PC=PC+SEXT[imm12*2] if rs1= rs2</td><td>注意imm12要乘以2</td></tr><tr><td>jal rd im20</td><td></td><td></td></tr></tbody></table><p><strong>存储数据的指定</strong>：</p><p>寄存器编号只需5位</p><p>32bit machine的总线只有32位，理论上最大访问的内存为2的32次方，也就是4GB；</p><hr><h3 id="单流水线cpu的设计" tabindex="-1"><a class="header-anchor" href="#单流水线cpu的设计"><span><strong>单流水线CPU的设计</strong></span></a></h3><p>除R-型外，其他5类都带有立即数 ——立即数扩展器</p><p>核心运算类功能的实现 ——ALU<br> 根据PC取指令和PC+4 ——取指令部件<br> 指令的RTL最终实现 ——完整数据通路</p><h4 id="立即数扩展器" tabindex="-1"><a class="header-anchor" href="#立即数扩展器"><span>立即数扩展器</span></a></h4><p>为什么需要一个立即数扩展器？ 因为RISCV的指令二进制表示中，imm的排列很混乱，而且不同的指令的imm位数和排列往往不同，因此需要立即数扩展器</p><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250425114704950.png" alt="image-20250425114704950" style="zoom:50%;"><p>除了R型指令不需要寄存器，其他都有寄存器。因此需要一个5选1的选择器。ExtOP为3位，具体如何得到ExtOP呢？<strong>需要根据编码Instr得到</strong></p><h4 id="alu-算数逻辑部件的设计" tabindex="-1"><a class="header-anchor" href="#alu-算数逻辑部件的设计"><span>ALU 算数逻辑部件的设计</span></a></h4><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250425115156719.png" alt="image-20250425115156719" style="zoom:50%;"><p>实现的功能：</p><ul><li><p>add or slt sltu srcB,判0</p><p>即实现了加法，或运算，比较，将B直接输出，判断是否为0；</p></li></ul><p>因为上述的9条指令需要这些运算，比如lw指令，需要加法（lw rd rs1 imm12: R[rd] &lt;--- M[R[]]</p><h4 id="取指令部件-instruction-fetch-unit" tabindex="-1"><a class="header-anchor" href="#取指令部件-instruction-fetch-unit"><span>取指令部件 Instruction Fetch Unit</span></a></h4><p>每一次运行指令都有一步<strong>更新PC</strong>的步骤，需要依靠取指令部件；</p><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427103915530.png" alt="image-20250427103915530" tabindex="0" loading="lazy"><figcaption>image-20250427103915530</figcaption></figure><h4 id="r型指令的数据通路" tabindex="-1"><a class="header-anchor" href="#r型指令的数据通路"><span>R型指令的数据通路</span></a></h4><p>R型指令：</p><ul><li>add rd rs1 rs2:</li><li>slt rd rs1 rs2;</li><li>sltu rd rs1 rs2;</li></ul><p>R型指令无需imm，直接从寄存器组中读取、写入数据即可：</p><p><strong>写使能端信号不能乱取！！！防止出现错误</strong></p><p>R型指令中，RegWr（<strong>Reg</strong>ister <strong>Wr</strong>ite）为1；</p><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427104315618.png" alt="image-20250427104315618" tabindex="0" loading="lazy"><figcaption>image-20250427104315618</figcaption></figure><h4 id="i型指令的型号通路-ori" tabindex="-1"><a class="header-anchor" href="#i型指令的型号通路-ori"><span>I型指令的型号通路（ori)</span></a></h4><p>因为除了R型指令，其他的指令都有imm，rs只有一个，因此需要ALU的输入端需要一个多路选择器，以<strong>ALUBSrc</strong>为控制信号。</p><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427104604542.png" alt="image-20250427104604542" tabindex="0" loading="lazy"><figcaption>image-20250427104604542</figcaption></figure><h4 id="u型指令的信号通路" tabindex="-1"><a class="header-anchor" href="#u型指令的信号通路"><span>U型指令的信号通路</span></a></h4><p>U型指令只有一个lui</p><ul><li>lui rd imm20</li></ul><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427110900124.png" alt="image-20250427110900124" tabindex="0" loading="lazy"><figcaption>image-20250427110900124</figcaption></figure><h4 id="load-store指令的信号通路" tabindex="-1"><a class="header-anchor" href="#load-store指令的信号通路"><span>Load&amp;Store指令的信号通路</span></a></h4><p>指令详情：</p><ul><li>load rd rs1 imm12; R[rd] = M[R[rs1]+SEXT[imm12]] 。 <strong>注意：这里的imm不需要乘以2，因为数据是按字节寻址的</strong></li><li>store rs1 rs2 imm12; M[R[rs1]+SEXT[imm12]]&lt;--R[rs2]。</li></ul><p>Load和Store指令涉及到了存储器的访问，这里以理想存储器为例：</p><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427110804853.png" alt="image-20250427110804853" tabindex="0" loading="lazy"><figcaption>image-20250427110804853</figcaption></figure><blockquote><p>MemtoReg: 即 Memory To Register</p></blockquote><p>注意：B和J型指令的imm通常需要左移一位，这是因为在设计的时候省略了1位，或者说默认最后一位为0（处于对齐指令的目的）；在RISCV规范中，给出了相关的内容，可以参考<a href="https://zhuanlan.zhihu.com/p/377200438" target="_blank" rel="noopener noreferrer">RV32I控制转移指令的偏移量计算问题 - 知乎</a></p><h4 id="b型指令的数据通路" tabindex="-1"><a class="header-anchor" href="#b型指令的数据通路"><span>B型指令的数据通路</span></a></h4><p>指令为：</p><ul><li>beq rs1 rs2 imm12; if(R[rs1]=R[rs2]) PC&lt;-- PC+(SEXT(imm12)&lt;&lt;1) else PC&lt;-- PC+4;</li></ul><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427112357474.png" alt="image-20250427112357474" tabindex="0" loading="lazy"><figcaption>image-20250427112357474</figcaption></figure><p>其中下地址逻辑为：（只有当ALU计算结果为0，并且是Branch指令，才会将imm和PC相加，否则PC=PC+4）</p><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427112744627.png" alt="image-20250427112744627" style="zoom:50%;"><h4 id="j型指令" tabindex="-1"><a class="header-anchor" href="#j型指令"><span>J型指令</span></a></h4><p>J型指令：</p><ul><li>jal rd imm20; R[rd]&lt;- PC+4, PC&lt;- PC+SEXT(imm20&lt;&lt;1);</li></ul><p>J型指令除了需要跳转，还需要将下一条指令存入寄存器（实现call的操作）</p><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427113923927.png" alt="image-20250427113923927" tabindex="0" loading="lazy"><figcaption>image-20250427113923927</figcaption></figure><hr><p><strong>指令的执行结果总是在新的时钟周期到来之前，才会将其保存在寄存器、PC、存储器中</strong></p><p>一个时钟周期的时间为：clk-to-q+longest delay +setup+ 时钟偏移，可以看出，时钟周期应该根据最长的delay来决定。</p><hr><h3 id="控制器的设计" tabindex="-1"><a class="header-anchor" href="#控制器的设计"><span>控制器的设计</span></a></h3><p>前面提过，CPU的核心是数据通路（执行部件）和控制器（控制部件），前面已经设计好了数据通路，但是数据通路中的很多信号，比如ALUctr需要控制器的作用。</p><h4 id="控制信号的取值分析" tabindex="-1"><a class="header-anchor" href="#控制信号的取值分析"><span>控制信号的取值分析</span></a></h4><p>每一条指令运行的过程都是：Clk信号到来，经过一个Clk-To-Q（锁存延时）之后，将当前PC的值写入指令寄存器，取出指令，送入控制器，在控制器中译码，并且发出控制信号，之后进入数据通路计算，下一个时钟周期到来，新的数据被写入。</p>',101)]))}const g=a(r,[["render",s],["__file","chapter8CPU.html.vue"]]),l=JSON.parse('{"path":"/posts/NJUCS/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/chapter8CPU.html","title":"chapter8 | CPU的设计","lang":"zh-CN","frontmatter":{"date":"2025-04-21T00:00:00.000Z","title":"chapter8 | CPU的设计","description":"CPU概述 CPU执行指令的过程： 根据pc取指令 异常时内部异常，中断时由于外部事件的出现导致CPU停止执行指令； 即内部异常，外部中断 计算机的五大组成部件 Memory I/O Datapath 数据通路 执行部件 Control Unit 控制部件 控制器：控制器对执行部件发出信号。 数据通路Datapath的基本结构 数据通路是由操作元件和存...","head":[["meta",{"property":"og:url","content":"https://github.com/yama-lei/yama-lei.github.io/posts/NJUCS/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/chapter8CPU.html"}],["meta",{"property":"og:site_name","content":"Myblog"}],["meta",{"property":"og:title","content":"chapter8 | CPU的设计"}],["meta",{"property":"og:description","content":"CPU概述 CPU执行指令的过程： 根据pc取指令 异常时内部异常，中断时由于外部事件的出现导致CPU停止执行指令； 即内部异常，外部中断 计算机的五大组成部件 Memory I/O Datapath 数据通路 执行部件 Control Unit 控制部件 控制器：控制器对执行部件发出信号。 数据通路Datapath的基本结构 数据通路是由操作元件和存..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250421114837747.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-04-27T13:05:44.000Z"}],["meta",{"property":"article:published_time","content":"2025-04-21T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-04-27T13:05:44.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"chapter8 | CPU的设计\\",\\"image\\":[\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250421114837747.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427103915530.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427104315618.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427104604542.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427110900124.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427110804853.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427112357474.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427113923927.png\\"],\\"datePublished\\":\\"2025-04-21T00:00:00.000Z\\",\\"dateModified\\":\\"2025-04-27T13:05:44.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Yama-lei\\",\\"url\\":\\"/underbuilding.html\\"}]}"]]},"headers":[{"level":2,"title":"CPU概述","slug":"cpu概述","link":"#cpu概述","children":[{"level":3,"title":"计算机的五大组成部件","slug":"计算机的五大组成部件","link":"#计算机的五大组成部件","children":[]},{"level":3,"title":"计算机性能","slug":"计算机性能","link":"#计算机性能","children":[]}]},{"level":2,"title":"单周期的CPU设计","slug":"单周期的cpu设计","link":"#单周期的cpu设计","children":[{"level":3,"title":"单流水线CPU的设计","slug":"单流水线cpu的设计","link":"#单流水线cpu的设计","children":[]},{"level":3,"title":"控制器的设计","slug":"控制器的设计","link":"#控制器的设计","children":[]}]}],"git":{"createdTime":1745218327000,"updatedTime":1745759144000,"contributors":[{"name":"yama-lei","username":"yama-lei","email":"1908777046@qq.com","commits":2,"url":"https://github.com/yama-lei"}]},"readingTime":{"minutes":6.51,"words":1953},"filePathRelative":"posts/NJUCS/数字逻辑与计算机组成/chapter8CPU.md","localizedDate":"2025年4月21日","excerpt":"<h2>CPU概述</h2>\\n<p><strong>CPU执行指令的过程</strong>：</p>\\n<ol>\\n<li>根据pc取指令</li>\\n</ol>\\n<p>异常时内部异常，中断时由于外部事件的出现导致CPU停止执行指令； 即<code>内部异常，外部中断</code></p>\\n<hr>\\n<h3><strong>计算机的五大组成部件</strong></h3>\\n<ul>\\n<li>Memory</li>\\n<li>I/O</li>\\n<li>Datapath 数据通路 <strong>执行部件</strong></li>\\n<li>Control Unit 控制部件 <strong>控制器</strong>：控制器对执行部件发出信号。</li>\\n</ul>","autoDesc":true}');export{g as comp,l as data};
