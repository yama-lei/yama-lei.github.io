import{_ as i,c as t,d as p,o as n}from"./app-CeypbMp0.js";const e={};function o(s,a){return n(),t("div",null,a[0]||(a[0]=[p('<h2 id="cpu概述" tabindex="-1"><a class="header-anchor" href="#cpu概述"><span>CPU概述</span></a></h2><p><strong>CPU执行指令的过程</strong>：</p><ol><li>根据pc取指令</li></ol><p>异常时内部异常，中断时由于外部事件的出现导致CPU停止执行指令； 即<code>内部异常，外部中断</code></p><hr><h3 id="计算机的五大组成部件" tabindex="-1"><a class="header-anchor" href="#计算机的五大组成部件"><span><strong>计算机的五大组成部件</strong></span></a></h3><ul><li>Memory</li><li>I/O</li><li>Datapath 数据通路 <strong>执行部件</strong></li><li>Control Unit 控制部件 <strong>控制器</strong>：控制器对执行部件发出信号。</li></ul><hr><h4 id="数据通路datapath的基本结构" tabindex="-1"><a class="header-anchor" href="#数据通路datapath的基本结构"><span><strong>数据通路Datapath的基本结构</strong></span></a></h4><p>数据通路是由<strong>操作元件和存储元件</strong>通过<strong>总线</strong>方式或<strong>分散</strong>方式连接而成的进行<em><strong>数据存储、处理、传送</strong></em>的路径</p><p><strong>操作元件</strong>：（是组合逻辑电路）</p><p><strong>存储元件</strong>：（时序逻辑电路）</p><p>setup时间：在时钟边沿到来<strong>之前</strong>，输入端保持不变的时间；</p><p>hold时间：在时钟边沿<strong>之后</strong>，输入端必须保持不变的时间；</p><p>clk-to-q锁存延迟：从时钟边沿到输出端稳定的时间；</p><h4 id="数据通路和时序控制" tabindex="-1"><a class="header-anchor" href="#数据通路和时序控制"><span>数据通路和时序控制</span></a></h4><p>指令周期 : CPU执行一条指令需要的时间。</p><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250421114837747.png" alt="image-20250421114837747" tabindex="0" loading="lazy"><figcaption>image-20250421114837747</figcaption></figure><p>指令周期：<strong>Cycle Time = Latch Prop + Longest Delay Path + Setup + Clock Skew</strong></p><p>为了满足数据通路的要求，要能够盲注下面这个约束关系：<br> $$<br> holdTime&lt; ClkToQ+shortestDelay<br> $$<br> 即，<strong>在下一个信号到来前，能够hold不变，防止输出异常</strong></p><hr><h3 id="计算机性能" tabindex="-1"><a class="header-anchor" href="#计算机性能"><span>计算机性能</span></a></h3><p>衡量CPU性能的是<strong>用户CPU时间</strong>，执行用户的作业所需的时间，不考虑IO等</p><p>CPU的执行时间：</p><p>T= CPU的时钟周期数*时钟周期/程序= 指令条数/程序 *CPI *时钟周期</p><blockquote><p>一个程序的时钟周期数x时钟周期</p></blockquote><p><strong>CPI</strong>： Cycle Per Instruction，每一条指令需要多少个时钟周期</p><p>CPI是一个确定值--和CPU的设计,指令类型有关。</p><p>某个程序的CPU时间为：<br> $$<br> CPU \\space Time= \\sum_{i=1}^n {CPI_i * C_i}<br> $$<br> Ci为第i类指令，CPI_i 是这种指令的CPI。 再除以指令总数，即可得到程序的平均CPI.</p><hr><p>为什么 ISA也会影响CPI？ 因为RISC-V没有提供像乘法和除法的指令，每个指令的时钟周期都比较短。</p><p>时钟频率翻倍但是</p><p>基准测试程序：专门用于测试性能测试的程序，使得计算机有个公共的比较方法。</p><p><strong>计算机性能由三个关键因素决定：指令数目，CPI，时钟周期</strong></p><ul><li>指令数目由编译器和ISA决定</li><li>CPI由ISA和CPU决定</li><li>时钟周期由CPU的实现来决定</li></ul><p>CPU时间 = 指令数目 *</p><h2 id="单周期的cpu设计" tabindex="-1"><a class="header-anchor" href="#单周期的cpu设计"><span>单周期的CPU设计</span></a></h2><p><strong>单总线数据通路</strong></p><p>这一部分没有听懂，请自行看ppt。</p><p>时钟周期的宽度：以read、write为准（因为要以最长的为准）</p><p><strong>常见的指令！！！</strong></p><table><thead><tr><th>指令</th><th>功能 这里用的不是RTL！是我自己写的</th><th>说明</th></tr></thead><tbody><tr><td>add rd rs1 rs2</td><td>R[rd]=R[rs1]+R[rs2]</td><td></td></tr><tr><td>slt rd rs1 rs2</td><td>rd = 1 if R[rs1]&lt;R[rs2] else 0</td><td>使用signed比较</td></tr><tr><td>sltu rd rs1 rs2</td><td>rd= 1 if R[rs1]&lt;R[rs2] else 0</td><td>使用unsigned比较</td></tr><tr><td>ori rd rs1 imm12</td><td>R[rd]= rs1 | SEXT[imm12]</td><td>ori：or immedia</td></tr><tr><td>lui rd imm20</td><td>R[rd]= SEXT[imm20]</td><td>U型imm</td></tr><tr><td>lw rd rs1 imm12</td><td>R[rd] = M[rs1+SEXT[imm12]]</td><td></td></tr><tr><td>sw rs1 rs2 imm12</td><td>M[R[rs1]+SEXT[imm12]] =</td><td></td></tr><tr><td>beq rs1 rs2 imm12</td><td>PC=PC+SEXT[imm12*2] if rs1= rs2</td><td>注意imm12要乘以2</td></tr><tr><td>jal rd im20</td><td></td><td></td></tr></tbody></table><p><strong>存储数据的指定</strong>：</p><p>寄存器编号只需5位</p><p>32bit machine的总线只有32位，理论上最大访问的内存为2的32次方，也就是4GB；</p><hr><h3 id="单流水线cpu的设计" tabindex="-1"><a class="header-anchor" href="#单流水线cpu的设计"><span><strong>单流水线CPU的设计</strong></span></a></h3><p>除R-型外，其他5类都带有立即数 ——立即数扩展器</p><p>核心运算类功能的实现 ——ALU<br> 根据PC取指令和PC+4 ——取指令部件<br> 指令的RTL最终实现 ——完整数据通路</p><h4 id="立即数扩展器" tabindex="-1"><a class="header-anchor" href="#立即数扩展器"><span>立即数扩展器</span></a></h4><p>为什么需要一个立即数扩展器？ 因为RISCV的指令二进制表示中，imm的排列很混乱，而且不同的指令的imm位数和排列往往不同，因此需要立即数扩展器</p><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250425114704950.png" alt="image-20250425114704950" style="zoom:50%;"><p>除了R型指令不需要寄存器，其他都有寄存器。因此需要一个5选1的选择器。ExtOP为3位，具体如何得到ExtOP呢？<strong>需要根据编码Instr得到</strong></p><h4 id="alu-算数逻辑部件的设计" tabindex="-1"><a class="header-anchor" href="#alu-算数逻辑部件的设计"><span>ALU 算数逻辑部件的设计</span></a></h4><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250425115156719.png" alt="image-20250425115156719" style="zoom:50%;"><p>实现的功能：</p><ul><li><p>add or slt sltu srcB,判0</p><p>即实现了加法，或运算，比较，将B直接输出，判断是否为0；</p></li></ul><p>因为上述的9条指令需要这些运算，比如lw指令，需要加法（lw rd rs1 imm12: R[rd] &lt;--- M[R[]]</p><h4 id="取指令部件-instruction-fetch-unit" tabindex="-1"><a class="header-anchor" href="#取指令部件-instruction-fetch-unit"><span>取指令部件 Instruction Fetch Unit</span></a></h4><p>每一次运行指令都有一步<strong>更新PC</strong>的步骤，需要依靠取指令部件；</p><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427103915530.png" alt="image-20250427103915530" tabindex="0" loading="lazy"><figcaption>image-20250427103915530</figcaption></figure><h4 id="r型指令的数据通路" tabindex="-1"><a class="header-anchor" href="#r型指令的数据通路"><span>R型指令的数据通路</span></a></h4><p>R型指令：</p><ul><li>add rd rs1 rs2:</li><li>slt rd rs1 rs2;</li><li>sltu rd rs1 rs2;</li></ul><p>R型指令无需imm，直接从寄存器组中读取、写入数据即可：</p><p><strong>写使能端信号不能乱取！！！防止出现错误</strong></p><p>R型指令中，RegWr（<strong>Reg</strong>ister <strong>Wr</strong>ite）为1；</p><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427104315618.png" alt="image-20250427104315618" tabindex="0" loading="lazy"><figcaption>image-20250427104315618</figcaption></figure><h4 id="i型指令的型号通路-ori" tabindex="-1"><a class="header-anchor" href="#i型指令的型号通路-ori"><span>I型指令的型号通路（ori)</span></a></h4><p>因为除了R型指令，其他的指令都有imm，rs只有一个，因此需要ALU的输入端需要一个多路选择器，以<strong>ALUBSrc</strong>为控制信号。</p><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427104604542.png" alt="image-20250427104604542" tabindex="0" loading="lazy"><figcaption>image-20250427104604542</figcaption></figure><h4 id="u型指令的信号通路" tabindex="-1"><a class="header-anchor" href="#u型指令的信号通路"><span>U型指令的信号通路</span></a></h4><p>U型指令只有一个lui</p><ul><li>lui rd imm20</li></ul><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427110900124.png" alt="image-20250427110900124" tabindex="0" loading="lazy"><figcaption>image-20250427110900124</figcaption></figure><h4 id="load-store指令的信号通路" tabindex="-1"><a class="header-anchor" href="#load-store指令的信号通路"><span>Load&amp;Store指令的信号通路</span></a></h4><p>指令详情：</p><ul><li>load rd rs1 imm12; R[rd] = M[R[rs1]+SEXT[imm12]] 。 <strong>注意：这里的imm不需要乘以2，因为数据是按字节寻址的</strong></li><li>store rs1 rs2 imm12; M[R[rs1]+SEXT[imm12]]&lt;--R[rs2]。</li></ul><p>Load和Store指令涉及到了存储器的访问，这里以理想存储器为例：</p><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427110804853.png" alt="image-20250427110804853" tabindex="0" loading="lazy"><figcaption>image-20250427110804853</figcaption></figure><blockquote><p>MemtoReg: 即 Memory To Register</p></blockquote><p>注意：B和J型指令的imm通常需要左移一位，这是因为在设计的时候省略了1位，或者说默认最后一位为0（处于对齐指令的目的）；在RISCV规范中，给出了相关的内容，可以参考<a href="https://zhuanlan.zhihu.com/p/377200438" target="_blank" rel="noopener noreferrer">RV32I控制转移指令的偏移量计算问题 - 知乎</a></p><h4 id="b型指令的数据通路" tabindex="-1"><a class="header-anchor" href="#b型指令的数据通路"><span>B型指令的数据通路</span></a></h4><p>指令为：</p><ul><li>beq rs1 rs2 imm12; if(R[rs1]=R[rs2]) PC&lt;-- PC+(SEXT(imm12)&lt;&lt;1) else PC&lt;-- PC+4;</li></ul><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427112357474.png" alt="image-20250427112357474" tabindex="0" loading="lazy"><figcaption>image-20250427112357474</figcaption></figure><p>其中下地址逻辑为：（只有当ALU计算结果为0，并且是Branch指令，才会将imm和PC相加，否则PC=PC+4）</p><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427112744627.png" alt="image-20250427112744627" style="zoom:50%;"><h4 id="j型指令" tabindex="-1"><a class="header-anchor" href="#j型指令"><span>J型指令</span></a></h4><p>J型指令：</p><ul><li>jal rd imm20; R[rd]&lt;- PC+4, PC&lt;- PC+SEXT(imm20&lt;&lt;1);</li></ul><p>J型指令除了需要跳转，还需要将下一条指令存入寄存器（实现call的操作）</p><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427113923927.png" alt="image-20250427113923927" tabindex="0" loading="lazy"><figcaption>image-20250427113923927</figcaption></figure><hr><p><strong>指令的执行结果总是在新的时钟周期到来之前，才会将其保存在寄存器、PC、存储器中</strong></p><p>一个时钟周期的时间为：clk-to-q+longest delay +setup+ 时钟偏移，可以看出，时钟周期应该根据最长的delay来决定。</p><hr><blockquote><p>考试的时候以 短周期和流水线的数据通路图、控制器，很清楚地知道每一个控制信号，每一条线的内容，指令必须看得到，不一定会写汇编代码。</p></blockquote><h3 id="控制器的设计" tabindex="-1"><a class="header-anchor" href="#控制器的设计"><span>控制器的设计</span></a></h3><p>前面提过，CPU的核心是数据通路（执行部件）和控制器（控制部件），前面已经设计好了数据通路，但是数据通路中的很多信号，比如ALUctr需要控制器的作用。</p><h4 id="控制信号的取值分析" tabindex="-1"><a class="header-anchor" href="#控制信号的取值分析"><span>控制信号的取值分析</span></a></h4><ol><li><p><strong>所有指令执行的共同操作</strong></p><p>每一条指令运行的过程都是：Clk信号到来，经过一个Clk-To-Q（锁存延时）之后，PC被写入<strong>指令存储器</strong>，经过取数时间，指令被取出，送入控制器，<strong>在控制器中译码，并且发出控制信号</strong>，之后进入数据通路计算，下一个时钟周期到来，新的数据被写入。</p><blockquote><p>对于R型指令，新的PC很快得到，到那时对于跳转指令，需要等待运算才能得到新的PC值。</p></blockquote></li><li><p><strong>R型指令的执行过程</strong></p><p>Rd,Rs1,Rs2来自取指令单元（指令存储器），各种控制信号来自控制器。（回顾过程：PC寄存器经过clk2q之后MAR得</p><p>R型指令的执行过程可以概括为：Rigister(rs1,rs2) -&gt; busA,busB-&gt;buwW-&gt;Rigister(rd)</p><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250428101709013.png" alt="image-20250428101709013" tabindex="0" loading="lazy"><figcaption>image-20250428101709013</figcaption></figure><blockquote><p>留心这些控制信号的取值和含义，比如MemWr应该一定为0，MemtoReg也是为0</p></blockquote><p>R型指令的时间分析：</p><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250428102812207.png" alt="image-20250428102812207" tabindex="0" loading="lazy"><figcaption>image-20250428102812207</figcaption></figure></li><li><p>I型指令的执行过程</p><p>Rigister(rs1)-&gt;busA,扩展器(imm12)-&gt; ALU-&gt; Rigister(rd)</p><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250428103132649.png" alt="image-20250428103132649" tabindex="0" loading="lazy"><figcaption>image-20250428103132649</figcaption></figure></li><li><p>U型指令的执行过程</p></li><li><p>Load指令</p></li><li><p>Store指令</p></li><li><p>B型指令</p></li><li><p>J型指令</p></li><li><p>最终指令和真值表的取值</p><p><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250428103320124.png" alt="image-20250428103320124" loading="lazy">因此可以通过极小项写出每一个控制信号的 逻辑表达式</p><p>比如：Branch=op&lt;6&gt;&amp;op&lt;5&gt;&amp;<sub>op&lt;4&gt;&amp;</sub>op&lt;3&gt;&amp;~op&lt;2&gt;&amp;op&lt;1&gt;&amp;op&lt;0&gt; (B-type)</p><p>Jump=op&lt;6&gt;&amp;op&lt;5&gt;&amp;~op&lt;4&gt;&amp;op&lt;3&gt;&amp;op&lt;2&gt;&amp;op&lt;1&gt;&amp;op&lt;0&gt; (J-type)</p><blockquote><p>这里没有考虑funct3功能码，是因为B-type指令的op都是1100011，具体功能由funct3决定，即，B型指令的op都相同，只要保证op为1100011时Branch信号为1即可；而J-type的指令没有funct3字段；</p></blockquote><p>我们依次分析每一个控制信号的真值表达式，最后链接电路：</p><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250428105102309.png" alt="image-20250428105102309" tabindex="0" loading="lazy"><figcaption>image-20250428105102309</figcaption></figure></li></ol><h4 id="时钟周期的设计" tabindex="-1"><a class="header-anchor" href="#时钟周期的设计"><span>时钟周期的设计</span></a></h4><p>时钟周期应该要满足最慢的指令（load）的要求</p><p>load指令：（load rd rs1 imm12）</p><ul><li>clk2q+取指令时间</li><li>译码时间（控制单元延迟）</li><li>寄存器读数延迟（得到R[rs1]）</li><li>ALU延迟（得到addr=R[rs1]+SEXT[imm12]）</li><li>存储器读数延迟 （读取M[addr]）</li><li>寄存器setup时间</li></ul><hr><p>例子：<a id="q"></a>假设在单周期处理器中，各主要功能单元的操作时间为：</p><p>存储单元：200ps\\ ALU和加法器：100ps\\ 寄存器堆（读/写）：50ps</p><p>假设MUX、控制单元、PC、扩展器和传输线路都没有延迟，则单周期实现方式（每条指令在一个固定长度的时钟周期内完成）中，CPU执行时间如何计算？</p><p>那么我们可以确定：</p><p>R-type： 取指令200+读rs1、rs2 50+ALU100+写rd 50= 400</p><p>Load Word指令：取指令200+读rs1 50+ ALU100+ 存储器读取 200+ 写入rd 50= 600</p><p>Store Word指令：取指令200 + 读取rs1，rs2 50 +ALU100 + store 200= 550（注意rs1和rs2的读取是并行的）</p><p>Branch： 取指令200+ 读取rs1，rs2, 50 +ALU100 = 350</p><p>Jump： 取指令200+ 存入PC+4 50 + ALU计算跳转位置 100 =350；</p><hr><h2 id="多周期cpu设计" tabindex="-1"><a class="header-anchor" href="#多周期cpu设计"><span>多周期CPU设计</span></a></h2><p>下面以实现一个简单的指令系统为例，讲解多周期CPU的设计</p><blockquote><p>这个指令系统不用记！！！</p></blockquote><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250428112505398.png" alt="image-20250428112505398" tabindex="0" loading="lazy"><figcaption>image-20250428112505398</figcaption></figure><p><strong>多周期的数据通路</strong></p><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250428112702885.png" alt="image-20250428112702885" tabindex="0" loading="lazy"><figcaption>image-20250428112702885</figcaption></figure><h3 id="指令执行的过程" tabindex="-1"><a class="header-anchor" href="#指令执行的过程"><span>指令执行的过程</span></a></h3><blockquote><p>Note: 多周期的CPU的时钟周期取的是任何一条指令、所有阶段中最长的那一个；在下面的各种阶段中，取指令阶段因为涉及到一次存储器访问和一次寄存器保存过程，因此耗时最长（访问寄存器的耗时比较长，可以参考<a href="#q">上面的例题</a></p></blockquote><h4 id="取指令并计算下条指令地址" tabindex="-1"><a class="header-anchor" href="#取指令并计算下条指令地址"><span>取指令并计算下条指令地址</span></a></h4><p>该阶段对应状态记为IFetch。因为采用定长指令字，故PC增量操作可在取指令阶段完成。取指阶段的功能是：将PC内容作为地址访问主存以取出指令，将指令存入指令寄存器IR中，并将PC+4作为下条指令地址送PC。实现上述功能的有效控制信号及其取值如下。</p><ul><li>R[IR]&lt;-M[PC]:PCout=1,MARout=0,MemWr=0,IRWr=1。</li><li>PC&lt;-PC+4:Add1MUX=0,Add2MUX=1,PCWr=1。、</li><li>其他寄存器写使能信号(如MARWr、CCWr、MDRWr、ALUoutWr、RegWr)全部为0。</li></ul><hr><h4 id="译码并取数" tabindex="-1"><a class="header-anchor" href="#译码并取数"><span>译码并取数</span></a></h4><p>将IR中的op段送入控制器，得到控制信号；将Rs,Rt输入到寄存器组的Ra，Rb端；</p><p>同时会进行“投机计算”：计算Load、Store指令中的地址，并且存放在MAR中。</p><h4 id="执行指令" tabindex="-1"><a class="header-anchor" href="#执行指令"><span>执行指令</span></a></h4><p>3)执行指令<br> 控制部件对指令译码后，会和条件码中的标志信息组合生成控制信号，从而使CPU在控制信号的控制下执行指令。针对不同指令的功能，其对应的有效控制信号如下。</p><ol><li><p>R-型指令：R[Rt]-R[Rs]op R[Rt]<br> R-型指令的执行需要两个时钟周期，对应状态分别记为RExec和RFinish。</p><ul><li>RExec状态的功能为：进行ALU运算并将结果存入ALUout和CC寄存器。其有效控制信号及其取值为 BMUX=1,ALUOp=xxx,ALUoutWr=1,CCWr=1,其他寄存器写使能信号全部为0。其中，ALUOp的取值由指令操作码决定，以控制ALU进行不同的运算。</li><li>RFinish状态的功能为：将ALUout的内容存入Rt。其有效控制信号及其取值为：RegMUX=1,RegWr=1,其他寄存器写使能信号全部为0。</li></ul><p>问题：为什么不把这两个阶段给合并？如果两个周期合并，可能来不及把异常结果转去进行异常处理，就可能把错误结果写入寄存器了如果Rfinish之后再进入溢出异常处理状态，则需要保证RegWr修改为0；简而言之：为了异常处理。</p></li><li><p>I-型运算指令：R[Rt]←R[Rs]op EXT[imm16]<br> I-型运算指令的执行需要两个时钟周期，对应状态分别记为IExec和IFinish。</p><ul><li>IExec状态的功能为：进行ALU运算并将结果存入ALUout和CC寄存器。其有效控制信号及其取值为：ExtOp=0或1,BMUX=0,ALUOp=xxx,ALUoutWr=1,CCWr=1,其他寄存器写使能信号全部为0。与R-型指令一样，ALUOp的取值由指令操作码决定，不同的取值控制ALU进行不同的运算。</li><li>IFinish状态的功能为：将ALUout的内容存入Rt。其有效控制信号及其取值为：RegMUX=1,RegWr=1,其他寄存器写使能信号全部为0。经分析可知，IFinish和RFinish两个状态的功能完全一样，因此，可以将两个状态合并成一个状态：RIFinish。</li></ul></li><li><p>Load指令：R[Rt]-M[R[Rs]+SEXT[imm16]]<br> Load指令的执行包含三个子功能，需要三个时钟周期。因为在“译码并取数”阶段已经计算出地址并存入MAR中，因而还需要两个时钟周期，对应状态分别记为lwExec和lwFinish。</p><ul><li>lwExec状态的功能为：读主存内容并保存到MDR。其有效控制信号及其取值为：MARout=1,PCout=0,MemWr=0,MDRMUX=0,MDRWr=1,其他寄存器写使能信号全部为0。</li><li>lwFinish状态的功能为：将MDR内容存入Rt。其有效控制信号及其取值为：RegMUX=0,RegWr=1,其他寄存器写使能信号全部为0。</li></ul></li><li><p>Store指令：M[R[Rs]+SEXT[imm16]]-R[Rt]</p><p>Store指令的执行包含三个子功能，需要至少三个时钟周期。因为在“译码并取数”阶段已经计算出地址并存入MAR中，因而只需要两个时钟周期，对应状态分别记为swExec和swFinish。</p><ul><li>swExec状态的功能为：将Rt存入MDR并直送总线。其有效控制信号及其取值为：MDRMUX=1,MDRWr=1,MARout=1,PCout=0,MemWr-0,其他寄存器写使能信号全部为0。</li><li>swFinish状态的功能为：将MDR送入总线的数据写入主存。其有效控制信号及其取值为：MARout=1,PCout=0,MemWr=1,其他寄存器写使能信号全部为0。</li></ul></li><li><p>Jump指令：PC+PC+SEXT[imm16]<br> Jump指令的功能为：进行转移目标地址计算并送PC。它只需要一个时钟周期，对应状态记为JFinish。</p><ul><li>其有效控制信号及其取值为：ExtOp=1,Add1MUX=0,Add2MUX=0,PCWr=1,其他寄存器写使能信号全部为0。</li></ul><p>根据上述对每条指令执行过程的分析，得到一个状态转换图。图8.32是一个支持R-型指令、I-型运算指令、Load/Store指令和Jump指令执行的状态转换示意图。</p><p>图中每个状态用一个状态编号和状态名标识，例如，0:IFetch表示第0状态，执行取指令(IFetch)操作，圆圈中示意性地给出了该状态下部分控制信号的取值，其中，有取值为0和取值为1的两种有效控制信号，以及多值有效控制信号ALUOp,ALUOp=xxx表示根据操作码OP译码得到的一个ALU操作控制信号取值为xxx。此外，图中的x表示取值为任意的无效控制信号。</p><p>在图8.31所示的多周期数据通路中，每条指令的执行过程就是图8.32所示的状态转换过程。每来一个时钟，进入下一个状态。从图8.32可看出，R-型指令、I-型运算指令、Load和Store指令的CPI都为4,跳转指令Jump的CPI为3。如果不在译码/取数阶段“投机”计算访存地址，则Load和Store指令的CPI为5。</p><figure><img src="https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250428115548563.png" alt="image-20250428115548563" tabindex="0" loading="lazy"><figcaption>image-20250428115548563</figcaption></figure></li></ol>',135)]))}const g=i(e,[["render",o],["__file","chapter8CPU.html.vue"]]),l=JSON.parse('{"path":"/posts/NJUCS/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/chapter8CPU.html","title":"chapter8 | CPU的设计","lang":"zh-CN","frontmatter":{"date":"2025-04-21T00:00:00.000Z","title":"chapter8 | CPU的设计","author":"yama-lei","description":"CPU概述 CPU执行指令的过程： 根据pc取指令 异常时内部异常，中断时由于外部事件的出现导致CPU停止执行指令； 即内部异常，外部中断 计算机的五大组成部件 Memory I/O Datapath 数据通路 执行部件 Control Unit 控制部件 控制器：控制器对执行部件发出信号。 数据通路Datapath的基本结构 数据通路是由操作元件和存...","head":[["meta",{"property":"og:url","content":"https://github.com/yama-lei/yama-lei.github.io/posts/NJUCS/%E6%95%B0%E5%AD%97%E9%80%BB%E8%BE%91%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90/chapter8CPU.html"}],["meta",{"property":"og:site_name","content":"Myblog"}],["meta",{"property":"og:title","content":"chapter8 | CPU的设计"}],["meta",{"property":"og:description","content":"CPU概述 CPU执行指令的过程： 根据pc取指令 异常时内部异常，中断时由于外部事件的出现导致CPU停止执行指令； 即内部异常，外部中断 计算机的五大组成部件 Memory I/O Datapath 数据通路 执行部件 Control Unit 控制部件 控制器：控制器对执行部件发出信号。 数据通路Datapath的基本结构 数据通路是由操作元件和存..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:image","content":"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250421114837747.png"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2025-05-03T07:14:16.000Z"}],["meta",{"property":"article:author","content":"yama-lei"}],["meta",{"property":"article:published_time","content":"2025-04-21T00:00:00.000Z"}],["meta",{"property":"article:modified_time","content":"2025-05-03T07:14:16.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"chapter8 | CPU的设计\\",\\"image\\":[\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250421114837747.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427103915530.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427104315618.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427104604542.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427110900124.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427110804853.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427112357474.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250427113923927.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250428101709013.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250428102812207.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250428103132649.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250428103320124.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250428105102309.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250428112505398.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250428112702885.png\\",\\"https://yamapicgo.oss-cn-nanjing.aliyuncs.com/picgoImage/image-20250428115548563.png\\"],\\"datePublished\\":\\"2025-04-21T00:00:00.000Z\\",\\"dateModified\\":\\"2025-05-03T07:14:16.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"yama-lei\\"}]}"]]},"headers":[{"level":2,"title":"CPU概述","slug":"cpu概述","link":"#cpu概述","children":[{"level":3,"title":"计算机的五大组成部件","slug":"计算机的五大组成部件","link":"#计算机的五大组成部件","children":[]},{"level":3,"title":"计算机性能","slug":"计算机性能","link":"#计算机性能","children":[]}]},{"level":2,"title":"单周期的CPU设计","slug":"单周期的cpu设计","link":"#单周期的cpu设计","children":[{"level":3,"title":"单流水线CPU的设计","slug":"单流水线cpu的设计","link":"#单流水线cpu的设计","children":[]},{"level":3,"title":"控制器的设计","slug":"控制器的设计","link":"#控制器的设计","children":[]}]},{"level":2,"title":"多周期CPU设计","slug":"多周期cpu设计","link":"#多周期cpu设计","children":[{"level":3,"title":"指令执行的过程","slug":"指令执行的过程","link":"#指令执行的过程","children":[]}]}],"git":{"createdTime":1745218327000,"updatedTime":1746256456000,"contributors":[{"name":"yama-lei","username":"yama-lei","email":"1908777046@qq.com","commits":3,"url":"https://github.com/yama-lei"}]},"readingTime":{"minutes":14.7,"words":4410},"filePathRelative":"posts/NJUCS/数字逻辑与计算机组成/chapter8CPU.md","localizedDate":"2025年4月21日","excerpt":"<h2>CPU概述</h2>\\n<p><strong>CPU执行指令的过程</strong>：</p>\\n<ol>\\n<li>根据pc取指令</li>\\n</ol>\\n<p>异常时内部异常，中断时由于外部事件的出现导致CPU停止执行指令； 即<code>内部异常，外部中断</code></p>\\n<hr>\\n<h3><strong>计算机的五大组成部件</strong></h3>\\n<ul>\\n<li>Memory</li>\\n<li>I/O</li>\\n<li>Datapath 数据通路 <strong>执行部件</strong></li>\\n<li>Control Unit 控制部件 <strong>控制器</strong>：控制器对执行部件发出信号。</li>\\n</ul>","autoDesc":true}');export{g as comp,l as data};
